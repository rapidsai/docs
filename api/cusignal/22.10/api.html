<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator">

    <title>cuSignal API Reference &mdash; cusignal 22.10.00 documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link href="_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet">
  <link as="font" crossorigin href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2">
  <link as="font" crossorigin href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2">

    <link href="_static/pygments.css" rel="stylesheet" type="text/css">
    <link href="_static/copybutton.css" rel="stylesheet" type="text/css">
    <link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet" type="text/css">

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695" rel="preload">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script defer="defer" src="https://docs.rapids.ai/assets/js/custom.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="genindex.html" rel="index" title="Index">
    <link href="search.html" rel="search" title="Search">
    <link href="index.html" rel="prev" title="Welcome to cusignal&rsquo;s documentation!">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="en" name="docsearch:language">
  <script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
  
  
  <body data-default-mode data-offset="180" data-spy="scroll" data-target="#bd-toc-nav">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="index.html">
  
  
  
  
    <img alt="Logo image" class="logo__image only-light" src="_static/RAPIDS-logo-purple.png">
    <img alt="Logo image" class="logo__image only-dark" src="_static/RAPIDS-logo-purple.png">
  
  
</a>
    
  </div>

  <button aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbar-collapsible" data-toggle="collapse" type="button">
    <span class="fas fa-bars"></span>
  </button>

  
  <div class="collapse navbar-collapse" id="navbar-collapsible">
    <div class="ml-auto" id="navbar-center">
      
      <div class="navbar-center-item">
        <ul class="navbar-nav" id="navbar-main-elements">
    <li class="toctree-l1 current active nav-item">
 <a class="current reference internal nav-link" href="#">
  cuSignal API Reference
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span class="btn btn-sm btn-outline-primary navbar-btn rounded-circle" id="theme-switch">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul aria-label="Icon Links" class="navbar-nav" id="navbar-icon-links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/rapidsai/cusignal" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/rapidsai" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar"><div id="rapids-pydata-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">cusignal</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (22.10)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cusignal/nightly/api.html">nightly (22.10)</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">stable (22.06)</a><a class="rapids-selector__menu-item" href="/api/cusignal/legacy/api.html">legacy (22.04)</a></div></div></div>
  <div class="sidebar-start-items"><form action="search.html" class="bd-search d-flex align-items-center" method="get">
  <i class="icon fas fa-search"></i>
  <input aria-label="Search the docs ..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search the docs ..." type="search">
</form><nav aria-label="Main navigation" class="bd-links" id="bd-docs-nav">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#convolution">
   Convolution
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.convolution.convolve">
     Convolve
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.convolution.correlate">
     Correlate
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modulation-demodulation">
   Modulation/Demodulation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.demod.demod">
     Demodulation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#estimation">
   Estimation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kalman-filter">
     Kalman Filter
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#filtering">
   Filtering
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.filtering.resample">
     Resample
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.filtering.filtering.firfilter">
     FIR Filters
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#parameters">
       Parameters
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#returns">
       Returns
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.filtering.channelize_poly">
     Channelizer
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id8">
       Parameters
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id9">
       Returns
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#notes">
       Notes
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#filter-design">
   Filter Design
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id10">
     Resample
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#peak-finding">
   Peak Finding
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id17">
     Peak Finding
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#window-functions">
   Window Functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.windows.windows">
     Windows
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#waveforms">
   Waveforms
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#waveform-generation">
     Waveform Generation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#spectrum-analysis">
   Spectrum Analysis
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.spectral_analysis.spectral">
     Spectral
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.acoustics.cepstrum">
     Acoustics
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#wavelets">
   Wavelets
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id105">
     Wavelets
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#b-splines">
   B-splines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id106">
     B-splines
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#utilities">
   Utilities
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.utils.arraytools">
     Array Tools
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fftpack-helper">
     FFTPack Helper
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#io">
   IO
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.io.reader">
     Reader
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.io.writer">
     Writer
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#radar-phased-array">
   Radar/Phased Array
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cusignal.radartools.radartools">
     Radar Tools
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="cusignal-api-reference">
<h1>cuSignal API Reference<a class="headerlink" href="#cusignal-api-reference" title="Permalink to this heading">#</a></h1>
<section id="convolution">
<h2>Convolution<a class="headerlink" href="#convolution" title="Permalink to this heading">#</a></h2>
<section id="module-cusignal.convolution.convolve">
<span id="convolve"></span><h3>Convolve<a class="headerlink" href="#module-cusignal.convolution.convolve" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.convolve.choose_conv_method">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.convolve.</span></span><span class="sig-name descname"><span class="pre">choose_conv_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.convolve.choose_conv_method" title="Permalink to this definition">#</a></dt>
<dd><p>Find the fastest convolution/correlation method.</p>
<p>This primarily exists to be called during the <code class="docutils literal notranslate"><span class="pre">method='auto'</span></code> option in
<cite>convolve</cite> and <cite>correlate</cite>, but can also be used when performing many
convolutions of the same input shapes and dtypes, determining
which method to use for all of them, either to avoid the overhead of the
&lsquo;auto&rsquo; option or to use accurate real-world measurements.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>The first argument passed into the convolution function.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>The second argument passed into the convolution function.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the &lsquo;full&rsquo; output.</p>
</dd>
</dl>
</dd>
<dt><strong>measure</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, run and time the convolution of <cite>in1</cite> and <cite>in2</cite> with both
methods and return the fastest. If False (default), predict the fastest
method using precomputed values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>A string indicating which convolution method is fastest, either
&lsquo;direct&rsquo; or &lsquo;fft&rsquo;</p>
</dd>
<dt><strong>times</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary containing the times (in seconds) needed for each method.
This value is only returned if <code class="docutils literal notranslate"><span class="pre">measure=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.convolution.convolve.convolve" title="cusignal.convolution.convolve.convolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve</span></code></a></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlate</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Estimate the fastest method for a given input:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">method</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">choose_conv_method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">method</span>
<span class="go">'fft'</span>
</pre></div>
</div>
<p>This can then be applied to other arrays of the same dtype and shape:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># `method` works with correlate and convolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr1</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr2</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv1</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv2</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.convolve.convolve">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.convolve.</span></span><span class="sig-name descname"><span class="pre">convolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.convolve.convolve" title="Permalink to this definition">#</a></dt>
<dd><p>Convolve two N-dimensional arrays.</p>
<p>Convolve <cite>in1</cite> and <cite>in2</cite>, with the output size determined by the
<cite>mode</cite> argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In &lsquo;valid&rsquo; mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the &lsquo;full&rsquo; output.</p>
</dd>
</dl>
</dd>
<dt><strong>method</strong><span class="classifier">str {&lsquo;auto&rsquo;, &lsquo;direct&rsquo;, &lsquo;fft&rsquo;}, optional</span></dt><dd><p>A string indicating which method to use to calculate the convolution.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">direct</span></code></dt><dd><p>The convolution is determined directly from sums, the definition of
convolution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fft</span></code></dt><dd><p>The Fourier Transform is used to perform the convolution by calling
<cite>fftconvolve</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto</span></code></dt><dd><p>Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>convolve</strong><span class="classifier">array</span></dt><dd><p>An N-dimensional array containing a subset of the discrete linear
convolution of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.convolution.convolve.choose_conv_method" title="cusignal.convolution.convolve.choose_conv_method"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose_conv_method</span></code></a></dt><dd><p>chooses the fastest appropriate convolution method</p>
</dd>
<dt><a class="reference internal" href="#cusignal.convolution.convolve.fftconvolve" title="cusignal.convolution.convolve.fftconvolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftconvolve</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>By default, <cite>convolve</cite> and <cite>correlate</cite> use <code class="docutils literal notranslate"><span class="pre">method='auto'</span></code>, which calls
<cite>choose_conv_method</cite> to choose the fastest method using pre-computed
values (<cite>choose_conv_method</cite> can also measure real-world timing with a
keyword argument). Because <cite>fftconvolve</cite> relies on floating point numbers,
there are certain constraints that may force <cite>method=direct</cite> (more detail
in <cite>choose_conv_method</cite> docstring).</p>
<p class="rubric">Examples</p>
<p>Smooth a square pulse using a Hann window:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">win</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">)</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_win</span><span class="p">,</span> <span class="n">ax_filt</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Original pulse'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_win</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">win</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_win</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Filter impulse response'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_win</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_filt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">filtered</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_filt</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Filtered signal'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_filt</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.convolve.convolve1d2o">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.convolve.</span></span><span class="sig-name descname"><span class="pre">convolve1d2o</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'valid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'direct'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.convolve.convolve1d2o" title="Permalink to this definition">#</a></dt>
<dd><p>Convolve a 1-dimensional arrays with a 2nd order filter.
This results in a second order convolution.</p>
<p>Convolve <cite>in1</cite> and <cite>in2</cite>, with the output size determined by the
<cite>mode</cite> argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In &lsquo;valid&rsquo; mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the &lsquo;full&rsquo; output.</p>
</dd>
</dl>
</dd>
<dt><strong>method</strong><span class="classifier">str {&lsquo;auto&rsquo;, &lsquo;direct&rsquo;, &lsquo;fft&rsquo;}, optional</span></dt><dd><p>A string indicating which method to use to calculate the convolution.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">direct</span></code></dt><dd><p>The convolution is determined directly from sums, the definition of
convolution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fft</span></code></dt><dd><p>The Fourier Transform is used to perform the convolution by calling
<cite>fftconvolve</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto</span></code></dt><dd><p>Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>A 1-dimensional array containing a subset of the discrete linear
convolution of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.convolution.convolve.convolve" title="cusignal.convolution.convolve.convolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cusignal.convolution.convolve.convolve1d2o" title="cusignal.convolution.convolve.convolve1d2o"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve1d2o</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cusignal.convolution.convolve.convolve1d3o" title="cusignal.convolution.convolve.convolve1d3o"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve1d3o</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Convolution of a 2nd order filter on a 1d signal</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span> <span class="k">as</span> <span class="nn">cs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">convolve1d2o</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.convolve.convolve1d3o">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.convolve.</span></span><span class="sig-name descname"><span class="pre">convolve1d3o</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'valid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'direct'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.convolve.convolve1d3o" title="Permalink to this definition">#</a></dt>
<dd><p>Convolve a 1-dimensional array with a 3rd order filter.
This results in a second order convolution.</p>
<p>Convolve <cite>in1</cite> and <cite>in2</cite>, with the output size determined by the
<cite>mode</cite> argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In &lsquo;valid&rsquo; mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the &lsquo;full&rsquo; output.</p>
</dd>
</dl>
</dd>
<dt><strong>method</strong><span class="classifier">str {&lsquo;auto&rsquo;, &lsquo;direct&rsquo;, &lsquo;fft&rsquo;}, optional</span></dt><dd><p>A string indicating which method to use to calculate the convolution.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">direct</span></code></dt><dd><p>The convolution is determined directly from sums, the definition of
convolution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fft</span></code></dt><dd><p>The Fourier Transform is used to perform the convolution by calling
<cite>fftconvolve</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto</span></code></dt><dd><p>Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>A 1-dimensional array containing a subset of the discrete linear
convolution of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.convolution.convolve.convolve" title="cusignal.convolution.convolve.convolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cusignal.convolution.convolve.convolve1d2o" title="cusignal.convolution.convolve.convolve1d2o"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve1d2o</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cusignal.convolution.convolve.convolve1d3o" title="cusignal.convolution.convolve.convolve1d3o"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve1d3o</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Convolution of a 3rd order filter on a 1d signal</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span> <span class="k">as</span> <span class="nn">cs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">convolve1d3o</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.convolve.convolve2d">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.convolve.</span></span><span class="sig-name descname"><span class="pre">convolve2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fill'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.convolve.convolve2d" title="Permalink to this definition">#</a></dt>
<dd><p>Convolve two 2-dimensional arrays.
Convolve <cite>in1</cite> and <cite>in2</cite> with output size determined by <cite>mode</cite>, and
boundary conditions determined by <cite>boundary</cite> and <cite>fillvalue</cite>.
Parameters
&mdash;&mdash;&mdash;-
in1 : array_like</p>
<blockquote>
<div><p>First input.</p>
</div></blockquote>
<dl>
<dt>in2<span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt>mode<span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output:
<code class="docutils literal notranslate"><span class="pre">full</span></code></p>
<blockquote>
<div><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In &lsquo;valid&rsquo; mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the &lsquo;full&rsquo; output.</p>
</dd>
</dl>
</dd>
<dt>boundary<span class="classifier">str {&lsquo;fill&rsquo;, &lsquo;wrap&rsquo;, &lsquo;symm&rsquo;}, optional</span></dt><dd><p>A flag indicating how to handle boundaries:
<code class="docutils literal notranslate"><span class="pre">fill</span></code></p>
<blockquote>
<div><p>pad input arrays with fillvalue. (default)</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wrap</span></code></dt><dd><p>circular boundary conditions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symm</span></code></dt><dd><p>symmetrical boundary conditions.</p>
</dd>
</dl>
</dd>
<dt>fillvalue<span class="classifier">scalar, optional</span></dt><dd><p>Value to fill pad input arrays with. Default is 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array containing a subset of the discrete linear
convolution of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the gradient of an image by 2D convolution with a complex Scharr
operator.  (Horizontal operator is real, vertical is imaginary.)  Use
symmetric boundary condition to avoid creating edges at the image
boundaries.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">misc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ascent</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scharr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mi">3</span><span class="o">-</span><span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="o">-</span><span class="mi">10</span><span class="n">j</span><span class="p">,</span>  <span class="o">+</span><span class="mi">3</span> <span class="o">-</span><span class="mi">3</span><span class="n">j</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="o">+</span><span class="mi">10</span> <span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span> <span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="mi">10</span><span class="n">j</span><span class="p">,</span>  <span class="o">+</span><span class="mi">3</span> <span class="o">+</span><span class="mi">3</span><span class="n">j</span><span class="p">]])</span> <span class="c1"># Gx + j*Gy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">ascent</span><span class="p">,</span> <span class="n">scharr</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">'symm'</span><span class="p">,</span>                 <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_mag</span><span class="p">,</span> <span class="n">ax_ang</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">ascent</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Original'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_mag</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">grad</span><span class="p">)),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_mag</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Gradient magnitude'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_mag</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_ang</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">grad</span><span class="p">)),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'hsv'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_ang</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Gradient orientation'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_ang</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.convolve.fftconvolve">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.convolve.</span></span><span class="sig-name descname"><span class="pre">fftconvolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.convolve.fftconvolve" title="Permalink to this definition">#</a></dt>
<dd><p>Convolve two N-dimensional arrays using FFT.</p>
<p>Convolve <cite>in1</cite> and <cite>in2</cite> using the fast Fourier transform method, with
the output size determined by the <cite>mode</cite> argument.</p>
<p>This is generally much faster than <cite>convolve</cite> for large arrays (n &gt; ~500),
but can be slower when only a few output values are needed, and can only
output float arrays (int or object array inputs will be cast to float).</p>
<p>As of v0.19, <cite>convolve</cite> automatically chooses this method or the direct
method based on an estimation of which is faster.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In &lsquo;valid&rsquo; mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the &lsquo;full&rsquo; output.
axis : tuple, optional</p>
</dd>
</dl>
</dd>
<dt><strong>axes</strong><span class="classifier">int or array_like of ints or None, optional</span></dt><dd><p>Axes over which to compute the convolution.
The default is over all axes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>An N-dimensional array containing a subset of the discrete linear
convolution of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Autocorrelation of white noise is an impulse.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">autocorr</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'full'</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_mag</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'White noise'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_mag</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">))),</span>
<span class="go">        cp.asnumpy(autocorr))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_mag</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Autocorrelation'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Gaussian blur implemented using FFT convolution.  Notice the dark borders
around the image, due to the zero-padding beyond its boundaries.
The <cite>convolve2d</cite> function allows for other types of image boundaries,
but is far slower.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">misc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">face</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">gray</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">cusignal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blurred</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_kernel</span><span class="p">,</span> <span class="n">ax_blurred</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Original'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_kernel</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">kernel</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_kernel</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Gaussian kernel'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_kernel</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_blurred</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">blurred</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_blurred</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Blurred'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_blurred</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cusignal.convolution.correlate">
<span id="correlate"></span><h3>Correlate<a class="headerlink" href="#module-cusignal.convolution.correlate" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.correlate.correlate">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.correlate.</span></span><span class="sig-name descname"><span class="pre">correlate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.correlate.correlate" title="Permalink to this definition">#</a></dt>
<dd><p>Cross-correlate two N-dimensional arrays.</p>
<p>Cross-correlate <cite>in1</cite> and <cite>in2</cite>, with the output size determined by the
<cite>mode</cite> argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear cross-correlation
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In &lsquo;valid&rsquo; mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the &lsquo;full&rsquo; output.</p>
</dd>
</dl>
</dd>
<dt><strong>method</strong><span class="classifier">str {&lsquo;auto&rsquo;, &lsquo;direct&rsquo;, &lsquo;fft&rsquo;}, optional</span></dt><dd><p>A string indicating which method to use to calculate the correlation.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">direct</span></code></dt><dd><p>The correlation is determined directly from sums, the definition of
correlation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fft</span></code></dt><dd><p>The Fast Fourier Transform is used to perform the correlation more
quickly (only available for numerical arrays.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto</span></code></dt><dd><p>Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See <cite>convolve</cite> Notes for more detail.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>correlate</strong><span class="classifier">array</span></dt><dd><p>An N-dimensional array containing a subset of the discrete linear
cross-correlation of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose_conv_method</span></code></dt><dd><p>contains more documentation on <cite>method</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The correlation z of two d-dimensional arrays x and y is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">z</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span>
    <span class="nb">sum</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i_l</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i_l</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">conj</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i_l</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>This way, if x and y are 1-D arrays and <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">correlate(x,</span> <span class="pre">y,</span> <span class="pre">'full')</span></code>
then</p>
<div class="math notranslate nohighlight">
\[z[k] = (x * y)(k - N + 1)
     = \sum_{l=0}^{||x||-1}x_l y_{l-k+N-1}^{*}\]</div>
<p>for <span class="math notranslate nohighlight">\(k = 0, 1, ..., ||x|| + ||y|| - 2\)</span></p>
<p>where <span class="math notranslate nohighlight">\(||x||\)</span> is the length of <code class="docutils literal notranslate"><span class="pre">x</span></code>, <span class="math notranslate nohighlight">\(N = \max(||x||,||y||)\)</span>,
and <span class="math notranslate nohighlight">\(y_m\)</span> is 0 when m is outside the range of y.</p>
<p><code class="docutils literal notranslate"><span class="pre">method='fft'</span></code> only works for numerical arrays as it relies on
<cite>fftconvolve</cite>. In certain cases (i.e., arrays of objects or when
rounding integers can lose precision), <code class="docutils literal notranslate"><span class="pre">method='direct'</span></code> is always used.</p>
<p class="rubric">Examples</p>
<p>Implement a matched filter using cross-correlation, to recover a signal
that has passed through a noisy channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]),</span> <span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig_noise</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">+</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">sig_noise</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clock</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">),</span> <span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_noise</span><span class="p">,</span> <span class="n">ax_corr</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">clock</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">clock</span><span class="p">]),</span> <span class="s1">'ro'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Original signal'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_noise</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">sig_noise</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_noise</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Signal with noise'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_corr</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">corr</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_corr</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">clock</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">corr</span><span class="p">[</span><span class="n">clock</span><span class="p">]),</span> <span class="s1">'ro'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_corr</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">':'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_corr</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Cross-correlated with rectangular pulse'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.correlate.correlate2d">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.correlate.</span></span><span class="sig-name descname"><span class="pre">correlate2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fill'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.correlate.correlate2d" title="Permalink to this definition">#</a></dt>
<dd><p>Cross-correlate two 2-dimensional arrays.
Cross correlate <cite>in1</cite> and <cite>in2</cite> with output size determined by <cite>mode</cite>, and
boundary conditions determined by <cite>boundary</cite> and <cite>fillvalue</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output:
<code class="docutils literal notranslate"><span class="pre">full</span></code></p>
<blockquote>
<div><p>The output is the full discrete linear cross-correlation
of the inputs. (Default)</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In &lsquo;valid&rsquo; mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the &lsquo;full&rsquo; output.</p>
</dd>
</dl>
</dd>
<dt><strong>boundary</strong><span class="classifier">str {&lsquo;fill&rsquo;, &lsquo;wrap&rsquo;, &lsquo;symm&rsquo;}, optional</span></dt><dd><p>A flag indicating how to handle boundaries:
<code class="docutils literal notranslate"><span class="pre">fill</span></code></p>
<blockquote>
<div><p>pad input arrays with fillvalue. (default)</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wrap</span></code></dt><dd><p>circular boundary conditions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symm</span></code></dt><dd><p>symmetrical boundary conditions.</p>
</dd>
</dl>
</dd>
<dt><strong>fillvalue</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill pad input arrays with. Default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>correlate2d</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array containing a subset of the discrete linear
cross-correlation of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Use 2D cross-correlation to find the location of a template in a noisy
image:
&gt;&gt;&gt; import cusignal
&gt;&gt;&gt; import cupy as cp
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; face = cp.asarray(misc.face(gray=True) - misc.face(gray=True).mean())
&gt;&gt;&gt; template = cp.copy(face[300:365, 670:750])  # right eye
&gt;&gt;&gt; template -= template.mean()
&gt;&gt;&gt; face = face + cp.random.randn(<a href="#id1"><span class="problematic" id="id2">*</span></a>face.shape) * 50  # add noise
&gt;&gt;&gt; corr = cusignal.correlate2d(face, template, boundary=&rsquo;symm&rsquo;,         mode=&rsquo;same&rsquo;)
&gt;&gt;&gt; y, x = cp.unravel_index(cp.argmax(corr), corr.shape)  # find the match
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_template, ax_corr) =
&hellip;     plt.subplots(3, 1, figsize=(6, 15))
&gt;&gt;&gt; ax_orig.imshow(cp.asnumpy(face), cmap=&rsquo;gray&rsquo;)
&gt;&gt;&gt; ax_orig.set_title(&lsquo;Original&rsquo;)
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_template.imshow(cp.asnumpy(template), cmap=&rsquo;gray&rsquo;)
&gt;&gt;&gt; ax_template.set_title(&lsquo;Template&rsquo;)
&gt;&gt;&gt; ax_template.set_axis_off()
&gt;&gt;&gt; ax_corr.imshow(cp.asnumpy(corr), cmap=&rsquo;gray&rsquo;)
&gt;&gt;&gt; ax_corr.set_title(&lsquo;Cross-correlation&rsquo;)
&gt;&gt;&gt; ax_corr.set_axis_off()
&gt;&gt;&gt; ax_orig.plot(cp.asnumpy(x), cp.asnumpy(y), &lsquo;ro&rsquo;)
&gt;&gt;&gt; fig.show()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.convolution.correlate.correlation_lags">
<span class="sig-prename descclassname"><span class="pre">cusignal.convolution.correlate.</span></span><span class="sig-name descname"><span class="pre">correlation_lags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1_len</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2_len</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.convolution.correlate.correlation_lags" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the lag / displacement indices array for 1D cross-correlation.
Parameters
&mdash;&mdash;&mdash;-
in1_size : int</p>
<blockquote>
<div><p>First input size.</p>
</div></blockquote>
<dl class="simple">
<dt>in2_size<span class="classifier">int</span></dt><dd><p>Second input size.</p>
</dd>
<dt>mode<span class="classifier">str {&lsquo;full&rsquo;, &lsquo;valid&rsquo;, &lsquo;same&rsquo;}, optional</span></dt><dd><p>A string indicating the size of the output.
See the documentation <cite>correlate</cite> for more information.</p>
</dd>
</dl>
<p>correlate : Compute the N-dimensional cross-correlation.
Returns
&mdash;&mdash;-
lags : array</p>
<blockquote>
<div><p>Returns an array containing cross-correlation lag/displacement indices.
Indices can be indexed with the np.argmax of the correlation to return
the lag/displacement.</p>
</div></blockquote>
<p>Cross-correlation for continuous functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> is
defined as:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">left</span> <span class="p">(</span> <span class="n">f</span>\<span class="n">star</span> <span class="n">g</span> \<span class="n">right</span> <span class="p">)</span>\<span class="n">left</span> <span class="p">(</span> \<span class="n">tau</span> \<span class="n">right</span> <span class="p">)</span>
\<span class="n">triangleq</span> \<span class="n">int_</span><span class="p">{</span><span class="n">t_0</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="n">t_0</span> <span class="o">+</span><span class="n">T</span><span class="p">}</span>
\<span class="n">overline</span><span class="p">{</span><span class="n">f</span>\<span class="n">left</span> <span class="p">(</span> <span class="n">t</span> \<span class="n">right</span> <span class="p">)}</span><span class="n">g</span>\<span class="n">left</span> <span class="p">(</span> <span class="n">t</span><span class="o">+</span>\<span class="n">tau</span> \<span class="n">right</span> <span class="p">)</span><span class="n">dt</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(\tau\)</span> is defined as the displacement, also known as the lag.
Cross correlation for discrete functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> is
defined as:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">left</span> <span class="p">(</span> <span class="n">f</span>\<span class="n">star</span> <span class="n">g</span> \<span class="n">right</span> <span class="p">)</span>\<span class="n">left</span> <span class="p">[</span> <span class="n">n</span> \<span class="n">right</span> <span class="p">]</span>
\<span class="n">triangleq</span> \<span class="n">sum_</span><span class="p">{</span><span class="o">-</span>\<span class="n">infty</span><span class="p">}</span><span class="o">^</span><span class="p">{</span>\<span class="n">infty</span><span class="p">}</span>
\<span class="n">overline</span><span class="p">{</span><span class="n">f</span>\<span class="n">left</span> <span class="p">[</span> <span class="n">m</span> \<span class="n">right</span> <span class="p">]}</span><span class="n">g</span>\<span class="n">left</span> <span class="p">[</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span> \<span class="n">right</span> <span class="p">]</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(n\)</span> is the lag.
Examples
&mdash;&mdash;&ndash;
Cross-correlation of a signal with its time-delayed self.
&gt;&gt;&gt; import cusignal
&gt;&gt;&gt; import cupy as cp
&gt;&gt;&gt; from cupy.random import default_rng
&gt;&gt;&gt; rng = default_rng()
&gt;&gt;&gt; x = rng.standard_normal(1000)
&gt;&gt;&gt; y = cp.concatenate([rng.standard_normal(100), x])
&gt;&gt;&gt; correlation = cusignal.correlate(x, y, mode=&rdquo;full&rdquo;)
&gt;&gt;&gt; lags = cusignal.correlation_lags(x.size, y.size, mode=&rdquo;full&rdquo;)
&gt;&gt;&gt; lag = lags[cp.argmax(correlation)]</p>
</dd></dl>

</section>
</section>
<section id="modulation-demodulation">
<h2>Modulation/Demodulation<a class="headerlink" href="#modulation-demodulation" title="Permalink to this heading">#</a></h2>
<section id="module-cusignal.demod.demod">
<span id="demodulation"></span><h3>Demodulation<a class="headerlink" href="#module-cusignal.demod.demod" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.demod.demod.fm_demod">
<span class="sig-prename descclassname"><span class="pre">cusignal.demod.demod.</span></span><span class="sig-name descname"><span class="pre">fm_demod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.demod.demod.fm_demod" title="Permalink to this definition">#</a></dt>
<dd><p>Demodulate Frequency Modulated Signal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>Received complex valued signal or batch of signals</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The demodulated output with the same shape as <cite>x</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="estimation">
<h2>Estimation<a class="headerlink" href="#estimation" title="Permalink to this heading">#</a></h2>
<section id="kalman-filter">
<h3>Kalman Filter<a class="headerlink" href="#kalman-filter" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-cusignal.estimation.filters"></span><dl class="py class">
<dt class="sig sig-object py" id="cusignal.estimation.filters.KalmanFilter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cusignal.estimation.filters.</span></span><span class="sig-name descname"><span class="pre">KalmanFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_u=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.estimation.filters.KalmanFilter" title="Permalink to this definition">#</a></dt>
<dd><p>This is a multi-point Kalman Filter implementation of
<a class="reference external" href="https://github.com/rlabbe/filterpy/blob/master/filterpy/kalman/kalman_filter.py">https://github.com/rlabbe/filterpy/blob/master/filterpy/kalman/kalman_filter.py</a>,
with a subset of functionality.</p>
<p>All Kalman Filter matrices are stack on the X axis. This is to allow
for optimal global accesses on the GPU.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim_x</strong><span class="classifier">int</span></dt><dd><p>Number of state variables for the Kalman filter. For example, if
you are tracking the position and velocity of an object in two
dimensions, dim_x would be 4.
This is used to set the default size of P, Q, and u</p>
</dd>
<dt><strong>dim_z</strong><span class="classifier">int</span></dt><dd><p>Number of of measurement inputs. For example, if the sensor
provides you with position in (x,y), dim_z would be 2.</p>
</dd>
<dt><strong>dim_u</strong><span class="classifier">int (optional)</span></dt><dd><p>Size of the control input, if it is being used.
Default value of 0 indicates it is not used.</p>
</dd>
<dt><strong>points</strong><span class="classifier">int (optional)</span></dt><dd><p>Number of Kalman Filter points to track.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype (optional)</span></dt><dd><p>Data type of compute.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5bc1e6222706-1"><span class="brackets"><a class="fn-backref" href="#id5">1</a></span></dt>
<dd><p>Dan Simon. &ldquo;Optimal State Estimation.&rdquo; John Wiley &amp; Sons.
p. 208-212. (2006)</p>
</dd>
<dt class="label" id="r5bc1e6222706-2"><span class="brackets">2</span></dt>
<dd><p>Roger Labbe. &ldquo;Kalman and Bayesian Filters in Python&rdquo;
<a class="reference external" href="https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python">https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here is a filter that tracks position and velocity using a sensor that only
reads position.</p>
<p>First construct the object with the required dimensionality,
number of points, and data type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">cusignal</span> <span class="kn">import</span> <span class="n">KalmanFilter</span>

<span class="n">points</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">kf</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span><span class="n">dim_x</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dim_z</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
<p>Assign the initial value for the state (position and velocity)
for all Kalman Filter points.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initial_location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span>
<span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># x, y, v_x, v_y</span>
<span class="n">kf</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
    <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">initial_location</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Define the state transition matrix for all Kalman Filter points:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># x = x0 + v_x*dt</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  <span class="c1"># y = y0 + v_y*dt</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># dx = v_x</span>
        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
    <span class="p">],</span>  <span class="c1"># dy = v_y</span>
    <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">kf</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Define the measurement function for all Kalman Filter points:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
    <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>  <span class="c1"># x_0  # y_0</span>
<span class="p">)</span>
<span class="n">kf</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Define the covariance matrix for all Kalman Filter points:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initial_estimate_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim_x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span>
<span class="p">)</span>
<span class="n">kf</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
    <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">initial_estimate_error</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span>
    <span class="n">points</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Define the measurement noise  for all Kalman Filter points:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">measurement_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim_z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.01</span>
<span class="n">kf</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
    <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">measurement_noise</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Define the process noise  for all Kalman Filter points:</p>
<blockquote>
<div></div></blockquote>
<p>Now just perform the standard predict/update loop:
Note: This example just uses the same sensor reading for all points</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kf</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">get_sensor_reading</span><span class="p">()</span> <span class="p">(</span><span class="n">dim_z</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">kf</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">kf</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>Results are in:</p>
<blockquote>
<div></div></blockquote>
<p class="rubric">Attributes</p>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 96%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>x</strong></p></td>
<td><p>(array(points, dim_x, 1)) Current state estimate. Any call to update() or predict() updates this variable.</p></td>
</tr>
<tr class="row-even"><td><p><strong>P</strong></p></td>
<td><p>(array(points, dim_x, dim_x)) Current state covariance matrix. Any call to update() or predict() updates this variable.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>z</strong></p></td>
<td><p>(array(points, dim_z, 1)) Last measurement used in update(). Read only.</p></td>
</tr>
<tr class="row-even"><td><p><strong>R</strong></p></td>
<td><p>(array(points, dim_z, dim_z)) Measurement noise matrix</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Q</strong></p></td>
<td><p>(array(points, dim_x, dim_x)) Process noise matrix</p></td>
</tr>
<tr class="row-even"><td><p><strong>F</strong></p></td>
<td><p>(array(points, dim_x, dim_x)) State Transition matrix</p></td>
</tr>
<tr class="row-odd"><td><p><strong>H</strong></p></td>
<td><p>(array(points, dim_z, dim_x)) Measurement function</p></td>
</tr>
<tr class="row-even"><td><p><strong>_alpha_sq</strong></p></td>
<td><p>(float (points, 1, 1)) Fading memory setting. 1.0 gives the normal Kalman filter, and values slightly larger than 1.0 (such as 1.02) give a fading memory effect - previous measurements have less influence on the filter&rsquo;s estimates. This formulation of the Fading memory filter (there are many) is due to Dan Simon <a class="reference internal" href="#r5bc1e6222706-1" id="id5">[1]</a>.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cusignal.estimation.filters.KalmanFilter.predict" title="cusignal.estimation.filters.KalmanFilter.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>([u,&nbsp;B,&nbsp;F,&nbsp;Q])</p></td>
<td><p>Predict next state (prior) using the Kalman filter state propagation equations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cusignal.estimation.filters.KalmanFilter.update" title="cusignal.estimation.filters.KalmanFilter.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(z[,&nbsp;R,&nbsp;H])</p></td>
<td><p>Add a new measurement (z) to the Kalman filter.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cusignal.estimation.filters.KalmanFilter.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.estimation.filters.KalmanFilter.predict" title="Permalink to this definition">#</a></dt>
<dd><p>Predict next state (prior) using the Kalman filter state propagation
equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u</strong><span class="classifier">narray, default 0</span></dt><dd><p>Optional control vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">array(points, dim_x, dim_u), or None</span></dt><dd><p>Optional control transition matrix; a value of None
will cause the filter to use <cite>self.B</cite>.</p>
</dd>
<dt><strong>F</strong><span class="classifier">array(points, dim_x, dim_x), or None</span></dt><dd><p>Optional state transition matrix; a value of None
will cause the filter to use <cite>self.F</cite>.</p>
</dd>
<dt><strong>Q</strong><span class="classifier">array(points, dim_x, dim_x), scalar, or None</span></dt><dd><p>Optional process noise matrix; a value of None will cause the
filter to use <cite>self.Q</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cusignal.estimation.filters.KalmanFilter.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.estimation.filters.KalmanFilter.update" title="Permalink to this definition">#</a></dt>
<dd><p>Add a new measurement (z) to the Kalman filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z</strong><span class="classifier">array(points, dim_z, 1)</span></dt><dd><p>measurement for this update. z can be a scalar if dim_z is 1,
otherwise it must be convertible to a column vector.
If you pass in a value of H, z must be a column vector the
of the correct size.</p>
</dd>
<dt><strong>R</strong><span class="classifier">array(points, dim_z, dim_z), scalar, or None</span></dt><dd><p>Optionally provide R to override the measurement noise for this
one call, otherwise  self.R will be used.</p>
</dd>
<dt><strong>H</strong><span class="classifier">array(points, dim_z, dim_x), or None</span></dt><dd><p>Optionally provide H to override the measurement function for this
one call, otherwise self.H will be used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="filtering">
<h2>Filtering<a class="headerlink" href="#filtering" title="Permalink to this heading">#</a></h2>
<section id="module-cusignal.filtering.resample">
<span id="resample"></span><h3>Resample<a class="headerlink" href="#module-cusignal.filtering.resample" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.filtering.resample.decimate">
<span class="sig-prename descclassname"><span class="pre">cusignal.filtering.resample.</span></span><span class="sig-name descname"><span class="pre">decimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gpupath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filtering.resample.decimate" title="Permalink to this definition">#</a></dt>
<dd><p>Downsample the signal after applying an anti-aliasing filter.
Parameters
&mdash;&mdash;&mdash;-
x : array_like</p>
<blockquote>
<div><p>The signal to be downsampled, as an N-dimensional array.</p>
</div></blockquote>
<dl class="simple">
<dt>q<span class="classifier">int</span></dt><dd><p>The downsampling factor.</p>
</dd>
<dt>n<span class="classifier">int or array_like, optional</span></dt><dd><p>The order of the filter (1 less than the length for FIR) to calculate,
or the FIR filter coefficients to employ. Defaults to calculating the
coefficients for 20 times the downsampling factor.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis along which to decimate.</p>
</dd>
<dt>zero_phase<span class="classifier">bool, optional</span></dt><dd><p>Prevent shifting the outputs back by the filter&rsquo;s
group delay when using an FIR filter. The default value of <code class="docutils literal notranslate"><span class="pre">True</span></code> is
recommended, since a phase shift is generally not desired.</p>
</dd>
<dt>gpupath<span class="classifier">bool, Optional</span></dt><dd><p>Optional path for filter design. gpupath == False may be desirable if
filter sizes are small.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The down-sampled signal.</p>
</dd>
<dt>See Also</dt><dd></dd>
</dl>
<blockquote>
<div></div></blockquote>
<dl class="simple">
<dt><strong>resample</strong><span class="classifier">Resample up or down using the FFT method.</span></dt><dd></dd>
<dt><strong>resample_poly</strong><span class="classifier">Resample using polyphase filtering and an FIR filter.</span></dt><dd></dd>
<dt>Notes</dt><dd></dd>
</dl>
<blockquote>
<div></div></blockquote>
<dl class="simple">
<dt>Only FIR filter types are currently supported in cuSignal.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.filtering.resample.resample">
<span class="sig-prename descclassname"><span class="pre">cusignal.filtering.resample.</span></span><span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'time'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filtering.resample.resample" title="Permalink to this definition">#</a></dt>
<dd><p>Resample <cite>x</cite> to <cite>num</cite> samples using Fourier method along the given axis.</p>
<p>The resampled signal starts at the same value as <cite>x</cite> but is sampled
with a spacing of <code class="docutils literal notranslate"><span class="pre">len(x)</span> <span class="pre">/</span> <span class="pre">num</span> <span class="pre">*</span> <span class="pre">(spacing</span> <span class="pre">of</span> <span class="pre">x)</span></code>.  Because a
Fourier method is used, the signal is assumed to be periodic.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The data to be resampled.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int</span></dt><dd><p>The number of samples in the resampled signal.</p>
</dd>
<dt><strong>t</strong><span class="classifier">array_like, optional</span></dt><dd><p>If <cite>t</cite> is given, it is assumed to be the sample positions
associated with the signal data in <cite>x</cite>.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis of <cite>x</cite> that is resampled.  Default is 0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">array_like, callable, string, float, or tuple, optional</span></dt><dd><p>Specifies the window applied to the signal in the Fourier
domain.  See below for details.</p>
</dd>
<dt><strong>domain</strong><span class="classifier">string, optional</span></dt><dd><p>A string indicating the domain of the input <cite>x</cite>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">time</span></code></dt><dd><p>Consider the input <cite>x</cite> as time-domain. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freq</span></code></dt><dd><p>Consider the input <cite>x</cite> as frequency-domain.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>resampled_x or (resampled_x, resampled_t)</dt><dd><p>Either the resampled array, or, if <cite>t</cite> was given, a tuple
containing the resampled array and the corresponding resampled
positions.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.filtering.resample.decimate" title="cusignal.filtering.resample.decimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate</span></code></a></dt><dd><p>Downsample the signal after applying an FIR or IIR filter.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.filtering.resample.resample_poly" title="cusignal.filtering.resample.resample_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample_poly</span></code></a></dt><dd><p>Resample using polyphase filtering and an FIR filter.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The argument <cite>window</cite> controls a Fourier-domain window that tapers
the Fourier spectrum before zero-padding to alleviate ringing in
the resampled values for sampled signals you didn&rsquo;t intend to be
interpreted as band-limited.</p>
<p>If <cite>window</cite> is a function, then it is called with a vector of inputs
indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).</p>
<p>If <cite>window</cite> is an array of the same length as <cite>x.shape[axis]</cite> it is
assumed to be the window to be applied directly in the Fourier
domain (with dc and low-frequency first).</p>
<p>For any other type of <cite>window</cite>, the function <cite>cusignal.get_window</cite>
is called to generate the window.</p>
<p>The first sample of the returned vector is the same as the first
sample of the input vector.  The spacing between samples is changed
from <code class="docutils literal notranslate"><span class="pre">dx</span></code> to <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">*</span> <span class="pre">len(x)</span> <span class="pre">/</span> <span class="pre">num</span></code>.</p>
<p>If <cite>t</cite> is not None, then it represents the old sample positions,
and the new sample positions will be returned as well as the new
samples.</p>
<p>As noted, <cite>resample</cite> uses FFT transformations, which can be very
slow if the number of input or output samples is large and prime;
see <cite>scipy.fftpack.fft</cite>.</p>
<p class="rubric">Examples</p>
<p>Note that the end of the resampled data rises to meet the first
sample of the next cycle:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xnew</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="s1">'go-'</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">xnew</span><span class="p">),</span>                 <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="s1">'.-'</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">'ro'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'data'</span><span class="p">,</span> <span class="s1">'resampled'</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">'best'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.filtering.resample.resample_poly">
<span class="sig-prename descclassname"><span class="pre">cusignal.filtering.resample.</span></span><span class="sig-name descname"><span class="pre">resample_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">down</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('kaiser',</span> <span class="pre">5.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gpupath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filtering.resample.resample_poly" title="Permalink to this definition">#</a></dt>
<dd><p>Resample <cite>x</cite> along the given axis using polyphase filtering.</p>
<p>The signal <cite>x</cite> is upsampled by the factor <cite>up</cite>, a zero-phase low-pass
FIR filter is applied, and then it is downsampled by the factor <cite>down</cite>.
The resulting sample rate is <code class="docutils literal notranslate"><span class="pre">up</span> <span class="pre">/</span> <span class="pre">down</span></code> times the original sample
rate. Values beyond the boundary of the signal are assumed to be zero
during the filtering step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The data to be resampled.</p>
</dd>
<dt><strong>up</strong><span class="classifier">int</span></dt><dd><p>The upsampling factor.</p>
</dd>
<dt><strong>down</strong><span class="classifier">int</span></dt><dd><p>The downsampling factor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis of <cite>x</cite> that is resampled. Default is 0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">string, tuple, or array_like, optional</span></dt><dd><p>Desired window to use to design the low-pass filter, or the FIR filter
coefficients to employ. See below for details.</p>
</dd>
<dt><strong>gpupath</strong><span class="classifier">bool, Optional</span></dt><dd><p>Optional path for filter design. gpupath == False may be desirable if
filter sizes are small.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resampled_x</strong><span class="classifier">array</span></dt><dd><p>The resampled array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.filtering.resample.decimate" title="cusignal.filtering.resample.decimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate</span></code></a></dt><dd><p>Downsample the signal after applying an FIR or IIR filter.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.filtering.resample.resample" title="cusignal.filtering.resample.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a></dt><dd><p>Resample up or down using the FFT method.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This polyphase method will likely be faster than the Fourier method
in <cite>cusignal.resample</cite> when the number of samples is large and
prime, or when the number of samples is large and <cite>up</cite> and <cite>down</cite>
share a large greatest common denominator. The length of the FIR
filter used will depend on <code class="docutils literal notranslate"><span class="pre">max(up,</span> <span class="pre">down)</span> <span class="pre">//</span> <span class="pre">gcd(up,</span> <span class="pre">down)</span></code>, and
the number of operations during polyphase filtering will depend on
the filter length and <cite>down</cite> (see <cite>cusignal.upfirdn</cite> for details).</p>
<p>The argument <cite>window</cite> specifies the FIR low-pass filter design.</p>
<p>If <cite>window</cite> is an array_like it is assumed to be the FIR filter
coefficients. Note that the FIR filter is applied after the upsampling
step, so it should be designed to operate on a signal at a sampling
frequency higher than the original by a factor of <cite>up//gcd(up, down)</cite>.
This function&rsquo;s output will be centered with respect to this array, so it
is best to pass a symmetric filter with an odd number of samples if, as
is usually the case, a zero-phase filter is desired.</p>
<p>For any other type of <cite>window</cite>, the functions <cite>cusignal.get_window</cite>
and <cite>cusignal.firwin</cite> are called to generate the appropriate filter
coefficients.</p>
<p>The first sample of the returned vector is the same as the first
sample of the input vector. The spacing between samples is changed
from <code class="docutils literal notranslate"><span class="pre">dx</span></code> to <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">*</span> <span class="pre">down</span> <span class="pre">/</span> <span class="pre">float(up)</span></code>.</p>
<p class="rubric">Examples</p>
<p>Note that the end of the resampled data rises to meet the first
sample of the next cycle for the FFT method, and gets closer to zero
for the polyphase method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_fft</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_poly</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xnew</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">xnew</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f_fft</span><span class="p">),</span> <span class="s1">'b.-'</span><span class="p">,</span>                  <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">xnew</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f_poly</span><span class="p">),</span> <span class="s1">'r.-'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="s1">'ko-'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">'bo'</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s1">'ro'</span><span class="p">)</span>  <span class="c1"># boundaries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'resample'</span><span class="p">,</span> <span class="s1">'resamp_poly'</span><span class="p">,</span> <span class="s1">'data'</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">'best'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.filtering.resample.upfirdn">
<span class="sig-prename descclassname"><span class="pre">cusignal.filtering.resample.</span></span><span class="sig-name descname"><span class="pre">upfirdn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">down</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filtering.resample.upfirdn" title="Permalink to this definition">#</a></dt>
<dd><p>Upsample, FIR filter, and downsample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>h</strong><span class="classifier">array_like</span></dt><dd><p>1-dimensional FIR (finite-impulse response) filter coefficients.</p>
</dd>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Input signal array.</p>
</dd>
<dt><strong>up</strong><span class="classifier">int, optional</span></dt><dd><p>Upsampling rate. Default is 1.</p>
</dd>
<dt><strong>down</strong><span class="classifier">int, optional</span></dt><dd><p>Downsampling rate. Default is 1.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis. Default is -1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>The output signal array. Dimensions will be the same as <cite>x</cite> except
for along <cite>axis</cite>, which will change size according to the <cite>h</cite>,
<cite>up</cite>,  and <cite>down</cite> parameters.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The algorithm is an implementation of the block diagram shown on page 129
of the Vaidyanathan text <a class="reference internal" href="#r9ac9eb812332-1" id="id6">[1]</a> (Figure 4.3-8d).</p>
<p>The direct approach of upsampling by factor of P with zero insertion,
FIR filtering of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, and downsampling by factor of Q is
O(N*Q) per output sample. The polyphase implementation used here is
O(N/P).</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9ac9eb812332-1"><span class="brackets"><a class="fn-backref" href="#id6">1</a></span></dt>
<dd><p>P. P. Vaidyanathan, Multirate Systems and Filter Banks,
Prentice Hall, 1993.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple operations:
&gt;&gt;&gt; from cusignal import upfirdn
&gt;&gt;&gt; upfirdn([1, 1, 1], [1, 1, 1])   # FIR filter
array([ 1.,  2.,  3.,  2.,  1.])
&gt;&gt;&gt; upfirdn([1], [1, 2, 3], 3)  # upsampling with zeros insertion
array([ 1.,  0.,  0.,  2.,  0.,  0.,  3.,  0.,  0.])
&gt;&gt;&gt; upfirdn([1, 1, 1], [1, 2, 3], 3)  # upsampling with sample-and-hold
array([ 1.,  1.,  1.,  2.,  2.,  2.,  3.,  3.,  3.])
&gt;&gt;&gt; upfirdn([.5, 1, .5], [1, 1, 1], 2)  # linear interpolation
array([ 0.5,  1. ,  1. ,  1. ,  1. ,  1. ,  0.5,  0. ])
&gt;&gt;&gt; upfirdn([1], cp.arange(10), 1, 3)  # decimation by 3
array([ 0.,  3.,  6.,  9.])
&gt;&gt;&gt; upfirdn([.5, 1, .5], cp.arange(10), 2, 3)  # linear interp, rate 2/3
array([ 0. ,  1. ,  2.5,  4. ,  5.5,  7. ,  8.5,  0. ])
Apply a single filter to multiple signals:
&gt;&gt;&gt; x = cp.reshape(cp.arange(8), (4, 2))
&gt;&gt;&gt; x
array([[0, 1],</p>
<blockquote>
<div><p>[2, 3],
[4, 5],
[6, 7]])</p>
</div></blockquote>
<p>Apply along the last dimension of <code class="docutils literal notranslate"><span class="pre">x</span></code>:
&gt;&gt;&gt; h = [1, 1]
&gt;&gt;&gt; upfirdn(h, x, 2)
array([[ 0.,  0.,  1.,  1.],</p>
<blockquote>
<div><p>[ 2.,  2.,  3.,  3.],
[ 4.,  4.,  5.,  5.],
[ 6.,  6.,  7.,  7.]])</p>
</div></blockquote>
<p>Apply along the 0th dimension of <code class="docutils literal notranslate"><span class="pre">x</span></code>:
&gt;&gt;&gt; upfirdn(h, x, 2, axis=0)
array([[ 0.,  1.],</p>
<blockquote>
<div><p>[ 0.,  1.],
[ 2.,  3.],
[ 2.,  3.],
[ 4.,  5.],
[ 4.,  5.],
[ 6.,  7.],
[ 6.,  7.]])</p>
</div></blockquote>
</dd></dl>

</section>
<section id="module-cusignal.filtering.filtering.firfilter">
<span id="fir-filters"></span><h3>FIR Filters<a class="headerlink" href="#module-cusignal.filtering.filtering.firfilter" title="Permalink to this heading">#</a></h3>
<p>Filter data along one-dimension with an FIR filter.</p>
<p>Filter a data sequence, <cite>x</cite>, using a digital filter. This works for many
fundamental data types (including Object type). Please note, cuSignal
doesn&rsquo;t support IIR filters presently, and this implementation is optimized
for large filtering operations (and inherently depends on fftconvolve)</p>
<section id="parameters">
<h4>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>b<span class="classifier">array_like</span></dt><dd><p>The numerator coefficient vector in a 1-D sequence.</p>
</dd>
<dt>x<span class="classifier">array_like</span></dt><dd><p>An N-dimensional input array.</p>
</dd>
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis.  Default is -1.</p>
</dd>
<dt>zi<span class="classifier">array_like, optional</span></dt><dd><p>Initial conditions for the filter delays.  It is a vector
(or array of vectors for an N-dimensional input) of length
<code class="docutils literal notranslate"><span class="pre">max(len(a),</span> <span class="pre">len(b))</span> <span class="pre">-</span> <span class="pre">1</span></code>.  If <cite>zi</cite> is None or is not given then
initial rest is assumed.  See <cite>lfiltic</cite> for more information.</p>
</dd>
</dl>
</section>
<section id="returns">
<h4>Returns<a class="headerlink" href="#returns" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>y<span class="classifier">array</span></dt><dd><p>The output of the digital filter.</p>
</dd>
<dt>zf<span class="classifier">array, optional</span></dt><dd><p>If <cite>zi</cite> is None, this is not returned, otherwise, <cite>zf</cite> holds the
final filter delay values.</p>
</dd>
</dl>
</section>
<span class="target" id="module-cusignal.filter_design.fir_filter_design"></span><dl class="py function">
<dt class="sig sig-object py" id="cusignal.filter_design.fir_filter_design.cmplx_sort">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">cmplx_sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filter_design.fir_filter_design.cmplx_sort" title="Permalink to this definition">#</a></dt>
<dd><p>Sort roots based on magnitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">array_like</span></dt><dd><p>The roots to sort, as a 1-D array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p_sorted</strong><span class="classifier">ndarray</span></dt><dd><p>Sorted roots.</p>
</dd>
<dt><strong>indx</strong><span class="classifier">ndarray</span></dt><dd><p>Array of indices needed to sort the input <cite>p</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_sorted</span><span class="p">,</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">cmplx_sort</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_sorted</span>
<span class="go">array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span>
<span class="go">array([0, 2, 3, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.filter_design.fir_filter_design.firwin">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">firwin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numtaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hamming'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nyq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gpupath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filter_design.fir_filter_design.firwin" title="Permalink to this definition">#</a></dt>
<dd><p>FIR filter design using the window method.</p>
<p>This function computes the coefficients of a finite impulse response
filter.  The filter will have linear phase; it will be Type I if
<cite>numtaps</cite> is odd and Type II if <cite>numtaps</cite> is even.</p>
<p>Type II filters always have zero response at the Nyquist frequency, so a
ValueError exception is raised if firwin is called with <cite>numtaps</cite> even and
having a passband whose right end is at the Nyquist frequency.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>numtaps</strong><span class="classifier">int</span></dt><dd><p>Length of the filter (number of coefficients, i.e. the filter
order + 1).  <cite>numtaps</cite> must be odd if a passband includes the
Nyquist frequency.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float or 1D array_like</span></dt><dd><p>Cutoff frequency of filter (expressed in the same units as <cite>fs</cite>)
OR an array of cutoff frequencies (that is, band edges). In the
latter case, the frequencies in <cite>cutoff</cite> should be positive and
monotonically increasing between 0 and <cite>fs/2</cite>.  The values 0 and
<cite>fs/2</cite> must not be included in <cite>cutoff</cite>.</p>
</dd>
<dt><strong>width</strong><span class="classifier">float or None, optional</span></dt><dd><p>If <cite>width</cite> is not None, then assume it is the approximate width
of the transition region (expressed in the same units as <cite>fs</cite>)
for use in Kaiser FIR filter design.  In this case, the <cite>window</cite>
argument is ignored.</p>
</dd>
<dt><strong>window</strong><span class="classifier">string or tuple of string and parameter values, optional</span></dt><dd><p>Desired window to use. See <cite>cusignal.get_window</cite> for a list
of windows and required parameters.</p>
</dd>
<dt><strong>pass_zero</strong><span class="classifier">{True, False, &lsquo;bandpass&rsquo;, &lsquo;lowpass&rsquo;, &lsquo;highpass&rsquo;, &lsquo;bandstop&rsquo;},</span></dt><dd><p>optional
If True, the gain at the frequency 0 (i.e. the &ldquo;DC gain&rdquo;) is 1.
If False, the DC gain is 0. Can also be a string argument for the
desired filter type (equivalent to <code class="docutils literal notranslate"><span class="pre">btype</span></code> in IIR design functions).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0: </span>Support for string arguments.</p>
</div>
</dd>
<dt><strong>scale</strong><span class="classifier">bool, optional</span></dt><dd><p>Set to True to scale the coefficients so that the frequency
response is exactly unity at a certain frequency.
That frequency is either:</p>
<ul class="simple">
<li><p>0 (DC) if the first passband starts at 0 (i.e. pass_zero
is True)</p></li>
<li><p><cite>fs/2</cite> (the Nyquist frequency) if the first passband ends at
<cite>fs/2</cite> (i.e the filter is a single band highpass filter);
center of first passband otherwise</p></li>
</ul>
</dd>
<dt><strong>nyq</strong><span class="classifier">float, optional</span></dt><dd><p><em>Deprecated.  Use `fs` instead.</em>  This is the Nyquist frequency.
Each frequency in <cite>cutoff</cite> must be between 0 and <cite>nyq</cite>. Default
is 1.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float, optional</span></dt><dd><p>The sampling frequency of the signal.  Each frequency in <cite>cutoff</cite>
must be between 0 and <code class="docutils literal notranslate"><span class="pre">fs/2</span></code>.  Default is 2.</p>
</dd>
<dt><strong>gpupath</strong><span class="classifier">bool, Optional</span></dt><dd><p>Optional path for filter design. gpupath == False may be desirable if
filter sizes are small.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h</strong><span class="classifier">(numtaps,) ndarray</span></dt><dd><p>Coefficients of length <cite>numtaps</cite> FIR filter.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If any value in <cite>cutoff</cite> is less than or equal to 0 or greater
than or equal to <code class="docutils literal notranslate"><span class="pre">fs/2</span></code>, if the values in <cite>cutoff</cite> are not strictly
monotonically increasing, or if <cite>numtaps</cite> is even but a passband
includes the Nyquist frequency.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id12" title="cusignal.filter_design.fir_filter_design.firwin2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">firwin2</span></code></a></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">firls</span></code></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum_phase</span></code></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">remez</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Low-pass from 0 to f:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numtaps</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="go">array([ 0.06799017,  0.86401967,  0.06799017])</span>
</pre></div>
</div>
<p>Use a specific window function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">'nuttall'</span><span class="p">)</span>
<span class="go">array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04])</span>
</pre></div>
</div>
<p>High-pass (&lsquo;stop&rsquo; from 0 to f):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([-0.00859313,  0.98281375, -0.00859313])</span>
</pre></div>
</div>
<p>Band-pass:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">],</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 0.06301614,  0.88770441,  0.06301614])</span>
</pre></div>
</div>
<p>Band-stop:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="go">array([-0.00801395,  1.0160279 , -0.00801395])</span>
</pre></div>
</div>
<p>Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span><span class="p">,</span> <span class="n">f4</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">])</span>
<span class="go">array([-0.01376344,  1.02752689, -0.01376344])</span>
</pre></div>
</div>
<p>Multi-band (passbands are [f1, f2] and [f3,f4]):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">],</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 0.04890915,  0.91284326,  0.04890915])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.filter_design.fir_filter_design.firwin2">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">firwin2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numtaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfreqs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hamming'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nyq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">antisymmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gpupath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filter_design.fir_filter_design.firwin2" title="Permalink to this definition">#</a></dt>
<dd><p>FIR filter design using the window method.
From the given frequencies <cite>freq</cite> and corresponding gains <cite>gain</cite>,
this function constructs an FIR filter with linear phase and
(approximately) the given frequency response.
Parameters
&mdash;&mdash;&mdash;-
numtaps : int</p>
<blockquote>
<div><p>The number of taps in the FIR filter.  <cite>numtaps</cite> must be less than
<cite>nfreqs</cite>.</p>
</div></blockquote>
<dl class="simple">
<dt>freq<span class="classifier">array_like, 1-D</span></dt><dd><p>The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being
Nyquist.  The Nyquist frequency is half <cite>fs</cite>.
The values in <cite>freq</cite> must be nondecreasing. A value can be repeated
once to implement a discontinuity. The first value in <cite>freq</cite> must
be 0, and the last value must be <code class="docutils literal notranslate"><span class="pre">fs/2</span></code>. Values 0 and <code class="docutils literal notranslate"><span class="pre">fs/2</span></code> must
not be repeated.</p>
</dd>
<dt>gain<span class="classifier">array_like</span></dt><dd><p>The filter gains at the frequency sampling points. Certain
constraints to gain values, depending on the filter type, are applied,
see Notes for details.</p>
</dd>
<dt>nfreqs<span class="classifier">int, optional</span></dt><dd><p>The size of the interpolation mesh used to construct the filter.
For most efficient behavior, this should be a power of 2 plus 1
(e.g, 129, 257, etc). The default is one more than the smallest
power of 2 that is not less than <cite>numtaps</cite>. <cite>nfreqs</cite> must be greater
than <cite>numtaps</cite>.</p>
</dd>
<dt>window<span class="classifier">string or (string, float) or float, or None, optional</span></dt><dd><p>Window function to use. Default is &ldquo;hamming&rdquo;. See
<cite>scipy.signal.get_window</cite> for the complete list of possible values.
If None, no window function is applied.</p>
</dd>
<dt>nyq<span class="classifier">float, optional</span></dt><dd><p><em>Deprecated. Use `fs` instead.</em> This is the Nyquist frequency.
Each frequency in <cite>freq</cite> must be between 0 and <cite>nyq</cite>.  Default is 1.</p>
</dd>
<dt>antisymmetric<span class="classifier">bool, optional</span></dt><dd><p>Whether resulting impulse response is symmetric/antisymmetric.
See Notes for more details.</p>
</dd>
<dt>fs<span class="classifier">float, optional</span></dt><dd><p>The sampling frequency of the signal. Each frequency in <cite>cutoff</cite>
must be between 0 and <code class="docutils literal notranslate"><span class="pre">fs/2</span></code>. Default is 2.</p>
</dd>
</dl>
<dl class="simple">
<dt>taps<span class="classifier">ndarray</span></dt><dd><p>The filter coefficients of the FIR filter, as a 1-D array of length
<cite>numtaps</cite>.</p>
</dd>
</dl>
<p>firls
firwin
minimum_phase
remez
Notes
&mdash;&ndash;
From the given set of frequencies and gains, the desired response is
constructed in the frequency domain. The inverse FFT is applied to the
desired response to create the associated convolution kernel, and the
first <cite>numtaps</cite> coefficients of this kernel, scaled by <cite>window</cite>, are
returned.
The FIR filter will have linear phase. The type of filter is determined by
the value of &lsquo;numtaps` and <cite>antisymmetric</cite> flag.
There are four possible combinations:</p>
<blockquote>
<div><ul class="simple">
<li><p>odd  <cite>numtaps</cite>, <cite>antisymmetric</cite> is False, type I filter is produced</p></li>
<li><p>even <cite>numtaps</cite>, <cite>antisymmetric</cite> is False, type II filter is produced</p></li>
<li><p>odd  <cite>numtaps</cite>, <cite>antisymmetric</cite> is True, type III filter is produced</p></li>
<li><p>even <cite>numtaps</cite>, <cite>antisymmetric</cite> is True, type IV filter is produced</p></li>
</ul>
</div></blockquote>
<p>Magnitude response of all but type I filters are subjects to following
constraints:</p>
<blockquote>
<div><ul class="simple">
<li><p>type II  &ndash; zero at the Nyquist frequency</p></li>
<li><p>type III &ndash; zero at zero and Nyquist frequencies</p></li>
<li><p>type IV  &ndash; zero at zero frequency</p></li>
</ul>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.9.0.</span></p>
</div>
<dl class="citation">
<dt class="label" id="rea3838c19fb4-1"><span class="brackets">1</span></dt>
<dd><p>Oppenheim, A. V. and Schafer, R. W., &ldquo;Discrete-Time Signal
Processing&rdquo;, Prentice-Hall, Englewood Cliffs, New Jersey (1989).
(See, for example, Section 7.4.)</p>
</dd>
<dt class="label" id="rea3838c19fb4-2"><span class="brackets">2</span></dt>
<dd><p>Smith, Steven W., &ldquo;The Scientist and Engineer&rsquo;s Guide to Digital
Signal Processing&rdquo;, Ch. 17. <a class="reference external" href="http://www.dspguide.com/ch17/1.htm">http://www.dspguide.com/ch17/1.htm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.filter_design.fir_filter_design.kaiser_atten">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">kaiser_atten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numtaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filter_design.fir_filter_design.kaiser_atten" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the attenuation of a Kaiser FIR filter.
Given the number of taps <cite>N</cite> and the transition width <cite>width</cite>, compute the
attenuation <cite>a</cite> in dB, given by Kaiser&rsquo;s formula:</p>
<blockquote>
<div><p>a = 2.285 * (N - 1) * pi * width + 7.95</p>
</div></blockquote>
<dl class="simple">
<dt>numtaps<span class="classifier">int</span></dt><dd><p>The number of taps in the FIR filter.</p>
</dd>
<dt>width<span class="classifier">float</span></dt><dd><p>The desired width of the transition region between passband and
stopband (or, in general, at any discontinuity) for the filter.</p>
</dd>
</dl>
<dl class="simple">
<dt>a<span class="classifier">float</span></dt><dd><p>The attenuation of the ripple, in dB.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.filter_design.fir_filter_design.kaiser_beta">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">kaiser_beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.filter_design.fir_filter_design.kaiser_beta" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Kaiser parameter <cite>beta</cite>, given the attenuation <cite>a</cite>.
Parameters
&mdash;&mdash;&mdash;-
a : float</p>
<blockquote>
<div><p>The desired attenuation in the stopband and maximum ripple in
the passband, in dB.  This should be a <em>positive</em> number.</p>
</div></blockquote>
<dl class="simple">
<dt>beta<span class="classifier">float</span></dt><dd><p>The <cite>beta</cite> parameter to be used in the formula for a Kaiser window.</p>
</dd>
</dl>
<p>Oppenheim, Schafer, &ldquo;Discrete-Time Signal Processing&rdquo;, p.475-476.</p>
</dd></dl>

</section>
<section id="module-cusignal.filtering.channelize_poly">
<span id="channelizer"></span><h3>Channelizer<a class="headerlink" href="#module-cusignal.filtering.channelize_poly" title="Permalink to this heading">#</a></h3>
<p>Polyphase channelize signal into n channels</p>
<section id="id8">
<h4>Parameters<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>The input data to be channelized</p>
</dd>
<dt>h<span class="classifier">array_like</span></dt><dd><p>The 1-D input filter; will be split into n
channels of int number of taps</p>
</dd>
<dt>n_chans<span class="classifier">int</span></dt><dd><p>Number of channels for channelizer</p>
</dd>
</dl>
</section>
<section id="id9">
<h4>Returns<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h4>
<p>yy : channelized output matrix</p>
</section>
<section id="notes">
<h4>Notes<a class="headerlink" href="#notes" title="Permalink to this heading">#</a></h4>
<p>Currently only supports simple channelizer where channel
spacing is equivalent to the number of channels used (zero overlap).
Number of filter taps (len of filter / n_chans) must be &lt;=32.</p>
</section>
</section>
</section>
<section id="filter-design">
<h2>Filter Design<a class="headerlink" href="#filter-design" title="Permalink to this heading">#</a></h2>
<section id="id10">
<h3>Resample<a class="headerlink" href="#id10" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-0"></span><dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">cmplx_sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition">#</a></dt>
<dd><p>Sort roots based on magnitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">array_like</span></dt><dd><p>The roots to sort, as a 1-D array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p_sorted</strong><span class="classifier">ndarray</span></dt><dd><p>Sorted roots.</p>
</dd>
<dt><strong>indx</strong><span class="classifier">ndarray</span></dt><dd><p>Array of indices needed to sort the input <cite>p</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_sorted</span><span class="p">,</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">cmplx_sort</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_sorted</span>
<span class="go">array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span>
<span class="go">array([0, 2, 3, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id11">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">firwin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numtaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hamming'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nyq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gpupath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id11" title="Permalink to this definition">#</a></dt>
<dd><p>FIR filter design using the window method.</p>
<p>This function computes the coefficients of a finite impulse response
filter.  The filter will have linear phase; it will be Type I if
<cite>numtaps</cite> is odd and Type II if <cite>numtaps</cite> is even.</p>
<p>Type II filters always have zero response at the Nyquist frequency, so a
ValueError exception is raised if firwin is called with <cite>numtaps</cite> even and
having a passband whose right end is at the Nyquist frequency.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>numtaps</strong><span class="classifier">int</span></dt><dd><p>Length of the filter (number of coefficients, i.e. the filter
order + 1).  <cite>numtaps</cite> must be odd if a passband includes the
Nyquist frequency.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float or 1D array_like</span></dt><dd><p>Cutoff frequency of filter (expressed in the same units as <cite>fs</cite>)
OR an array of cutoff frequencies (that is, band edges). In the
latter case, the frequencies in <cite>cutoff</cite> should be positive and
monotonically increasing between 0 and <cite>fs/2</cite>.  The values 0 and
<cite>fs/2</cite> must not be included in <cite>cutoff</cite>.</p>
</dd>
<dt><strong>width</strong><span class="classifier">float or None, optional</span></dt><dd><p>If <cite>width</cite> is not None, then assume it is the approximate width
of the transition region (expressed in the same units as <cite>fs</cite>)
for use in Kaiser FIR filter design.  In this case, the <cite>window</cite>
argument is ignored.</p>
</dd>
<dt><strong>window</strong><span class="classifier">string or tuple of string and parameter values, optional</span></dt><dd><p>Desired window to use. See <cite>cusignal.get_window</cite> for a list
of windows and required parameters.</p>
</dd>
<dt><strong>pass_zero</strong><span class="classifier">{True, False, &lsquo;bandpass&rsquo;, &lsquo;lowpass&rsquo;, &lsquo;highpass&rsquo;, &lsquo;bandstop&rsquo;},</span></dt><dd><p>optional
If True, the gain at the frequency 0 (i.e. the &ldquo;DC gain&rdquo;) is 1.
If False, the DC gain is 0. Can also be a string argument for the
desired filter type (equivalent to <code class="docutils literal notranslate"><span class="pre">btype</span></code> in IIR design functions).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0: </span>Support for string arguments.</p>
</div>
</dd>
<dt><strong>scale</strong><span class="classifier">bool, optional</span></dt><dd><p>Set to True to scale the coefficients so that the frequency
response is exactly unity at a certain frequency.
That frequency is either:</p>
<ul class="simple">
<li><p>0 (DC) if the first passband starts at 0 (i.e. pass_zero
is True)</p></li>
<li><p><cite>fs/2</cite> (the Nyquist frequency) if the first passband ends at
<cite>fs/2</cite> (i.e the filter is a single band highpass filter);
center of first passband otherwise</p></li>
</ul>
</dd>
<dt><strong>nyq</strong><span class="classifier">float, optional</span></dt><dd><p><em>Deprecated.  Use `fs` instead.</em>  This is the Nyquist frequency.
Each frequency in <cite>cutoff</cite> must be between 0 and <cite>nyq</cite>. Default
is 1.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float, optional</span></dt><dd><p>The sampling frequency of the signal.  Each frequency in <cite>cutoff</cite>
must be between 0 and <code class="docutils literal notranslate"><span class="pre">fs/2</span></code>.  Default is 2.</p>
</dd>
<dt><strong>gpupath</strong><span class="classifier">bool, Optional</span></dt><dd><p>Optional path for filter design. gpupath == False may be desirable if
filter sizes are small.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h</strong><span class="classifier">(numtaps,) ndarray</span></dt><dd><p>Coefficients of length <cite>numtaps</cite> FIR filter.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If any value in <cite>cutoff</cite> is less than or equal to 0 or greater
than or equal to <code class="docutils literal notranslate"><span class="pre">fs/2</span></code>, if the values in <cite>cutoff</cite> are not strictly
monotonically increasing, or if <cite>numtaps</cite> is even but a passband
includes the Nyquist frequency.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id12" title="cusignal.filter_design.fir_filter_design.firwin2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">firwin2</span></code></a></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">firls</span></code></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimum_phase</span></code></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">remez</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Low-pass from 0 to f:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numtaps</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="go">array([ 0.06799017,  0.86401967,  0.06799017])</span>
</pre></div>
</div>
<p>Use a specific window function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">'nuttall'</span><span class="p">)</span>
<span class="go">array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04])</span>
</pre></div>
</div>
<p>High-pass (&lsquo;stop&rsquo; from 0 to f):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([-0.00859313,  0.98281375, -0.00859313])</span>
</pre></div>
</div>
<p>Band-pass:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">],</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 0.06301614,  0.88770441,  0.06301614])</span>
</pre></div>
</div>
<p>Band-stop:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="go">array([-0.00801395,  1.0160279 , -0.00801395])</span>
</pre></div>
</div>
<p>Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span><span class="p">,</span> <span class="n">f4</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">])</span>
<span class="go">array([-0.01376344,  1.02752689, -0.01376344])</span>
</pre></div>
</div>
<p>Multi-band (passbands are [f1, f2] and [f3,f4]):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">],</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 0.04890915,  0.91284326,  0.04890915])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id12">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">firwin2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numtaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfreqs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hamming'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nyq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">antisymmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gpupath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id12" title="Permalink to this definition">#</a></dt>
<dd><p>FIR filter design using the window method.
From the given frequencies <cite>freq</cite> and corresponding gains <cite>gain</cite>,
this function constructs an FIR filter with linear phase and
(approximately) the given frequency response.
Parameters
&mdash;&mdash;&mdash;-
numtaps : int</p>
<blockquote>
<div><p>The number of taps in the FIR filter.  <cite>numtaps</cite> must be less than
<cite>nfreqs</cite>.</p>
</div></blockquote>
<dl class="simple">
<dt>freq<span class="classifier">array_like, 1-D</span></dt><dd><p>The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being
Nyquist.  The Nyquist frequency is half <cite>fs</cite>.
The values in <cite>freq</cite> must be nondecreasing. A value can be repeated
once to implement a discontinuity. The first value in <cite>freq</cite> must
be 0, and the last value must be <code class="docutils literal notranslate"><span class="pre">fs/2</span></code>. Values 0 and <code class="docutils literal notranslate"><span class="pre">fs/2</span></code> must
not be repeated.</p>
</dd>
<dt>gain<span class="classifier">array_like</span></dt><dd><p>The filter gains at the frequency sampling points. Certain
constraints to gain values, depending on the filter type, are applied,
see Notes for details.</p>
</dd>
<dt>nfreqs<span class="classifier">int, optional</span></dt><dd><p>The size of the interpolation mesh used to construct the filter.
For most efficient behavior, this should be a power of 2 plus 1
(e.g, 129, 257, etc). The default is one more than the smallest
power of 2 that is not less than <cite>numtaps</cite>. <cite>nfreqs</cite> must be greater
than <cite>numtaps</cite>.</p>
</dd>
<dt>window<span class="classifier">string or (string, float) or float, or None, optional</span></dt><dd><p>Window function to use. Default is &ldquo;hamming&rdquo;. See
<cite>scipy.signal.get_window</cite> for the complete list of possible values.
If None, no window function is applied.</p>
</dd>
<dt>nyq<span class="classifier">float, optional</span></dt><dd><p><em>Deprecated. Use `fs` instead.</em> This is the Nyquist frequency.
Each frequency in <cite>freq</cite> must be between 0 and <cite>nyq</cite>.  Default is 1.</p>
</dd>
<dt>antisymmetric<span class="classifier">bool, optional</span></dt><dd><p>Whether resulting impulse response is symmetric/antisymmetric.
See Notes for more details.</p>
</dd>
<dt>fs<span class="classifier">float, optional</span></dt><dd><p>The sampling frequency of the signal. Each frequency in <cite>cutoff</cite>
must be between 0 and <code class="docutils literal notranslate"><span class="pre">fs/2</span></code>. Default is 2.</p>
</dd>
</dl>
<dl class="simple">
<dt>taps<span class="classifier">ndarray</span></dt><dd><p>The filter coefficients of the FIR filter, as a 1-D array of length
<cite>numtaps</cite>.</p>
</dd>
</dl>
<p>firls
firwin
minimum_phase
remez
Notes
&mdash;&ndash;
From the given set of frequencies and gains, the desired response is
constructed in the frequency domain. The inverse FFT is applied to the
desired response to create the associated convolution kernel, and the
first <cite>numtaps</cite> coefficients of this kernel, scaled by <cite>window</cite>, are
returned.
The FIR filter will have linear phase. The type of filter is determined by
the value of &lsquo;numtaps` and <cite>antisymmetric</cite> flag.
There are four possible combinations:</p>
<blockquote>
<div><ul class="simple">
<li><p>odd  <cite>numtaps</cite>, <cite>antisymmetric</cite> is False, type I filter is produced</p></li>
<li><p>even <cite>numtaps</cite>, <cite>antisymmetric</cite> is False, type II filter is produced</p></li>
<li><p>odd  <cite>numtaps</cite>, <cite>antisymmetric</cite> is True, type III filter is produced</p></li>
<li><p>even <cite>numtaps</cite>, <cite>antisymmetric</cite> is True, type IV filter is produced</p></li>
</ul>
</div></blockquote>
<p>Magnitude response of all but type I filters are subjects to following
constraints:</p>
<blockquote>
<div><ul class="simple">
<li><p>type II  &ndash; zero at the Nyquist frequency</p></li>
<li><p>type III &ndash; zero at zero and Nyquist frequencies</p></li>
<li><p>type IV  &ndash; zero at zero frequency</p></li>
</ul>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.9.0.</span></p>
</div>
<dl class="citation">
<dt class="label" id="id13"><span class="brackets">1</span></dt>
<dd><p>Oppenheim, A. V. and Schafer, R. W., &ldquo;Discrete-Time Signal
Processing&rdquo;, Prentice-Hall, Englewood Cliffs, New Jersey (1989).
(See, for example, Section 7.4.)</p>
</dd>
<dt class="label" id="id14"><span class="brackets">2</span></dt>
<dd><p>Smith, Steven W., &ldquo;The Scientist and Engineer&rsquo;s Guide to Digital
Signal Processing&rdquo;, Ch. 17. <a class="reference external" href="http://www.dspguide.com/ch17/1.htm">http://www.dspguide.com/ch17/1.htm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id15">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">kaiser_atten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numtaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id15" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the attenuation of a Kaiser FIR filter.
Given the number of taps <cite>N</cite> and the transition width <cite>width</cite>, compute the
attenuation <cite>a</cite> in dB, given by Kaiser&rsquo;s formula:</p>
<blockquote>
<div><p>a = 2.285 * (N - 1) * pi * width + 7.95</p>
</div></blockquote>
<dl class="simple">
<dt>numtaps<span class="classifier">int</span></dt><dd><p>The number of taps in the FIR filter.</p>
</dd>
<dt>width<span class="classifier">float</span></dt><dd><p>The desired width of the transition region between passband and
stopband (or, in general, at any discontinuity) for the filter.</p>
</dd>
</dl>
<dl class="simple">
<dt>a<span class="classifier">float</span></dt><dd><p>The attenuation of the ripple, in dB.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id16">
<span class="sig-prename descclassname"><span class="pre">cusignal.filter_design.fir_filter_design.</span></span><span class="sig-name descname"><span class="pre">kaiser_beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id16" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Kaiser parameter <cite>beta</cite>, given the attenuation <cite>a</cite>.
Parameters
&mdash;&mdash;&mdash;-
a : float</p>
<blockquote>
<div><p>The desired attenuation in the stopband and maximum ripple in
the passband, in dB.  This should be a <em>positive</em> number.</p>
</div></blockquote>
<dl class="simple">
<dt>beta<span class="classifier">float</span></dt><dd><p>The <cite>beta</cite> parameter to be used in the formula for a Kaiser window.</p>
</dd>
</dl>
<p>Oppenheim, Schafer, &ldquo;Discrete-Time Signal Processing&rdquo;, p.475-476.</p>
</dd></dl>

</section>
</section>
<section id="peak-finding">
<h2>Peak Finding<a class="headerlink" href="#peak-finding" title="Permalink to this heading">#</a></h2>
<section id="id17">
<h3>Peak Finding<a class="headerlink" href="#id17" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-cusignal.peak_finding.peak_finding"></span><dl class="py function">
<dt class="sig sig-object py" id="cusignal.peak_finding.peak_finding.argrelextrema">
<span class="sig-prename descclassname"><span class="pre">cusignal.peak_finding.peak_finding.</span></span><span class="sig-name descname"><span class="pre">argrelextrema</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comparator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clip'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.peak_finding.peak_finding.argrelextrema" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the relative extrema of <cite>data</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>Array in which to find the relative extrema.</p>
</dd>
<dt><strong>comparator</strong><span class="classifier">callable</span></dt><dd><p>Function to use to compare two data points.
Should take two arrays as arguments.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to select from <cite>data</cite>.  Default is 0.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>How many points on each side to use for the comparison
to consider <code class="docutils literal notranslate"><span class="pre">comparator(n,</span> <span class="pre">n+x)</span></code> to be True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>extrema</strong><span class="classifier">tuple of ndarrays</span></dt><dd><p>Indices of the maxima in arrays of integers.  <code class="docutils literal notranslate"><span class="pre">extrema[k]</span></code> is
the array of indices of axis <cite>k</cite> of <cite>data</cite>.  Note that the
return value is a tuple even when <cite>data</cite> is one-dimensional.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.peak_finding.peak_finding.argrelmin" title="cusignal.peak_finding.peak_finding.argrelmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argrelmin</span></code></a>, <a class="reference internal" href="#cusignal.peak_finding.peak_finding.argrelmax" title="cusignal.peak_finding.peak_finding.argrelmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argrelmax</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cusignal</span> <span class="kn">import</span> <span class="n">argrelextrema</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">argrelextrema</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">greater</span><span class="p">)</span>
<span class="go">(array([3, 6]),)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">argrelextrema</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">less</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(array([0, 2]), array([2, 1]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.peak_finding.peak_finding.argrelmax">
<span class="sig-prename descclassname"><span class="pre">cusignal.peak_finding.peak_finding.</span></span><span class="sig-name descname"><span class="pre">argrelmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clip'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.peak_finding.peak_finding.argrelmax" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the relative maxima of <cite>data</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>Array in which to find the relative maxima.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to select from <cite>data</cite>.  Default is 0.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>How many points on each side to use for the comparison
to consider <code class="docutils literal notranslate"><span class="pre">comparator(n,</span> <span class="pre">n+x)</span></code> to be True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>extrema</strong><span class="classifier">tuple of ndarrays</span></dt><dd><p>Indices of the maxima in arrays of integers.  <code class="docutils literal notranslate"><span class="pre">extrema[k]</span></code> is
the array of indices of axis <cite>k</cite> of <cite>data</cite>.  Note that the
return value is a tuple even when <cite>data</cite> is one-dimensional.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.peak_finding.peak_finding.argrelextrema" title="cusignal.peak_finding.peak_finding.argrelextrema"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argrelextrema</span></code></a>, <a class="reference internal" href="#cusignal.peak_finding.peak_finding.argrelmin" title="cusignal.peak_finding.peak_finding.argrelmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argrelmin</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">find_peaks</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function uses <cite>argrelextrema</cite> with cp.greater as comparator. Therefore
it  requires a strict inequality on both sides of a value to consider it a
maximum. This means flat maxima (more than one sample wide) are not
detected. In case of one-dimensional <cite>data</cite> <cite>find_peaks</cite> can be used to
detect all local maxima, including flat ones.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cusignal</span> <span class="kn">import</span> <span class="n">argrelmax</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">argrelmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(array([3, 6]),)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">argrelmax</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(array([0]), array([1]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.peak_finding.peak_finding.argrelmin">
<span class="sig-prename descclassname"><span class="pre">cusignal.peak_finding.peak_finding.</span></span><span class="sig-name descname"><span class="pre">argrelmin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clip'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.peak_finding.peak_finding.argrelmin" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the relative minima of <cite>data</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">ndarray</span></dt><dd><p>Array in which to find the relative minima.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis over which to select from <cite>data</cite>.  Default is 0.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>How many points on each side to use for the comparison
to consider <code class="docutils literal notranslate"><span class="pre">comparator(n,</span> <span class="pre">n+x)</span></code> to be True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>extrema</strong><span class="classifier">tuple of ndarrays</span></dt><dd><p>Indices of the minima in arrays of integers.  <code class="docutils literal notranslate"><span class="pre">extrema[k]</span></code> is
the array of indices of axis <cite>k</cite> of <cite>data</cite>.  Note that the
return value is a tuple even when <cite>data</cite> is one-dimensional.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.peak_finding.peak_finding.argrelextrema" title="cusignal.peak_finding.peak_finding.argrelextrema"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argrelextrema</span></code></a>, <a class="reference internal" href="#cusignal.peak_finding.peak_finding.argrelmax" title="cusignal.peak_finding.peak_finding.argrelmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argrelmax</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">find_peaks</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function uses <cite>argrelextrema</cite> with cp.less as comparator. Therefore it
requires a strict inequality on both sides of a value to consider it a
minimum. This means flat minima (more than one sample wide) are not
detected. In case of one-dimensional <cite>data</cite> <cite>find_peaks</cite> can be used to
detect all local minima, including flat ones, by calling it with negated
<cite>data</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cusignal</span> <span class="kn">import</span> <span class="n">argrelmin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">argrelmin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(array([1, 5]),)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">argrelmin</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(array([0, 2]), array([2, 1]))</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="window-functions">
<h2>Window Functions<a class="headerlink" href="#window-functions" title="Permalink to this heading">#</a></h2>
<section id="module-cusignal.windows.windows">
<span id="windows"></span><h3>Windows<a class="headerlink" href="#module-cusignal.windows.windows" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.barthann">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">barthann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.barthann" title="Permalink to this definition">#</a></dt>
<dd><p>Return a modified Bartlett-Hann window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">barthann</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Bartlett-Hann window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Bartlett-Hann window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.bartlett">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">bartlett</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.bartlett" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Bartlett window.</p>
<p>The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The triangular window, with the first and last samples equal to zero
and the maximum value normalized to 1 (though the value 1 does not
appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.windows.windows.triang" title="cusignal.windows.windows.triang"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triang</span></code></a></dt><dd><p>A triangular window that does not touch zero at the ends</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The Bartlett window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = \frac{2}{M-1} \left(
\frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
\right)\]</div>
<p>Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means&rdquo;removing the foot&rdquo;, i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The Fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich. <a class="reference internal" href="#rc5299d5ac5ba-2" id="id18">[2]</a></p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc5299d5ac5ba-1"><span class="brackets">1</span></dt>
<dd><p>M.S. Bartlett, &ldquo;Periodogram Analysis and Continuous Spectra&rdquo;,
Biometrika 37, 1-16, 1950.</p>
</dd>
<dt class="label" id="rc5299d5ac5ba-2"><span class="brackets"><a class="fn-backref" href="#id18">2</a></span></dt>
<dd><p>E.R. Kanasewich, &ldquo;Time Sequence Analysis in Geophysics&rdquo;,
The University of Alberta Press, 1975, pp. 109-110.</p>
</dd>
<dt class="label" id="rc5299d5ac5ba-3"><span class="brackets">3</span></dt>
<dd><p>A.V. Oppenheim and R.W. Schafer, &ldquo;Discrete-Time Signal
Processing&rdquo;, Prentice-Hall, 1999, pp. 468-471.</p>
</dd>
<dt class="label" id="rc5299d5ac5ba-4"><span class="brackets">4</span></dt>
<dd><p>Wikipedia, &ldquo;Window function&rdquo;,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
<dt class="label" id="rc5299d5ac5ba-5"><span class="brackets">5</span></dt>
<dd><p>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
&ldquo;Numerical Recipes&rdquo;, Cambridge University Press, 1986, page 429.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">bartlett</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Bartlett window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Bartlett window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.blackman">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">blackman</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.blackman" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Blackman window.</p>
<p>The Blackman window is a taper formed by using the first three terms of
a summation of cosines. It was designed to have close to the minimal
leakage possible.  It is close to optimal, only slightly worse than a
Kaiser window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Blackman window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)\]</div>
<p>The &ldquo;exact Blackman&rdquo; window was designed to null out the third and fourth
sidelobes, but has discontinuities at the boundaries, resulting in a
6 dB/oct fall-off.  This window is an approximation of the &ldquo;exact&rdquo; window,
which does not null the sidelobes as well, but is smooth at the edges,
improving the fall-off rate to 18 dB/oct. <a class="reference internal" href="#recccbd37472c-3" id="id24">[3]</a></p>
<p>Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
&ldquo;removing the foot&rdquo;, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
&ldquo;near optimal&rdquo; tapering function, almost as good (by some measures)
as the Kaiser window.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="recccbd37472c-1"><span class="brackets">1</span></dt>
<dd><p>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.</p>
</dd>
<dt class="label" id="recccbd37472c-2"><span class="brackets">2</span></dt>
<dd><p>Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</p>
</dd>
<dt class="label" id="recccbd37472c-3"><span class="brackets"><a class="fn-backref" href="#id24">3</a></span></dt>
<dd><p>Harris, Fredric J. (Jan 1978). &ldquo;On the use of Windows for Harmonic
Analysis with the Discrete Fourier Transform&rdquo;. Proceedings of the
IEEE 66 (1): 51-83. <a href="#id25"><span class="problematic" id="id26">:doi:`10.1109/PROC.1978.10837`</span></a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Blackman window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Blackman window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.blackmanharris">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">blackmanharris</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.blackmanharris" title="Permalink to this definition">#</a></dt>
<dd><p>Return a minimum 4-term Blackman-Harris window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">blackmanharris</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Blackman-Harris window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Blackman-Harris window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.bohman">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">bohman</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.bohman" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Bohman window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">bohman</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Bohman window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Bohman window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.boxcar">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">boxcar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.boxcar" title="Permalink to this definition">#</a></dt>
<dd><p>Return a boxcar or rectangular window.</p>
<p>Also known as a rectangular window or Dirichlet window, this is equivalent
to no window at all.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the window is symmetric. (Has no effect for boxcar.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Boxcar window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the boxcar window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.chebwin">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">chebwin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.chebwin" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Dolph-Chebyshev window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>at</strong><span class="classifier">float</span></dt><dd><p>Attenuation (in dB).</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value always normalized to 1</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This window optimizes for the narrowest main lobe width for a given order
<cite>M</cite> and sidelobe equiripple attenuation <cite>at</cite>, using Chebyshev
polynomials.  It was originally developed by Dolph to optimize the
directionality of radio antenna arrays.</p>
<p>Unlike most windows, the Dolph-Chebyshev is defined in terms of its
frequency response:</p>
<div class="math notranslate nohighlight">
\[W(k) = \frac
{\cos\{M \cos^{-1}[\beta \cos(\frac{\pi k}{M})]\}}
{\cosh[M \cosh^{-1}(\beta)]}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\beta = \cosh \left [\frac{1}{M}
\cosh^{-1}(10^\frac{A}{20}) \right ]\]</div>
<p>and 0 &lt;= abs(k) &lt;= M-1. A is the attenuation in decibels (<cite>at</cite>).</p>
<p>The time domain window is then generated using the IFFT, so
power-of-two <cite>M</cite> are the fastest to generate, and prime number <cite>M</cite> are
the slowest.</p>
<p>The equiripple condition in the frequency domain creates impulses in the
time domain, which appear at the ends of the window.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r487085e58518-1"><span class="brackets">1</span></dt>
<dd><p>C. Dolph, &ldquo;A current distribution for broadside arrays which
optimizes the relationship between beam width and side-lobe level&rdquo;,
Proceedings of the IEEE, Vol. 34, Issue 6</p>
</dd>
<dt class="label" id="r487085e58518-2"><span class="brackets">2</span></dt>
<dd><p>Peter Lynch, &ldquo;The Dolph-Chebyshev Window: A Simple Optimal Filter&rdquo;,
American Meteorological Society (April 1997)
<a class="reference external" href="http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf">http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf</a></p>
</dd>
<dt class="label" id="r487085e58518-3"><span class="brackets">3</span></dt>
<dd><p>F. J. Harris, &ldquo;On the use of windows for harmonic analysis with the
discrete Fourier transforms&rdquo;, Proceedings of the IEEE, Vol. 66,
No. 1, January 1978</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">chebwin</span><span class="p">(</span><span class="mi">51</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Dolph-Chebyshev window (100 dB)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Dolph-Chebyshev window (100 dB)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.cosine">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">cosine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.cosine" title="Permalink to this definition">#</a></dt>
<dd><p>Return a window with a simple cosine shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.13.0.</span></p>
</div>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">cosine</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Cosine window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the cosine window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.exponential">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">exponential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.exponential" title="Permalink to this definition">#</a></dt>
<dd><p>Return an exponential (or Poisson) window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>center</strong><span class="classifier">float, optional</span></dt><dd><p>Parameter defining the center location of the window function.
The default value if not given is <code class="docutils literal notranslate"><span class="pre">center</span> <span class="pre">=</span> <span class="pre">(M-1)</span> <span class="pre">/</span> <span class="pre">2</span></code>.  This
parameter must take its default value for symmetric windows.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float, optional</span></dt><dd><p>Parameter defining the decay.  For <code class="docutils literal notranslate"><span class="pre">center</span> <span class="pre">=</span> <span class="pre">0</span></code> use
<code class="docutils literal notranslate"><span class="pre">tau</span> <span class="pre">=</span> <span class="pre">-(M-1)</span> <span class="pre">/</span> <span class="pre">ln(x)</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> is the fraction of the window
remaining at the end.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Exponential window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = e^{-|n-center| / \tau}\]</div>
<p class="rubric">References</p>
<p>S. Gade and H. Herlufsen, &ldquo;Windows to FFT analysis (Part I)&rdquo;,
Technical Review 3, Bruel &amp; Kjaer, 1987.</p>
<p class="rubric">Examples</p>
<p>Plot the symmetric window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="mi">51</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Exponential Window (tau=3.0)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Exponential window (tau=3.0)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
<p>This function can also generate non-symmetric windows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tau2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window2</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tau2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.flattop">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">flattop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.flattop" title="Permalink to this definition">#</a></dt>
<dd><p>Return a flat top window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Flat top windows are used for taking accurate measurements of signal
amplitude in the frequency domain, with minimal scalloping error from the
center of a frequency bin to its edges, compared to others.  This is a
5th-order cosine window, with the 5 terms optimized to make the main lobe
maximally flat. <a class="reference internal" href="#r72a2ad723976-1" id="id33">[1]</a></p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r72a2ad723976-1"><span class="brackets"><a class="fn-backref" href="#id33">1</a></span></dt>
<dd><p>D&rsquo;Antona, Gabriele, and A. Ferrero, &ldquo;Digital Signal Processing for
Measurement Systems&rdquo;, Springer Media, 2006, p. 70
<a href="#id34"><span class="problematic" id="id35">:doi:`10.1007/0-387-28666-7`</span></a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">flattop</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Flat top window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the flat top window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.gaussian">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.gaussian" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Gaussian window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>std</strong><span class="classifier">float</span></dt><dd><p>The standard deviation, sigma.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Gaussian window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = e^{ -\frac{1}{2}\left(\frac{n}{\sigma}\right)^2 }\]</div>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">51</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">"Gaussian window ($\sigma$=7)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">"Frequency response of the Gaussian window ($\sigma$=7)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.general_cosine">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">general_cosine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.general_cosine" title="Permalink to this definition">#</a></dt>
<dd><p>Generic weighted sum of cosine terms window</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window</p>
</dd>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Sequence of weighting coefficients. This uses the convention of being
centered on the origin, so these will typically all be positive
numbers, not alternating sign.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r81a7b0073b4a-1"><span class="brackets">1</span></dt>
<dd><p>A. Nuttall, &ldquo;Some windows with very good sidelobe behavior,&rdquo; IEEE
Transactions on Acoustics, Speech, and Signal Processing, vol. 29,
no. 1, pp. 84-91, Feb 1981. <a href="#id37"><span class="problematic" id="id38">:doi:`10.1109/TASSP.1981.1163506`</span></a>.</p>
</dd>
<dt class="label" id="r81a7b0073b4a-2"><span class="brackets"><a class="fn-backref" href="#id41">2</a></span></dt>
<dd><p>Heinzel G. et al., &ldquo;Spectrum and spectral density estimation by the
Discrete Fourier transform (DFT), including a comprehensive list of
window functions and some new flat-top windows&rdquo;, February 15, 2002
<a class="reference external" href="https://holometer.fnal.gov/GH_FFT.pdf">https://holometer.fnal.gov/GH_FFT.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Heinzel describes a flat-top window named &ldquo;HFT90D&rdquo; with formula: <a class="reference internal" href="#r81a7b0073b4a-2" id="id41">[2]</a></p>
<div class="math notranslate nohighlight">
\[w_j = 1 - 1.942604 \cos(z) + 1.340318 \cos(2z)
- 0.440811 \cos(3z) + 0.043097 \cos(4z)\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[z = \frac{2 \pi j}{N}, j = 0...N - 1\]</div>
<p>Since this uses the convention of starting at the origin, to reproduce the
window, we need to convert every other coefficient to a positive number:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">HFT90D</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.942604</span><span class="p">,</span> <span class="mf">1.340318</span><span class="p">,</span> <span class="mf">0.440811</span><span class="p">,</span> <span class="mf">0.043097</span><span class="p">]</span>
</pre></div>
</div>
<p>The paper states that the highest sidelobe is at -90.2 dB.  Reproduce
Figure 42 by plotting the window and its frequency response, and confirm
the sidelobe level in red:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cusignal.windows</span> <span class="kn">import</span> <span class="n">general_cosine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">general_cosine</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">HFT90D</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"HFT90D window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mi">50</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">50</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="o">-</span><span class="mi">140</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the HFT90D window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="o">-</span><span class="mf">90.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">'red'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.general_gaussian">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">general_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.general_gaussian" title="Permalink to this definition">#</a></dt>
<dd><p>Return a window with a generalized Gaussian shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>Shape parameter.  p = 1 is identical to <cite>gaussian</cite>, p = 0.5 is
the same shape as the Laplace distribution.</p>
</dd>
<dt><strong>sig</strong><span class="classifier">float</span></dt><dd><p>The standard deviation, sigma.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The generalized Gaussian window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = e^{ -\frac{1}{2}\left|\frac{n}{\sigma}\right|^{2p} }\]</div>
<p>the half-power point is at</p>
<div class="math notranslate nohighlight">
\[(2 \log(2))^{1/(2 p)} \sigma\]</div>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">general_gaussian</span><span class="p">(</span><span class="mi">51</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">"Generalized Gaussian window (p=1.5, $\sigma$=7)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">"Freq. resp. of the gen. Gaussian "</span>
<span class="gp">... </span>          <span class="sa">r</span><span class="s2">"window (p=1.5, $\sigma$=7)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.general_hamming">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">general_hamming</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.general_hamming" title="Permalink to this definition">#</a></dt>
<dd><p>Return a generalized Hamming window.</p>
<p>The generalized Hamming window is constructed by multiplying a rectangular
window by one period of a cosine function <a class="reference internal" href="#r2a9a124e2681-1" id="id42">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>The window coefficient, <span class="math notranslate nohighlight">\(\alpha\)</span></p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.windows.windows.hamming" title="cusignal.windows.windows.hamming"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hamming</span></code></a>, <a class="reference internal" href="#cusignal.windows.windows.hann" title="cusignal.windows.windows.hann"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hann</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The generalized Hamming window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = \alpha -
\left(1 - \alpha\right) \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1\]</div>
<p>Both the common Hamming window and Hann window are special cases of the
generalized Hamming window with <span class="math notranslate nohighlight">\(\alpha\)</span> = 0.54 and <span class="math notranslate nohighlight">\(\alpha\)</span> =
0.5, respectively <a class="reference internal" href="#r2a9a124e2681-2" id="id43">[2]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2a9a124e2681-1"><span class="brackets"><a class="fn-backref" href="#id42">1</a></span></dt>
<dd><p>DSPRelated, &ldquo;Generalized Hamming Window Family&rdquo;,
<a class="reference external" href="https://www.dsprelated.com/freebooks/sasp/Generalized_Hamming_Window_Family.html">https://www.dsprelated.com/freebooks/sasp/Generalized_Hamming_Window_Family.html</a></p>
</dd>
<dt class="label" id="r2a9a124e2681-2"><span class="brackets"><a class="fn-backref" href="#id43">2</a></span></dt>
<dd><p>Wikipedia, &ldquo;Window function&rdquo;,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
<dt class="label" id="r2a9a124e2681-3"><span class="brackets"><a class="fn-backref" href="#id48">3</a></span></dt>
<dd><p>Riccardo Piantanida ESA, &ldquo;Sentinel-1 Level 1 Detailed Algorithm
Definition&rdquo;,
<a class="reference external" href="https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Level-1-Detailed-Algorithm-Definition">https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Level-1-Detailed-Algorithm-Definition</a></p>
</dd>
<dt class="label" id="r2a9a124e2681-4"><span class="brackets"><a class="fn-backref" href="#id49">4</a></span></dt>
<dd><p>Matthieu Bourbigot ESA, &ldquo;Sentinel-1 Product Definition&rdquo;,
<a class="reference external" href="https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Product-Definition">https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Product-Definition</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The Sentinel-1A/B Instrument Processing Facility uses generalized Hamming
windows in the processing of spaceborne Synthetic Aperture Radar (SAR)
data <a class="reference internal" href="#r2a9a124e2681-3" id="id48">[3]</a>. The facility uses various values for the <span class="math notranslate nohighlight">\(\alpha\)</span>
parameter based on operating mode of the SAR instrument. Some common
<span class="math notranslate nohighlight">\(\alpha\)</span> values include 0.75, 0.7 and 0.52 <a class="reference internal" href="#r2a9a124e2681-4" id="id49">[4]</a>. As an example, we
plot these different windows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig1</span><span class="p">,</span> <span class="n">spatial_plot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_plot</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">"Generalized Hamming Windows"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_plot</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_plot</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig2</span><span class="p">,</span> <span class="n">freq_plot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq_plot</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">"Frequency Responses"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq_plot</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq_plot</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.52</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">general_hamming</span><span class="p">(</span><span class="mi">41</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">spatial_plot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">"</span><span class="si">{:.2f}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">... </span>    <span class="n">freq_plot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">label</span><span class="o">=</span><span class="s2">"</span><span class="si">{:.2f}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq_plot</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">"upper right"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_plot</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">"upper right"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.get_window">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">get_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fftbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.get_window" title="Permalink to this definition">#</a></dt>
<dd><p>Return a window of a given length and type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window</strong><span class="classifier">string, float, or tuple</span></dt><dd><p>The type of window to create. See below for more details.</p>
</dd>
<dt><strong>Nx</strong><span class="classifier">int</span></dt><dd><p>The number of samples in the window.</p>
</dd>
<dt><strong>fftbins</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), create a &ldquo;periodic&rdquo; window, ready to use with
<cite>ifftshift</cite> and be multiplied by the result of an FFT (see also
<cite>fftpack.fftfreq</cite>).
If False, create a &ldquo;symmetric&rdquo; window, for use in filter design.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>get_window</strong><span class="classifier">ndarray</span></dt><dd><p>Returns a window of length <cite>Nx</cite> and type <cite>window</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Window types:</p>
<ul class="simple">
<li><p><cite>~cusignal.windows.windows.boxcar</cite></p></li>
<li><p><cite>~cusignal.windows.windows.triang</cite></p></li>
<li><p><cite>~cusignal.windows.windows.blackman</cite></p></li>
<li><p><cite>~cusignal.windows.windows.hamming</cite></p></li>
<li><p><cite>~cusignal.windows.windows.hann</cite></p></li>
<li><p><cite>~cusignal.windows.windows.bartlett</cite></p></li>
<li><p><cite>~cusignal.windows.windows.flattop</cite></p></li>
<li><p><cite>~cusignal.windows.windows.parzen</cite></p></li>
<li><p><cite>~cusignal.windows.windows.bohman</cite></p></li>
<li><p><cite>~cusignal.windows.windows.blackmanharris</cite></p></li>
<li><p><cite>~cusignal.windows.windows.nuttall</cite></p></li>
<li><p><cite>~cusignal.windows.windows.barthann</cite></p></li>
<li><p><cite>~cusignal.windows.windows.kaiser</cite> (needs beta)</p></li>
<li><p><cite>~cusignal.windows.windows.gaussian</cite> (needs standard deviation)</p></li>
<li><dl class="simple">
<dt><cite>~cusignal.windows.windows.general_gaussian</cite> </dt><dd><p>(needs power, width)</p>
</dd>
</dl>
</li>
<li><p><cite>~cusignal.windows.windows.slepian</cite> (needs width)</p></li>
<li><dl class="simple">
<dt><cite>~cusignal.windows.windows.dpss</cite> </dt><dd><p>(needs normalized half-bandwidth)</p>
</dd>
</dl>
</li>
<li><p><cite>~cusignal.windows.windows.chebwin</cite> (needs attenuation)</p></li>
<li><p><cite>~cusignal.windows.windows.exponential</cite> (needs decay scale)</p></li>
<li><p><cite>~cusignal.windows.windows.tukey</cite> (needs taper fraction)</p></li>
</ul>
<p>If the window requires no parameters, then <cite>window</cite> can be a string.</p>
<p>If the window requires parameters, then <cite>window</cite> must be a tuple
with the first argument the string name of the window, and the next
arguments the needed parameters.</p>
<p>If <cite>window</cite> is a floating point number, it is interpreted as the beta
parameter of the <cite>~cusignal.windows.windows.kaiser</cite> window.</p>
<p>Each of the window types listed above is also the name of
a function that can be called directly to create a window of
that type.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">get_window</span><span class="p">(</span><span class="s1">'triang'</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">array([ 0.125,  0.375,  0.625,  0.875,  0.875,  0.625,  0.375])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">get_window</span><span class="p">((</span><span class="s1">'kaiser'</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">),</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">array([0.08848053, 0.32578323, 0.63343178, 0.89640418, 1.,</span>
<span class="go">       0.89640418, 0.63343178, 0.32578323, 0.08848053])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">get_window</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">array([0.08848053, 0.32578323, 0.63343178, 0.89640418, 1.,</span>
<span class="go">       0.89640418, 0.63343178, 0.32578323, 0.08848053])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.hamming">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">hamming</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.hamming" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Hamming window.</p>
<p>The Hamming window is a taper formed by using a raised cosine with
non-zero endpoints, optimized to minimize the nearest side lobe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Hamming window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = 0.54 - 0.46 \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1\]</div>
<p>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and
is described in Blackman and Tukey. It was recommended for smoothing the
truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
&ldquo;removing the foot&rdquo;, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd758e30181ab-1"><span class="brackets">1</span></dt>
<dd><p>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.</p>
</dd>
<dt class="label" id="rd758e30181ab-2"><span class="brackets">2</span></dt>
<dd><p>E.R. Kanasewich, &ldquo;Time Sequence Analysis in Geophysics&rdquo;, The
University of Alberta Press, 1975, pp. 109-110.</p>
</dd>
<dt class="label" id="rd758e30181ab-3"><span class="brackets">3</span></dt>
<dd><p>Wikipedia, &ldquo;Window function&rdquo;,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
<dt class="label" id="rd758e30181ab-4"><span class="brackets">4</span></dt>
<dd><p>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
&ldquo;Numerical Recipes&rdquo;, Cambridge University Press, 1986, page 425.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Hamming window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Hamming window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.hann">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">hann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.hann" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Hann window.</p>
<p>The Hann window is a taper formed by using a raised cosine or sine-squared
with ends that touch zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Hann window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = 0.5 - 0.5 \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1\]</div>
<p>The window was named for Julius von Hann, an Austrian meteorologist. It is
also known as the Cosine Bell. It is sometimes erroneously referred to as
the &ldquo;Hanning&rdquo; window, from the use of &ldquo;hann&rdquo; as a verb in the original
paper and confusion with the very similar Hamming window.</p>
<p>Most references to the Hann window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
&ldquo;removing the foot&rdquo;, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc4539b1ae926-1"><span class="brackets">1</span></dt>
<dd><p>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.</p>
</dd>
<dt class="label" id="rc4539b1ae926-2"><span class="brackets">2</span></dt>
<dd><p>E.R. Kanasewich, &ldquo;Time Sequence Analysis in Geophysics&rdquo;,
The University of Alberta Press, 1975, pp. 106-108.</p>
</dd>
<dt class="label" id="rc4539b1ae926-3"><span class="brackets">3</span></dt>
<dd><p>Wikipedia, &ldquo;Window function&rdquo;,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
<dt class="label" id="rc4539b1ae926-4"><span class="brackets">4</span></dt>
<dd><p>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
&ldquo;Numerical Recipes&rdquo;, Cambridge University Press, 1986, page 425.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Hann window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Hann window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.kaiser">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">kaiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.kaiser" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Kaiser window.</p>
<p>The Kaiser window is a taper formed by using a Bessel function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float</span></dt><dd><p>Shape parameter, determines trade-off between main-lobe width and
side lobe level. As beta gets large, the window narrows.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Kaiser window is defined as</p>
<div class="math notranslate nohighlight">
\[w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
\right)/I_0(\beta)\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[\quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},\]</div>
<p>where <span class="math notranslate nohighlight">\(I_0\)</span> is the modified zeroth-order Bessel function.</p>
<p>The Kaiser was named for Jim Kaiser, who discovered a simple approximation
to the DPSS window based on Bessel functions.
The Kaiser window is a very good approximation to the Digital Prolate
Spheroidal Sequence, or Slepian window, which is the transform which
maximizes the energy in the main lobe of the window relative to total
energy.</p>
<p>The Kaiser can approximate other windows by varying the beta parameter.
(Some literature uses alpha = beta/pi.) <a class="reference internal" href="#r5d953c58f539-4" id="id58">[4]</a></p>
<table class="table">
<colgroup>
<col style="width: 15%">
<col style="width: 85%">
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>beta</p></th>
<th class="head"><p>Window shape</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Rectangular</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>Similar to a Hamming</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>Similar to a Hann</p></td>
</tr>
<tr class="row-odd"><td><p>8.6</p></td>
<td><p>Similar to a Blackman</p></td>
</tr>
</tbody>
</table>
<p>A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
be returned.</p>
<p>Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
&ldquo;removing the foot&rdquo;, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5d953c58f539-1"><span class="brackets">1</span></dt>
<dd><p>J. F. Kaiser, &ldquo;Digital Filters&rdquo; - Ch 7 in &ldquo;Systems analysis by
digital computer&rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
John Wiley and Sons, New York, (1966).</p>
</dd>
<dt class="label" id="r5d953c58f539-2"><span class="brackets">2</span></dt>
<dd><p>E.R. Kanasewich, &ldquo;Time Sequence Analysis in Geophysics&rdquo;, The
University of Alberta Press, 1975, pp. 177-178.</p>
</dd>
<dt class="label" id="r5d953c58f539-3"><span class="brackets">3</span></dt>
<dd><p>Wikipedia, &ldquo;Window function&rdquo;,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
</dd>
<dt class="label" id="r5d953c58f539-4"><span class="brackets"><a class="fn-backref" href="#id58">4</a></span></dt>
<dd><p>F. J. Harris, &ldquo;On the use of windows for harmonic analysis with the
discrete Fourier transform,&rdquo; Proceedings of the IEEE, vol. 66,
no. 1, pp. 51-83, Jan. 1978. <a href="#id59"><span class="problematic" id="id60">:doi:`10.1109/PROC.1978.10837`</span></a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="mi">51</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">"Kaiser window ($\beta$=14)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">"Frequency response of the Kaiser window ($\beta$=14)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.nuttall">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">nuttall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.nuttall" title="Permalink to this definition">#</a></dt>
<dd><p>Return a minimum 4-term Blackman-Harris window according to Nuttall.</p>
<p>This variation is called &ldquo;Nuttall4c&rdquo; by Heinzel. <a class="reference internal" href="#r7984f0aaf76b-2" id="id65">[2]</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7984f0aaf76b-1"><span class="brackets">1</span></dt>
<dd><p>A. Nuttall, &ldquo;Some windows with very good sidelobe behavior,&rdquo; IEEE
Transactions on Acoustics, Speech, and Signal Processing, vol. 29,
no. 1, pp. 84-91, Feb 1981. <a href="#id66"><span class="problematic" id="id67">:doi:`10.1109/TASSP.1981.1163506`</span></a>.</p>
</dd>
<dt class="label" id="r7984f0aaf76b-2"><span class="brackets"><a class="fn-backref" href="#id65">2</a></span></dt>
<dd><p>Heinzel G. et al., &ldquo;Spectrum and spectral density estimation by the
Discrete Fourier transform (DFT), including a comprehensive list of
window functions and some new flat-top windows&rdquo;, February 15, 2002
<a class="reference external" href="https://holometer.fnal.gov/GH_FFT.pdf">https://holometer.fnal.gov/GH_FFT.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">nuttall</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Nuttall window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Nuttall window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.parzen">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">parzen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.parzen" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.taylor">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">taylor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.taylor" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Taylor window.
The Taylor window taper function approximates the Dolph-Chebyshev window&rsquo;s
constant sidelobe level for a parameterized number of near-in sidelobes,
but then allows a taper beyond <a class="reference internal" href="#rc5e098a1a171-2" id="id70">[2]</a>.
The SAR (synthetic aperature radar) community commonly uses Taylor
weighting for image formation processing because it provides strong,
selectable sidelobe suppression with minimum broadening of the
mainlobe <span id="id71">[Rc5e098a1a171-1]</span>.
Parameters
&mdash;&mdash;&mdash;-
M : int</p>
<blockquote>
<div><p>Number of points in the output window. If zero or less, an
empty array is returned.</p>
</div></blockquote>
<dl class="simple">
<dt>nbar<span class="classifier">int, optional</span></dt><dd><p>Number of nearly constant level sidelobes adjacent to the mainlobe.</p>
</dd>
<dt>sll<span class="classifier">float, optional</span></dt><dd><p>Desired suppression of sidelobe level in decibels (dB) relative to the
DC gain of the mainlobe. This should be a positive number.</p>
</dd>
<dt>norm<span class="classifier">bool, optional</span></dt><dd><p>When True (default), divides the window by the largest (middle) value
for odd-length windows or the value that would occur between the two
repeated middle values for even-length windows such that all values
are less than or equal to 1. When False the DC gain will remain at 1
(0 dB) and the sidelobes will be <cite>sll</cite> dB down.</p>
</dd>
<dt>sym<span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array</span></dt><dd><p>The window. When <cite>norm</cite> is True (default), the maximum value is
normalized to 1 (though the value 1 does not appear if <cite>M</cite> is
even and <cite>sym</cite> is True).</p>
</dd>
</dl>
<p>chebwin, kaiser, bartlett, blackman, hamming, hanning
References
&mdash;&mdash;&mdash;-
.. [Rc5e098a1a171-1] W. Carrara, R. Goodman, and R. Majewski, &ldquo;Spotlight Synthetic</p>
<blockquote>
<div><p>Aperture Radar: Signal Processing Algorithms&rdquo; Pages 512-513,
July 1995.</p>
</div></blockquote>
<dl class="citation">
<dt class="label" id="rc5e098a1a171-2"><span class="brackets"><a class="fn-backref" href="#id70">2</a></span></dt>
<dd><p>Armin Doerry, &ldquo;Catalog of Window Taper Functions for
Sidelobe Control&rdquo;, 2017.
<a class="reference external" href="https://www.researchgate.net/profile/Armin_Doerry/publication/316281181_Catalog_of_Window_Taper_Functions_for_Sidelobe_Control/links/58f92cb2a6fdccb121c9d54d/Catalog-of-Window-Taper-Functions-for-Sidelobe-Control.pdf">https://www.researchgate.net/profile/Armin_Doerry/publication/316281181_Catalog_of_Window_Taper_Functions_for_Sidelobe_Control/links/58f92cb2a6fdccb121c9d54d/Catalog-of-Window-Taper-Functions-for-Sidelobe-Control.pdf</a></p>
</dd>
</dl>
<p>Plot the window and its frequency response:
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fft import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; window = signal.windows.taylor(51, nbar=20, sll=100, norm=False)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(&ldquo;Taylor window (100 dB)&rdquo;)
&gt;&gt;&gt; plt.ylabel(&ldquo;Amplitude&rdquo;)
&gt;&gt;&gt; plt.xlabel(&ldquo;Sample&rdquo;)
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title(&ldquo;Frequency response of the Taylor window (100 dB)&rdquo;)
&gt;&gt;&gt; plt.ylabel(&ldquo;Normalized magnitude [dB]&rdquo;)
&gt;&gt;&gt; plt.xlabel(&ldquo;Normalized frequency [cycles per sample]&rdquo;)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.triang">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">triang</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.triang" title="Permalink to this definition">#</a></dt>
<dd><p>Return a triangular window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.windows.windows.bartlett" title="cusignal.windows.windows.bartlett"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bartlett</span></code></a></dt><dd><p>A triangular window that touches zero</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">triang</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Triangular window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the triangular window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.windows.windows.tukey">
<span class="sig-prename descclassname"><span class="pre">cusignal.windows.windows.</span></span><span class="sig-name descname"><span class="pre">tukey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.windows.windows.tukey" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Tukey window, also known as a tapered cosine window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Number of points in the output window. If zero or less, an empty
array is returned.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Shape parameter of the Tukey window, representing the fraction of the
window inside the cosine tapered region.
If zero, the Tukey window is equivalent to a rectangular window.
If one, the Tukey window is equivalent to a Hann window.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool, optional</span></dt><dd><p>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>The window, with the maximum value normalized to 1 (though the value 1
does not appear if <cite>M</cite> is even and <cite>sym</cite> is True).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb9b22f3b27e9-1"><span class="brackets">1</span></dt>
<dd><p>Harris, Fredric J. (Jan 1978). &ldquo;On the use of Windows for Harmonic
Analysis with the Discrete Fourier Transform&rdquo;. Proceedings of the
IEEE 66 (1): 51-83. <a href="#id72"><span class="problematic" id="id73">:doi:`10.1109/PROC.1978.10837`</span></a></p>
</dd>
<dt class="label" id="rb9b22f3b27e9-2"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, &ldquo;Window function&rdquo;,
<a class="reference external" href="https://en.wikipedia.org/wiki/Window_function#Tukey_window">https://en.wikipedia.org/wiki/Window_function#Tukey_window</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the window and its frequency response:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">tukey</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Tukey window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Amplitude"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Sample"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">response</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Frequency response of the Tukey window"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Normalized magnitude [dB]"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Normalized frequency [cycles per sample]"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="waveforms">
<h2>Waveforms<a class="headerlink" href="#waveforms" title="Permalink to this heading">#</a></h2>
<section id="waveform-generation">
<h3>Waveform Generation<a class="headerlink" href="#waveform-generation" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-cusignal.waveforms.waveforms"></span><dl class="py function">
<dt class="sig sig-object py" id="cusignal.waveforms.waveforms.chirp">
<span class="sig-prename descclassname"><span class="pre">cusignal.waveforms.waveforms.</span></span><span class="sig-name descname"><span class="pre">chirp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.waveforms.waveforms.chirp" title="Permalink to this definition">#</a></dt>
<dd><p>Frequency-swept cosine generator.</p>
<p>In the following, &lsquo;Hz&rsquo; should be interpreted as &lsquo;cycles per unit&rsquo;;
there is no requirement here that the unit is one second.  The
important distinction is that the units of rotation are cycles, not
radians. Likewise, <cite>t</cite> could be a measurement of space instead of time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array_like</span></dt><dd><p>Times at which to evaluate the waveform.</p>
</dd>
<dt><strong>f0</strong><span class="classifier">float</span></dt><dd><p>Frequency (e.g. Hz) at time t=0.</p>
</dd>
<dt><strong>t1</strong><span class="classifier">float</span></dt><dd><p>Time at which <cite>f1</cite> is specified.</p>
</dd>
<dt><strong>f1</strong><span class="classifier">float</span></dt><dd><p>Frequency (e.g. Hz) of the waveform at time <cite>t1</cite>.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{&lsquo;linear&rsquo;, &lsquo;quadratic&rsquo;, &lsquo;logarithmic&rsquo;, &lsquo;hyperbolic&rsquo;}, optional</span></dt><dd><p>Kind of frequency sweep.  If not given, <cite>linear</cite> is assumed.  See
Notes below for more details.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float, optional</span></dt><dd><p>Phase offset, in degrees. Default is 0.</p>
</dd>
<dt><strong>vertex_zero</strong><span class="classifier">bool, optional</span></dt><dd><p>This parameter is only used when <cite>method</cite> is &lsquo;quadratic&rsquo;.
It determines whether the vertex of the parabola that is the graph
of the frequency is at t=0 or t=t1.</p>
</dd>
<dt><strong>type</strong><span class="classifier">{&lsquo;real&rsquo;, &lsquo;complex&rsquo;}, optional</span></dt><dd><p>Specify output chirp type, only applicable when <cite>method</cite> is &lsquo;linear&rsquo;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>A numpy array containing the signal evaluated at <cite>t</cite> with the
requested time-varying frequency.  More precisely, the function
returns <code class="docutils literal notranslate"><span class="pre">cos(phase</span> <span class="pre">+</span> <span class="pre">(pi/180)*phi)</span></code> where <cite>phase</cite> is the integral
(from 0 to <cite>t</cite>) of <code class="docutils literal notranslate"><span class="pre">2*pi*f(t)</span></code>. <code class="docutils literal notranslate"><span class="pre">f(t)</span></code> is defined below.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The following will be used in the examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cusignal</span> <span class="kn">import</span> <span class="n">chirp</span><span class="p">,</span> <span class="n">spectrogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
</pre></div>
</div>
<p>For the first example, we&rsquo;ll plot the waveform for a linear chirp
from 6 Hz to 1 Hz over 10 seconds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5001</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">chirp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">f1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'linear'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Linear Chirp, f(0)=6, f(10)=1"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'t (sec)'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>For the remaining examples, we&rsquo;ll use higher frequency ranges,
and demonstrate the result using <cite>cusignal.spectrogram</cite>.
We&rsquo;ll use a 10 second interval sampled at 8000 Hz.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mi">8000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span><span class="n">fs</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Quadratic chirp from 1500 Hz to 250 Hz over 10 seconds
(vertex of the parabolic curve of the frequency is at t=0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">chirp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span> <span class="n">f1</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">t1</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'quadratic'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ff</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">nfft</span><span class="o">=</span><span class="mi">2048</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">tt</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">ff</span><span class="p">[:</span><span class="mi">513</span><span class="p">]),</span>
<span class="go">                   cp.asnumpy(Sxx[:513]), cmap='gray_r')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Quadratic Chirp, f(0)=1500, f(10)=250'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'t (sec)'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Frequency (Hz)'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.waveforms.waveforms.gausspulse">
<span class="sig-prename descclassname"><span class="pre">cusignal.waveforms.waveforms.</span></span><span class="sig-name descname"><span class="pre">gausspulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bwr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tpr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retquad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retenv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.waveforms.waveforms.gausspulse" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Gaussian modulated sinusoid:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">exp(-a</span> <span class="pre">t^2)</span> <span class="pre">exp(1j*2*pi*fc*t).</span></code></p>
</div></blockquote>
<p>If <cite>retquad</cite> is True, then return the real and imaginary parts
(in-phase and quadrature).
If <cite>retenv</cite> is True, then return the envelope (unmodulated signal).
Otherwise, return the real part of the modulated sinusoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">ndarray or the string &lsquo;cutoff&rsquo;</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>fc</strong><span class="classifier">int, optional</span></dt><dd><p>Center frequency (e.g. Hz).  Default is 1000.</p>
</dd>
<dt><strong>bw</strong><span class="classifier">float, optional</span></dt><dd><p>Fractional bandwidth in frequency domain of pulse (e.g. Hz).
Default is 0.5.</p>
</dd>
<dt><strong>bwr</strong><span class="classifier">float, optional</span></dt><dd><p>Reference level at which fractional bandwidth is calculated (dB).
Default is -6.</p>
</dd>
<dt><strong>tpr</strong><span class="classifier">float, optional</span></dt><dd><p>If <cite>t</cite> is &lsquo;cutoff&rsquo;, then the function returns the cutoff
time for when the pulse amplitude falls below <cite>tpr</cite> (in dB).
Default is -60.</p>
</dd>
<dt><strong>retquad</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return the quadrature (imaginary) as well as the real part
of the signal.  Default is False.</p>
</dd>
<dt><strong>retenv</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return the envelope of the signal.  Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>yI</strong><span class="classifier">ndarray</span></dt><dd><p>Real part of signal.  Always returned.</p>
</dd>
<dt><strong>yQ</strong><span class="classifier">ndarray</span></dt><dd><p>Imaginary part of signal.  Only returned if <cite>retquad</cite> is True.</p>
</dd>
<dt><strong>yenv</strong><span class="classifier">ndarray</span></dt><dd><p>Envelope of signal.  Only returned if <cite>retenv</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cusignal.morlet</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Plot real component, imaginary component, and envelope for a 5 Hz pulse,
sampled at 100 Hz for 2 seconds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">gausspulse</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">retquad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">retenv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
<span class="go">             cp.asnumpy(t), cp.asnumpy(e), '--')</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.waveforms.waveforms.sawtooth">
<span class="sig-prename descclassname"><span class="pre">cusignal.waveforms.waveforms.</span></span><span class="sig-name descname"><span class="pre">sawtooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.waveforms.waveforms.sawtooth" title="Permalink to this definition">#</a></dt>
<dd><p>Return a periodic sawtooth or triangle waveform.
The sawtooth waveform has a period <code class="docutils literal notranslate"><span class="pre">2*pi</span></code>, rises from -1 to 1 on the
interval 0 to <code class="docutils literal notranslate"><span class="pre">width*2*pi</span></code>, then drops from 1 to -1 on the interval
<code class="docutils literal notranslate"><span class="pre">width*2*pi</span></code> to <code class="docutils literal notranslate"><span class="pre">2*pi</span></code>. <cite>width</cite> must be in the interval [0, 1].
Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.
Parameters
&mdash;&mdash;&mdash;-
t : array_like</p>
<blockquote>
<div><p>Time.</p>
</div></blockquote>
<dl class="simple">
<dt>width<span class="classifier">array_like, optional</span></dt><dd><p>Width of the rising ramp as a proportion of the total cycle.
Default is 1, producing a rising ramp, while 0 produces a falling
ramp.  <cite>width</cite> = 0.5 produces a triangle wave.
If an array, causes wave shape to change over time, and must be the
same length as t.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">ndarray</span></dt><dd><p>Output array containing the sawtooth waveform.</p>
</dd>
</dl>
<p>A 5 Hz waveform sampled at 500 Hz for 1 second:
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.linspace(0, 1, 500)
&gt;&gt;&gt; plt.plot(t, signal.sawtooth(2 * np.pi * 5 * t))</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.waveforms.waveforms.square">
<span class="sig-prename descclassname"><span class="pre">cusignal.waveforms.waveforms.</span></span><span class="sig-name descname"><span class="pre">square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duty</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.waveforms.waveforms.square" title="Permalink to this definition">#</a></dt>
<dd><p>Return a periodic square-wave waveform.</p>
<p>The square wave has a period <code class="docutils literal notranslate"><span class="pre">2*pi</span></code>, has value +1 from 0 to
<code class="docutils literal notranslate"><span class="pre">2*pi*duty</span></code> and -1 from <code class="docutils literal notranslate"><span class="pre">2*pi*duty</span></code> to <code class="docutils literal notranslate"><span class="pre">2*pi</span></code>. <cite>duty</cite> must be in
the interval [0,1].</p>
<p>Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array_like</span></dt><dd><p>The input time array.</p>
</dd>
<dt><strong>duty</strong><span class="classifier">array_like, optional</span></dt><dd><p>Duty cycle.  Default is 0.5 (50% duty cycle).
If an array, causes wave shape to change over time, and must be the
same length as t.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>Output array containing the square waveform.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>A 5 Hz waveform sampled at 500 Hz for 1 second:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cusignal</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>A pulse-width modulated sine wave:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">duty</span><span class="o">=</span><span class="p">(</span><span class="n">sig</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">pwm</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.waveforms.waveforms.unit_impulse">
<span class="sig-prename descclassname"><span class="pre">cusignal.waveforms.waveforms.</span></span><span class="sig-name descname"><span class="pre">unit_impulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'float'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.waveforms.waveforms.unit_impulse" title="Permalink to this definition">#</a></dt>
<dd><p>Unit impulse signal (discrete delta function) or unit basis vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">int or tuple of int</span></dt><dd><p>Number of samples in the output (1-D), or a tuple that represents the
shape of the output (N-D).</p>
</dd>
<dt><strong>idx</strong><span class="classifier">None or int or tuple of int or &lsquo;mid&rsquo;, optional</span></dt><dd><p>Index at which the value is 1.  If None, defaults to the 0th element.
If <code class="docutils literal notranslate"><span class="pre">idx='mid'</span></code>, the impulse will be centered at <code class="docutils literal notranslate"><span class="pre">shape</span> <span class="pre">//</span> <span class="pre">2</span></code> in
all dimensions.  If an int, the impulse will be at <cite>idx</cite> in all
dimensions.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array, e.g., <code class="docutils literal notranslate"><span class="pre">numpy.int8</span></code>.  Default is
<code class="docutils literal notranslate"><span class="pre">numpy.float64</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>Output array containing an impulse signal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The 1D case is also known as the Kronecker delta.</p>
<p class="rubric">Examples</p>
<p>An impulse at the 0th element (<span class="math notranslate nohighlight">\(\delta[n]\)</span>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">unit_impulse</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">array([ 1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
<p>Impulse offset by 2 samples (<span class="math notranslate nohighlight">\(\delta[n-2]\)</span>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">unit_impulse</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  1.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
<p>2-dimensional impulse, centered:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">unit_impulse</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">'mid'</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>Impulse at (2, 2), using broadcasting:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cusignal</span><span class="o">.</span><span class="n">unit_impulse</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="spectrum-analysis">
<h2>Spectrum Analysis<a class="headerlink" href="#spectrum-analysis" title="Permalink to this heading">#</a></h2>
<section id="module-cusignal.spectral_analysis.spectral">
<span id="spectral"></span><h3>Spectral<a class="headerlink" href="#module-cusignal.spectral_analysis.spectral" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.coherence">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">coherence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hann'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperseg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noverlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.coherence" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate the magnitude squared coherence estimate, Cxy, of
discrete-time signals X and Y using Welch&rsquo;s method.</p>
<p><code class="docutils literal notranslate"><span class="pre">Cxy</span> <span class="pre">=</span> <span class="pre">abs(Pxy)**2/(Pxx*Pyy)</span></code>, where <cite>Pxx</cite> and <cite>Pyy</cite> are power
spectral density estimates of X and Y, and <cite>Pxy</cite> is the cross
spectral density estimate of X and Y.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Time series of measurement values</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Time series of measurement values</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float, optional</span></dt><dd><p>Sampling frequency of the <cite>x</cite> and <cite>y</cite> time series. Defaults
to 1.0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">str or tuple or array_like, optional</span></dt><dd><p>Desired window to use. If <cite>window</cite> is a string or tuple, it is
passed to <cite>get_window</cite> to generate the window values, which are
DFT-even by default. See <cite>get_window</cite> for a list of windows and
required parameters. If <cite>window</cite> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.</p>
</dd>
<dt><strong>nperseg</strong><span class="classifier">int, optional</span></dt><dd><p>Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.</p>
</dd>
<dt><strong>noverlap: int, optional</strong></dt><dd><p>Number of points to overlap between segments. If <cite>None</cite>,
<code class="docutils literal notranslate"><span class="pre">noverlap</span> <span class="pre">=</span> <span class="pre">nperseg</span> <span class="pre">//</span> <span class="pre">2</span></code>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the FFT used, if a zero padded FFT is desired. If
<cite>None</cite>, the FFT length is <cite>nperseg</cite>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">str or function or <cite>False</cite>, optional</span></dt><dd><p>Specifies how to detrend each segment. If <cite>detrend</cite> is a
string, it is passed as the <cite>type</cite> argument to the <cite>detrend</cite>
function. If it is a function, it takes a segment and returns a
detrended segment. If <cite>detrend</cite> is <cite>False</cite>, no detrending is
done. Defaults to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the coherence is computed for both inputs; the
default is over the last axis (i.e. <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>Array of sample frequencies.</p>
</dd>
<dt><strong>Cxy</strong><span class="classifier">ndarray</span></dt><dd><p>Magnitude squared coherence of x and y.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.periodogram" title="cusignal.spectral_analysis.spectral.periodogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodogram</span></code></a></dt><dd><p>Simple, optionally modified periodogram</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.lombscargle" title="cusignal.spectral_analysis.spectral.lombscargle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lombscargle</span></code></a></dt><dd><p>Lomb-Scargle periodogram for unevenly sampled data</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.welch" title="cusignal.spectral_analysis.spectral.welch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">welch</span></code></a></dt><dd><p>Power spectral density by Welch&rsquo;s method.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.csd" title="cusignal.spectral_analysis.spectral.csd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csd</span></code></a></dt><dd><p>Cross spectral density by Welch&rsquo;s method.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4c11c1f73420-1"><span class="brackets">1</span></dt>
<dd><p>P. Welch, &ldquo;The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms&rdquo;, IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.</p>
</dd>
<dt class="label" id="r4c11c1f73420-2"><span class="brackets">2</span></dt>
<dd><p>Stoica, Petre, and Randolph Moses, &ldquo;Spectral Analysis of
Signals&rdquo; Prentice Hall, 2005</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<p>Generate two test signals with some common features.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mf">10e3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="mf">1234.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise_power</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">'low'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># lfilter not implemented in cuSignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+=</span> <span class="n">amp</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span><span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute and plot the coherence.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">Cxy</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">coherence</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">Cxy</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Coherence'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.csd">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">csd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hann'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperseg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noverlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_onesided</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'density'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.csd" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate the cross power spectral density, Pxy, using Welch&rsquo;s
method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Time series of measurement values</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Time series of measurement values</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float, optional</span></dt><dd><p>Sampling frequency of the <cite>x</cite> and <cite>y</cite> time series. Defaults
to 1.0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">str or tuple or array_like, optional</span></dt><dd><p>Desired window to use. If <cite>window</cite> is a string or tuple, it is
passed to <cite>get_window</cite> to generate the window values, which are
DFT-even by default. See <cite>get_window</cite> for a list of windows and
required parameters. If <cite>window</cite> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.</p>
</dd>
<dt><strong>nperseg</strong><span class="classifier">int, optional</span></dt><dd><p>Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.</p>
</dd>
<dt><strong>noverlap: int, optional</strong></dt><dd><p>Number of points to overlap between segments. If <cite>None</cite>,
<code class="docutils literal notranslate"><span class="pre">noverlap</span> <span class="pre">=</span> <span class="pre">nperseg</span> <span class="pre">//</span> <span class="pre">2</span></code>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the FFT used, if a zero padded FFT is desired. If
<cite>None</cite>, the FFT length is <cite>nperseg</cite>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">str or function or <cite>False</cite>, optional</span></dt><dd><p>Specifies how to detrend each segment. If <cite>detrend</cite> is a
string, it is passed as the <cite>type</cite> argument to the <cite>detrend</cite>
function. If it is a function, it takes a segment and returns a
detrended segment. If <cite>detrend</cite> is <cite>False</cite>, no detrending is
done. Defaults to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>return_onesided</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return a one-sided spectrum for real data. If
<cite>False</cite> return a two-sided spectrum. Defaults to <cite>True</cite>, but for
complex data, a two-sided spectrum is always returned.</p>
</dd>
<dt><strong>scaling</strong><span class="classifier">{ &lsquo;density&rsquo;, &lsquo;spectrum&rsquo; }, optional</span></dt><dd><p>Selects between computing the cross spectral density (&lsquo;density&rsquo;)
where <cite>Pxy</cite> has units of V**2/Hz and computing the cross spectrum
(&lsquo;spectrum&rsquo;) where <cite>Pxy</cite> has units of V**2, if <cite>x</cite> and <cite>y</cite> are
measured in V and <cite>fs</cite> is measured in Hz. Defaults to &lsquo;density&rsquo;</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the CSD is computed for both inputs; the
default is over the last axis (i.e. <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>).</p>
</dd>
<dt><strong>average</strong><span class="classifier">{ &lsquo;mean&rsquo;, &lsquo;median&rsquo; }, optional</span></dt><dd><p>Method to use when averaging periodograms. Defaults to &lsquo;mean&rsquo;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>Array of sample frequencies.</p>
</dd>
<dt><strong>Pxy</strong><span class="classifier">ndarray</span></dt><dd><p>Cross spectral density or cross power spectrum of x,y.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.periodogram" title="cusignal.spectral_analysis.spectral.periodogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodogram</span></code></a></dt><dd><p>Simple, optionally modified periodogram</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.lombscargle" title="cusignal.spectral_analysis.spectral.lombscargle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lombscargle</span></code></a></dt><dd><p>Lomb-Scargle periodogram for unevenly sampled data</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.welch" title="cusignal.spectral_analysis.spectral.welch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">welch</span></code></a></dt><dd><p>Power spectral density by Welch&rsquo;s method. [Equivalent to csd(x,x)]</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.coherence" title="cusignal.spectral_analysis.spectral.coherence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coherence</span></code></a></dt><dd><p>Magnitude squared coherence by Welch&rsquo;s method.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>By convention, Pxy is computed with the conjugate FFT of X
multiplied by the FFT of Y.</p>
<p>If the input series differ in length, the shorter series will be
zero-padded to match.</p>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1b21e9c2a5a6-1"><span class="brackets">1</span></dt>
<dd><p>P. Welch, &ldquo;The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms&rdquo;, IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.</p>
</dd>
<dt class="label" id="r1b21e9c2a5a6-2"><span class="brackets">2</span></dt>
<dd><p>Rabiner, Lawrence R., and B. Gold. &ldquo;Theory and Application of
Digital Signal Processing&rdquo; Prentice-Hall, pp. 414-419, 1975</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<p>Generate two test signals with some common features.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mf">10e3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="mf">1234.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise_power</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">'low'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># lfilter not currently implemented in cuSignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+=</span> <span class="n">amp</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span><span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute and plot the magnitude of the cross spectral density.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">Pxy</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Pxy</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'CSD [V**2/Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.istft">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">istft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Zxx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hann'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperseg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noverlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_onesided</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.istft" title="Permalink to this definition">#</a></dt>
<dd><p>Perform the inverse Short Time Fourier transform (iSTFT).
Parameters
&mdash;&mdash;&mdash;-
Zxx : array_like</p>
<blockquote>
<div><p>STFT of the signal to be reconstructed. If a purely real array
is passed, it will be cast to a complex data type.</p>
</div></blockquote>
<dl class="simple">
<dt>fs<span class="classifier">float, optional</span></dt><dd><p>Sampling frequency of the time series. Defaults to 1.0.</p>
</dd>
<dt>window<span class="classifier">str or tuple or array_like, optional</span></dt><dd><p>Desired window to use. If <cite>window</cite> is a string or tuple, it is
passed to <cite>get_window</cite> to generate the window values, which are
DFT-even by default. See <cite>get_window</cite> for a list of windows and
required parameters. If <cite>window</cite> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window. Must match the window used to generate the
STFT for faithful inversion.</p>
</dd>
<dt>nperseg<span class="classifier">int, optional</span></dt><dd><p>Number of data points corresponding to each STFT segment. This
parameter must be specified if the number of data points per
segment is odd, or if the STFT was padded via <code class="docutils literal notranslate"><span class="pre">nfft</span> <span class="pre">&gt;</span>
<span class="pre">nperseg</span></code>. If <cite>None</cite>, the value depends on the shape of
<cite>Zxx</cite> and <cite>input_onesided</cite>. If <cite>input_onesided</cite> is <cite>True</cite>,
<code class="docutils literal notranslate"><span class="pre">nperseg=2*(Zxx.shape[freq_axis]</span> <span class="pre">-</span> <span class="pre">1)</span></code>. Otherwise,
<code class="docutils literal notranslate"><span class="pre">nperseg=Zxx.shape[freq_axis]</span></code>. Defaults to <cite>None</cite>.</p>
</dd>
<dt>noverlap<span class="classifier">int, optional</span></dt><dd><p>Number of points to overlap between segments. If <cite>None</cite>, half
of the segment length. Defaults to <cite>None</cite>. When specified, the
COLA constraint must be met (see Notes below), and should match
the parameter used to generate the STFT. Defaults to <cite>None</cite>.</p>
</dd>
<dt>nfft<span class="classifier">int, optional</span></dt><dd><p>Number of FFT points corresponding to each STFT segment. This
parameter must be specified if the STFT was padded via <code class="docutils literal notranslate"><span class="pre">nfft</span> <span class="pre">&gt;</span>
<span class="pre">nperseg</span></code>. If <cite>None</cite>, the default values are the same as for
<cite>nperseg</cite>, detailed above, with one exception: if
<cite>input_onesided</cite> is True and
<code class="docutils literal notranslate"><span class="pre">nperseg==2*Zxx.shape[freq_axis]</span> <span class="pre">-</span> <span class="pre">1</span></code>, <cite>nfft</cite> also takes on
that value. This case allows the proper inversion of an
odd-length unpadded STFT using <code class="docutils literal notranslate"><span class="pre">nfft=None</span></code>. Defaults to
<cite>None</cite>.</p>
</dd>
<dt>input_onesided<span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, interpret the input array as one-sided FFTs, such
as is returned by <cite>stft</cite> with <code class="docutils literal notranslate"><span class="pre">return_onesided=True</span></code> and
<cite>numpy.fft.rfft</cite>. If <cite>False</cite>, interpret the input as a a
two-sided FFT. Defaults to <cite>True</cite>.</p>
</dd>
<dt>boundary<span class="classifier">bool, optional</span></dt><dd><p>Specifies whether the input signal was extended at its
boundaries by supplying a non-<cite>None</cite> <code class="docutils literal notranslate"><span class="pre">boundary</span></code> argument to
<cite>stft</cite>. Defaults to <cite>True</cite>.</p>
</dd>
<dt>time_axis<span class="classifier">int, optional</span></dt><dd><p>Where the time segments of the STFT is located; the default is
the last axis (i.e. <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>).</p>
</dd>
<dt>freq_axis<span class="classifier">int, optional</span></dt><dd><p>Where the frequency axis of the STFT is located; the default is
the penultimate axis (i.e. <code class="docutils literal notranslate"><span class="pre">axis=-2</span></code>).</p>
</dd>
</dl>
<dl class="simple">
<dt>t<span class="classifier">ndarray</span></dt><dd><p>Array of output data times.</p>
</dd>
<dt>x<span class="classifier">ndarray</span></dt><dd><p>iSTFT of <cite>Zxx</cite>.</p>
</dd>
</dl>
<p>stft: Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint</p>
<blockquote>
<div><p>is met</p>
</div></blockquote>
<p>check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
Notes
&mdash;&ndash;
In order to enable inversion of an STFT via the inverse STFT with
<cite>istft</cite>, the signal windowing must obey the constraint of &ldquo;nonzero
overlap add&rdquo; (NOLA):
.. math:: sum_{t}w^{2}[n-tH] ne 0
This ensures that the normalization factors that appear in the denominator
of the overlap-add reconstruction equation
.. math:: x[n]=frac{sum_{t}x_{t}[n]w[n-tH]}{sum_{t}w^{2}[n-tH]}
are not zero. The NOLA constraint can be checked with the <cite>check_NOLA</cite>
function.
An STFT which has been modified (via masking or otherwise) is not
guaranteed to correspond to a exactly realizible signal. This
function implements the iSTFT via the least-squares estimation
algorithm detailed in <a class="reference internal" href="#rb890c6d0cb06-2" id="id80">[2]</a>, which produces a signal that minimizes
the mean squared error between the STFT of the returned signal and
the modified STFT.
.. versionadded:: 0.19.0
References
&mdash;&mdash;&mdash;-
.. [Rb890c6d0cb06-1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck</p>
<blockquote>
<div><p>&ldquo;Discrete-Time Signal Processing&rdquo;, Prentice Hall, 1999.</p>
</div></blockquote>
<dl class="citation">
<dt class="label" id="rb890c6d0cb06-2"><span class="brackets"><a class="fn-backref" href="#id80">2</a></span></dt>
<dd><p>Daniel W. Griffin, Jae S. Lim &ldquo;Signal Estimation from
Modified Short-Time Fourier Transform&rdquo;, IEEE 1984,
10.1109/TASSP.1984.1164317</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="go">Generate a test signal, a 2 Vrms sine wave at 50Hz corrupted by</span>
<span class="go">0.001 V**2/Hz of white noise sampled at 1024 Hz.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">fs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nperseg</span> <span class="o">=</span> <span class="mi">512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise_power</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">carrier</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">50</span><span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">carrier</span> <span class="o">+</span> <span class="n">noise</span>
<span class="go">Compute the STFT, and plot its magnitude</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Zxx</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Zxx</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">Zxx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Zxx</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">amp</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s1">'gouraud'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'STFT Magnitude'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">Zero the components that are 10% or less of the carrier magnitude,</span>
<span class="go">then convert back to a time series via inverse STFT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Zxx</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Zxx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">amp</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="n">Zxx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">xrec</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">Zxx</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xrec</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">xrec</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">carrier</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">carrier</span><span class="p">)</span>
<span class="go">Compare the cleaned signal with the original and true carrier signals.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">xrec</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">carrier</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span><span class="o">*+</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Signal'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'Carrier + Noise'</span><span class="p">,</span> <span class="s1">'Filtered via STFT'</span><span class="p">,</span> <span class="s1">'True Carrier'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">Note that the cleaned signal does not start as abruptly as the original,</span>
<span class="go">since some of the coefficients of the transient were also removed:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">xrec</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">carrier</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Signal'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'Carrier + Noise'</span><span class="p">,</span> <span class="s1">'Filtered via STFT'</span><span class="p">,</span> <span class="s1">'True Carrier'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.lombscargle">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">lombscargle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.lombscargle" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the Lomb-Scargle periodogram.
The Lomb-Scargle periodogram was developed by Lomb <a class="reference internal" href="#rde1fa02559c1-1" id="id81">[1]</a> and further
extended by Scargle <a class="reference internal" href="#rde1fa02559c1-2" id="id82">[2]</a> to find, and test the significance of weak
periodic signals with uneven temporal sampling.
When <em>normalize</em> is False (default) the computed periodogram
is unnormalized, it takes the value <code class="docutils literal notranslate"><span class="pre">(A**2)</span> <span class="pre">*</span> <span class="pre">N/4</span></code> for a harmonic
signal with amplitude A for sufficiently large N.
When <em>normalize</em> is True the computed periodogram is normalized by
the residuals of the data around a constant reference model (at zero).
Input arrays should be one-dimensional and will be cast to float64.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Sample times.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Measurement values.</p>
</dd>
<dt><strong>freqs</strong><span class="classifier">array_like</span></dt><dd><p>Angular frequencies for output periodogram.</p>
</dd>
<dt><strong>precenter</strong><span class="classifier">bool, optional</span></dt><dd><p>Pre-center amplitudes by subtracting the mean.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>Compute normalized periodogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pgram</strong><span class="classifier">array_like</span></dt><dd><p>Lomb-Scargle periodogram.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the input arrays <cite>x</cite> and <cite>y</cite> do not have the same shape.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.istft" title="cusignal.spectral_analysis.spectral.istft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">istft</span></code></a></dt><dd><p>Inverse Short Time Fourier Transform</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_COLA</span></code></dt><dd><p>Check whether the Constant OverLap Add (COLA) constraint is met</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.welch" title="cusignal.spectral_analysis.spectral.welch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">welch</span></code></a></dt><dd><p>Power spectral density by Welch&rsquo;s method</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.spectrogram" title="cusignal.spectral_analysis.spectral.spectrogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spectrogram</span></code></a></dt><dd><p>Spectrogram by Welch&rsquo;s method</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.csd" title="cusignal.spectral_analysis.spectral.csd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csd</span></code></a></dt><dd><p>Cross spectral density by Welch&rsquo;s method</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This subroutine calculates the periodogram using a slightly
modified algorithm due to Townsend <a class="reference internal" href="#rde1fa02559c1-3" id="id83">[3]</a> which allows the
periodogram to be calculated using only a single pass through
the input arrays for each frequency.
The algorithm running time scales roughly as O(x * freqs) or O(N^2)
for a large number of samples and frequencies.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rde1fa02559c1-1"><span class="brackets"><a class="fn-backref" href="#id81">1</a></span></dt>
<dd><p>N.R. Lomb &ldquo;Least-squares frequency analysis of unequally spaced
data&rdquo;, Astrophysics and Space Science, vol 39, pp. 447-462, 1976</p>
</dd>
<dt class="label" id="rde1fa02559c1-2"><span class="brackets"><a class="fn-backref" href="#id82">2</a></span></dt>
<dd><p>J.D. Scargle &ldquo;Studies in astronomical time series analysis. II -
Statistical aspects of spectral analysis of unevenly spaced data&rdquo;,
The Astrophysical Journal, vol 263, pp. 835-853, 1982</p>
</dd>
<dt class="label" id="rde1fa02559c1-3"><span class="brackets"><a class="fn-backref" href="#id83">3</a></span></dt>
<dd><p>R.H.D. Townsend, &ldquo;Fast calculation of the Lomb-Scargle
periodogram using graphics processing units.&rdquo;, The Astrophysical
Journal Supplement Series, vol 191, pp. 247-253, 2010</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="go">First define some input parameters for the signal:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nin</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nout</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frac_points</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="c1"># Fraction of points to select</span>
<span class="go">Randomly select a fraction of an array with timesteps:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">nin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">frac_points</span><span class="p">]</span>
<span class="go">Plot a sine wave for the selected times:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>
<span class="go">Define the array of frequencies for which to compute the periodogram:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">nout</span><span class="p">)</span>
<span class="go">Calculate Lomb-Scargle periodogram:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pgram</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">lombscargle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Now make a plot of the input data:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="s1">'b+'</span><span class="p">)</span>
<span class="go">Then plot the normalized periodogram:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">pgram</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.periodogram">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">periodogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'boxcar'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_onesided</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'density'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.periodogram" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate power spectral density using a periodogram.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Time series of measurement values</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float, optional</span></dt><dd><p>Sampling frequency of the <cite>x</cite> time series. Defaults to 1.0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">str or tuple or array_like, optional</span></dt><dd><p>Desired window to use. If <cite>window</cite> is a string or tuple, it is
passed to <cite>get_window</cite> to generate the window values, which are
DFT-even by default. See <cite>get_window</cite> for a list of windows and
required parameters. If <cite>window</cite> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to &lsquo;boxcar&rsquo;.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the FFT used. If <cite>None</cite> the length of <cite>x</cite> will be
used.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">str or function or <cite>False</cite>, optional</span></dt><dd><p>Specifies how to detrend each segment. If <cite>detrend</cite> is a
string, it is passed as the <cite>type</cite> argument to the <cite>detrend</cite>
function. If it is a function, it takes a segment and returns a
detrended segment. If <cite>detrend</cite> is <cite>False</cite>, no detrending is
done. Defaults to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>return_onesided</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return a one-sided spectrum for real data. If
<cite>False</cite> return a two-sided spectrum. Defaults to <cite>True</cite>, but for
complex data, a two-sided spectrum is always returned.</p>
</dd>
<dt><strong>scaling</strong><span class="classifier">{ &lsquo;density&rsquo;, &lsquo;spectrum&rsquo; }, optional</span></dt><dd><p>Selects between computing the power spectral density (&lsquo;density&rsquo;)
where <cite>Pxx</cite> has units of V**2/Hz and computing the power
spectrum (&lsquo;spectrum&rsquo;) where <cite>Pxx</cite> has units of V**2, if <cite>x</cite>
is measured in V and <cite>fs</cite> is measured in Hz. Defaults to
&lsquo;density&rsquo;</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the periodogram is computed; the default is
over the last axis (i.e. <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>Array of sample frequencies.</p>
</dd>
<dt><strong>Pxx</strong><span class="classifier">ndarray</span></dt><dd><p>Power spectral density or power spectrum of <cite>x</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.welch" title="cusignal.spectral_analysis.spectral.welch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">welch</span></code></a></dt><dd><p>Estimate power spectral density using Welch&rsquo;s method</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.lombscargle" title="cusignal.spectral_analysis.spectral.lombscargle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lombscargle</span></code></a></dt><dd><p>Lomb-Scargle periodogram for unevenly sampled data</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
</pre></div>
</div>
<p>Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mf">10e3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="mf">1234.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise_power</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">amp</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span><span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute and plot the power spectral density.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx_den</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">Pxx_den</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mf">1e-7</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'PSD [V**2/Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Pxx_den</span><span class="p">[</span><span class="mi">25000</span><span class="p">:])</span>
<span class="go">0.00099728892368242854</span>
</pre></div>
</div>
<p>Now compute and plot the power spectrum.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx_spec</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="s1">'flattop'</span><span class="p">,</span>             <span class="n">scaling</span><span class="o">=</span><span class="s1">'spectrum'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pxx_spec</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mf">1e-4</span><span class="p">,</span> <span class="mf">1e1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Linear spectrum [V RMS]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The peak height in the power spectrum is an estimate of the RMS
amplitude.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pxx_spec</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="go">2.0077340678640727</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.spectrogram">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">spectrogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('tukey',</span> <span class="pre">0.25)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperseg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noverlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_onesided</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'density'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'psd'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.spectrogram" title="Permalink to this definition">#</a></dt>
<dd><p>Compute a spectrogram with consecutive Fourier transforms.</p>
<p>Spectrograms can be used as a way of visualizing the change of a
nonstationary signal&rsquo;s frequency content over time.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Time series of measurement values</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float, optional</span></dt><dd><p>Sampling frequency of the <cite>x</cite> time series. Defaults to 1.0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">str or tuple or array_like, optional</span></dt><dd><p>Desired window to use. If <cite>window</cite> is a string or tuple, it is
passed to <cite>get_window</cite> to generate the window values, which are
DFT-even by default. See <cite>get_window</cite> for a list of windows and
required parameters. If <cite>window</cite> is array_like it will be used
directly as the window and its length must be nperseg.
Defaults to a Tukey window with shape parameter of 0.25.</p>
</dd>
<dt><strong>nperseg</strong><span class="classifier">int, optional</span></dt><dd><p>Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.</p>
</dd>
<dt><strong>noverlap</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points to overlap between segments. If <cite>None</cite>,
<code class="docutils literal notranslate"><span class="pre">noverlap</span> <span class="pre">=</span> <span class="pre">nperseg</span> <span class="pre">//</span> <span class="pre">8</span></code>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the FFT used, if a zero padded FFT is desired. If
<cite>None</cite>, the FFT length is <cite>nperseg</cite>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">str or function or <cite>False</cite>, optional</span></dt><dd><p>Specifies how to detrend each segment. If <cite>detrend</cite> is a
string, it is passed as the <cite>type</cite> argument to the <cite>detrend</cite>
function. If it is a function, it takes a segment and returns a
detrended segment. If <cite>detrend</cite> is <cite>False</cite>, no detrending is
done. Defaults to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>return_onesided</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return a one-sided spectrum for real data. If
<cite>False</cite> return a two-sided spectrum. Defaults to <cite>True</cite>, but for
complex data, a two-sided spectrum is always returned.</p>
</dd>
<dt><strong>scaling</strong><span class="classifier">{ &lsquo;density&rsquo;, &lsquo;spectrum&rsquo; }, optional</span></dt><dd><p>Selects between computing the power spectral density (&lsquo;density&rsquo;)
where <cite>Sxx</cite> has units of V**2/Hz and computing the power
spectrum (&lsquo;spectrum&rsquo;) where <cite>Sxx</cite> has units of V**2, if <cite>x</cite>
is measured in V and <cite>fs</cite> is measured in Hz. Defaults to
&lsquo;density&rsquo;.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the spectrogram is computed; the default is over
the last axis (i.e. <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>).</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>Defines what kind of return values are expected. Options are
[&lsquo;psd&rsquo;, &lsquo;complex&rsquo;, &lsquo;magnitude&rsquo;, &lsquo;angle&rsquo;, &lsquo;phase&rsquo;]. &lsquo;complex&rsquo; is
equivalent to the output of <cite>stft</cite> with no padding or boundary
extension. &lsquo;magnitude&rsquo; returns the absolute magnitude of the
STFT. &lsquo;angle&rsquo; and &lsquo;phase&rsquo; return the complex angle of the STFT,
with and without unwrapping, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>Array of sample frequencies.</p>
</dd>
<dt><strong>t</strong><span class="classifier">ndarray</span></dt><dd><p>Array of segment times.</p>
</dd>
<dt><strong>Sxx</strong><span class="classifier">ndarray</span></dt><dd><p>Spectrogram of x. By default, the last axis of Sxx corresponds
to the segment times.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.periodogram" title="cusignal.spectral_analysis.spectral.periodogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodogram</span></code></a></dt><dd><p>Simple, optionally modified periodogram</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.lombscargle" title="cusignal.spectral_analysis.spectral.lombscargle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lombscargle</span></code></a></dt><dd><p>Lomb-Scargle periodogram for unevenly sampled data</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.welch" title="cusignal.spectral_analysis.spectral.welch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">welch</span></code></a></dt><dd><p>Power spectral density by Welch&rsquo;s method.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.csd" title="cusignal.spectral_analysis.spectral.csd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csd</span></code></a></dt><dd><p>Cross spectral density by Welch&rsquo;s method.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. In contrast to welch&rsquo;s method, where the
entire data stream is averaged over, one may wish to use a smaller
overlap (or perhaps none at all) when computing a spectrogram, to
maintain some statistical independence between individual segments.
It is for this reason that the default window is a Tukey window with
1/8th of a window&rsquo;s length overlap at each end.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.16.0.</span></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd2b2e304d588-1"><span class="brackets">1</span></dt>
<dd><p>Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
&ldquo;Discrete-Time Signal Processing&rdquo;, Prentice Hall, 1999.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<p>Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mf">10e3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise_power</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span> <span class="o">=</span> <span class="mi">500</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.25</span><span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">carrier</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">3e3</span><span class="o">*</span><span class="n">time</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">*=</span> <span class="n">cp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">time</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">carrier</span> <span class="o">+</span> <span class="n">noise</span>
</pre></div>
</div>
<p>Compute and plot the spectrogram.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">Sxx</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Note, if using output that is not one sided, then use the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>         <span class="n">cp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.stft">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">stft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hann'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperseg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noverlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_onesided</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'zeros'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padded</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.stft" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Short Time Fourier Transform (STFT).</p>
<p>STFTs can be used as a way of quantifying the change of a
nonstationary signal&rsquo;s frequency and phase content over time.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Time series of measurement values</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float, optional</span></dt><dd><p>Sampling frequency of the <cite>x</cite> time series. Defaults to 1.0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">str or tuple or array_like, optional</span></dt><dd><p>Desired window to use. If <cite>window</cite> is a string or tuple, it is
passed to <cite>get_window</cite> to generate the window values, which are
DFT-even by default. See <cite>get_window</cite> for a list of windows and
required parameters. If <cite>window</cite> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.</p>
</dd>
<dt><strong>nperseg</strong><span class="classifier">int, optional</span></dt><dd><p>Length of each segment. Defaults to 256.</p>
</dd>
<dt><strong>noverlap</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points to overlap between segments. If <cite>None</cite>,
<code class="docutils literal notranslate"><span class="pre">noverlap</span> <span class="pre">=</span> <span class="pre">nperseg</span> <span class="pre">//</span> <span class="pre">2</span></code>. Defaults to <cite>None</cite>. When
specified, the COLA constraint must be met (see Notes below).</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the FFT used, if a zero padded FFT is desired. If
<cite>None</cite>, the FFT length is <cite>nperseg</cite>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">str or function or <cite>False</cite>, optional</span></dt><dd><p>Specifies how to detrend each segment. If <cite>detrend</cite> is a
string, it is passed as the <cite>type</cite> argument to the <cite>detrend</cite>
function. If it is a function, it takes a segment and returns a
detrended segment. If <cite>detrend</cite> is <cite>False</cite>, no detrending is
done. Defaults to <cite>False</cite>.</p>
</dd>
<dt><strong>return_onesided</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return a one-sided spectrum for real data. If
<cite>False</cite> return a two-sided spectrum. Defaults to <cite>True</cite>, but for
complex data, a two-sided spectrum is always returned.</p>
</dd>
<dt><strong>boundary</strong><span class="classifier">str or None, optional</span></dt><dd><p>Specifies whether the input signal is extended at both ends, and
how to generate the new values, in order to center the first
windowed segment on the first input point. This has the benefit
of enabling reconstruction of the first input point when the
employed window function starts at zero. Valid options are
<code class="docutils literal notranslate"><span class="pre">['even',</span> <span class="pre">'odd',</span> <span class="pre">'constant',</span> <span class="pre">'zeros',</span> <span class="pre">None]</span></code>. Defaults to
&lsquo;zeros&rsquo;, for zero padding extension. I.e. <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code> is
extended to <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">0]</span></code> for <code class="docutils literal notranslate"><span class="pre">nperseg=3</span></code>.</p>
</dd>
<dt><strong>padded</strong><span class="classifier">bool, optional</span></dt><dd><p>Specifies whether the input signal is zero-padded at the end to
make the signal fit exactly into an integer number of window
segments, so that all of the signal is included in the output.
Defaults to <cite>True</cite>. Padding occurs after boundary extension, if
<cite>boundary</cite> is not <cite>None</cite>, and <cite>padded</cite> is <cite>True</cite>, as is the
default.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the STFT is computed; the default is over the
last axis (i.e. <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>Array of sample frequencies.</p>
</dd>
<dt><strong>t</strong><span class="classifier">ndarray</span></dt><dd><p>Array of segment times.</p>
</dd>
<dt><strong>Zxx</strong><span class="classifier">ndarray</span></dt><dd><p>STFT of <cite>x</cite>. By default, the last axis of <cite>Zxx</cite> corresponds
to the segment times.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.welch" title="cusignal.spectral_analysis.spectral.welch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">welch</span></code></a></dt><dd><p>Power spectral density by Welch&rsquo;s method.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.spectrogram" title="cusignal.spectral_analysis.spectral.spectrogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spectrogram</span></code></a></dt><dd><p>Spectrogram by Welch&rsquo;s method.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.csd" title="cusignal.spectral_analysis.spectral.csd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csd</span></code></a></dt><dd><p>Cross spectral density by Welch&rsquo;s method.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.lombscargle" title="cusignal.spectral_analysis.spectral.lombscargle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lombscargle</span></code></a></dt><dd><p>Lomb-Scargle periodogram for unevenly sampled data</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In order to enable inversion of an STFT via the inverse STFT in
<cite>istft</cite>, the signal windowing must obey the constraint of &ldquo;Nonzero
OverLap Add&rdquo; (NOLA), and the input signal must have complete
windowing coverage (i.e. <code class="docutils literal notranslate"><span class="pre">(x.shape[axis]</span> <span class="pre">-</span> <span class="pre">nperseg)</span> <span class="pre">%</span>
<span class="pre">(nperseg-noverlap)</span> <span class="pre">==</span> <span class="pre">0</span></code>). The <cite>padded</cite> argument may be used to
accomplish this.</p>
<p>Given a time-domain signal <span class="math notranslate nohighlight">\(x[n]\)</span>, a window <span class="math notranslate nohighlight">\(w[n]\)</span>, and a hop
size <span class="math notranslate nohighlight">\(H\)</span> = <cite>nperseg - noverlap</cite>, the windowed frame at time index
<span class="math notranslate nohighlight">\(t\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[x_{t}[n]=x[n]w[n-tH]\]</div>
<p>The overlap-add (OLA) reconstruction equation is given by</p>
<div class="math notranslate nohighlight">
\[x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}\]</div>
<p>The NOLA constraint ensures that every normalization term that appears
in the denomimator of the OLA reconstruction equation is nonzero. Whether a
choice of <cite>window</cite>, <cite>nperseg</cite>, and <cite>noverlap</cite> satisfy this constraint can
be tested with <cite>check_NOLA</cite>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r6d6bbe5a35ca-1"><span class="brackets">1</span></dt>
<dd><p>Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
&ldquo;Discrete-Time Signal Processing&rdquo;, Prentice Hall, 1999.</p>
</dd>
<dt class="label" id="r6d6bbe5a35ca-2"><span class="brackets">2</span></dt>
<dd><p>Daniel W. Griffin, Jae S. Lim &ldquo;Signal Estimation from
Modified Short-Time Fourier Transform&rdquo;, IEEE 1984,
10.1109/TASSP.1984.1164317</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<p>Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mf">10e3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise_power</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span> <span class="o">=</span> <span class="mi">500</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.25</span><span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">carrier</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">3e3</span><span class="o">*</span><span class="n">time</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">*=</span> <span class="n">cp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">time</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">carrier</span> <span class="o">+</span> <span class="n">noise</span>
</pre></div>
</div>
<p>Compute and plot the STFT&rsquo;s magnitude.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Zxx</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Zxx</span><span class="p">)),</span> \
<span class="go">    vmin=0, vmax=amp)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'STFT Magnitude'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'Time [sec]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.vectorstrength">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">vectorstrength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">period</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.vectorstrength" title="Permalink to this definition">#</a></dt>
<dd><p>Determine the vector strength of the events corresponding to the given
period.</p>
<p>The vector strength is a measure of phase synchrony, how well the
timing of the events is synchronized to a single period of a periodic
signal.</p>
<p>If multiple periods are used, calculate the vector strength of each.
This is called the &ldquo;resonating vector strength&rdquo;.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>events</strong><span class="classifier">1D array_like</span></dt><dd><p>An array of time points containing the timing of the events.</p>
</dd>
<dt><strong>period</strong><span class="classifier">float or array_like</span></dt><dd><p>The period of the signal that the events should synchronize to.
The period is in the same units as <cite>events</cite>.  It can also be an array
of periods, in which case the outputs are arrays of the same length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">float or 1D array</span></dt><dd><p>The strength of the synchronization.  1.0 is perfect synchronization
and 0.0 is no synchronization.  If <cite>period</cite> is an array, this is also
an array with each element containing the vector strength at the
corresponding period.</p>
</dd>
<dt><strong>phase</strong><span class="classifier">float or array</span></dt><dd><p>The phase that the events are most strongly synchronized to in radians.
If <cite>period</cite> is an array, this is also an array with each element
containing the phase for the corresponding period.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4c87d7fd288a-1"><span class="brackets">1</span></dt>
<dd><p>van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating
vector strength: Auditory system, electric fish, and noise.
Chaos 21, 047508 (2011);
<a href="#id90"><span class="problematic" id="id91">:doi:`10.1063/1.3670512`</span></a>.</p>
</dd>
<dt class="label" id="r4c87d7fd288a-2"><span class="brackets">2</span></dt>
<dd><p>van Hemmen, JL. Vector strength after Goldberg, Brown, and
von Mises: biological and mathematical perspectives.  Biol Cybern.
2013 Aug;107(4):385-96. <a href="#id92"><span class="problematic" id="id93">:doi:`10.1007/s00422-013-0561-7`</span></a>.</p>
</dd>
<dt class="label" id="r4c87d7fd288a-3"><span class="brackets">3</span></dt>
<dd><p>van Hemmen, JL and Vollmayr, AN.  Resonating vector strength:
what happens when we vary the &ldquo;probing&rdquo; frequency while keeping
the spike times fixed.  Biol Cybern. 2013 Aug;107(4):491-94.
<a href="#id94"><span class="problematic" id="id95">:doi:`10.1007/s00422-013-0560-8`</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.spectral_analysis.spectral.welch">
<span class="sig-prename descclassname"><span class="pre">cusignal.spectral_analysis.spectral.</span></span><span class="sig-name descname"><span class="pre">welch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hann'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperseg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noverlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_onesided</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'density'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.spectral_analysis.spectral.welch" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate power spectral density using Welch&rsquo;s method.</p>
<p>Welch&rsquo;s method <a class="reference internal" href="#r183d1264652b-1" id="id99">[1]</a> computes an estimate of the power spectral
density by dividing the data into overlapping segments, computing a
modified periodogram for each segment and averaging the
periodograms.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Time series of measurement values</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float, optional</span></dt><dd><p>Sampling frequency of the <cite>x</cite> time series. Defaults to 1.0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">str or tuple or array_like, optional</span></dt><dd><p>Desired window to use. If <cite>window</cite> is a string or tuple, it is
passed to <cite>get_window</cite> to generate the window values, which are
DFT-even by default. See <cite>get_window</cite> for a list of windows and
required parameters. If <cite>window</cite> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.</p>
</dd>
<dt><strong>nperseg</strong><span class="classifier">int, optional</span></dt><dd><p>Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.</p>
</dd>
<dt><strong>noverlap</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points to overlap between segments. If <cite>None</cite>,
<code class="docutils literal notranslate"><span class="pre">noverlap</span> <span class="pre">=</span> <span class="pre">nperseg</span> <span class="pre">//</span> <span class="pre">2</span></code>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Length of the FFT used, if a zero padded FFT is desired. If
<cite>None</cite>, the FFT length is <cite>nperseg</cite>. Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">str or function or <cite>False</cite>, optional</span></dt><dd><p>Specifies how to detrend each segment. If <cite>detrend</cite> is a
string, it is passed as the <cite>type</cite> argument to the <cite>detrend</cite>
function. If it is a function, it takes a segment and returns a
detrended segment. If <cite>detrend</cite> is <cite>False</cite>, no detrending is
done. Defaults to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>return_onesided</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return a one-sided spectrum for real data. If
<cite>False</cite> return a two-sided spectrum. Defaults to <cite>True</cite>, but for
complex data, a two-sided spectrum is always returned.</p>
</dd>
<dt><strong>scaling</strong><span class="classifier">{ &lsquo;density&rsquo;, &lsquo;spectrum&rsquo; }, optional</span></dt><dd><p>Selects between computing the power spectral density (&lsquo;density&rsquo;)
where <cite>Pxx</cite> has units of V**2/Hz and computing the power
spectrum (&lsquo;spectrum&rsquo;) where <cite>Pxx</cite> has units of V**2, if <cite>x</cite>
is measured in V and <cite>fs</cite> is measured in Hz. Defaults to
&lsquo;density&rsquo;</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which the periodogram is computed; the default is
over the last axis (i.e. <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>).</p>
</dd>
<dt><strong>average</strong><span class="classifier">{ &lsquo;mean&rsquo;, &lsquo;median&rsquo; }, optional</span></dt><dd><p>Method to use when averaging periodograms. Defaults to &lsquo;mean&rsquo;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">ndarray</span></dt><dd><p>Array of sample frequencies.</p>
</dd>
<dt><strong>Pxx</strong><span class="classifier">ndarray</span></dt><dd><p>Power spectral density or power spectrum of x.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.periodogram" title="cusignal.spectral_analysis.spectral.periodogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodogram</span></code></a></dt><dd><p>Simple, optionally modified periodogram</p>
</dd>
<dt><a class="reference internal" href="#cusignal.spectral_analysis.spectral.lombscargle" title="cusignal.spectral_analysis.spectral.lombscargle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lombscargle</span></code></a></dt><dd><p>Lomb-Scargle periodogram for unevenly sampled data</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p>If <cite>noverlap</cite> is 0, this method is equivalent to Bartlett&rsquo;s method
<a class="reference internal" href="#r183d1264652b-2" id="id100">[2]</a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.12.0.</span></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r183d1264652b-1"><span class="brackets"><a class="fn-backref" href="#id99">1</a></span></dt>
<dd><p>P. Welch, &ldquo;The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms&rdquo;, IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.</p>
</dd>
<dt class="label" id="r183d1264652b-2"><span class="brackets"><a class="fn-backref" href="#id100">2</a></span></dt>
<dd><p>M.S. Bartlett, &ldquo;Periodogram Analysis and Continuous Spectra&rdquo;,
Biometrika, vol. 37, pp. 1-16, 1950.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
</pre></div>
</div>
<p>Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mf">10e3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="mf">1234.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise_power</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">amp</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span><span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute and plot the power spectral density.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx_den</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">Pxx_den</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mf">0.5e-3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'PSD [V**2/Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Pxx_den</span><span class="p">[</span><span class="mi">256</span><span class="p">:])</span>
<span class="go">0.0009924865443739191</span>
</pre></div>
</div>
<p>Now compute and plot the power spectrum.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx_spec</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="s1">'flattop'</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> \
<span class="go">    scaling='spectrum')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pxx_spec</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Linear spectrum [V RMS]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The peak height in the power spectrum is an estimate of the RMS
amplitude.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pxx_spec</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="go">2.0077340678640727</span>
</pre></div>
</div>
<p>If we now introduce a discontinuity in the signal, by increasing the
amplitude of a small portion of the signal by 50, we can see the
corruption of the mean average power spectral density, but using a
median average better estimates the normal behaviour.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">50.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx_den</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_med</span><span class="p">,</span> <span class="n">Pxx_den_med</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span>
<span class="go">                                      average='median')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">Pxx_den</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">'mean'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">f_med</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">Pxx_den_med</span><span class="p">),</span> \
<span class="go">    label='median')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mf">0.5e-3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'frequency [Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'PSD [V**2/Hz]'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cusignal.acoustics.cepstrum">
<span id="acoustics"></span><h3>Acoustics<a class="headerlink" href="#module-cusignal.acoustics.cepstrum" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.acoustics.cepstrum.complex_cepstrum">
<span class="sig-prename descclassname"><span class="pre">cusignal.acoustics.cepstrum.</span></span><span class="sig-name descname"><span class="pre">complex_cepstrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.acoustics.cepstrum.complex_cepstrum" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the complex cepstrum of a real valued input sequence x
where the cepstrum is defined as the inverse Fourier transform
of the log magnitude DFT (spectrum) of a signal. It&rsquo;s primarily
used for source/speaker separation in speech signal processing.</p>
<p>The input is altered to have zero-phase at pi radians (180 degrees)
Parameters
&mdash;&mdash;&mdash;-
x : ndarray</p>
<blockquote>
<div><p>Input sequence, if x is a matrix, return cepstrum in direction of axis</p>
</div></blockquote>
<dl class="simple">
<dt>n<span class="classifier">int</span></dt><dd><p>Size of Fourier Transform; If none, will use length of input array</p>
</dd>
<dt>axis: int</dt><dd><p>Direction for cepstrum calculation</p>
</dd>
</dl>
<dl class="simple">
<dt>ceps<span class="classifier">ndarray</span></dt><dd><p>Complex cepstrum result</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.acoustics.cepstrum.inverse_complex_cepstrum">
<span class="sig-prename descclassname"><span class="pre">cusignal.acoustics.cepstrum.</span></span><span class="sig-name descname"><span class="pre">inverse_complex_cepstrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ceps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndelay</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.acoustics.cepstrum.inverse_complex_cepstrum" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the inverse complex cepstrum of a real sequence.
ceps : ndarray</p>
<blockquote>
<div><p>Real sequence to compute inverse complex cepstrum of.</p>
</div></blockquote>
<dl class="simple">
<dt>ndelay: int</dt><dd><p>The amount of samples of circular delay added to <cite>x</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>x<span class="classifier">ndarray</span></dt><dd><p>The inverse complex cepstrum of the real sequence <cite>ceps</cite>.</p>
</dd>
</dl>
<p>The inverse complex cepstrum is given by
.. math:: x[n] = F^{-1}left{exp(F(c[n]))right}
where <span class="math notranslate nohighlight">\(c_[n]\)</span> is the input signal and <span class="math notranslate nohighlight">\(F\)</span> and :math:<a href="#id103"><span class="problematic" id="id104">`</span></a>F_{-1}
are respectively the forward and backward Fourier transform.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.acoustics.cepstrum.minimum_phase">
<span class="sig-prename descclassname"><span class="pre">cusignal.acoustics.cepstrum.</span></span><span class="sig-name descname"><span class="pre">minimum_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.acoustics.cepstrum.minimum_phase" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the minimum phase reconstruction of a real sequence.
x : ndarray</p>
<blockquote>
<div><p>Real sequence to compute the minimum phase reconstruction of.</p>
</div></blockquote>
<dl class="simple">
<dt>n<span class="classifier">{None, int}, optional</span></dt><dd><p>Length of the Fourier transform.</p>
</dd>
</dl>
<p>Compute the minimum phase reconstruction of a real sequence using the
real cepstrum.
Returns
&mdash;&mdash;-
m : ndarray</p>
<blockquote>
<div><p>The minimum phase reconstruction of the real sequence <cite>x</cite>.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.acoustics.cepstrum.real_cepstrum">
<span class="sig-prename descclassname"><span class="pre">cusignal.acoustics.cepstrum.</span></span><span class="sig-name descname"><span class="pre">real_cepstrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.acoustics.cepstrum.real_cepstrum" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the real cepstrum of an input sequence x where the cepstrum is
defined as the inverse Fourier transform of the log magnitude DFT
(spectrum) of a signal. It&rsquo;s primarily used for source/speaker separation
in speech signal processing</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>Input sequence, if x is a matrix, return cepstrum in direction of axis</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Size of Fourier Transform; If none, will use length of input array</p>
</dd>
<dt><strong>axis: int</strong></dt><dd><p>Direction for cepstrum calculation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ceps</strong><span class="classifier">ndarray</span></dt><dd><p>Complex cepstrum result</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="wavelets">
<h2>Wavelets<a class="headerlink" href="#wavelets" title="Permalink to this heading">#</a></h2>
<section id="id105">
<h3>Wavelets<a class="headerlink" href="#id105" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-cusignal.wavelets.wavelets"></span><dl class="py function">
<dt class="sig sig-object py" id="cusignal.wavelets.wavelets.cwt">
<span class="sig-prename descclassname"><span class="pre">cusignal.wavelets.wavelets.</span></span><span class="sig-name descname"><span class="pre">cwt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">widths</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.wavelets.wavelets.cwt" title="Permalink to this definition">#</a></dt>
<dd><p>Continuous wavelet transform.</p>
<p>Performs a continuous wavelet transform on <cite>data</cite>,
using the <cite>wavelet</cite> function. A CWT performs a convolution
with <cite>data</cite> using the <cite>wavelet</cite> function, which is characterized
by a width parameter and length parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N,) ndarray</span></dt><dd><p>data on which to perform the transform.</p>
</dd>
<dt><strong>wavelet</strong><span class="classifier">function</span></dt><dd><p>Wavelet function, which should take 2 arguments.
The first argument is the number of points that the returned vector
will have (len(wavelet(length,width)) == length).
The second is a width parameter, defining the size of the wavelet
(e.g. standard deviation of a gaussian). See <cite>ricker</cite>, which
satisfies these requirements.</p>
</dd>
<dt><strong>widths</strong><span class="classifier">(M,) sequence</span></dt><dd><p>Widths to use for transform.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>cwt: (M, N) ndarray</dt><dd><p>Will have shape of (len(widths), len(data)).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">width</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">cwt</span><span class="p">[</span><span class="n">ii</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wavelet</span><span class="p">(</span><span class="n">length</span><span class="p">,</span>
                            <span class="n">width</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'same'</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span>  <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">gausspulse</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">widths</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cwtmatr</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">cwt</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">ricker</span><span class="p">,</span> <span class="n">widths</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">cwtmatr</span><span class="p">)),</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">               cmap='PRGn', aspect='auto', vmax=abs(cwtmatr).max(),</span>
<span class="go">               vmin=-abs(cwtmatr).max())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.wavelets.wavelets.morlet">
<span class="sig-prename descclassname"><span class="pre">cusignal.wavelets.wavelets.</span></span><span class="sig-name descname"><span class="pre">morlet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.wavelets.wavelets.morlet" title="Permalink to this definition">#</a></dt>
<dd><p>Complex Morlet wavelet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Length of the wavelet.</p>
</dd>
<dt><strong>w</strong><span class="classifier">float, optional</span></dt><dd><p>Omega0. Default is 5</p>
</dd>
<dt><strong>s</strong><span class="classifier">float, optional</span></dt><dd><p>Scaling factor, windowed from <code class="docutils literal notranslate"><span class="pre">-s*2*pi</span></code> to <code class="docutils literal notranslate"><span class="pre">+s*2*pi</span></code>. Default is 1.</p>
</dd>
<dt><strong>complete</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to use the complete or the standard version.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>morlet</strong><span class="classifier">(M,) ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cusignal.gausspulse</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The standard version:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pi</span><span class="o">**-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>This commonly used wavelet is often referred to simply as the
Morlet wavelet.  Note that this simplified version can cause
admissibility problems at low values of <cite>w</cite>.</p>
<p>The complete version:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pi</span><span class="o">**-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>This version has a correction
term to improve admissibility. For <cite>w</cite> greater than 5, the
correction term is negligible.</p>
<p>Note that the energy of the return wavelet is not normalised
according to <cite>s</cite>.</p>
<p>The fundamental frequency of this wavelet in Hz is given
by <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">2*s*w*r</span> <span class="pre">/</span> <span class="pre">M</span></code> where <cite>r</cite> is the sampling rate.</p>
<p>Note: This function was created before <cite>cwt</cite> and is not compatible
with it.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.wavelets.wavelets.morlet2">
<span class="sig-prename descclassname"><span class="pre">cusignal.wavelets.wavelets.</span></span><span class="sig-name descname"><span class="pre">morlet2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.wavelets.wavelets.morlet2" title="Permalink to this definition">#</a></dt>
<dd><p>Complex Morlet wavelet, designed to work with <cite>cwt</cite>.
Returns the complete version of morlet wavelet, normalised
according to <cite>s</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>M<span class="classifier">int</span></dt><dd><p>Length of the wavelet.</p>
</dd>
<dt>s<span class="classifier">float</span></dt><dd><p>Width parameter of the wavelet.</p>
</dd>
<dt>w<span class="classifier">float, optional</span></dt><dd><p>Omega0. Default is 5</p>
</dd>
</dl>
<p>morlet : (M,) ndarray
See Also
&mdash;&mdash;&ndash;
morlet : Implementation of Morlet wavelet, incompatible with <cite>cwt</cite>
Notes
&mdash;&ndash;
.. versionadded:: 1.4.0
This function was designed to work with <cite>cwt</cite>. Because <cite>morlet2</cite>
returns an array of complex numbers, the <cite>dtype</cite> argument of <cite>cwt</cite>
should be set to <cite>complex128</cite> for best results.
Note the difference in implementation with <cite>morlet</cite>.
The fundamental frequency of this wavelet in Hz is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">fs</span></code> is the sampling rate and <cite>s</cite> is the wavelet width parameter.
Similarly we can get the wavelet width parameter at <code class="docutils literal notranslate"><span class="pre">f</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wavelet</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">morlet2</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">wavelet</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">This example shows basic use of `morlet2` with `cwt` in time-frequency</span>
<span class="go">analysis:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mf">6.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mi">50</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">40</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">widths</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">freq</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cwtm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">cwt</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">morlet2</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cwtm</span><span class="p">),</span>
<span class="go">    cmap='viridis', shading='gouraud')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.wavelets.wavelets.qmf">
<span class="sig-prename descclassname"><span class="pre">cusignal.wavelets.wavelets.</span></span><span class="sig-name descname"><span class="pre">qmf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hk</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.wavelets.wavelets.qmf" title="Permalink to this definition">#</a></dt>
<dd><p>Return high-pass qmf filter from low-pass</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hk</strong><span class="classifier">array_like</span></dt><dd><p>Coefficients of high-pass filter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.wavelets.wavelets.ricker">
<span class="sig-prename descclassname"><span class="pre">cusignal.wavelets.wavelets.</span></span><span class="sig-name descname"><span class="pre">ricker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.wavelets.wavelets.ricker" title="Permalink to this definition">#</a></dt>
<dd><p>Return a Ricker wavelet, also known as the &ldquo;Mexican hat wavelet&rdquo;.</p>
<p>It models the function:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">(1</span> <span class="pre">-</span> <span class="pre">x^2/a^2)</span> <span class="pre">exp(-x^2/2</span> <span class="pre">a^2)</span></code>,</p>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">2/sqrt(3a)pi^1/4</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">int</span></dt><dd><p>Number of points in <cite>vector</cite>.
Will be centered around 0.</p>
</dd>
<dt><strong>a</strong><span class="classifier">scalar</span></dt><dd><p>Width parameter of the wavelet.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vector</strong><span class="classifier">(N,) ndarray</span></dt><dd><p>Array of length <cite>points</cite> in shape of ricker curve.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cusignal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec2</span> <span class="o">=</span> <span class="n">cusignal</span><span class="o">.</span><span class="n">ricker</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vec2</span><span class="p">))</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">vec2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="b-splines">
<h2>B-splines<a class="headerlink" href="#b-splines" title="Permalink to this heading">#</a></h2>
<section id="id106">
<h3>B-splines<a class="headerlink" href="#id106" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-cusignal.bsplines.bsplines"></span><dl class="py function">
<dt class="sig sig-object py" id="cusignal.bsplines.bsplines.cubic">
<span class="sig-prename descclassname"><span class="pre">cusignal.bsplines.bsplines.</span></span><span class="sig-name descname"><span class="pre">cubic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.bsplines.bsplines.cubic" title="Permalink to this definition">#</a></dt>
<dd><p>A cubic B-spline.</p>
<p>This is a special case of <cite>bspline</cite>, and equivalent to <code class="docutils literal notranslate"><span class="pre">bspline(x,</span> <span class="pre">3)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.bsplines.bsplines.gauss_spline">
<span class="sig-prename descclassname"><span class="pre">cusignal.bsplines.bsplines.</span></span><span class="sig-name descname"><span class="pre">gauss_spline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.bsplines.bsplines.gauss_spline" title="Permalink to this definition">#</a></dt>
<dd><p>Gaussian approximation to B-spline basis function of order n.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The order of the spline. Must be nonnegative, i.e. n &gt;= 0</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd02af954a573-1"><span class="brackets">1</span></dt>
<dd><p>Bouma H., Vilanova A., Bescos J.O., ter Haar Romeny B.M., Gerritsen
F.A. (2007) Fast and Accurate Gaussian Derivatives Based on B-Splines.
In: Sgallari F., Murli A., Paragios N. (eds) Scale Space and Variational
Methods in Computer Vision. SSVM 2007. Lecture Notes in Computer
Science, vol 4485. Springer, Berlin, Heidelberg</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.bsplines.bsplines.quadratic">
<span class="sig-prename descclassname"><span class="pre">cusignal.bsplines.bsplines.</span></span><span class="sig-name descname"><span class="pre">quadratic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.bsplines.bsplines.quadratic" title="Permalink to this definition">#</a></dt>
<dd><p>A quadratic B-spline.</p>
<p>This is a special case of <cite>bspline</cite>, and equivalent to <code class="docutils literal notranslate"><span class="pre">bspline(x,</span> <span class="pre">2)</span></code>.</p>
</dd></dl>

</section>
</section>
<section id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this heading">#</a></h2>
<section id="module-cusignal.utils.arraytools">
<span id="array-tools"></span><h3>Array Tools<a class="headerlink" href="#module-cusignal.utils.arraytools" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.utils.arraytools.from_pycuda">
<span class="sig-prename descclassname"><span class="pre">cusignal.utils.arraytools.</span></span><span class="sig-name descname"><span class="pre">from_pycuda</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pycuda_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.utils.arraytools.from_pycuda" title="Permalink to this definition">#</a></dt>
<dd><p>Read in gpuarray from PyCUDA and output CuPy array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pycuda_arr</strong><span class="classifier">PyCUDA gpuarray</span></dt><dd></dd>
<dt><strong>device</strong><span class="classifier">int</span></dt><dd><p>GPU Device ID</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cupy_arr</strong><span class="classifier">CuPy ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.utils.arraytools.get_pinned_array">
<span class="sig-prename descclassname"><span class="pre">cusignal.utils.arraytools.</span></span><span class="sig-name descname"><span class="pre">get_pinned_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.utils.arraytools.get_pinned_array" title="Permalink to this definition">#</a></dt>
<dd><p>Return populated pinned memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>The array to be copied to shared buffer</p>
</dd>
<dt><strong>strides: int or None</strong></dt><dd></dd>
<dt><strong>order: char</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.utils.arraytools.get_pinned_mem">
<span class="sig-prename descclassname"><span class="pre">cusignal.utils.arraytools.</span></span><span class="sig-name descname"><span class="pre">get_pinned_mem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.utils.arraytools.get_pinned_mem" title="Permalink to this definition">#</a></dt>
<dd><p>Create a pinned memory allocation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">int or tuple of ints</span></dt><dd><p>Output shape.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>Output data type.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ret</strong><span class="classifier">ndarray</span></dt><dd><p>Pinned memory numpy array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.utils.arraytools.get_shared_array">
<span class="sig-prename descclassname"><span class="pre">cusignal.utils.arraytools.</span></span><span class="sig-name descname"><span class="pre">get_shared_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stream</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">portable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.utils.arraytools.get_shared_array" title="Permalink to this definition">#</a></dt>
<dd><p>Return populated shared memory between GPU and CPU.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>The array to be copied to shared buffer</p>
</dd>
<dt><strong>strides: int or None</strong></dt><dd></dd>
<dt><strong>order: char</strong></dt><dd></dd>
<dt><strong>stream</strong><span class="classifier">int</span></dt><dd><p>Stream number (0 for default)</p>
</dd>
<dt><strong>portable</strong><span class="classifier">bool</span></dt><dd></dd>
<dt><strong>wc</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.utils.arraytools.get_shared_mem">
<span class="sig-prename descclassname"><span class="pre">cusignal.utils.arraytools.</span></span><span class="sig-name descname"><span class="pre">get_shared_mem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order='C'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stream=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">portable=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wc=True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.utils.arraytools.get_shared_mem" title="Permalink to this definition">#</a></dt>
<dd><p>Return shared memory between GPU and CPU. Similar to numpy.zeros</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">ndarray.shape</span></dt><dd><p>Size of shared memory allocation</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">cupy.dtype or numpy.dtype</span></dt><dd><p>Data type of allocation</p>
</dd>
<dt><strong>strides: int or None</strong></dt><dd></dd>
<dt><strong>order: char</strong></dt><dd></dd>
<dt><strong>stream</strong><span class="classifier">int</span></dt><dd><p>Stream number (0 for default)</p>
</dd>
<dt><strong>portable</strong><span class="classifier">bool</span></dt><dd></dd>
<dt><strong>wc</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="fftpack-helper">
<h3>FFTPack Helper<a class="headerlink" href="#fftpack-helper" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-cusignal.utils.fftpack_helper"></span><dl class="py function">
<dt class="sig sig-object py" id="cusignal.utils.fftpack_helper.next_fast_len">
<span class="sig-prename descclassname"><span class="pre">cusignal.utils.fftpack_helper.</span></span><span class="sig-name descname"><span class="pre">next_fast_len</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.utils.fftpack_helper.next_fast_len" title="Permalink to this definition">#</a></dt>
<dd><p>Find the next fast size of input data to <cite>fft</cite>, for zero-padding, etc.</p>
<p>SciPy&rsquo;s FFTPACK has efficient functions for radix {2, 3, 4, 5}, so this
returns the next composite of the prime factors 2, 3, and 5 which is
greater than or equal to <cite>target</cite>. (These are also known as 5-smooth
numbers, regular numbers, or Hamming numbers.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target</strong><span class="classifier">int</span></dt><dd><p>Length to start searching from.  Must be a positive integer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">int</span></dt><dd><p>The first 5-smooth number greater than or equal to <cite>target</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.0.</span></p>
</div>
<p class="rubric">Examples</p>
<p>On a particular machine, an FFT of prime length takes 133 ms:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">fftpack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_len</span> <span class="o">=</span> <span class="mi">10007</span>  <span class="c1"># prime length is worst case for speed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">min_len</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Zero-padding to the next 5-smooth length reduces computation time to
211 us, a speedup of 630 times:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fftpack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="n">min_len</span><span class="p">)</span>
<span class="go">10125</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10125</span><span class="p">)</span>
</pre></div>
</div>
<p>Rounding up to the next power of 2 is not optimal, taking 367 us to
compute, 1.7 times as long as the 5-smooth size:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">16384</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="io">
<h2>IO<a class="headerlink" href="#io" title="Permalink to this heading">#</a></h2>
<section id="module-cusignal.io.reader">
<span id="reader"></span><h3>Reader<a class="headerlink" href="#module-cusignal.io.reader" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.io.reader.read_bin">
<span class="sig-prename descclassname"><span class="pre">cusignal.io.reader.</span></span><span class="sig-name descname"><span class="pre">read_bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset=0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.io.reader.read_bin" title="Permalink to this definition">#</a></dt>
<dd><p>Reads binary file into GPU memory.
Can be used as a building blocks for custom unpack/pack
data readers/writers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file</strong><span class="classifier">str</span></dt><dd><p>A string of filename to be read to GPU.</p>
</dd>
<dt><strong>buffer</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Pinned memory buffer to use when copying data from GPU.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Any object that can be interpreted as a numpy data type.</p>
</dd>
<dt><strong>num_samples</strong><span class="classifier">int, optional</span></dt><dd><p>Number of samples to be loaded to GPU. If set to 0,
read in all samples.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int, optional</span></dt><dd><p>In the file, array data starts at this offset.
Since offset is measured in bytes, it should normally
be a multiple of the byte-size of dtype.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>&mdash;&mdash;-</strong></dt><dd></dd>
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>An 1-dimensional array containing binary data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.io.reader.read_sigmf">
<span class="sig-prename descclassname"><span class="pre">cusignal.io.reader.</span></span><span class="sig-name descname"><span class="pre">read_sigmf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.io.reader.read_sigmf" title="Permalink to this definition">#</a></dt>
<dd><p>Read and unpack binary file, with SigMF spec, to GPU memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_file</strong><span class="classifier">str</span></dt><dd><p>File contain sigmf data.</p>
</dd>
<dt><strong>meta_file</strong><span class="classifier">str, optional</span></dt><dd><p>File contain sigmf meta.</p>
</dd>
<dt><strong>buffer</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Pinned memory buffer to use when copying data from GPU.</p>
</dd>
<dt><strong>num_samples</strong><span class="classifier">int, optional</span></dt><dd><p>Number of samples to be loaded to GPU. If set to 0,
read in all samples.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int, optional</span></dt><dd><p>May be specified as a non-negative integer offset.
It is the number of samples before loading &lsquo;num_samples&rsquo;.
&lsquo;offset&rsquo; must be a multiple of ALLOCATIONGRANULARITY which
is equal to PAGESIZE on Unix systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>An 1-dimensional array containing unpacked binary data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.io.reader.unpack_bin">
<span class="sig-prename descclassname"><span class="pre">cusignal.io.reader.</span></span><span class="sig-name descname"><span class="pre">unpack_bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endianness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.io.reader.unpack_bin" title="Permalink to this definition">#</a></dt>
<dd><p>Unpack binary file.
If endianness is big-endian, it my be converted
to little endian for NVIDIA GPU compatibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>binary</strong><span class="classifier">ndarray</span></dt><dd><p>The binary array to be unpack.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>Any object that can be interpreted as a numpy data type.</p>
</dd>
<dt><strong>endianness</strong><span class="classifier">{&lsquo;L&rsquo;, &lsquo;B&rsquo;}, optional</span></dt><dd><p>Data set byte order</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>An 1-dimensional array containing unpacked binary data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cusignal.io.writer">
<span id="writer"></span><h3>Writer<a class="headerlink" href="#module-cusignal.io.writer" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.io.writer.pack_bin">
<span class="sig-prename descclassname"><span class="pre">cusignal.io.writer.</span></span><span class="sig-name descname"><span class="pre">pack_bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.io.writer.pack_bin" title="Permalink to this definition">#</a></dt>
<dd><p>Pack binary arrary.
Data will be packed with little endian for NVIDIA GPU compatibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>in1</strong><span class="classifier">ndarray</span></dt><dd><p>The ndarray to be pack at binary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>An 1-dimensional array containing packed binary data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.io.writer.write_bin">
<span class="sig-prename descclassname"><span class="pre">cusignal.io.writer.</span></span><span class="sig-name descname"><span class="pre">write_bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">append</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.io.writer.write_bin" title="Permalink to this definition">#</a></dt>
<dd><p>Writes binary array to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file</strong><span class="classifier">str</span></dt><dd><p>A string of filename to store output.</p>
</dd>
<dt><strong>binary</strong><span class="classifier">ndarray</span></dt><dd><p>Binary array to be written to file.</p>
</dd>
<dt><strong>buffer</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Pinned memory buffer to use when copying data from GPU.</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool, optional</span></dt><dd><p>Append to file if created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>An 1-dimensional array containing binary data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.io.writer.write_sigmf">
<span class="sig-prename descclassname"><span class="pre">cusignal.io.writer.</span></span><span class="sig-name descname"><span class="pre">write_sigmf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">append</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.io.writer.write_sigmf" title="Permalink to this definition">#</a></dt>
<dd><p>Pack and write binary array to file, with SigMF spec.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file</strong><span class="classifier">str</span></dt><dd><p>A string of filename to be read/unpacked to GPU.</p>
</dd>
<dt><strong>binary</strong><span class="classifier">ndarray</span></dt><dd><p>Binary array to be written to file.</p>
</dd>
<dt><strong>buffer</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Pinned memory buffer to use when copying data from GPU.</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool, optional</span></dt><dd><p>Append to file if created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"></dd>
</dl>
</dd></dl>

</section>
</section>
<section id="radar-phased-array">
<h2>Radar/Phased Array<a class="headerlink" href="#radar-phased-array" title="Permalink to this heading">#</a></h2>
<section id="module-cusignal.radartools.radartools">
<span id="radar-tools"></span><h3>Radar Tools<a class="headerlink" href="#module-cusignal.radartools.radartools" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cusignal.radartools.radartools.ambgfun">
<span class="sig-prename descclassname"><span class="pre">cusignal.radartools.radartools.</span></span><span class="sig-name descname"><span class="pre">ambgfun</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutValue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.radartools.radartools.ambgfun" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the normalized ambiguity function for the vector x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>Input pulse waveform</p>
</dd>
<dt><strong>fs: int, float</strong></dt><dd><p>Sampling rate in Hz</p>
</dd>
<dt><strong>prf: int, float</strong></dt><dd><p>Pulse repetition frequency in Hz</p>
</dd>
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>Second input pulse waveform. If not given, y = x</p>
</dd>
<dt><strong>cut</strong><span class="classifier">string</span></dt><dd><p>Direction of one-dimensional cut through ambiguity function</p>
</dd>
<dt><strong>cutValue</strong><span class="classifier">int, float</span></dt><dd><p>Time delay or doppler shift at which one-dimensional cut
through ambiguity function is taken</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>amfun</strong><span class="classifier">ndarray</span></dt><dd><p>Normalized magnitude of the ambiguity function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.radartools.radartools.ca_cfar">
<span class="sig-prename descclassname"><span class="pre">cusignal.radartools.radartools.</span></span><span class="sig-name descname"><span class="pre">ca_cfar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guard_cells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_cells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pfa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.radartools.radartools.ca_cfar" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the cell-averaged constant false alarm rate (CA CFAR) detector
threshold and returns for a given array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing data to be processed.</p>
</dd>
<dt><strong>guard_cells_x</strong><span class="classifier">int</span></dt><dd><p>One-sided guard cell count in the first dimension.</p>
</dd>
<dt><strong>guard_cells_y</strong><span class="classifier">int</span></dt><dd><p>One-sided guard cell count in the second dimension.</p>
</dd>
<dt><strong>reference_cells_x</strong><span class="classifier">int</span></dt><dd><p>one-sided reference cell count in the first dimension.</p>
</dd>
<dt><strong>reference_cells_y</strong><span class="classifier">int</span></dt><dd><p>one-sided referenc cell count in the second dimension.</p>
</dd>
<dt><strong>pfa</strong><span class="classifier">float</span></dt><dd><p>Probability of false alarm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">ndarray</span></dt><dd><p>CFAR threshold</p>
</dd>
<dt><strong>return</strong><span class="classifier">ndarray</span></dt><dd><p>CFAR detections</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.radartools.radartools.cfar_alpha">
<span class="sig-prename descclassname"><span class="pre">cusignal.radartools.radartools.</span></span><span class="sig-name descname"><span class="pre">cfar_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pfa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.radartools.radartools.cfar_alpha" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the value of alpha corresponding to a given probability
of false alarm and number of reference cells N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pfa</strong><span class="classifier">float</span></dt><dd><p>Probability of false alarm.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of reference cells.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Alpha value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.radartools.radartools.pulse_compression">
<span class="sig-prename descclassname"><span class="pre">cusignal.radartools.radartools.</span></span><span class="sig-name descname"><span class="pre">pulse_compression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.radartools.radartools.pulse_compression" title="Permalink to this definition">#</a></dt>
<dd><p>Pulse Compression is used to increase the range resolution and SNR
by performing matched filtering of the transmitted pulse (template)
with the received signal (x)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>Received signal, assume 2D array with [num_pulses, sample_per_pulse]</p>
</dd>
<dt><strong>template</strong><span class="classifier">ndarray</span></dt><dd><p>Transmitted signal, assume 1D array</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>Normalize transmitted signal</p>
</dd>
<dt><strong>window</strong><span class="classifier">array_like, callable, string, float, or tuple, optional</span></dt><dd><p>Specifies the window applied to the signal in the Fourier
domain.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, size of FFT for pulse compression. Default is number of</span></dt><dd><p>samples per pulse</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>compressedIQ</strong><span class="classifier">ndarray</span></dt><dd><p>Pulse compressed output</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cusignal.radartools.radartools.pulse_doppler">
<span class="sig-prename descclassname"><span class="pre">cusignal.radartools.radartools.</span></span><span class="sig-name descname"><span class="pre">pulse_doppler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.radartools.radartools.pulse_doppler" title="Permalink to this definition">#</a></dt>
<dd><p>Pulse doppler processing yields a range/doppler data matrix that represents
moving target data that&rsquo;s separated from clutter. An estimation of the
doppler shift can also be obtained from pulse doppler processing. FFT taken
across slow-time (pulse) dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>Received signal, assume 2D array with [num_pulses, sample_per_pulse]</p>
</dd>
<dt><strong>window</strong><span class="classifier">array_like, callable, string, float, or tuple, optional</span></dt><dd><p>Specifies the window applied to the signal in the Fourier
domain.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, size of FFT for pulse compression. Default is number of</span></dt><dd><p>samples per pulse</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pd_dataMatrix</strong><span class="classifier">ndarray</span></dt><dd><p>Pulse-doppler output (range/doppler matrix)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-cusignal.radartools.beamformers"></span><dl class="py function">
<dt class="sig sig-object py" id="cusignal.radartools.beamformers.mvdr">
<span class="sig-prename descclassname"><span class="pre">cusignal.radartools.beamformers.</span></span><span class="sig-name descname"><span class="pre">mvdr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.radartools.beamformers.mvdr" title="Permalink to this definition">#</a></dt>
<dd><p>Minimum variance distortionless response (MVDR) beamformer weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>Received signal or input covariance matrix, assume 2D array with
size [num_sensors, num_samples]</p>
</dd>
<dt><strong>sv: ndarray</strong></dt><dd><p>Steering vector, assume 1D array with size [num_sensors, 1]</p>
</dd>
<dt><strong>calc_cov</strong><span class="classifier">bool</span></dt><dd><p>Determine whether to calculate covariance matrix. Simply put, calc_cov
defines whether x input is made of sensor/observation data or is
a precalculated covariance matrix</p>
</dd>
<dt><strong>Note: Unlike MATLAB where input matrix x is of size MxN where N represents</strong></dt><dd></dd>
<dt><strong>the number of array elements, we assume row-major formatted data where each</strong></dt><dd></dd>
<dt><strong>row is assumed to be complex-valued data from a given sensor (i.e. NxM)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
  <a class="left-prev" href="index.html" id="prev-link" title="previous page">
      <i class="fas fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Welcome to cusignal&rsquo;s documentation!</p>
      </div>
  </a>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2019-2020, NVIDIA.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.1.1.<br>
</p>
  </div>
  
</div>
</footer>
  
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>