

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cuSignal API Reference &mdash; cusignal 0.12.0a documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/params.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to cusignal’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cusignal
          

          
          </a>

          
            
            
              <div class="version">
                0.12
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">cuSignal API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#signal-tools">Signal Tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Signal Tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cusignal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>cuSignal API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cusignal-api-reference">
<h1>cuSignal API Reference<a class="headerlink" href="#cusignal-api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="signal-tools">
<h2>Signal Tools<a class="headerlink" href="#signal-tools" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Signal Tools<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-cusignal.signaltools"></span><dl class="function">
<dt id="cusignal.signaltools.choose_conv_method">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">choose_conv_method</code><span class="sig-paren">(</span><em class="sig-param">in1</em>, <em class="sig-param">in2</em>, <em class="sig-param">mode='full'</em>, <em class="sig-param">measure=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.choose_conv_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the fastest convolution/correlation method.</p>
<p>This primarily exists to be called during the <code class="docutils literal notranslate"><span class="pre">method='auto'</span></code> option in
<cite>convolve</cite> and <cite>correlate</cite>, but can also be used when performing many
convolutions of the same input shapes and dtypes, determining
which method to use for all of them, either to avoid the overhead of the
‘auto’ option or to use accurate real-world measurements.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>The first argument passed into the convolution function.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>The second argument passed into the convolution function.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {‘full’, ‘valid’, ‘same’}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the ‘full’ output.</p>
</dd>
</dl>
</dd>
<dt><strong>measure</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, run and time the convolution of <cite>in1</cite> and <cite>in2</cite> with both
methods and return the fastest. If False (default), predict the fastest
method using precomputed values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>A string indicating which convolution method is fastest, either
‘direct’ or ‘fft’</p>
</dd>
<dt><strong>times</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary containing the times (in seconds) needed for each method.
This value is only returned if <code class="docutils literal notranslate"><span class="pre">measure=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.signaltools.convolve" title="cusignal.signaltools.convolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cusignal.signaltools.correlate" title="cusignal.signaltools.correlate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlate</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For large n, <code class="docutils literal notranslate"><span class="pre">measure=False</span></code> is accurate and can quickly determine the
fastest method to perform the convolution.  However, this is not as
accurate for small n (when any dimension in the input or output is small).</p>
<p>In practice, we found that this function estimates the faster method up to
a multiplicative factor of 5 (i.e., the estimated method is <em>at most</em> 5
times slower than the fastest method). The estimation values were tuned on
an early 2015 MacBook Pro with 8GB RAM but we found that the prediction
held <em>fairly</em> accurately across different machines.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">measure=True</span></code>, time the convolutions. Because this function uses
<cite>fftconvolve</cite>, an error will be thrown if it does not support the inputs.
There are cases when <cite>fftconvolve</cite> supports the inputs but this function
returns <cite>direct</cite> (e.g., to protect against floating point integer
precision).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19.</span></p>
</div>
<p class="rubric">Examples</p>
<p>Estimate the fastest method for a given input:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">method</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">choose_conv_method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">method</span>
<span class="go">&#39;fft&#39;</span>
</pre></div>
</div>
<p>This can then be applied to other arrays of the same dtype and shape:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># `method` works with correlate and convolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr1</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr2</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv1</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv2</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.cmplx_sort">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">cmplx_sort</code><span class="sig-paren">(</span><em class="sig-param">p</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.cmplx_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort roots based on magnitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">array_like</span></dt><dd><p>The roots to sort, as a 1-D array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p_sorted</strong><span class="classifier">ndarray</span></dt><dd><p>Sorted roots.</p>
</dd>
<dt><strong>indx</strong><span class="classifier">ndarray</span></dt><dd><p>Array of indices needed to sort the input <cite>p</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_sorted</span><span class="p">,</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">cmplx_sort</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_sorted</span>
<span class="go">array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span>
<span class="go">array([0, 2, 3, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.convolve">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">convolve</code><span class="sig-paren">(</span><em class="sig-param">in1</em>, <em class="sig-param">in2</em>, <em class="sig-param">mode='full'</em>, <em class="sig-param">method='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve two N-dimensional arrays.</p>
<p>Convolve <cite>in1</cite> and <cite>in2</cite>, with the output size determined by the
<cite>mode</cite> argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {‘full’, ‘valid’, ‘same’}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In ‘valid’ mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the ‘full’ output.</p>
</dd>
</dl>
</dd>
<dt><strong>method</strong><span class="classifier">str {‘auto’, ‘direct’, ‘fft’}, optional</span></dt><dd><p>A string indicating which method to use to calculate the convolution.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">direct</span></code></dt><dd><p>The convolution is determined directly from sums, the definition of
convolution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fft</span></code></dt><dd><p>The Fourier Transform is used to perform the convolution by calling
<cite>fftconvolve</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto</span></code></dt><dd><p>Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See Notes for more detail.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>convolve</strong><span class="classifier">array</span></dt><dd><p>An N-dimensional array containing a subset of the discrete linear
convolution of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.polymul</span></code></dt><dd><p>performs polynomial multiplication (same operation, but also accepts poly1d objects)</p>
</dd>
<dt><a class="reference internal" href="#cusignal.signaltools.choose_conv_method" title="cusignal.signaltools.choose_conv_method"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose_conv_method</span></code></a></dt><dd><p>chooses the fastest appropriate convolution method</p>
</dd>
<dt><a class="reference internal" href="#cusignal.signaltools.fftconvolve" title="cusignal.signaltools.fftconvolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftconvolve</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>By default, <cite>convolve</cite> and <cite>correlate</cite> use <code class="docutils literal notranslate"><span class="pre">method='auto'</span></code>, which calls
<cite>choose_conv_method</cite> to choose the fastest method using pre-computed
values (<cite>choose_conv_method</cite> can also measure real-world timing with a
keyword argument). Because <cite>fftconvolve</cite> relies on floating point numbers,
there are certain constraints that may force <cite>method=direct</cite> (more detail
in <cite>choose_conv_method</cite> docstring).</p>
<p class="rubric">Examples</p>
<p>Smooth a square pulse using a Hann window:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">win</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_win</span><span class="p">,</span> <span class="n">ax_filt</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original pulse&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_win</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_win</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Filter impulse response&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_win</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_filt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">filtered</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_filt</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Filtered signal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_filt</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.convolve2d">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">convolve2d</code><span class="sig-paren">(</span><em class="sig-param">in1</em>, <em class="sig-param">in2</em>, <em class="sig-param">mode='full'</em>, <em class="sig-param">boundary='fill'</em>, <em class="sig-param">fillvalue=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.convolve2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve two 2-dimensional arrays.
Convolve <cite>in1</cite> and <cite>in2</cite> with output size determined by <cite>mode</cite>, and
boundary conditions determined by <cite>boundary</cite> and <cite>fillvalue</cite>.
Parameters
———-
in1 : array_like</p>
<blockquote>
<div><p>First input.</p>
</div></blockquote>
<dl>
<dt>in2<span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt>mode<span class="classifier">str {‘full’, ‘valid’, ‘same’}, optional</span></dt><dd><p>A string indicating the size of the output:
<code class="docutils literal notranslate"><span class="pre">full</span></code></p>
<blockquote>
<div><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In ‘valid’ mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the ‘full’ output.</p>
</dd>
</dl>
</dd>
<dt>boundary<span class="classifier">str {‘fill’, ‘wrap’, ‘symm’}, optional</span></dt><dd><p>A flag indicating how to handle boundaries:
<code class="docutils literal notranslate"><span class="pre">fill</span></code></p>
<blockquote>
<div><p>pad input arrays with fillvalue. (default)</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wrap</span></code></dt><dd><p>circular boundary conditions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symm</span></code></dt><dd><p>symmetrical boundary conditions.</p>
</dd>
</dl>
</dd>
<dt>fillvalue<span class="classifier">scalar, optional</span></dt><dd><p>Value to fill pad input arrays with. Default is 0.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array containing a subset of the discrete linear
convolution of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
<p>Compute the gradient of an image by 2D convolution with a complex Scharr
operator.  (Horizontal operator is real, vertical is imaginary.)  Use
symmetric boundary condition to avoid creating edges at the image
boundaries.
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; ascent = misc.ascent()
&gt;&gt;&gt; scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],
…                    [-10+0j, 0+ 0j, +10 +0j],
…                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy
&gt;&gt;&gt; grad = signal.convolve2d(ascent, scharr, boundary=’symm’, mode=’same’)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(3, 1, figsize=(6, 15))
&gt;&gt;&gt; ax_orig.imshow(ascent, cmap=’gray’)
&gt;&gt;&gt; ax_orig.set_title(‘Original’)
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_mag.imshow(np.absolute(grad), cmap=’gray’)
&gt;&gt;&gt; ax_mag.set_title(‘Gradient magnitude’)
&gt;&gt;&gt; ax_mag.set_axis_off()
&gt;&gt;&gt; ax_ang.imshow(np.angle(grad), cmap=’hsv’) # hsv is cyclic, like angles
&gt;&gt;&gt; ax_ang.set_title(‘Gradient orientation’)
&gt;&gt;&gt; ax_ang.set_axis_off()
&gt;&gt;&gt; fig.show()</p>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.correlate">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">correlate</code><span class="sig-paren">(</span><em class="sig-param">in1</em>, <em class="sig-param">in2</em>, <em class="sig-param">mode='full'</em>, <em class="sig-param">method='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.correlate" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross-correlate two N-dimensional arrays.</p>
<p>Cross-correlate <cite>in1</cite> and <cite>in2</cite>, with the output size determined by the
<cite>mode</cite> argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {‘full’, ‘valid’, ‘same’}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear cross-correlation
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In ‘valid’ mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the ‘full’ output.</p>
</dd>
</dl>
</dd>
<dt><strong>method</strong><span class="classifier">str {‘auto’, ‘direct’, ‘fft’}, optional</span></dt><dd><p>A string indicating which method to use to calculate the correlation.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">direct</span></code></dt><dd><p>The correlation is determined directly from sums, the definition of
correlation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fft</span></code></dt><dd><p>The Fast Fourier Transform is used to perform the correlation more
quickly (only available for numerical arrays.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto</span></code></dt><dd><p>Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See <cite>convolve</cite> Notes for more detail.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>correlate</strong><span class="classifier">array</span></dt><dd><p>An N-dimensional array containing a subset of the discrete linear
cross-correlation of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cusignal.signaltools.choose_conv_method" title="cusignal.signaltools.choose_conv_method"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose_conv_method</span></code></a></dt><dd><p>contains more documentation on <cite>method</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The correlation z of two d-dimensional arrays x and y is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">z</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span>
    <span class="nb">sum</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i_l</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i_l</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">conj</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i_l</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>This way, if x and y are 1-D arrays and <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">correlate(x,</span> <span class="pre">y,</span> <span class="pre">'full')</span></code>
then</p>
<div class="math notranslate nohighlight">
\[z[k] = (x * y)(k - N + 1)
     = \sum_{l=0}^{||x||-1}x_l y_{l-k+N-1}^{*}\]</div>
<p>for <span class="math notranslate nohighlight">\(k = 0, 1, ..., ||x|| + ||y|| - 2\)</span></p>
<p>where <span class="math notranslate nohighlight">\(||x||\)</span> is the length of <code class="docutils literal notranslate"><span class="pre">x</span></code>, <span class="math notranslate nohighlight">\(N = \max(||x||,||y||)\)</span>,
and <span class="math notranslate nohighlight">\(y_m\)</span> is 0 when m is outside the range of y.</p>
<p><code class="docutils literal notranslate"><span class="pre">method='fft'</span></code> only works for numerical arrays as it relies on
<cite>fftconvolve</cite>. In certain cases (i.e., arrays of objects or when
rounding integers can lose precision), <code class="docutils literal notranslate"><span class="pre">method='direct'</span></code> is always used.</p>
<p class="rubric">Examples</p>
<p>Implement a matched filter using cross-correlation, to recover a signal
that has passed through a noisy channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig_noise</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">sig_noise</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">),</span> <span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_noise</span><span class="p">,</span> <span class="n">ax_corr</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="n">clock</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original signal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_noise</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sig_noise</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_noise</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Signal with noise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_corr</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_corr</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">corr</span><span class="p">[</span><span class="n">clock</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_corr</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_corr</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cross-correlated with rectangular pulse&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.correlate2d">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">correlate2d</code><span class="sig-paren">(</span><em class="sig-param">in1</em>, <em class="sig-param">in2</em>, <em class="sig-param">mode='full'</em>, <em class="sig-param">boundary='fill'</em>, <em class="sig-param">fillvalue=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.correlate2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross-correlate two 2-dimensional arrays.
Cross correlate <cite>in1</cite> and <cite>in2</cite> with output size determined by <cite>mode</cite>, and
boundary conditions determined by <cite>boundary</cite> and <cite>fillvalue</cite>.
Parameters
———-
in1 : array_like</p>
<blockquote>
<div><p>First input.</p>
</div></blockquote>
<dl>
<dt>in2<span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt>mode<span class="classifier">str {‘full’, ‘valid’, ‘same’}, optional</span></dt><dd><p>A string indicating the size of the output:
<code class="docutils literal notranslate"><span class="pre">full</span></code></p>
<blockquote>
<div><p>The output is the full discrete linear cross-correlation
of the inputs. (Default)</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In ‘valid’ mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the ‘full’ output.</p>
</dd>
</dl>
</dd>
<dt>boundary<span class="classifier">str {‘fill’, ‘wrap’, ‘symm’}, optional</span></dt><dd><p>A flag indicating how to handle boundaries:
<code class="docutils literal notranslate"><span class="pre">fill</span></code></p>
<blockquote>
<div><p>pad input arrays with fillvalue. (default)</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wrap</span></code></dt><dd><p>circular boundary conditions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symm</span></code></dt><dd><p>symmetrical boundary conditions.</p>
</dd>
</dl>
</dd>
<dt>fillvalue<span class="classifier">scalar, optional</span></dt><dd><p>Value to fill pad input arrays with. Default is 0.</p>
</dd>
</dl>
<dl class="simple">
<dt>correlate2d<span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array containing a subset of the discrete linear
cross-correlation of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
<p>Use 2D cross-correlation to find the location of a template in a noisy
image:
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; face = misc.face(gray=True) - misc.face(gray=True).mean()
&gt;&gt;&gt; template = np.copy(face[300:365, 670:750])  # right eye
&gt;&gt;&gt; template -= template.mean()
&gt;&gt;&gt; face = face + np.random.randn(<a href="#id2"><span class="problematic" id="id3">*</span></a>face.shape) * 50  # add noise
&gt;&gt;&gt; corr = signal.correlate2d(face, template, boundary=’symm’, mode=’same’)
&gt;&gt;&gt; y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_template, ax_corr) = plt.subplots(3, 1,
…                                                     figsize=(6, 15))
&gt;&gt;&gt; ax_orig.imshow(face, cmap=’gray’)
&gt;&gt;&gt; ax_orig.set_title(‘Original’)
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_template.imshow(template, cmap=’gray’)
&gt;&gt;&gt; ax_template.set_title(‘Template’)
&gt;&gt;&gt; ax_template.set_axis_off()
&gt;&gt;&gt; ax_corr.imshow(corr, cmap=’gray’)
&gt;&gt;&gt; ax_corr.set_title(‘Cross-correlation’)
&gt;&gt;&gt; ax_corr.set_axis_off()
&gt;&gt;&gt; ax_orig.plot(x, y, ‘ro’)
&gt;&gt;&gt; fig.show()</p>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.detrend">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">detrend</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">type='linear'</em>, <em class="sig-param">bp=0</em>, <em class="sig-param">overwrite_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove linear trend along axis from data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>The input data.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis along which to detrend the data. By default this is the
last axis (-1).</p>
</dd>
<dt><strong>type</strong><span class="classifier">{‘linear’, ‘constant’}, optional</span></dt><dd><p>The type of detrending. If <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">==</span> <span class="pre">'linear'</span></code> (default),
the result of a linear least-squares fit to <cite>data</cite> is subtracted
from <cite>data</cite>.
If <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">==</span> <span class="pre">'constant'</span></code>, only the mean of <cite>data</cite> is subtracted.</p>
</dd>
<dt><strong>bp</strong><span class="classifier">array_like of ints, optional</span></dt><dd><p>A sequence of break points. If given, an individual linear fit is
performed for each part of <cite>data</cite> between two break points.
Break points are specified as indices into <cite>data</cite>.</p>
</dd>
<dt><strong>overwrite_data</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, perform in place detrending and avoid a copy. Default is False</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ret</strong><span class="classifier">ndarray</span></dt><dd><p>The detrended input data.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">randgen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npoints</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">=</span> <span class="n">randgen</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">npoints</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">noise</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.fftconvolve">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">fftconvolve</code><span class="sig-paren">(</span><em class="sig-param">in1</em>, <em class="sig-param">in2</em>, <em class="sig-param">mode='full'</em>, <em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.fftconvolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve two N-dimensional arrays using FFT.</p>
<p>Convolve <cite>in1</cite> and <cite>in2</cite> using the fast Fourier transform method, with
the output size determined by the <cite>mode</cite> argument.</p>
<p>This is generally much faster than <cite>convolve</cite> for large arrays (n &gt; ~500),
but can be slower when only a few output values are needed, and can only
output float arrays (int or object array inputs will be cast to float).</p>
<p>As of v0.19, <cite>convolve</cite> automatically chooses this method or the direct
method based on an estimation of which is faster.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>in1</strong><span class="classifier">array_like</span></dt><dd><p>First input.</p>
</dd>
<dt><strong>in2</strong><span class="classifier">array_like</span></dt><dd><p>Second input. Should have the same number of dimensions as <cite>in1</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str {‘full’, ‘valid’, ‘same’}, optional</span></dt><dd><p>A string indicating the size of the output:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">full</span></code></dt><dd><p>The output is the full discrete linear convolution
of the inputs. (Default)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>The output consists only of those elements that do not
rely on the zero-padding. In ‘valid’ mode, either <cite>in1</cite> or <cite>in2</cite>
must be at least as large as the other in every dimension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">same</span></code></dt><dd><p>The output is the same size as <cite>in1</cite>, centered
with respect to the ‘full’ output.
axis : tuple, optional</p>
</dd>
</dl>
</dd>
<dt><strong>axes</strong><span class="classifier">int or array_like of ints or None, optional</span></dt><dd><p>Axes over which to compute the convolution.
The default is over all axes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>An N-dimensional array containing a subset of the discrete linear
convolution of <cite>in1</cite> with <cite>in2</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Autocorrelation of white noise is an impulse.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">autocorr</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_mag</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;White noise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_mag</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)),</span> <span class="n">autocorr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_mag</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Autocorrelation&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Gaussian blur implemented using FFT convolution.  Notice the dark borders
around the image, due to the zero-padding beyond its boundaries.
The <cite>convolve2d</cite> function allows for other types of image boundaries,
but is far slower.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">misc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">face</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">gray</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">signal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blurred</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_orig</span><span class="p">,</span> <span class="n">ax_kernel</span><span class="p">,</span> <span class="n">ax_blurred</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_orig</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_kernel</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_kernel</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Gaussian kernel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_kernel</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_blurred</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">blurred</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_blurred</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Blurred&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax_blurred</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.freq_shift">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">freq_shift</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">freq</em>, <em class="sig-param">fs</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.freq_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Frequency shift signal by freq at fs sample rate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like, complex valued</span></dt><dd><p>The data to be shifted.</p>
</dd>
<dt><strong>freq</strong><span class="classifier">float</span></dt><dd><p>Shift by this many (Hz)</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float</span></dt><dd><p>Sampling rate of the signal</p>
</dd>
<dt><strong>domain</strong><span class="classifier">string</span></dt><dd><p>freq or time</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.hilbert">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">hilbert</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">N=None</em>, <em class="sig-param">axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.hilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the analytic signal, using the Hilbert transform.</p>
<p>The transformation is done along the last axis by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Signal data.  Must be real.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int, optional</span></dt><dd><p>Number of Fourier components.  Default: <code class="docutils literal notranslate"><span class="pre">x.shape[axis]</span></code></p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>Axis along which to do the transformation.  Default: -1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xa</strong><span class="classifier">ndarray</span></dt><dd><p>Analytic signal of <cite>x</cite>, of each 1-D array along <cite>axis</cite></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.fftpack.hilbert</span></code></dt><dd><p>Return Hilbert transform of a periodic sequence x.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The analytic signal <code class="docutils literal notranslate"><span class="pre">x_a(t)</span></code> of signal <code class="docutils literal notranslate"><span class="pre">x(t)</span></code> is:</p>
<div class="math notranslate nohighlight">
\[x_a = F^{-1}(F(x) 2U) = x + i y\]</div>
<p>where <cite>F</cite> is the Fourier transform, <cite>U</cite> the unit step function,
and <cite>y</cite> the Hilbert transform of <cite>x</cite>. <a class="reference internal" href="#r884f44fa7f75-1" id="id4">[1]</a></p>
<p>In other words, the negative half of the frequency spectrum is zeroed
out, turning the real-valued signal into a complex signal.  The Hilbert
transformed signal can be obtained from <code class="docutils literal notranslate"><span class="pre">np.imag(hilbert(x))</span></code>, and the
original signal from <code class="docutils literal notranslate"><span class="pre">np.real(hilbert(x))</span></code>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r884f44fa7f75-1"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p>Wikipedia, “Analytic signal”.
<a class="reference external" href="https://en.wikipedia.org/wiki/Analytic_signal">https://en.wikipedia.org/wiki/Analytic_signal</a></p>
</dd>
<dt class="label" id="r884f44fa7f75-2"><span class="brackets">2</span></dt>
<dd><p>Leon Cohen, “Time-Frequency Analysis”, 1995. Chapter 2.</p>
</dd>
<dt class="label" id="r884f44fa7f75-3"><span class="brackets">3</span></dt>
<dd><p>Alan V. Oppenheim, Ronald W. Schafer. Discrete-Time Signal
Processing, Third Edition, 2009. Chapter 12.
ISBN 13: 978-1292-02572-8</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In this example we use the Hilbert transform to determine the amplitude
envelope and instantaneous frequency of an amplitude-modulated signal.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">hilbert</span><span class="p">,</span> <span class="n">chirp</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">duration</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mf">400.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="o">*</span><span class="n">duration</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
</pre></div>
</div>
<p>We create a chirp of which the frequency increases from 20 Hz to 100 Hz and
apply an amplitude modulation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">signal</span> <span class="o">=</span> <span class="n">chirp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">100.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signal</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">3.0</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>The amplitude envelope is given by magnitude of the analytic signal. The
instantaneous frequency can be obtained by differentiating the
instantaneous phase in respect to time. The instantaneous phase corresponds
to the phase angle of the analytic signal.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">analytic_signal</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude_envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">analytic_signal</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instantaneous_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instantaneous_frequency</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">instantaneous_phase</span><span class="p">)</span> <span class="o">/</span>
<span class="gp">... </span>                           <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax0</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">amplitude_envelope</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;envelope&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax0</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;time in seconds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax0</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">instantaneous_frequency</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;time in seconds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">120.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.hilbert2">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">hilbert2</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">N=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.hilbert2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the ‘2-D’ analytic signal of <cite>x</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>2-D signal data.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int or tuple of two ints, optional</span></dt><dd><p>Number of Fourier components. Default is <code class="docutils literal notranslate"><span class="pre">x.shape</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xa</strong><span class="classifier">ndarray</span></dt><dd><p>Analytic signal of <cite>x</cite> taken along axes (0,1).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0af4b49c4539-1"><span class="brackets">1</span></dt>
<dd><p>Wikipedia, “Analytic signal”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Analytic_signal">https://en.wikipedia.org/wiki/Analytic_signal</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.lfiltic">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">lfiltic</code><span class="sig-paren">(</span><em class="sig-param">b</em>, <em class="sig-param">a</em>, <em class="sig-param">y</em>, <em class="sig-param">x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.lfiltic" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct initial conditions for lfilter given input and output vectors.</p>
<p>Given a linear filter (b, a) and initial conditions on the output <cite>y</cite>
and the input <cite>x</cite>, return the initial conditions on the state vector zi
which is used by <cite>lfilter</cite> to generate the output given the input.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>b</strong><span class="classifier">array_like</span></dt><dd><p>Linear filter term.</p>
</dd>
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>Linear filter term.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Initial conditions.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(a)</span> <span class="pre">-</span> <span class="pre">1</span></code>, then <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">{y[-1],</span> <span class="pre">y[-2],</span> <span class="pre">...,</span> <span class="pre">y[-N]}</span></code>.</p>
<p>If <cite>y</cite> is too short, it is padded with zeros.</p>
</dd>
<dt><strong>x</strong><span class="classifier">array_like, optional</span></dt><dd><p>Initial conditions.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">len(b)</span> <span class="pre">-</span> <span class="pre">1</span></code>, then <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{x[-1],</span> <span class="pre">x[-2],</span> <span class="pre">...,</span> <span class="pre">x[-M]}</span></code>.</p>
<p>If <cite>x</cite> is not given, its initial conditions are assumed zero.</p>
<p>If <cite>x</cite> is too short, it is padded with zeros.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>zi</strong><span class="classifier">ndarray</span></dt><dd><p>The state vector <code class="docutils literal notranslate"><span class="pre">zi</span> <span class="pre">=</span> <span class="pre">{z_0[-1],</span> <span class="pre">z_1[-1],</span> <span class="pre">...,</span> <span class="pre">z_K-1[-1]}</span></code>,
where <code class="docutils literal notranslate"><span class="pre">K</span> <span class="pre">=</span> <span class="pre">max(M,</span> <span class="pre">N)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">lfilter</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">lfilter_zi</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.resample">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">resample</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">num</em>, <em class="sig-param">t=None</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">window=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample <cite>x</cite> to <cite>num</cite> samples using Fourier method along the given axis.</p>
<p>The resampled signal starts at the same value as <cite>x</cite> but is sampled
with a spacing of <code class="docutils literal notranslate"><span class="pre">len(x)</span> <span class="pre">/</span> <span class="pre">num</span> <span class="pre">*</span> <span class="pre">(spacing</span> <span class="pre">of</span> <span class="pre">x)</span></code>.  Because a
Fourier method is used, the signal is assumed to be periodic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The data to be resampled.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int</span></dt><dd><p>The number of samples in the resampled signal.</p>
</dd>
<dt><strong>t</strong><span class="classifier">array_like, optional</span></dt><dd><p>If <cite>t</cite> is given, it is assumed to be the sample positions
associated with the signal data in <cite>x</cite>.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis of <cite>x</cite> that is resampled.  Default is 0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">array_like, callable, string, float, or tuple, optional</span></dt><dd><p>Specifies the window applied to the signal in the Fourier
domain.  See below for details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>resampled_x or (resampled_x, resampled_t)</dt><dd><p>Either the resampled array, or, if <cite>t</cite> was given, a tuple
containing the resampled array and the corresponding resampled
positions.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate</span></code></dt><dd><p>Downsample the signal after applying an FIR or IIR filter.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.signaltools.resample_poly" title="cusignal.signaltools.resample_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample_poly</span></code></a></dt><dd><p>Resample using polyphase filtering and an FIR filter.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The argument <cite>window</cite> controls a Fourier-domain window that tapers
the Fourier spectrum before zero-padding to alleviate ringing in
the resampled values for sampled signals you didn’t intend to be
interpreted as band-limited.</p>
<p>If <cite>window</cite> is a function, then it is called with a vector of inputs
indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).</p>
<p>If <cite>window</cite> is an array of the same length as <cite>x.shape[axis]</cite> it is
assumed to be the window to be applied directly in the Fourier
domain (with dc and low-frequency first).</p>
<p>For any other type of <cite>window</cite>, the function <cite>scipy.signal.get_window</cite>
is called to generate the window.</p>
<p>The first sample of the returned vector is the same as the first
sample of the input vector.  The spacing between samples is changed
from <code class="docutils literal notranslate"><span class="pre">dx</span></code> to <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">*</span> <span class="pre">len(x)</span> <span class="pre">/</span> <span class="pre">num</span></code>.</p>
<p>If <cite>t</cite> is not None, then it represents the old sample positions,
and the new sample positions will be returned as well as the new
samples.</p>
<p>As noted, <cite>resample</cite> uses FFT transformations, which can be very
slow if the number of input or output samples is large and prime;
see <cite>scipy.fftpack.fft</cite>.</p>
<p class="rubric">Examples</p>
<p>Note that the end of the resampled data rises to meet the first
sample of the next cycle:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;go-&#39;</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;resampled&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.resample_poly">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">resample_poly</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">up</em>, <em class="sig-param">down</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">window=('kaiser'</em>, <em class="sig-param">5.0)</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.resample_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample <cite>x</cite> along the given axis using polyphase filtering.</p>
<p>The signal <cite>x</cite> is upsampled by the factor <cite>up</cite>, a zero-phase low-pass
FIR filter is applied, and then it is downsampled by the factor <cite>down</cite>.
The resulting sample rate is <code class="docutils literal notranslate"><span class="pre">up</span> <span class="pre">/</span> <span class="pre">down</span></code> times the original sample
rate. Values beyond the boundary of the signal are assumed to be zero
during the filtering step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The data to be resampled.</p>
</dd>
<dt><strong>up</strong><span class="classifier">int</span></dt><dd><p>The upsampling factor.</p>
</dd>
<dt><strong>down</strong><span class="classifier">int</span></dt><dd><p>The downsampling factor.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis of <cite>x</cite> that is resampled. Default is 0.</p>
</dd>
<dt><strong>window</strong><span class="classifier">string, tuple, or array_like, optional</span></dt><dd><p>Desired window to use to design the low-pass filter, or the FIR filter
coefficients to employ. See below for details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resampled_x</strong><span class="classifier">array</span></dt><dd><p>The resampled array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate</span></code></dt><dd><p>Downsample the signal after applying an FIR or IIR filter.</p>
</dd>
<dt><a class="reference internal" href="#cusignal.signaltools.resample" title="cusignal.signaltools.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a></dt><dd><p>Resample up or down using the FFT method.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This polyphase method will likely be faster than the Fourier method
in <cite>scipy.signal.resample</cite> when the number of samples is large and
prime, or when the number of samples is large and <cite>up</cite> and <cite>down</cite>
share a large greatest common denominator. The length of the FIR
filter used will depend on <code class="docutils literal notranslate"><span class="pre">max(up,</span> <span class="pre">down)</span> <span class="pre">//</span> <span class="pre">gcd(up,</span> <span class="pre">down)</span></code>, and
the number of operations during polyphase filtering will depend on
the filter length and <cite>down</cite> (see <cite>scipy.signal.upfirdn</cite> for details).</p>
<p>The argument <cite>window</cite> specifies the FIR low-pass filter design.</p>
<p>If <cite>window</cite> is an array_like it is assumed to be the FIR filter
coefficients. Note that the FIR filter is applied after the upsampling
step, so it should be designed to operate on a signal at a sampling
frequency higher than the original by a factor of <cite>up//gcd(up, down)</cite>.
This function’s output will be centered with respect to this array, so it
is best to pass a symmetric filter with an odd number of samples if, as
is usually the case, a zero-phase filter is desired.</p>
<p>For any other type of <cite>window</cite>, the functions <cite>scipy.signal.get_window</cite>
and <cite>scipy.signal.firwin</cite> are called to generate the appropriate filter
coefficients.</p>
<p>The first sample of the returned vector is the same as the first
sample of the input vector. The spacing between samples is changed
from <code class="docutils literal notranslate"><span class="pre">dx</span></code> to <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">*</span> <span class="pre">down</span> <span class="pre">/</span> <span class="pre">float(up)</span></code>.</p>
<p class="rubric">Examples</p>
<p>Note that the end of the resampled data rises to meet the first
sample of the next cycle for the FFT method, and gets closer to zero
for the polyphase method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_fft</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_poly</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">f_fft</span><span class="p">,</span> <span class="s1">&#39;b.-&#39;</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">f_poly</span><span class="p">,</span> <span class="s1">&#39;r.-&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ko-&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>  <span class="c1"># boundaries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;resample&#39;</span><span class="p">,</span> <span class="s1">&#39;resamp_poly&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.vectorstrength">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">vectorstrength</code><span class="sig-paren">(</span><em class="sig-param">events</em>, <em class="sig-param">period</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.vectorstrength" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the vector strength of the events corresponding to the given
period.</p>
<p>The vector strength is a measure of phase synchrony, how well the
timing of the events is synchronized to a single period of a periodic
signal.</p>
<p>If multiple periods are used, calculate the vector strength of each.
This is called the “resonating vector strength”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>events</strong><span class="classifier">1D array_like</span></dt><dd><p>An array of time points containing the timing of the events.</p>
</dd>
<dt><strong>period</strong><span class="classifier">float or array_like</span></dt><dd><p>The period of the signal that the events should synchronize to.
The period is in the same units as <cite>events</cite>.  It can also be an array
of periods, in which case the outputs are arrays of the same length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">float or 1D array</span></dt><dd><p>The strength of the synchronization.  1.0 is perfect synchronization
and 0.0 is no synchronization.  If <cite>period</cite> is an array, this is also
an array with each element containing the vector strength at the
corresponding period.</p>
</dd>
<dt><strong>phase</strong><span class="classifier">float or array</span></dt><dd><p>The phase that the events are most strongly synchronized to in radians.
If <cite>period</cite> is an array, this is also an array with each element
containing the phase for the corresponding period.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector</dt><dd><p>strength: Auditory system, electric fish, and noise.
Chaos 21, 047508 (2011);
<a href="#id9"><span class="problematic" id="id10">:doi:`10.1063/1.3670512`</span></a>.</p>
</dd>
<dt>van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:</dt><dd><p>biological and mathematical perspectives.  Biol Cybern.
2013 Aug;107(4):385-96. <a href="#id11"><span class="problematic" id="id12">:doi:`10.1007/s00422-013-0561-7`</span></a>.</p>
</dd>
<dt>van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens</dt><dd><p>when we vary the “probing” frequency while keeping the spike times
fixed.  Biol Cybern. 2013 Aug;107(4):491-94.
<a href="#id13"><span class="problematic" id="id14">:doi:`10.1007/s00422-013-0560-8`</span></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cusignal.signaltools.wiener">
<code class="sig-prename descclassname">cusignal.signaltools.</code><code class="sig-name descname">wiener</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">mysize=None</em>, <em class="sig-param">noise=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cusignal.signaltools.wiener" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a Wiener filter on an N-dimensional array.</p>
<p>Apply a Wiener filter to the N-dimensional array <cite>im</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>im</strong><span class="classifier">ndarray</span></dt><dd><p>An N-dimensional array.</p>
</dd>
<dt><strong>mysize</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>A scalar or an N-length list giving the size of the Wiener filter
window in each dimension.  Elements of mysize should be odd.
If mysize is a scalar, then this scalar is used as the size
in each dimension.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">float, optional</span></dt><dd><p>The noise-power to use. If None, then noise is estimated as the
average of the local variance of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Wiener filtered result with the same shape as <cite>im</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to cusignal’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019-2020, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>