
<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>cuSpatial API Reference — cuspatial 0.19.0 documentation</title>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/params.css" rel="stylesheet" type="text/css"/>
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script src="_static/js/theme.js" type="text/javascript"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="index.html" rel="prev" title="Welcome to cuSpatial’s documentation!"/>
<link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search"><div id="rapids-sphinx-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">cuspatial</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (0.19)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cuspatial/nightly/api.html">nightly (0.19)</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">stable (0.18)</a><a class="rapids-selector__menu-item" href="/api/cuspatial/legacy/api.html">legacy (0.17)</a></div></div></div>


<div role="search">
<form action="search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">cuSpatial API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#gis">GIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spatial-querying">Spatial Querying</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spatial-joining">Spatial Joining</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trajectory">Trajectory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#io">IO</a></li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="index.html">cuspatial</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a class="icon icon-home" href="index.html"></a> »</li>
<li>cuSpatial API Reference</li>
<li class="wy-breadcrumbs-aside">
<a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="cuspatial-api-reference">
<h1>cuSpatial API Reference<a class="headerlink" href="#cuspatial-api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="gis">
<h2>GIS<a class="headerlink" href="#gis" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cuspatial.directed_hausdorff_distance">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">directed_hausdorff_distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_offsets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.directed_hausdorff_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the directed Hausdorff distances between all pairs of
spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates</p>
</dd>
<dt><strong>space_offsets</strong></dt><dd><p>beginning index of each space, plus the last space’s end offset.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>The pairwise directed distance matrix with one row and one
column per input space; the value at row i, column j represents the
hausdorff distance from space i to space j.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The directed Hausdorff distance from one space to another is the greatest
of all the distances between any point in the first space to the closest
point in the second.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Hausdorff_distance">Wikipedia</a></p>
<p>Consider a pair of lines on a grid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>     <span class="p">:</span>
     <span class="n">x</span>
<span class="o">-----</span><span class="n">xyy</span><span class="o">---</span>
     <span class="p">:</span>
     <span class="p">:</span>
</pre></div>
</div>
<p>x<sub>0</sub> = (0, 0), x<sub>1</sub> = (0, 1)</p>
<p>y<sub>0</sub> = (1, 0), y<sub>1</sub> = (2, 0)</p>
<p>x<sub>0</sub> is the closest point in <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">y</span></code>. The distance from
x<sub>0</sub> to the farthest point in <code class="docutils literal notranslate"><span class="pre">y</span></code> is 2.</p>
<p>y<sub>0</sub> is the closest point in <code class="docutils literal notranslate"><span class="pre">y</span></code> to <code class="docutils literal notranslate"><span class="pre">x</span></code>. The distance from
y<sub>0</sub> to the farthest point in <code class="docutils literal notranslate"><span class="pre">x</span></code> is 1.414.</p>
<p>Compute the directed hausdorff distances between a set of spaces</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">directed_hausdorff_distance</span><span class="p">(</span>
<span class="go">        [0, 1, 0, 0], # xs</span>
<span class="go">        [0, 0, 1, 2], # ys</span>
<span class="go">        [0, 2, 4],    # space_offsets</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">         0         1</span>
<span class="go">    0  0.0  1.414214</span>
<span class="go">    1  2.0  0.000000</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.haversine_distance">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">haversine_distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1_lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1_lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2_lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2_lat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.haversine_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the haversine distances between an arbitrary list of lon/lat
pairs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p1_lon</strong></dt><dd><p>longitude of first set of coords</p>
</dd>
<dt><strong>p1_lat</strong></dt><dd><p>latitude of first set of coords</p>
</dd>
<dt><strong>p2_lon</strong></dt><dd><p>longitude of second set of coords</p>
</dd>
<dt><strong>p2_lat</strong></dt><dd><p>latitude of second set of coords</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.Series</span></dt><dd><p>The distance between all pairs of lon/lat coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.lonlat_to_cartesian">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">lonlat_to_cartesian</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin_lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin_lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_lat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.lonlat_to_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert lon/lat to <code class="docutils literal notranslate"><span class="pre">x,y</span></code> coordinates with respect to an origin lon/lat
point. Results are scaled relative to the size of the Earth in kilometers.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>origin_lon</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">number</span></code></span></dt><dd><p>longitude offset  (this is subtracted from each input before
converting to x,y)</p>
</dd>
<dt><strong>origin_lat</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">number</span></code></span></dt><dd><p>latitude offset (this is subtracted from each input before
converting to x,y)</p>
</dd>
<dt><strong>input_lon</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>longitude coordinates to convert to x</p>
</dd>
<dt><strong>input_lat</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>latitude coordinates to convert to y</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>x<span class="classifier">cudf.Series</span></dt><dd><p>x-coordinate of the input relative to the size of the Earth in
kilometers.</p>
</dd>
<dt>y<span class="classifier">cudf.Series</span></dt><dd><p>y-coordinate of the input relative to the size of the Earth in
kilometers.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.point_in_polygon">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">point_in_polygon</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_points_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_ring_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.point_in_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute from a set of points and a set of polygons which points fall
within which polygons. Note that <cite>polygons_(x,y)</cite> must be specified as
closed polygons: the first and last coordinate of each polygon must be
the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>test_points_x</strong></dt><dd><p>x-coordinate of test points</p>
</dd>
<dt><strong>test_points_y</strong></dt><dd><p>y-coordinate of test points</p>
</dd>
<dt><strong>poly_offsets</strong></dt><dd><p>beginning index of the first ring in each polygon</p>
</dd>
<dt><strong>poly_ring_offsets</strong></dt><dd><p>beginning index of the first point in each ring</p>
</dd>
<dt><strong>poly_points_x</strong></dt><dd><p>x closed-coordinate of polygon points</p>
</dd>
<dt><strong>poly_points_y</strong></dt><dd><p>y closed-coordinate of polygon points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A DataFrame of boolean values indicating whether each point falls
within each polygon.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Test whether 3 points fall within either of two polygons</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">point_in_polygon</span><span class="p">(</span>
<span class="go">    [0, -8, 6.0],                             # test_points_x</span>
<span class="go">    [0, -8, 6.0],                             # test_points_y</span>
<span class="go">    cudf.Series([0, 1], index=['nyc', 'hudson river']), # poly_offsets</span>
<span class="go">    [0, 3],                                   # ring_offsets</span>
<span class="go">    [-10, 5, 5, -10, 0, 10, 10, 0],           # poly_points_x</span>
<span class="go">    [-10, -10, 5, 5, 0, 0, 10, 10],           # poly_points_y</span>
<span class="go">)</span>
<span class="go"># The result of point_in_polygon is a DataFrame of Boolean</span>
<span class="go"># values indicating whether each point (rows) falls within</span>
<span class="go"># each polygon (columns).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">            nyc            hudson river</span>
<span class="go">0          True          True</span>
<span class="go">1          True         False</span>
<span class="go">2         False          True</span>
<span class="go"># Point 0: (0, 0) falls in both polygons</span>
<span class="go"># Point 1: (-8, -8) falls in the first polygon</span>
<span class="go"># Point 2: (6.0, 6.0) falls in the second polygon</span>
</pre></div>
</div>
<p>note
input Series x and y will not be index aligned, but computed as
sequential arrays.</p>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.polygon_bounding_boxes">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">polygon_bounding_boxes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.polygon_bounding_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum bounding-boxes for a set of polygons.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly_offsets</strong></dt><dd><p>Begin indices of the first ring in each polygon (i.e. prefix-sum)</p>
</dd>
<dt><strong>ring_offsets</strong></dt><dd><p>Begin indices of the first point in each ring (i.e. prefix-sum)</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>Polygon point x-coordinates</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>Polygon point y-coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>minimum bounding boxes for each polygon</p>
<dl class="simple">
<dt>x_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum x-coordinate of each bounding box</p>
</dd>
<dt>y_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum y-coordinate of each bounding box</p>
</dd>
<dt>x_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum x-coordinate of each bounding box</p>
</dd>
<dt>y_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum y-coordinate of each bounding box</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.polyline_bounding_boxes">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">polyline_bounding_boxes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expansion_radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.polyline_bounding_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum bounding-boxes for a set of polylines.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly_offsets</strong></dt><dd><p>Begin indices of the first ring in each polyline (i.e. prefix-sum)</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>Polyline point x-coordinates</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>Polyline point y-coordinates</p>
</dd>
<dt><strong>expansion_radius</strong></dt><dd><p>radius of each polyline point</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>minimum bounding boxes for each polyline</p>
<dl class="simple">
<dt>x_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum x-coordinate of each bounding box</p>
</dd>
<dt>y_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum y-coordinate of each bounding box</p>
</dd>
<dt>x_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum x-coordinate of each bounding box</p>
</dd>
<dt>y_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum y-coordinate of each bounding box</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="indexing">
<h2>Indexing<a class="headerlink" href="#indexing" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cuspatial.quadtree_on_points">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">quadtree_on_points</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.quadtree_on_points" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Construct a quadtree from a set of points for a given area-of-interest</dt><dd><p>bounding box.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xs</strong></dt><dd><p>Column of x-coordinates for each point</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>Column of y-coordinates for each point</p>
</dd>
<dt><strong>x_min</strong></dt><dd><p>The lower-left x-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>x_max</strong></dt><dd><p>The upper-right x-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>y_min</strong></dt><dd><p>The lower-left y-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>y_max</strong></dt><dd><p>The upper-right y-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>scale</strong></dt><dd><p>Scale to apply to each point’s distance from <code class="docutils literal notranslate"><span class="pre">(x_min,</span> <span class="pre">y_min)</span></code></p>
</dd>
<dt><strong>max_depth</strong></dt><dd><p>Maximum quadtree depth</p>
</dd>
<dt><strong>min_size</strong></dt><dd><p>Minimum number of points for a non-leaf quadtree node</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">tuple (cudf.Series, cudf.DataFrame)</span></dt><dd><dl>
<dt>keys_to_points<span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>A column of sorted keys to original point indices</p>
</dd>
<dt>quadtree<span class="classifier">cudf.DataFrame</span></dt><dd><p>A complete quadtree for the set of input points</p>
<dl>
<dt>key<span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>An int32 column of quadrant keys</p>
</dd>
<dt>level<span class="classifier">cudf.Series(dtype=np.int8)</span></dt><dd><p>An int8 column of quadtree levels</p>
</dd>
<dt>is_quad<span class="classifier">cudf.Series(dtype=np.bool_)</span></dt><dd><p>A boolean column indicating whether the node is a quad or leaf</p>
</dd>
<dt>length<span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>If this is a non-leaf quadrant (i.e. <code class="docutils literal notranslate"><span class="pre">is_quad</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>),
this column’s value is the number of children in the non-leaf
quadrant.</p>
<p>Otherwise this column’s value is the number of points
contained in the leaf quadrant.</p>
</dd>
<dt>offset<span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>If this is a non-leaf quadrant (i.e. <code class="docutils literal notranslate"><span class="pre">is_quad</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>),
this column’s value is the position of the non-leaf quadrant’s
first child.</p>
<p>Otherwise this column’s value is the position of the leaf
quadrant’s first point.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_x</span></code> and <code class="docutils literal notranslate"><span class="pre">max_x</span></code> if <code class="docutils literal notranslate"><span class="pre">min_x</span> <span class="pre">&gt;</span> <span class="pre">max_x</span></code></p></li>
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_y</span></code> and <code class="docutils literal notranslate"><span class="pre">max_y</span></code> if <code class="docutils literal notranslate"><span class="pre">min_y</span> <span class="pre">&gt;</span> <span class="pre">max_y</span></code></p></li>
</ul>
<p class="rubric">Examples</p>
<p>An example of selecting the <code class="docutils literal notranslate"><span class="pre">min_size</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> based on input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
<span class="go">        "x": cudf.Series(np.random.normal(size=120)) * 500,</span>
<span class="go">        "y": cudf.Series(np.random.normal(size=120)) * 500,</span>
<span class="go">    })</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">max_depth</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_size</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="s2">"x"</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="go">                                  points["y"].min(),</span>
<span class="go">                                  points["x"].max(),</span>
<span class="go">                                  points["y"].max())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">max_depth</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span>
<span class="go">        "min_size:   " + str(min_size) + "\n"</span>
<span class="go">        "num_points: " + str(len(points)) + "\n"</span>
<span class="go">        "min_x:      " + str(min_x) + "\n"</span>
<span class="go">        "max_x:      " + str(max_x) + "\n"</span>
<span class="go">        "min_y:      " + str(min_y) + "\n"</span>
<span class="go">        "max_y:      " + str(max_y) + "\n"</span>
<span class="go">        "scale:      " + str(scale) + "\n"</span>
<span class="go">    )</span>
<span class="go">min_size:   50</span>
<span class="go">num_points: 120</span>
<span class="go">min_x:      -1577.4949079170394</span>
<span class="go">max_x:      1435.877311993804</span>
<span class="go">min_y:      -1412.7015761122134</span>
<span class="go">max_y:      1492.572387431971</span>
<span class="go">scale:      301.0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">key_to_point</span><span class="p">,</span> <span class="n">quadtree</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">quadtree_on_points</span><span class="p">(</span>
<span class="go">        points["x"],</span>
<span class="go">        points["y"],</span>
<span class="go">        min_x,</span>
<span class="go">        max_x,</span>
<span class="go">        min_y,</span>
<span class="go">        max_y,</span>
<span class="go">        scale, max_depth, min_size</span>
<span class="go">    )</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">quadtree</span><span class="p">)</span>
<span class="go">    key  level  is_quad  length  offset</span>
<span class="go">0     0      0    False      15       0</span>
<span class="go">1     1      0    False      27      15</span>
<span class="go">2     2      0    False      12      42</span>
<span class="go">3     3      0     True       4       8</span>
<span class="go">4     4      0    False       5     106</span>
<span class="go">5     6      0    False       6     111</span>
<span class="go">6     9      0    False       2     117</span>
<span class="go">7    12      0    False       1     119</span>
<span class="go">8    12      1    False      22      54</span>
<span class="go">9    13      1    False      18      76</span>
<span class="go">10   14      1    False       9      94</span>
<span class="go">11   15      1    False       3     103</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">key_to_point</span><span class="p">)</span>
<span class="go">0       63</span>
<span class="go">1       20</span>
<span class="go">2       33</span>
<span class="go">3       66</span>
<span class="go">4       19</span>
<span class="go">    ...</span>
<span class="go">115    113</span>
<span class="go">116      3</span>
<span class="go">117     78</span>
<span class="go">118     98</span>
<span class="go">119     24</span>
<span class="go">Length: 120, dtype: int32</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="interpolation">
<h2>Interpolation<a class="headerlink" href="#interpolation" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cuspatial.CubicSpline">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">CubicSpline</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefixes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.CubicSpline" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits each column of the input Series <cite>y</cite> to a hermetic cubic spline.</p>
<p><code class="docutils literal notranslate"><span class="pre">cuspatial.CubicSpline</span></code> supports two usage patterns: The first is
identical to scipy.interpolate.CubicSpline:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">curve</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">new_points</span> <span class="o">=</span> <span class="n">curve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p>This allows API parity with scipy. This isn’t recommended, as scipy
host based interpolation performance is likely to exceed GPU performance
for a single curve.</p>
<p>However, cuSpatial massively outperforms scipy when many splines are fit
simultaneously. Data must be arranged in a SoA format, and the exclusive
<cite>prefix_sum</cite> of the separate curves must also be passed to the function.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'float32'</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'float32'</span><span class="p">)</span>
<span class="n">prefix_sum</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'int32'</span><span class="p">)</span>
<span class="n">new_samples</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'float32'</span><span class="p">)</span>

<span class="n">curve</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prefixes</span><span class="o">=</span><span class="n">prefix_sum</span><span class="p">)</span>
<span class="n">new_points</span> <span class="o">=</span> <span class="n">curve</span><span class="p">(</span><span class="n">new_samples</span><span class="p">,</span> <span class="n">prefix_sum</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cuspatial.CubicSpline.__call__" title="cuspatial.CubicSpline.__call__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code></a>(coordinates[, groups])</p></td>
<td><p>Interpolates new input values <cite>coordinates</cite> using the <cite>.c</cite> DataFrame or map of DataFrames.</p></td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="py method">
<dt id="cuspatial.CubicSpline.__init__">
<code class="sig-prename descclassname"><span class="pre">CubicSpline.</span></code><code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefixes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.CubicSpline.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes various error preconditions on the input data, then
uses CUDA to compute cubic splines for each set of input
coordinates on the GPU in parallel.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">cudf.Series</span></dt><dd><p>time sample values. Must be monotonically increasing.</p>
</dd>
<dt><strong>y</strong><span class="classifier">cudf.Series</span></dt><dd><p>columns to have curves fit to according to x</p>
</dd>
<dt><strong>ids (Optional)</strong><span class="classifier">cudf.Series</span></dt><dd><p>ids of each spline</p>
</dd>
<dt><strong>size (Optional)</strong><span class="classifier">cudf.Series</span></dt><dd><p>fixed size of each spline</p>
</dd>
<dt><strong>prefixes (Optional)</strong><span class="classifier">cudf.Series</span></dt><dd><p>alternative to <cite>size</cite>, allows splines of varying
length. Not yet fully supported.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>CubicSpline</strong><span class="classifier">callable <cite>o</cite></span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">o.c</span></code> contains the coefficients that can be used to compute new
points along the spline fitting the original <code class="docutils literal notranslate"><span class="pre">t</span></code> data. <code class="docutils literal notranslate"><span class="pre">o(n)</span></code>
interpolates the spline coordinates along new input values <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cuspatial.CubicSpline.__call__">
<code class="sig-prename descclassname"><span class="pre">CubicSpline.</span></code><code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.CubicSpline.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates new input values <cite>coordinates</cite> using the <cite>.c</cite> DataFrame
or map of DataFrames.</p>
</dd></dl>
</div>
<div class="section" id="spatial-querying">
<h2>Spatial Querying<a class="headerlink" href="#spatial-querying" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cuspatial.points_in_spatial_window">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">points_in_spatial_window</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.points_in_spatial_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return only the subset of coordinates that fall within a
rectangular window.</p>
<p>A point <cite>(x, y)</cite> is inside the query window if and only if
<code class="docutils literal notranslate"><span class="pre">min_x</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">max_x</span> <span class="pre">AND</span> <span class="pre">min_y</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">max_y</span></code></p>
<p>The window is specified by minimum and maximum x and y
coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_x</strong></dt><dd><p>lower x-coordinate of the query window</p>
</dd>
<dt><strong>max_x</strong></dt><dd><p>upper x-coordinate of the query window</p>
</dd>
<dt><strong>min_y</strong></dt><dd><p>lower y-coordinate of the query window</p>
</dd>
<dt><strong>max_y</strong></dt><dd><p>upper y-coordinate of the query window</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates that may fall within the window</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates that may fall within the window</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>subset of <cite>(x, y)</cite> pairs above that fall within the window</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_x</span></code> and <code class="docutils literal notranslate"><span class="pre">max_x</span></code> if <code class="docutils literal notranslate"><span class="pre">min_x</span> <span class="pre">&gt;</span> <span class="pre">max_x</span></code></p></li>
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_y</span></code> and <code class="docutils literal notranslate"><span class="pre">max_y</span></code> if <code class="docutils literal notranslate"><span class="pre">min_y</span> <span class="pre">&gt;</span> <span class="pre">max_y</span></code></p></li>
</ul>
</dd></dl>
</div>
<div class="section" id="spatial-joining">
<h2>Spatial Joining<a class="headerlink" href="#spatial-joining" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cuspatial.join_quadtree_and_bounding_boxes">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">join_quadtree_and_bounding_boxes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quadtree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_bounding_boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.join_quadtree_and_bounding_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Search a quadtree for polygon or polyline bounding box intersections.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>quadtree</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A complete quadtree for a given area-of-interest bounding box.</p>
</dd>
<dt><strong>poly_bounding_boxes</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Minimum bounding boxes for a set of polygons or polylines</p>
</dd>
<dt><strong>x_min</strong></dt><dd><p>The lower-left x-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>x_max</strong></dt><dd><p>The upper-right x-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>min_y</strong></dt><dd><p>The lower-left y-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>max_y</strong></dt><dd><p>The upper-right y-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>scale</strong></dt><dd><p>Scale to apply to each point’s distance from <code class="docutils literal notranslate"><span class="pre">(x_min,</span> <span class="pre">y_min)</span></code></p>
</dd>
<dt><strong>max_depth</strong></dt><dd><p>Maximum quadtree depth at which to stop testing for intersections</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Indices for each intersecting bounding box and leaf quadrant.</p>
<dl class="simple">
<dt>poly_offset<span class="classifier">cudf.Series</span></dt><dd><p>Indices for each poly bbox that intersects with the quadtree.</p>
</dd>
<dt>quad_offset<span class="classifier">cudf.Series</span></dt><dd><p>Indices for each leaf quadrant intersecting with a poly bbox.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_x</span></code> and <code class="docutils literal notranslate"><span class="pre">max_x</span></code> if <code class="docutils literal notranslate"><span class="pre">min_x</span> <span class="pre">&gt;</span> <span class="pre">max_x</span></code></p></li>
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_y</span></code> and <code class="docutils literal notranslate"><span class="pre">max_y</span></code> if <code class="docutils literal notranslate"><span class="pre">min_y</span> <span class="pre">&gt;</span> <span class="pre">max_y</span></code></p></li>
</ul>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.quadtree_point_in_polygon">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">quadtree_point_in_polygon</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly_quad_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadtree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.quadtree_point_in_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the specified points are inside any of the specified
polygons.</p>
<p>Uses the table of (polygon, quadrant) pairs returned by
<code class="docutils literal notranslate"><span class="pre">cuspatial.join_quadtree_and_bounding_boxes</span></code> to ensure only the points
in the same quadrant as each polygon are tested for intersection.</p>
<p>This pre-filtering can dramatically reduce number of points tested per
polygon, enabling faster intersection-testing at the expense of extra
memory allocated to store the quadtree and sorted point_indices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly_quad_pairs: cudf.DataFrame</strong></dt><dd><p>Table of (polygon, quadrant) index pairs returned by
<code class="docutils literal notranslate"><span class="pre">cuspatial.join_quadtree_and_bounding_boxes</span></code>.</p>
</dd>
<dt><strong>quadtree</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A complete quadtree for a given area-of-interest bounding box.</p>
</dd>
<dt><strong>point_indices</strong><span class="classifier">cudf.Series</span></dt><dd><p>Sorted point indices returned by <code class="docutils literal notranslate"><span class="pre">cuspatial.quadtree_on_points</span></code></p>
</dd>
<dt><strong>points_x</strong><span class="classifier">cudf.Series</span></dt><dd><p>x-coordinates of points used to construct the quadtree.</p>
</dd>
<dt><strong>points_y</strong><span class="classifier">cudf.Series</span></dt><dd><p>y-coordinates of points used to construct the quadtree.</p>
</dd>
<dt><strong>poly_offsets</strong><span class="classifier">cudf.Series</span></dt><dd><p>Begin index of the first ring in each polygon.</p>
</dd>
<dt><strong>ring_offsets</strong><span class="classifier">cudf.Series</span></dt><dd><p>Begin index of the first point in each ring.</p>
</dd>
<dt><strong>poly_points_x</strong><span class="classifier">cudf.Series</span></dt><dd><p>Polygon point x-coodinates.</p>
</dd>
<dt><strong>poly_points_y</strong><span class="classifier">cudf.Series</span></dt><dd><p>Polygon point y-coodinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Indices for each intersecting point and polygon pair.</p>
<dl class="simple">
<dt>polygon_index<span class="classifier">cudf.Series</span></dt><dd><p>Indices of each polygon with which a point intersected.</p>
</dd>
<dt>point_index<span class="classifier">cudf.Series</span></dt><dd><p>Indices of each point that intersects with a polygon.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.quadtree_point_to_nearest_polyline">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">quadtree_point_to_nearest_polyline</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly_quad_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadtree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.quadtree_point_to_nearest_polyline" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the nearest polyline to each point in a quadrant, and computes
the distances between each point and polyline.</p>
<p>Uses the table of (polyline, quadrant) pairs returned by
<code class="docutils literal notranslate"><span class="pre">cuspatial.join_quadtree_and_bounding_boxes</span></code> to ensure distances are
computed only for the points in the same quadrant as each polyline.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly_quad_pairs: cudf.DataFrame</strong></dt><dd><p>Table of (polyline, quadrant) index pairs returned by
<code class="docutils literal notranslate"><span class="pre">cuspatial.join_quadtree_and_bounding_boxes</span></code>.</p>
</dd>
<dt><strong>quadtree</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A complete quadtree for a given area-of-interest bounding box.</p>
</dd>
<dt><strong>point_indices</strong><span class="classifier">cudf.Series</span></dt><dd><p>Sorted point indices returned by <code class="docutils literal notranslate"><span class="pre">cuspatial.quadtree_on_points</span></code></p>
</dd>
<dt><strong>points_x</strong><span class="classifier">cudf.Series</span></dt><dd><p>x-coordinates of points used to construct the quadtree.</p>
</dd>
<dt><strong>points_y</strong><span class="classifier">cudf.Series</span></dt><dd><p>y-coordinates of points used to construct the quadtree.</p>
</dd>
<dt><strong>poly_offsets</strong><span class="classifier">cudf.Series</span></dt><dd><p>Begin index of the first point in each polyline.</p>
</dd>
<dt><strong>poly_points_x</strong><span class="classifier">cudf.Series</span></dt><dd><p>Polyline point x-coodinates.</p>
</dd>
<dt><strong>poly_points_y</strong><span class="classifier">cudf.Series</span></dt><dd><p>Polyline point y-coodinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Indices for each point and its nearest polyline, and the distance
between the two.</p>
<dl class="simple">
<dt>point_index<span class="classifier">cudf.Series</span></dt><dd><p>Indices of each point that intersects with a polyline.</p>
</dd>
<dt>polyline_index<span class="classifier">cudf.Series</span></dt><dd><p>Indices of each polyline with which a point intersected.</p>
</dd>
<dt>distance<span class="classifier">cudf.Series</span></dt><dd><p>Distances between each point and its nearest polyline.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="trajectory">
<h2>Trajectory<a class="headerlink" href="#trajectory" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cuspatial.derive_trajectories">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">derive_trajectories</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.derive_trajectories" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive trajectories from object ids, points, and timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>object_ids</strong></dt><dd><p>column of object (e.g., vehicle) ids</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates (in kilometers)</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates (in kilometers)</p>
</dd>
<dt><strong>timestamps</strong></dt><dd><p>column of timestamps in any resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">tuple (objects, traj_offsets)</span></dt><dd><dl class="simple">
<dt>objects<span class="classifier">cudf.DataFrame</span></dt><dd><p>object_ids, xs, ys, and timestamps sorted by
<code class="docutils literal notranslate"><span class="pre">(object_id,</span> <span class="pre">timestamp)</span></code>, used by <code class="docutils literal notranslate"><span class="pre">trajectory_bounding_boxes</span></code>
and <code class="docutils literal notranslate"><span class="pre">trajectory_distances_and_speeds</span></code></p>
</dd>
<dt>traj_offsets<span class="classifier">cudf.Series</span></dt><dd><p>offsets of discovered trajectories</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute sorted objects and discovered trajectories</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">objects</span><span class="p">,</span> <span class="n">traj_offsets</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">derive_trajectories</span><span class="p">(</span>
<span class="go">        [0, 1, 2, 3],  # object_id</span>
<span class="go">        [0, 0, 1, 1],  # x</span>
<span class="go">        [0, 0, 1, 1],  # y</span>
<span class="go">        [0, 10, 0, 10] # timestamp</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">traj_offsets</span><span class="p">)</span>
<span class="go">    0  0</span>
<span class="go">    1  2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
<span class="go">       object_id       x       y  timestamp</span>
<span class="go">    0          0       1       0          0</span>
<span class="go">    1          0       0       0         10</span>
<span class="go">    2          1       3       1          0</span>
<span class="go">    3          1       2       1         10</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.trajectory_bounding_boxes">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">trajectory_bounding_boxes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.trajectory_bounding_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bounding boxes of sets of trajectories.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_trajectories</strong></dt><dd><p>number of trajectories (unique object ids)</p>
</dd>
<dt><strong>object_ids</strong></dt><dd><p>column of object (e.g., vehicle) ids</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates (in kilometers)</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates (in kilometers)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>minimum bounding boxes (in kilometers) for each trajectory</p>
<dl class="simple">
<dt>x_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum x-coordinate of each bounding box</p>
</dd>
<dt>y_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum y-coordinate of each bounding box</p>
</dd>
<dt>x_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum x-coordinate of each bounding box</p>
</dd>
<dt>y_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum y-coordinate of each bounding box</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the minimum bounding boxes of derived trajectories</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">objects</span><span class="p">,</span> <span class="n">traj_offsets</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">derive_trajectories</span><span class="p">(</span>
<span class="go">        [0, 0, 1, 1],  # object_id</span>
<span class="go">        [0, 1, 2, 3],  # x</span>
<span class="go">        [0, 0, 1, 1],  # y</span>
<span class="go">        [0, 10, 0, 10] # timestamp</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj_bounding_boxes</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">trajectory_bounding_boxes</span><span class="p">(</span>
<span class="go">        len(traj_offsets),</span>
<span class="go">        objects['object_id'],</span>
<span class="go">        objects['x'],</span>
<span class="go">        objects['y']</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">traj_bounding_boxes</span><span class="p">)</span>
<span class="go">    x_min   y_min   x_max   y_max</span>
<span class="go">0     0.0     0.0     2.0     2.0</span>
<span class="go">1     1.0     1.0     3.0     3.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cuspatial.trajectory_distances_and_speeds">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">trajectory_distances_and_speeds</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.trajectory_distances_and_speeds" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the distance traveled and speed of sets of trajectories</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_trajectories</strong></dt><dd><p>number of trajectories (unique object ids)</p>
</dd>
<dt><strong>object_ids</strong></dt><dd><p>column of object (e.g., vehicle) ids</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates (in kilometers)</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates (in kilometers)</p>
</dd>
<dt><strong>timestamps</strong></dt><dd><p>column of timestamps in any resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>meters<span class="classifier">cudf.Series</span></dt><dd><p>trajectory distance (in kilometers)</p>
</dd>
<dt>speed<span class="classifier">cudf.Series</span></dt><dd><p>trajectory speed (in meters/second)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the distances and speeds of derived trajectories</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">objects</span><span class="p">,</span> <span class="n">traj_offsets</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">derive_trajectories</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dists_and_speeds</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">trajectory_distances_and_speeds</span><span class="p">(</span>
<span class="go">        len(traj_offsets)</span>
<span class="go">        objects['object_id'],</span>
<span class="go">        objects['x'],</span>
<span class="go">        objects['y'],</span>
<span class="go">        objects['timestamp']</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dists_and_speeds</span><span class="p">)</span>
<span class="go">                   distance          speed</span>
<span class="go">    trajectory_id</span>
<span class="go">    0                1000.0  100000.000000</span>
<span class="go">    1                1000.0  111111.109375</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="io">
<h2>IO<a class="headerlink" href="#io" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cuspatial.read_polygon_shapefile">
<code class="sig-prename descclassname"><span class="pre">cuspatial.</span></code><code class="sig-name descname"><span class="pre">read_polygon_shapefile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.read_polygon_shapefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads polygon geometry from an ESRI shapefile into GPU memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str, pathlike</span></dt><dd><p>ESRI Shapefile file path (usually ends in <code class="docutils literal notranslate"><span class="pre">.shp</span></code>)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">tuple (cudf.Series, cudf.Series, cudf.DataFrame)</span></dt><dd></dd>
<dt><strong>poly_offsets</strong><span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>Offsets of the first ring in each polygon</p>
</dd>
<dt><strong>ring_offsets</strong><span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>Offsets of the first point in each ring</p>
</dd>
<dt><strong>points</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>DataFrame of all points in the shapefile</dt><dd><dl class="simple">
<dt>x<span class="classifier">cudf.Series(dtype=np.float64)</span></dt><dd><p>x-components of each polygon’s points</p>
</dd>
<dt>y<span class="classifier">cudf.Series(dtype=np.float64)</span></dt><dd><p>y-components of each polygon’s points</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="p" class="btn btn-neutral float-left" href="index.html" rel="prev" title="Welcome to cuSpatial’s documentation!"><span aria-hidden="true" class="fa fa-arrow-circle-left"></span> Previous</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © Copyright 2019, NVIDIA.

    </p>
</div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>