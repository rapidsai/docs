<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcuspatial: cuSpatial C++ API Refactoring Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer="" src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcuspatial</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/nightly">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (22.10)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcuspatial/nightly">nightly (23.02)</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">stable (22.12)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuspatial/legacy">legacy (22.10)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">cuSpatial C++ API Refactoring Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The original cuSpatial C++ API (libcuspatial) was designed to depend on RAPIDS libcudf and use its core data types, especially <code>cudf::column</code>. For users who do not also use libcudf or other RAPIDS APIS, depending on libcudf could be a big barrier to adoption of libcuspatial. libcudf is a very large library and building it takes a lot of time.</p>
<p>Therefore, we are developing a standalone libcuspatial C++ API that does not depend on libcudf. This is a header-only template API with an iterator-based interface. This has a number of advantages</p>
<ol type="1">
<li>With a header-only API, users can include and build exactly what they use.</li>
<li>With a templated API, the API can be flexible to support a variety of basic data types, such as float and double for positional data, and different integer sizes for indices.</li>
<li>By templating on iterator types, cuSpatial algorithms can be fused with transformations of the input data, by using "fancy" iterators. Examples include transform iterators and counting iterators.</li>
<li>Memory resources only need to be part of APIs that allocate temporary intermediate storage. Output storage is allocated outside the API and an output iterator is passed as an argument.</li>
</ol>
<p>The main disadvantages of this type of API are</p>
<ol type="1">
<li>Header-only APIs can increase compilation time for code that depends on them.</li>
<li>Some users (especially our Python API) may prefer a cuDF-based API.</li>
</ol>
<p>The good news is that by maintaining the existing libcudf-based C++ API as a layer above the header- only libcuspatial API, we can avoid problem 1 and problem 2 for users of the legacy API.</p>
<h1><a class="anchor" id="autotoc_md77"></a>
Example API</h1>
<p>Following is an example iterator-based API for <code>cuspatial::haversine_distance</code>. (See below for discussion of API documentation.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class </span>LonLatItA,</div>
<div class="line">          <span class="keyword">class </span>LonLatItB,</div>
<div class="line">          <span class="keyword">class </span>OutputIt,</div>
<div class="line">          <span class="keyword">class </span>Location = <span class="keyword">typename</span> std::iterator_traits&lt;LonLatItA&gt;::value_type,</div>
<div class="line">          <span class="keyword">class </span>T        = <span class="keyword">typename</span> Location::value_type&gt;</div>
<div class="line">OutputIt <a class="code" href="group__distance.html#ga84eb7a8d22b290107e00e9000effe374">haversine_distance</a>(LonLatItA a_lonlat_first,</div>
<div class="line">                            LonLatItA a_lonlat_last,</div>
<div class="line">                            LonLatItB b_lonlat_first,</div>
<div class="line">                            OutputIt distance_first,</div>
<div class="line">                            T <span class="keyword">const</span> radius               = EARTH_RADIUS_KM,</div>
<div class="line">                            rmm::cuda_stream_view stream = rmm::cuda_stream_default);</div>
</div><!-- fragment --><p>There are a few key points to notice.</p>
<ol type="1">
<li>The API is very similar to STL algorithms such as <code>std::transform</code>.</li>
<li>All array inputs and outputs are iterator type templates.</li>
<li>Longitude/Latitude data is passed as array of structures, using the <code><a class="el" href="structcuspatial_1_1vec__2d.html" title="A generic 2D vector type.">cuspatial::vec_2d</a></code> type (<a class="el" href="vec__2d_8hpp.html">include/cuspatial/vec_2d.hpp</a>). This is enforced using a <code>static_assert</code> in the function body (discussed later).</li>
<li>The <code>Location</code> type is a template that is by default equal to the <code>value_type</code> of the input iterators.</li>
<li>The floating point type is a template (<code>T</code>) that is by default equal to the <code>value_type</code> of <code>Location</code>.</li>
<li>The iterator types for the two input ranges (A and B) are distinct templates. This is crucial to enable composition of fancy iterators that may be different types for A and B.</li>
<li>The size of the input and output ranges in the example API are equal, so the start and end of only the A range is provided (<code>a_lonlat_first</code> and <code>a_lonlat_last</code>). This mirrors STL APIs.</li>
<li>This API returns an iterator to the element past the last element written to the output. This is inspired by <code>std::transform</code>, even though as with <code>transform</code>, many uses of <code>haversine_distance</code> will not need this returned iterator.</li>
<li>All APIs that run CUDA device code (including Thrust algorithms) or allocate memory take a CUDA stream on which to execute the device code and allocate memory.</li>
</ol>
<h1><a class="anchor" id="autotoc_md78"></a>
Example Documentation</h1>
<p>Following is the (Doxygen) documentation for the above <code>cuspatial::haversine_distance</code>. </p><pre class="fragment">/**
 * @brief Compute haversine distances between points in set A to the corresponding points in set B.
 *
 * Computes N haversine distances, where N is `std::distance(a_lonlat_first, a_lonlat_last)`.
 * The distance for each `a_lonlat[i]` and `b_lonlat[i]` point pair is assigned to
 * `distance_first[i]`. `distance_first` must be an iterator to output storage allocated for N
 * distances.
 *
 * Computed distances will have the same units as `radius`.
 *
 * https://en.wikipedia.org/wiki/Haversine_formula
 *
 * @param[in]  a_lonlat_first: beginning of range of (longitude, latitude) locations in set A
 * @param[in]  a_lonlat_last: end of range of (longitude, latitude) locations in set A
 * @param[in]  b_lonlat_first: beginning of range of (longitude, latitude) locations in set B
 * @param[out] distance_first: beginning of output range of haversine distances
 * @param[in]  radius: radius of the sphere on which the points reside. default: 6371.0
 *            (approximate radius of Earth in km)
 * @param[in]  stream: The CUDA stream on which to perform computations and allocate memory.
 *
 * @tparam LonLatItA Iterator to input location set A. Must meet the requirements of
 * [LegacyRandomAccessIterator][LinkLRAI] and be device-accessible.
 * @tparam LonLatItB Iterator to input location set B. Must meet the requirements of
 * [LegacyRandomAccessIterator][LinkLRAI] and be device-accessible.
 * @tparam OutputIt Output iterator. Must meet the requirements of
 * [LegacyRandomAccessIterator][LinkLRAI] and be device-accessible.
 * @tparam Location The `value_type` of `LonLatItA` and `LonLatItB`. Must be `cuspatial::vec_2d&lt;T&gt;`.
 * @tparam T The underlying coordinate type. Must be a floating-point type.
 *
 * @pre `a_lonlat_first` may equal `distance_first`, but the range `[a_lonlat_first, a_lonlat_last)`
 * shall not overlap the range `[distance_first, distance_first + (a_lonlat_last - a_lonlat_last))
 * otherwise.
 * @pre `b_lonlat_first` may equal `distance_first`, but the range `[b_lonlat_first, b_lonlat_last)`
 * shall not overlap the range `[distance_first, distance_first + (b_lonlat_last - b_lonlat_last))
 * otherwise. 
 * @pre All iterators must have the same `Location` type, with  the same underlying floating-point
 * coordinate type (e.g. `cuspatial::vec_2d&lt;float&gt;`).
 *
 * @return Output iterator to the element past the last distance computed.
 *
 * [LinkLRAI]: https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator
 * "LegacyRandomAccessIterator"
 */
</pre><p>Key points:</p>
<ol type="1">
<li>Precisely and succinctly documents what the API computes, and provides references.</li>
<li>All parameters and all template parameters are documented.</li>
<li>States the C++ standard iterator concepts that must be implemented, and that iterators must be device-accessible.</li>
<li>Documents requirements as preconditions using <code>@pre</code>.</li>
<li>Uses preconditions to explicitly document what input ranges are allowed to overlap.</li>
<li>Documents the units of any inputs or outputs that have them.</li>
</ol>
<h1><a class="anchor" id="autotoc_md79"></a>
cuSpatial libcudf-based C++ API (legacy API)</h1>
<p>This is the existing API, unchanged by refactoring. Here is the existing <code>cuspatial::haversine_distance</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class </span>LonLatItA,</div>
<div class="line">          <span class="keyword">class </span>LonLatItB,</div>
<div class="line">          <span class="keyword">class </span>OutputIt,</div>
<div class="line">          <span class="keyword">class </span>T = <span class="keyword">typename</span> cuspatial::iterator_vec_base_type&lt;LonLatItA&gt;&gt;</div>
<div class="line">OutputIt <a class="code" href="group__distance.html#ga84eb7a8d22b290107e00e9000effe374">haversine_distance</a>(LonLatItA a_lonlat_first,</div>
<div class="line">                            LonLatItA a_lonlat_last,</div>
<div class="line">                            LonLatItB b_lonlat_first,</div>
<div class="line">                            OutputIt distance_first,</div>
<div class="line">                            T <span class="keyword">const</span> radius               = EARTH_RADIUS_KM,</div>
<div class="line">                            rmm::cuda_stream_view stream = rmm::cuda_stream_default);</div>
</div><!-- fragment --><p>key points:</p><ol type="1">
<li>All input data are <code>cudf::column_view</code>. This is a type-erased container so determining the type of data must be done at run time.</li>
<li>All inputs are arrays of scalars. Longitude and latitude are separate.</li>
<li>The output is a returned <code>unique_ptr&lt;cudf::column&gt;</code>.</li>
<li>The output is allocated inside the function using the passed memory resource.</li>
<li>The public API does not take a stream. There is a <code>detail</code> version of the API that takes a stream. This follows libcudf, and may change in the future.</li>
</ol>
<h1><a class="anchor" id="autotoc_md80"></a>
File Structure</h1>
<p>For now, libcuspatial APIs should be defined in a header file in the <code>cpp/include/cuspatial/experimental/</code> directory. Later, as we adopt the new API, we will rename the <code>experimental</code> directory. The API header should be named after the API. In the example, <code><a class="el" href="haversine_8hpp.html">haversine.hpp</a></code> defines the <code>cuspatial::haversine_distance</code> API.</p>
<p>The implementation must also be in a header, but should be in the <code>cuspatial/experimental/detail</code> directory. The implementation should be included from the API definition file, at the end of the file. Example:</p>
<div class="fragment"><div class="line">... <span class="comment">// declaration of API above this point</span></div>
<div class="line"><span class="preprocessor">#include &lt;cuspatial/experimental/detail/haversine.hpp&gt;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md81"></a>
Namespaces</h1>
<p>Public APIs are in the <code>cuspatial</code> namespace. Note that both the header-only API and the libcudf- based API can live in the same namespace, because they are non-ambiguous (very different parameters).</p>
<p>Implementation of the header-only API should be in a <code>cuspatial::detail</code> namespace.</p>
<h1><a class="anchor" id="autotoc_md82"></a>
Implementation</h1>
<p>The main implementation should be in detail headers.</p>
<h2><a class="anchor" id="autotoc_md83"></a>
Header-only API Implementation</h2>
<p>Because it is a statically typed API, the header-only implementation can be much simpler than the libcudf-based API, which requires run-time type dispatching. In the case of <code>haversine_distance</code>, it is a simple matter of a few static asserts and dynamic expectation checks, followed by a call to <code>thrust::transform</code> with a custom transform functor.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> LonLatItA, <span class="keyword">class</span> LonLatItB, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> T&gt;</div>
<div class="line">OutputIt <a class="code" href="group__distance.html#ga84eb7a8d22b290107e00e9000effe374">haversine_distance</a>(LonLatItA a_lonlat_first,</div>
<div class="line">                            LonLatItA a_lonlat_last,</div>
<div class="line">                            LonLatItB b_lonlat_first,</div>
<div class="line">                            OutputIt distance_first,</div>
<div class="line">                            T <span class="keyword">const</span> radius,</div>
<div class="line">                            rmm::cuda_stream_view stream)</div>
<div class="line">{</div>
<div class="line">  static_assert(is_same&lt;vec_2d&lt;T&gt;,</div>
<div class="line">                                cuspatial::iterator_value_type&lt;LonLatItA&gt;,</div>
<div class="line">                                cuspatial::iterator_value_type&lt;LonLatItB&gt;&gt;(),</div>
<div class="line">                <span class="stringliteral">"Inputs must be cuspatial::vec_2d"</span>);</div>
<div class="line">  static_assert(</div>
<div class="line">    is_same_floating_point&lt;T,</div>
<div class="line">                                   <span class="keyword">typename</span> cuspatial::iterator_vec_base_type&lt;LonLatItA&gt;,</div>
<div class="line">                                   <span class="keyword">typename</span> cuspatial::iterator_value_type&lt;OutputIt&gt;&gt;(),</div>
<div class="line">    <span class="stringliteral">"All iterator types and radius must have the same floating-point coordinate value type."</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="error_8hpp.html#ac62b6e15da5763cd1ae65f3845a697bc">CUSPATIAL_EXPECTS</a>(radius &gt; 0, <span class="stringliteral">"radius must be positive."</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> thrust::transform(rmm::exec_policy(stream),</div>
<div class="line">                           a_lonlat_first,</div>
<div class="line">                           a_lonlat_last,</div>
<div class="line">                           b_lonlat_first,</div>
<div class="line">                           distance_first,</div>
<div class="line">                           detail::haversine_distance_functor&lt;T&gt;(radius));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that we <code>static_assert</code> that the types of the iterator inputs match documented expectations. We also do a runtime check that the radius is positive. Finally we just call <code>thrust::transform</code>, passing it an instance of <code>haversine_distance_functor</code>, which is a function of two <code>vec_2d&lt;T&gt;</code> inputs that implements the Haversine distance formula.</p>
<h2><a class="anchor" id="autotoc_md84"></a>
libcudf-based API Implementation</h2>
<p>The substance of the refactoring is making the libcudf-based API a wrapper around the header-only API. This mostly involves replacing business logic implementation in the type-dispatched functor with a call to the header-only API. We also need to convert disjoint latitude and longitude inputs into <code>vec_2d&lt;T&gt;</code> structs. This is easily done using the <code>cuspatial::make_vec_2d_iterator</code> utility provided in <code>type_utils.hpp</code>.</p>
<p>So, to refactor the libcudf-based API, we remove the following code.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> input_tuple = thrust::make_tuple(thrust::make_constant_iterator(<span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(radius)),</div>
<div class="line">                                      a_lon.begin&lt;T&gt;(),</div>
<div class="line">                                      a_lat.begin&lt;T&gt;(),</div>
<div class="line">                                      b_lon.begin&lt;T&gt;(),</div>
<div class="line">                                      b_lat.begin&lt;T&gt;());</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> input_iter = thrust::make_zip_iterator(input_tuple);</div>
<div class="line"> </div>
<div class="line">thrust::transform(rmm::exec_policy(stream),</div>
<div class="line">                  input_iter,</div>
<div class="line">                  input_iter + result-&gt;size(),</div>
<div class="line">                  result-&gt;mutable_view().begin&lt;T&gt;(),</div>
<div class="line">                  [] __device__(<span class="keyword">auto</span> inputs) {</div>
<div class="line">                    <span class="keywordflow">return</span> calculate_haversine_distance(thrust::get&lt;0&gt;(inputs),</div>
<div class="line">                                                        thrust::get&lt;1&gt;(inputs),</div>
<div class="line">                                                        thrust::get&lt;2&gt;(inputs),</div>
<div class="line">                                                        thrust::get&lt;3&gt;(inputs),</div>
<div class="line">                                                        thrust::get&lt;4&gt;(inputs));</div>
<div class="line">                  });</div>
</div><!-- fragment --><p>And replace it with the following code.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lonlat_a = <a class="code" href="group__type__factories.html#gab634e2f29ae223f9a7f36a2d4a72ff0b">cuspatial::make_vec_2d_iterator</a>(a_lon.begin&lt;T&gt;(), a_lat.begin&lt;T&gt;());</div>
<div class="line"><span class="keyword">auto</span> lonlat_b = <a class="code" href="group__type__factories.html#gab634e2f29ae223f9a7f36a2d4a72ff0b">cuspatial::make_vec_2d_iterator</a>(b_lon.begin&lt;T&gt;(), b_lat.begin&lt;T&gt;());</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__distance.html#ga84eb7a8d22b290107e00e9000effe374">cuspatial::haversine_distance</a>(lonlat_a,</div>
<div class="line">                              lonlat_a + a_lon.size(),</div>
<div class="line">                              lonlat_b,</div>
<div class="line">                              <span class="keyword">static_cast&lt;</span>cudf::mutable_column_view<span class="keyword">&gt;</span>(*result).begin&lt;T&gt;(),</div>
<div class="line">                              T{radius},</div>
<div class="line">                              stream);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md85"></a>
Testing</h1>
<p>Existing libcudf-based API tests can mostly be left alone. New tests should be added to exercise the header-only API separately in case the libcudf-based API is removed.</p>
<p>Note that tests, like the header-only API, should not depend on libcudf or libcudf_test. The cuDF-based API made the mistake of depending on libcudf_test, which results in breakages of cuSpatial sometimes when libcudf_test changes. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aerror_8hpp_html_ac62b6e15da5763cd1ae65f3845a697bc"><div class="ttname"><a href="error_8hpp.html#ac62b6e15da5763cd1ae65f3845a697bc">CUSPATIAL_EXPECTS</a></div><div class="ttdeci">#define CUSPATIAL_EXPECTS(cond, reason)</div><div class="ttdoc">Macro for checking (pre-)conditions that throws an exception when a condition is violated.</div><div class="ttdef"><b>Definition:</b> <a href="error_8hpp_source.html#l00074">error.hpp:74</a></div></div>
<div class="ttc" id="agroup__type__factories_html_gab634e2f29ae223f9a7f36a2d4a72ff0b"><div class="ttname"><a href="group__type__factories.html#gab634e2f29ae223f9a7f36a2d4a72ff0b">cuspatial::make_vec_2d_iterator</a></div><div class="ttdeci">auto make_vec_2d_iterator(FirstIter first, SecondIter second)</div><div class="ttdoc">Create an iterator to vec_2d data from two input iterators.</div><div class="ttdef"><b>Definition:</b> <a href="iterator__factory_8cuh_source.html#l00151">iterator_factory.cuh:151</a></div></div>
<div class="ttc" id="agroup__distance_html_ga84eb7a8d22b290107e00e9000effe374"><div class="ttname"><a href="group__distance.html#ga84eb7a8d22b290107e00e9000effe374">cuspatial::haversine_distance</a></div><div class="ttdeci">std::unique_ptr&lt; cudf::column &gt; haversine_distance(cudf::column_view const &amp;a_lon, cudf::column_view const &amp;a_lat, cudf::column_view const &amp;b_lon, cudf::column_view const &amp;b_lat, double const radius=EARTH_RADIUS_KM, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Compute haversine distances between points in set A and the corresponding points in set B.</div></div>
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>