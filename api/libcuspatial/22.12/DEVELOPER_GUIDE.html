<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcuspatial: libcuspatial C++ Developer Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer="" src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcuspatial</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/legacy">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (22.12)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuspatial/nightly">nightly (22.12)</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">stable (22.10)</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/legacy">legacy (22.08)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libcuspatial C++ Developer Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_developer_guide_DEVELOPER_GUIDE"></a> This document serves as a guide for contributors to libcuspatial C++ code. Developers should also refer to these additional files for further documentation of libcuspatial best practices.</p>
<ul>
<li><a class="el" href="md_developer_guide_DOCUMENTATION.html">Documentation Guide</a> for guidelines on documenting libcuspatial code.</li>
<li><a class="el" href="md_developer_guide_TESTING.html">Testing Guide</a> for guidelines on writing unit tests.</li>
<li><a class="el" href="md_developer_guide_BENCHMARKING.html">Benchmarking Guide</a> for guidelines on writing unit benchmarks.</li>
<li><a class="el" href="md_developer_guide_REFACTORING_GUIDE.html">Refactoring Guide</a> for guidelines on refactoring legacy column-based APIs into header-only APIs.</li>
</ul>
<h1><a class="anchor" id="autotoc_md27"></a>
Overview</h1>
<p>libcuspatial is a C++ library that provides GPU-accelerated data-parallel algorithms for processing geospatial and spatiotemporal data. libcuspatial provides various spatial relationship algorithms including distance computation, containment (e.g. point-in-polygon testing), bounding box computations, and spatial indexing.</p>
<p>libcuspatial currently has two interfaces. The first is a C++ API based on data types from libcudf, (the <a href="https://github.com/rapidsai/cudf/">CUDA Dataframe library C++ API</a>). In this document we refer to it as the "column-based API". The column-based API represents spatial data as tables of type-erased columns.</p>
<p>The second API is the cuSpatial header-only C++ API, which is independent of libcudf and represents data as arrays of structures (e.g. 2D points). The header-only API uses iterators for input and output, and is similar in style to the C++ Standard Template Library (STL) and <a href="https://nvidia.github.io/thrust/">Thrust</a>.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Lexicon</h2>
<p>This section defines terminology used within libcuspatial. For terms specific to libcudf, such as Column, Table, etc., see the <a href="https://github.com/rapidsai/cudf/blob/main/cpp/docs/DEVELOPER_GUIDE.md#lexicon">libcudf developer guide</a>.</p>
<p>TODO: add terms</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Directory Structure and File Naming</h1>
<p>External/public libcuspatial APIs are grouped based on functionality into an appropriately titled header file in <code>cuspatial/cpp/include/cuspatial/</code>. For example, <code><a class="el" href="coordinate__transform_8hpp.html">cuspatial/cpp/include/cuspatial/coordinate_transform.hpp</a></code> contains the declarations of public API functions related to transforming coordinates. Note the <code>.hpp</code> file extension used to indicate a C++ header file that can be included from a <code>.cpp</code> source file.</p>
<p>Header files should use the <code>#pragma once</code> include guard.</p>
<p>The naming of public column-based cuSpatial API headers should be consistent with the name of the folder that contains the source files that implement the API. For example, the implementation of the APIs found in <code><a class="el" href="trajectory_8hpp.html">cuspatial/cpp/include/cuspatial/trajectory.hpp</a></code> are located in <code>cuspatial/src/trajectory</code>. This rule obviously does not apply to the header-only API, since the headers are the source files.</p>
<p>Likewise, unit tests reside in folders corresponding to the names of the API headers, e.g. <a class="el" href="trajectory_8hpp.html">trajectory.hpp</a> tests are in <code>cuspatial/tests/trajectory/</code>.</p>
<p>Internal API headers containing <code>detail</code> namespace definitions that are used across translation units inside libcuspatial should be placed in <code>include/cuspatial/detail</code>.</p>
<p>Note that (currently) header-only API files are in <code>include/cuspatial/experimental</code>, and their tests are in <code>tests/experimental</code>. When the header-only refactoring is complete these should be renamed or split into a separate library.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
File extensions</h2>
<ul>
<li><code>.hpp</code> : C++ header files</li>
<li><code>.cpp</code> : C++ source files</li>
<li><code>.cu</code> : CUDA C++ source files</li>
<li><code>.cuh</code> : Headers containing CUDA device code</li>
</ul>
<p>Only use <code>.cu</code> and <code>.cuh</code> if necessary. A good indicator is the inclusion of <code>__device__</code> and other symbols that are only recognized by <code>nvcc</code>. Another indicator is Thrust algorithm APIs with a device execution policy (always <code>rmm::exec_policy</code> in libcuspatial).</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Code and Documentation Style and Formatting</h2>
<p>libcuspatial code uses <a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> for all names except in a few cases: template parameters, unit tests and test case names may use Pascal case, aka <a href="https://en.wikipedia.org/wiki/Camel_case">UpperCamelCase</a>. We do not use <a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation</a>, except sometimes when naming device data variables and their corresponding host copies (e.g. <code>d_data</code> and <code>h_data</code>). Private member variables are typically prefixed with an underscore.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IteratorType&gt;</div>
<div class="line"><span class="keywordtype">void</span> algorithm_function(<span class="keywordtype">int</span> x, rmm::cuda_stream_view s, rmm::device_memory_resource* mr)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>utility_class</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">private:</div>
<div class="line">  <span class="keywordtype">int</span> _rating{};</div>
<div class="line">  std::unique_ptr&lt;rmm::device_uvector&gt; _data{};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> TestTypes = ::testing::Types&lt;float, double&gt;;</div>
<div class="line"> </div>
<div class="line">TYPED_TEST_SUITE(RepeatTypedTestFixture, TestTypes);</div>
<div class="line"> </div>
<div class="line">TYPED_TEST(RepeatTypedTestFixture, RepeatScalarCount)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>C++ formatting is enforced using <code>clang-format</code>. You should configure <code>clang-format</code> on your machine to use the <code>cuspatial/cpp/.clang-format</code> configuration file, and run <code>clang-format</code> on all changed code before committing it. The easiest way to do this is to configure your editor to "format on save", or to use <code>pre-commit</code>.</p>
<p>Aspects of code style not discussed in this document and not automatically enforceable are typically caught during code review, or not enforced.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
C++ Guidelines</h3>
<p>In general, we recommend following <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines</a>. We also recommend watching Sean Parent's <a href="https://www.youtube.com/watch?v=W2tWOdzgXHA">C++ Seasoning talk</a>, and we try to follow his rules: "No raw loops. No raw pointers. No raw synchronization primitives."</p>
<ul>
<li>Prefer algorithms from STL and Thrust to raw loops.</li>
<li>For device storage, prefer libcudf and RMM <a href="#libcuspatial-data-structures">owning data structures and views</a> to raw pointers and raw memory allocation. When pointers are used, prefer smart pointers (e.g. <code>std::shared_ptr</code> and <code>std::unique_ptr</code>) to raw pointers.</li>
<li>Prefer dispatching kernels to streams instead of explicit synchronization.</li>
</ul>
<p>Documentation is discussed in the <a class="el" href="md_developer_guide_DOCUMENTATION.html">Documentation Guide</a>.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Includes</h3>
<p>The following guidelines apply to organizing <code>#include</code> lines.</p>
<ul>
<li>Group includes by library (e.g. cuSpatial, RMM, Thrust, STL). <code>clang-format</code> will respect the groupings and sort the individual includes within a group lexicographically.</li>
<li>Separate groups by a blank line.</li>
<li>Order the groups from "nearest" to "farthest". In other words, local includes, then includes from other RAPIDS libraries, then includes from related libraries, like <code>&lt;thrust/...&gt;</code>, then includes from dependencies installed with cuSpatial, and then standard library headers (for example <code>&lt;string&gt;</code>, <code>&lt;iostream&gt;</code>).</li>
<li>Use <code>&lt;&gt;</code> instead of <code>""</code> unless the header is in the same directory as the source file.</li>
<li>Tools like <code>clangd</code> often auto-insert includes when they can, but they usually get the grouping and brackets wrong.</li>
<li>Always check that includes are only necessary for the file in which they are included. Try to avoid excessive including especially in header files. Double check this when you remove code.</li>
<li>Use quotes <code>"</code> to include local headers from the same relative source directory. This should only occur in source files and non-public header files. Otherwise use angle brackets <code>&lt;&gt;</code> around included header filenames.</li>
<li>Avoid relative paths with <code>..</code> when possible. Paths with <code>..</code> are necessary when including (internal) headers from source paths not in the same directory as the including file, because source paths are not passed with <code>-I</code>.</li>
<li>Avoid including library internal headers from non-internal files. For example, try not to include headers from libcuspatial <code>src</code> directories in tests or in libcuspatial public headers. If you find yourself doing this, start a discussion about moving (parts of) the included internal header to a public header.</li>
</ul>
<h1><a class="anchor" id="autotoc_md34"></a>
libcuspatial Data Structures</h1>
<p>The header-only libcuspatial API is agnostic to the type of containers used by the application to hold its data, because the header-only API is based on iterators (see <a href="#iterator-requirements">Iterator Requirements</a>). The cuDF-based cuSpatial API, on the other hand, uses cuDF Columns and Tables to store and access application data.</p>
<p>See the <a href="https://github.com/rapidsai/cudf/blob/main/cpp/docs/DEVELOPER_GUIDE.md#libcudf-data-structures">libcudf Developer guide</a> for more information on cuDF data structures, including views.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Views and Ownership</h2>
<p>Resource ownership is an essential concept in libcudf, and therefore in the cuDF-based libcuspatial API. In short, an "owning" object owns a resource (such as device memory). It acquires that resource during construction and releases the resource in destruction (<a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>). A "non-owning" object does not own resources. Any class in libcudf with the <code>*_view</code> suffix is non-owning. For more detail see the <a href="https://docs.google.com/presentation/d/1zKzAtc1AWFKfMhiUlV5yRZxSiPLwsObxMlWRWz_f5hA/edit?usp=sharing"><code>libcudf++</code> presentation.</a></p>
<p>cuDF-based libcuspatial functions typically take views as input (<code>column_view</code> or <code>table_view</code>) and produce <code>unique_ptr</code>s to owning objects as output. For example,</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;cudf::table&gt; <a class="code" href="group__spatial__relationship.html#gac6d17ba1201e752fbc6bd2770bb2fb2f">points_in_spatial_window</a>(</div>
<div class="line">  ...,</div>
<div class="line">  cudf::column_view <span class="keyword">const</span>&amp; x,</div>
<div class="line">  cudf::column_view <span class="keyword">const</span>&amp; y);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
RMM Memory Resources (&lt;tt&gt;rmm::device_memory_resource&lt;/tt&gt;)</h2>
<p>libcuspatial allocates all device memory via RMM memory resources (MR). See the <a href="https://github.com/rapidsai/rmm/blob/main/README.md">RMM documentation</a> for details.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
Current Device Memory Resource</h3>
<p>RMM provides a "default" memory resource for each device that can be accessed and updated via the <code>rmm::mr::get_current_device_resource()</code> and <code>rmm::mr::set_current_device_resource(...)</code> functions, respectively. All memory resource parameters should be defaulted to use the return value of <code>rmm::mr::get_current_device_resource()</code>.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
libcuspatial API and Implementation</h1>
<p>This section provides specifics about the structure and implementation of cuSpatial API functions.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Column-based cuSpatial API</h2>
<p>libcuspatial's column-based API is designed to integrate seamlessly with other RAPIDS libraries, notably cuDF. To that end, this API uses <code>cudf::column</code> and <code>cudf::table</code> data structures as input and output. This enables cuSpatial to provide Python and other language APIs (e.g. Java) that integrate seamlessly with the APIs of other RAPIDS libraries like cuDF and cuML. This allows users to integrate spatial data queries and transformations into end-to-end GPU-accelerated data analytics and machine learning workflows.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
Input/Output Style</h3>
<p>The preferred style for passing input to and returning output from column-based API functions is the following:</p>
<ul>
<li>Input parameters<ul>
<li>Columns:<ul>
<li><code>column_view const&amp;</code></li>
</ul>
</li>
<li>Tables:<ul>
<li><code>table_view const&amp;</code></li>
</ul>
</li>
<li>Scalar:<ul>
<li><code>scalar const&amp;</code></li>
</ul>
</li>
<li>Everything else:<ul>
<li>Trivial or inexpensively copied types<ul>
<li>Pass by value</li>
</ul>
</li>
<li>Non-trivial or expensive to copy types<ul>
<li>Pass by <code>const&amp;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Input/Output Parameters<ul>
<li>Columns:<ul>
<li><code>mutable_column_view&amp;</code></li>
</ul>
</li>
<li>Tables:<ul>
<li><code>mutable_table_view&amp;</code></li>
</ul>
</li>
<li>Everything else:<ul>
<li>Pass via raw pointer</li>
</ul>
</li>
</ul>
</li>
<li>Output<ul>
<li>Outputs should be <em>returned</em>, i.e., no output parameters</li>
<li>Columns:<ul>
<li><code>std::unique_ptr&lt;column&gt;</code></li>
</ul>
</li>
<li>Tables:<ul>
<li><code>std::unique_ptr&lt;table&gt;</code></li>
</ul>
</li>
<li>Scalars:<ul>
<li><code>std::unique_ptr&lt;scalar&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Here is an example column-based API function.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">std::unique_ptr&lt;cudf::column&gt; haversine_distance(</div>
<div class="line">  cudf::column_view const&amp; a_lon,</div>
<div class="line">  cudf::column_view const&amp; a_lat,</div>
<div class="line">  cudf::column_view const&amp; b_lon,</div>
<div class="line">  cudf::column_view const&amp; b_lat,</div>
<div class="line">  double const radius                 = EARTH_RADIUS_KM,</div>
<div class="line">  rmm::mr::device_memory_resource* mr = rmm::mr::get_current_device_resource());</div>
</div><!-- fragment --><p>key points:</p><ol type="1">
<li>All input data are <code>cudf::column_view</code>. This is a type-erased container so determining the type of data must be done at run time.</li>
<li>All inputs are arrays of scalars. Longitude and latitude are separate.</li>
<li>The output is a returned <code>unique_ptr&lt;cudf::column&gt;</code>.</li>
<li>The output is allocated inside the function using the passed memory resource.</li>
<li>The public API does not take a stream. There is a <code>detail</code> version of the API that takes a stream. This follows libcudf, and may change in the future.</li>
</ol>
<h3><a class="anchor" id="autotoc_md41"></a>
Multiple Return Values</h3>
<p>Sometimes it is necessary for functions to have multiple outputs. There are a few ways this can be done in C++ (including creating a <code>struct</code> for the output). One convenient way to do this is using <code>std::tie</code> and <code>std::pair</code>. Note that objects passed to <code>std::pair</code> will invoke either the copy constructor or the move constructor of the object, and it may be preferable to move non-trivially copyable objects (and required for types with deleted copy constructors, like <code>std::unique_ptr</code>).</p>
<p>Multiple column outputs that are functionally related (e.g. x- and y-coordinates), should be combined into a <code>table</code>.</p>
<div class="fragment"><div class="line">std::pair&lt;cudf::table, cudf::table&gt; return_two_tables(<span class="keywordtype">void</span>){</div>
<div class="line">  cudf::table out0;</div>
<div class="line">  cudf::table out1;</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Do stuff with out0, out1</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Return a std::pair of the two outputs</span></div>
<div class="line">  <span class="keywordflow">return</span> std::pair(std::move(out0), std::move(out1));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">cudf::table out0;</div>
<div class="line">cudf::table out1;</div>
<div class="line">std::tie(out0, out1) = return_two_outputs();</div>
</div><!-- fragment --><p>Note: <code>std::tuple</code> <em>could</em> be used if not for the fact that Cython does not support <code>std::tuple</code> Therefore, libcuspatial public column-based APIs must use <code>std::pair</code>, and are therefore limited to return only two objects of different types. Multiple objects of the same type may be returned via a <code>std::vector&lt;T&gt;</code>.</p>
<p>Alternatively, C++17 <a href="https://en.cppreference.com/w/cpp/language/structured_binding">structured binding</a> may be used to disaggregate multiple return values:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [out0, out1] = return_two_outputs();</div>
</div><!-- fragment --><p>Note that the compiler might not support capturing aliases defined in a structured binding in a lambda. One may work around this by using a capture with an initializer instead:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [out0, out1] = return_two_outputs();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Direct capture of alias from structured binding might fail with:</span></div>
<div class="line"><span class="comment">// "error: structured binding cannot be captured"</span></div>
<div class="line"><span class="comment">// auto foo = [out0]() {...};</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use an initializing capture:</span></div>
<div class="line"><span class="keyword">auto</span> foo = [&amp;out0 = out0] {</div>
<div class="line">  <span class="comment">// Use out0 to compute something.</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md42"></a>
Header-only cuSpatial API</h2>
<p>For C++ users and developers who do not also use libcudf or other RAPIDS APIS, depending on libcudf could be a barrier to adoption of libcuspatial. libcudf is a very large library and building it takes a lot of time.</p>
<p>Therefore, libcuspatial provides a header-only C++ API that does not depend on libcudf. The header-only API is an iterator-based interface. This has a number of advantages.</p>
<ol type="1">
<li>With a header-only API, users can include and build exactly what they use.</li>
<li>A template API can flexibly support a variety of basic data types, such as float and double for positional data, and different integer sizes for indices.</li>
<li>As with STL, iterators enable generic algorithms to be applied to arbitrary containers.</li>
<li>Iterators enable cuSpatial algorithms to be fused with transformations of the input data, by using "fancy" iterators. Examples include transform iterators and counting iterators.</li>
<li>Iterators enable the header-only cuSpatial API to use structured coordinate data (e.g. x,y coordinate pairs) while maintaining compatibility with the separate arrays of x and y coordinates required by the column-based API. This is accomplished with zip iterators. Internally, structured data (with arithmetic operators) enables clearer, more arithmetic code.</li>
<li>Memory resources only need to be part of APIs that allocate temporary intermediate storage. Output storage is allocated outside the API and an output iterator is passed as an argument.</li>
</ol>
<p>The main disadvantages of this type of API are</p>
<ol type="1">
<li>Header-only APIs can increase compilation time for code that depends on them.</li>
<li>Some users (especially the cuSpatial Python API) may prefer a cuDF-based API.</li>
</ol>
<p>The column-based C++ API is a simple layer above the header-only API. This approach protects column-based API users from the disadvantages while maintaining the advantages for users of the header-only API.</p>
<h3><a class="anchor" id="autotoc_md43"></a>
Input/Output Style</h3>
<p>All array inputs and outputs are iterator type templates to enable generic application of the APIs. An example function is helpful.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">template &lt;class LonLatItA,</div>
<div class="line">          class LonLatItB,</div>
<div class="line">          class OutputIt,</div>
<div class="line">          class T        = typename cuspatial::iterator_vec_base_type&lt;LonLatItA&gt;&gt;</div>
<div class="line">OutputIt haversine_distance(LonLatItA a_lonlat_first,</div>
<div class="line">                            LonLatItA a_lonlat_last,</div>
<div class="line">                            LonLatItB b_lonlat_first,</div>
<div class="line">                            OutputIt distance_first,</div>
<div class="line">                            T const radius               = EARTH_RADIUS_KM,</div>
<div class="line">                            rmm::cuda_stream_view stream = rmm::cuda_stream_default);</div>
</div><!-- fragment --><p>There are a few key points to notice.</p>
<ol type="1">
<li>The API is very similar to STL algorithms such as <code>std::transform</code>.</li>
<li>All array inputs and outputs are iterator type templates.</li>
<li>Longitude/Latitude data is passed as array of structures, using the <code><a class="el" href="structcuspatial_1_1vec__2d.html" title="A generic 2D vector type.">cuspatial::vec_2d</a>&lt;T&gt;</code> type (<a class="el" href="vec__2d_8hpp.html">include/cuspatial/vec_2d.hpp</a>). This is enforced using a <code>static_assert</code> in the function body.</li>
<li>The floating point type is a template (<code>T</code>) that is by default equal to the base <code>value_type</code> of the type iterated over by <code>LonLatItA</code>. libcuspatial provides the <code>iterator_vec_base_type</code> trait helper for this.</li>
<li>The iterator types for the two input ranges (A and B) are distinct templates. This is crucial to enable composition of fancy iterators that may be different types for A and B.</li>
<li>The size of the input and output ranges in the example API are equal, so the start and end of only the A range is provided (<code>a_lonlat_first</code> and <code>a_lonlat_last</code>). This mirrors STL APIs.</li>
<li>This API returns an iterator to the element past the last element written to the output. This is inspired by <code>std::transform</code>, even though as with <code>transform</code>, many uses of cuSpatial APIs will not need to use this returned iterator.</li>
<li>All APIs that run CUDA device code (including Thrust algorithms) or allocate memory take a CUDA stream on which to execute the device code and allocate memory.</li>
<li>Any API that allocate and return device data (not shown here) should also take an <code>rmm::device_memory_resource</code> to use for output memory allocation.</li>
</ol>
<h3><a class="anchor" id="autotoc_md44"></a>
(Multiple) Return Values</h3>
<p>Whenever possible in the header-only API, output data should be written to output iterators that reference data allocated by the caller of the API. In this case, multiple "return values" are simply written to multiple output iterators. Typically such APIs return an iterator one past the end of the primary output iterator (in the style of <code>std::transform()</code>.</p>
<p>In functions where the output size is data dependent, the API may allocate the output data and return it as a <code>rmm::device_uvector</code> or other data structure containing <code>device_uvector</code>s.</p>
<h3><a class="anchor" id="autotoc_md45"></a>
Iterator requirements</h3>
<p>All input and output iterators must be device-accessible with random access. They must satisfy the requirements of C++ <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a>. Output iterators must be mutable.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Streams</h2>
<p>CUDA streams are not yet exposed in public column-based libcuspatial APIs. header-only libcuspatial APIs that execute GPU work or allocate GPU memory should take a stream parameter.</p>
<p>In order to ease the transition to future use of streams in the public column-based API, all libcuspatial APIs that allocate device memory or execute GPU work (including kernels, Thrust algorithms, or anything that can take a stream) should be implemented using asynchronous APIs on the default stream (e.g., stream 0).</p>
<p>The recommended pattern for doing this is to make the definition of the external API invoke an internal API in the <code>detail</code> namespace. The internal <code>detail</code> API has the same parameters as the public API, plus a <code>rmm::cuda_stream_view</code> parameter at the end with no default value. If the detail API also accepts a memory resource parameter, the stream parameter should be ideally placed just <em>before</em> the memory resource. The public API will call the detail API and provide <code>rmm::cuda_stream_default</code>. The implementation should be wholly contained in the <code>detail</code> API definition and use only asynchronous versions of CUDA APIs with the stream parameter.</p>
<p>In order to make the <code>detail</code> API callable from other libcuspatial functions, it may be exposed in a header placed in the <code>cuspatial/cpp/include/detail/</code> directory.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="comment">// cpp/include/cuspatial/header.hpp</span></div>
<div class="line"><span class="keywordtype">void</span> external_function(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// cpp/include/cuspatial/detail/header.hpp</span></div>
<div class="line"><span class="keyword">namespace </span>detail{</div>
<div class="line"><span class="keywordtype">void</span> external_function(..., rmm::cuda_stream_view stream)</div>
<div class="line">} <span class="comment">// namespace detail</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// cuspatial/src/implementation.cpp</span></div>
<div class="line"><span class="keyword">namespace </span>detail{</div>
<div class="line">    <span class="comment">// Use the stream parameter in the detail implementation.</span></div>
<div class="line">    <span class="keywordtype">void</span> external_function(..., rmm::cuda_stream_view stream){</div>
<div class="line">        <span class="comment">// Implementation uses the stream with async APIs.</span></div>
<div class="line">        rmm::device_buffer buff(...,stream);</div>
<div class="line">        <a class="code" href="error_8hpp.html#acfc1039c29661ff7f37f5b83b2b7a6fd">CUSPATIAL_CUDA_TRY</a>(cudaMemcpyAsync(...,stream.value()));</div>
<div class="line">        kernel&lt;&lt;&lt;..., stream&gt;&gt;&gt;(...);</div>
<div class="line">        thrust::algorithm(rmm::exec_policy(stream), ...);</div>
<div class="line">    }</div>
<div class="line">} <span class="comment">// namespace detail</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> external_function(...){</div>
<div class="line">    CUSPATIAL_FUNC_RANGE(); <span class="comment">// Generates an NVTX range for the lifetime of this function.</span></div>
<div class="line">    detail::external_function(..., rmm::cuda_stream_default);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Note:</b> It is important to synchronize the stream if <em>and only if</em> it is necessary. For example, when a non-pointer value is returned from the API that is the result of an asynchronous device-to-host copy, the stream used for the copy should be synchronized before returning. However, when a column is returned, the stream should not be synchronized because doing so will break asynchrony if and when we add an asynchronous API to libcuspatial.</p>
<p><b>Note:</b> <code>cudaDeviceSynchronize()</code> should <em>never</em> be used. This limits the ability to do any multi-stream/multi-threaded work with libcuspatial APIs.</p>
<h3><a class="anchor" id="autotoc_md47"></a>
NVTX Ranges</h3>
<p>In order to aid in performance optimization and debugging, all compute intensive libcuspatial functions should have a corresponding NVTX range. In libcuspatial, we have a convenience macro <code>CUSPATIAL_FUNC_RANGE()</code> that automatically annotates the lifetime of the enclosing function and uses the function's name as the name of the NVTX range. For more information about NVTX, see <a href="https://github.com/NVIDIA/NVTX/tree/dev/cpp">here</a>.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
Stream Creation</h3>
<p>(Note: cuSpatial has not yet had the need for internal stream creation.) The following guidance is copied from libcudf's documentation. There may be times in implementing libcuspatial features where it would be advantageous to use streams <em>internally</em>, i.e., to accomplish overlap in implementing an algorithm. However, dynamically creating a stream can be expensive. RMM has a stream pool class to help avoid dynamic stream creation. However, this is not yet exposed in libcuspatial, so for the time being, libcuspatial features should avoid creating streams (even if it is slightly less efficient). It is a good idea to leave a <code>// TODO:</code> note indicating where using a stream would be beneficial.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Memory Allocation</h2>
<p>Device <a href="#rmmdevice_memory_resource">memory resources</a> are used in libcuspatial to abstract and control how device memory is allocated.</p>
<h3><a class="anchor" id="autotoc_md50"></a>
Output Memory</h3>
<p>Any libcuspatial API that allocates memory that is <em>returned</em> to a user must accept a pointer to a <code>device_memory_resource</code> as the last parameter. Inside the API, this memory resource must be used to allocate any memory for returned objects. It should therefore be passed into functions whose outputs will be returned. Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Returned `column` contains newly allocated memory,</span></div>
<div class="line"><span class="comment">// therefore the API must accept a memory resource pointer</span></div>
<div class="line">std::unique_ptr&lt;column&gt; returns_output_memory(</div>
<div class="line">  ..., rmm::device_memory_resource * mr = rmm::mr::get_current_device_resource());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This API does not allocate any new *output* memory, therefore</span></div>
<div class="line"><span class="comment">// a memory resource is unnecessary</span></div>
<div class="line"><span class="keywordtype">void</span> does_not_allocate_output_memory(...);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md51"></a>
Temporary Memory</h3>
<p>Not all memory allocated within a libcuspatial API is returned to the caller. Often algorithms must allocate temporary, scratch memory for intermediate results. Always use the default resource obtained from <code>rmm::mr::get_current_device_resource()</code> for temporary memory allocations. Example:</p>
<div class="fragment"><div class="line">rmm::device_buffer some_function(</div>
<div class="line">  ..., rmm::mr::device_memory_resource mr * = rmm::mr::get_current_device_resource()) {</div>
<div class="line">    rmm::device_buffer returned_buffer(..., mr); <span class="comment">// Returned buffer uses the passed in MR</span></div>
<div class="line">    ...</div>
<div class="line">    rmm::device_buffer temporary_buffer(...); <span class="comment">// Temporary buffer uses default MR</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">return</span> returned_buffer;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md52"></a>
Memory Management</h3>
<p>libcuspatial code eschews raw pointers and direct memory allocation. Use RMM classes built to use <a href="https://github.com/rapidsai/rmm/#device_memory_resource"><code>device_memory_resource</code></a> for device memory allocation with automated lifetime management.</p>
<h4><a class="anchor" id="autotoc_md53"></a>
rmm::device_buffer</h4>
<p>Allocates a specified number of bytes of untyped, uninitialized device memory using a <code>device_memory_resource</code>. If no resource is explicitly provided, uses <code>rmm::mr::get_current_device_resource()</code>.</p>
<p><code>rmm::device_buffer</code> is movable and copyable on a stream. A copy performs a deep copy of the <code>device_buffer</code>'s device memory on the specified stream, whereas a move moves ownership of the device memory from one <code>device_buffer</code> to another.</p>
<div class="fragment"><div class="line"><span class="comment">// Allocates at least 100 bytes of uninitialized device memory</span></div>
<div class="line"><span class="comment">// using the specified resource and stream</span></div>
<div class="line">rmm::device_buffer buff(100, stream, mr);</div>
<div class="line"><span class="keywordtype">void</span> * raw_data = buff.data(); <span class="comment">// Raw pointer to underlying device memory</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deep copies `buff` into `copy` on `stream`</span></div>
<div class="line">rmm::device_buffer copy(buff, stream);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Moves contents of `buff` into `moved_to`</span></div>
<div class="line">rmm::device_buffer moved_to(std::move(buff));</div>
<div class="line"> </div>
<div class="line">custom_memory_resource *mr...;</div>
<div class="line"><span class="comment">// Allocates 100 bytes from the custom_memory_resource</span></div>
<div class="line">rmm::device_buffer custom_buff(100, mr, stream);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md54"></a>
rmm::device_scalar&lt;T&gt;</h4>
<p>Allocates a single element of the specified type initialized to the specified value. Use this for scalar input/outputs into device kernels, e.g., reduction results, null count, etc. This is effectively a convenience wrapper around a <code>rmm::device_vector&lt;T&gt;</code> of length 1.</p>
<div class="fragment"><div class="line"><span class="comment">// Allocates device memory for a single int using the specified resource and stream</span></div>
<div class="line"><span class="comment">// and initializes the value to 42</span></div>
<div class="line">rmm::device_scalar&lt;int&gt; int_scalar{42, stream, mr};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// scalar.data() returns pointer to value in device memory</span></div>
<div class="line">kernel&lt;&lt;&lt;...&gt;&gt;&gt;(int_scalar.data(),...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// scalar.value() synchronizes the scalar's stream and copies the</span></div>
<div class="line"><span class="comment">// value from device to host and returns the value</span></div>
<div class="line"><span class="keywordtype">int</span> host_value = int_scalar.value();</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md55"></a>
rmm::device_vector&lt;T&gt;</h4>
<p>Allocates a specified number of elements of the specified type. If no initialization value is provided, all elements are default initialized (this incurs a kernel launch).</p>
<p><b>Note</b>: (TODO: this not true yet in libcuspatial but we should strive for it. The following is copied from libcudf's developer guide.) We have removed all usage of <code>rmm::device_vector</code> and <code>thrust::device_vector</code> from libcuspatial, and you should not use it in new code in libcuspatial without careful consideration. Instead, use <code>rmm::device_uvector</code> along with the utility factories in <code>device_factories.hpp</code>. These utilities enable creation of <code>uvector</code>s from host-side vectors, or creating zero-initialized <code>uvector</code>s, so that they are as convenient to use as <code>device_vector</code>. Avoiding <code>device_vector</code> has a number of benefits, as described in the following section on <code>rmm::device_uvector</code>.</p>
<h4><a class="anchor" id="autotoc_md56"></a>
rmm::device_uvector&lt;T&gt;</h4>
<p>Similar to a <code>device_vector</code>, allocates a contiguous set of elements in device memory but with key differences:</p><ul>
<li>As an optimization, elements are uninitialized and no synchronization occurs at construction. This limits the types <code>T</code> to trivially copyable types.</li>
<li>All operations are stream-ordered (i.e., they accept a <code>cuda_stream_view</code> specifying the stream on which the operation is performed). This improves safety when using non-default streams.</li>
<li><code>device_uvector.hpp</code> does not include any <code>__device__</code> code, unlike <code>thrust/device_vector.hpp</code>, which means <code>device_uvector</code>s can be used in <code>.cpp</code> files, rather than just in <code>.cu</code> files.</li>
</ul>
<div class="fragment"><div class="line">cuda_stream s;</div>
<div class="line"><span class="comment">// Allocates uninitialized storage for 100 `int32_t` elements on stream `s` using the</span></div>
<div class="line"><span class="comment">// default resource</span></div>
<div class="line">rmm::device_uvector&lt;int32_t&gt; v(100, s);</div>
<div class="line"><span class="comment">// Initializes the elements to 0</span></div>
<div class="line">thrust::uninitialized_fill(thrust::cuda::par.on(s.value()), v.begin(), v.end(), int32_t{0});</div>
<div class="line"> </div>
<div class="line">rmm::mr::device_memory_resource * mr = <span class="keyword">new</span> my_custom_resource{...};</div>
<div class="line"><span class="comment">// Allocates uninitialized storage for 100 `int32_t` elements on stream `s` using the resource `mr`</span></div>
<div class="line">rmm::device_uvector&lt;int32_t&gt; v2{100, s, mr};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md57"></a>
Namespaces</h2>
<h3><a class="anchor" id="autotoc_md58"></a>
External</h3>
<p>All public libcuspatial APIs should be placed in the <code>cuspatial</code> namespace. Example: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>cuspatial{</div>
<div class="line">   <span class="keywordtype">void</span> public_function(...);</div>
<div class="line">} <span class="comment">// namespace cuspatial</span></div>
</div><!-- fragment --><p>The top-level <code>cuspatial</code> namespace is sufficient for most of the public API. However, to logically group a broad set of functions, further namespaces may be used.</p>
<h3><a class="anchor" id="autotoc_md59"></a>
Internal</h3>
<p>Many functions are not meant for public use, so place them in either the <code>detail</code> or an <em>anonymous</em> namespace, depending on the situation.</p>
<h4><a class="anchor" id="autotoc_md60"></a>
detail namespace</h4>
<p>Functions or objects that will be used across <em>multiple</em> translation units (i.e., source files), should be exposed in an internal header file and placed in the <code>detail</code> namespace. Example:</p>
<div class="fragment"><div class="line"><span class="comment">// some_utilities.hpp</span></div>
<div class="line"><span class="keyword">namespace </span>cuspatial{</div>
<div class="line"><span class="keyword">namespace </span>detail{</div>
<div class="line"><span class="keywordtype">void</span> reusable_helper_function(...);</div>
<div class="line">} <span class="comment">// namespace detail</span></div>
<div class="line">} <span class="comment">// namespace cuspatial</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md61"></a>
Anonymous namespace</h4>
<p>Functions or objects that will only be used in a <em>single</em> translation unit should be defined in an <em>anonymous</em> namespace in the source file where it is used. Example:</p>
<div class="fragment"><div class="line"><span class="comment">// some_file.cpp</span></div>
<div class="line"><span class="keyword">namespace</span>{</div>
<div class="line"><span class="keywordtype">void</span> isolated_helper_function(...);</div>
<div class="line">} <span class="comment">// anonymous namespace</span></div>
</div><!-- fragment --><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL59-CPP.+Do+not+define+an+unnamed+namespace+in+a+header+file"><b>Anonymous namespaces should <em>never</em> be used in a header file.</b></a></p>
<h1><a class="anchor" id="autotoc_md62"></a>
Deprecating and Removing Code</h1>
<p>libcuspatial is constantly evolving to improve performance and better meet our users' needs. As a result, we occasionally need to break or entirely remove APIs to respond to new and improved understanding of the functionality we provide. Remaining free to do this is essential to making libcuspatial an agile library that can rapidly accommodate our users needs. As a result, we do not always provide a warning or any lead time prior to releasing breaking changes. On a best effort basis, the libcuspatial team will notify users of changes that we expect to have significant or widespread effects.</p>
<p>Where possible, indicate pending API removals using the <a href="https://en.cppreference.com/w/cpp/language/attributes/deprecated">deprecated</a> attribute and document them using Doxygen's <a href="https://www.doxygen.nl/manual/commands.html#cmddeprecated">deprecated</a> command prior to removal. When a replacement API is available for a deprecated API, mention the replacement in both the deprecation message and the deprecation documentation. Pull requests that introduce deprecations should be labeled "deprecation" to facilitate discovery and removal in the subsequent release.</p>
<p>Advertise breaking changes by labeling any pull request that breaks or removes an existing API with the "breaking" tag. This ensures that the "Breaking" section of the release notes includes a description of what has broken from the past release. Label pull requests that contain deprecations with the "non-breaking" tag.</p>
<h1><a class="anchor" id="autotoc_md63"></a>
Error Handling</h1>
<p>libcuspatial follows conventions (and provides utilities) enforcing compile-time and run-time conditions and detecting and handling CUDA errors. Communication of errors is always via C++ exceptions.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Runtime Conditions</h2>
<p>Use the <code>CUSPATIAL_EXPECTS</code> macro to enforce runtime conditions necessary for correct execution.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code" href="error_8hpp.html#ac62b6e15da5763cd1ae65f3845a697bc">CUSPATIAL_EXPECTS</a>(lhs.type() == rhs.type(), <span class="stringliteral">"Column type mismatch"</span>);</div>
</div><!-- fragment --><p>The first argument is the conditional expression expected to resolve to <code>true</code> under normal conditions. If the conditional evaluates to <code>false</code>, then an error has occurred and an instance of <code><a class="el" href="structcuspatial_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cuspatial::logic_error</a></code> is thrown. The second argument to <code>CUSPATIAL_EXPECTS</code> is a short description of the error that has occurred and is used for the exception's <code>what()</code> message.</p>
<p>There are times where a particular code path, if reached, should indicate an error no matter what. For example, often the <code>default</code> case of a <code>switch</code> statement represents an invalid alternative. Use the <code>CUSPATIAL_FAIL</code> macro for such errors. This is effectively the same as calling <code><a class="el" href="error_8hpp.html#ac62b6e15da5763cd1ae65f3845a697bc" title="Macro for checking (pre-)conditions that throws an exception when a condition is violated.">CUSPATIAL_EXPECTS(false, reason)</a></code>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="error_8hpp.html#ae11b6562fe29fefbd9255c33b879c0b3">CUSPATIAL_FAIL</a>(<span class="stringliteral">"This code path should not be reached."</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md65"></a>
CUDA Error Checking</h3>
<p>Use the <code>CUSPATIAL_CUDA_TRY</code> macro to check for the successful completion of CUDA runtime API functions. This macro throws a <code><a class="el" href="structcuspatial_1_1cuda__error.html" title="Exception thrown when a CUDA error is encountered.">cuspatial::cuda_error</a></code> exception if the CUDA API return value is not <code>cudaSuccess</code>. The thrown exception includes a description of the CUDA error code in its <code>what()</code> message.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="error_8hpp.html#acfc1039c29661ff7f37f5b83b2b7a6fd">CUSPATIAL_CUDA_TRY</a>( cudaMemcpy(&amp;dst, &amp;src, num_bytes) );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
Compile-Time Conditions</h2>
<p>Use <code>static_assert</code> to enforce compile-time conditions. For example,</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> trivial_types_only(T t){</div>
<div class="line">  static_assert(std::is_trivial&lt;T&gt;::value, <span class="stringliteral">"This function requires a trivial type."</span>);</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md67"></a>
Data Types</h1>
<p>Columns may contain data of a number of types. cuDF supports a variety of types that are not used in cuSpatial. cuSpatial functions mostly operate on numeric and timestamp data. For more information on libcudf data types see the <a href="https://github.com/rapidsai/cudf/blob/main/cpp/docs/DEVELOPER_GUIDE.md#data-types">libcudf developer guide</a>.</p>
<h1><a class="anchor" id="autotoc_md68"></a>
Type Dispatcher</h1>
<p><code>cudf::column</code> stores data (for columns and scalars) "type erased" in <code>void*</code> device memory. This <em>type-erasure</em> enables interoperability with other languages and type systems, such as Python and Java. In order to determine the type, functions must use the run-time information stored in the column <code>type()</code> to reconstruct the data type <code>T</code> by casting the <code>void*</code> to the appropriate <code>T*</code>.</p>
<p>This so-called <em>type dispatch</em> is pervasive throughout libcudf and the column-based libcuspatial API. The <code>cudf::type_dispatcher</code> is a central utility that automates the process of mapping the runtime type information in <code>data_type</code> to a concrete C++ type. See the <a href="https://github.com/rapidsai/cudf/blob/main/cpp/docs/DEVELOPER_GUIDE.md#type-dispatcher">libcudf developer guide</a> for more information. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aerror_8hpp_html_ac62b6e15da5763cd1ae65f3845a697bc"><div class="ttname"><a href="error_8hpp.html#ac62b6e15da5763cd1ae65f3845a697bc">CUSPATIAL_EXPECTS</a></div><div class="ttdeci">#define CUSPATIAL_EXPECTS(cond, reason)</div><div class="ttdoc">Macro for checking (pre-)conditions that throws an exception when a condition is violated.</div><div class="ttdef"><b>Definition:</b> <a href="error_8hpp_source.html#l00074">error.hpp:74</a></div></div>
<div class="ttc" id="agroup__spatial__relationship_html_gac6d17ba1201e752fbc6bd2770bb2fb2f"><div class="ttname"><a href="group__spatial__relationship.html#gac6d17ba1201e752fbc6bd2770bb2fb2f">cuspatial::points_in_spatial_window</a></div><div class="ttdeci">std::unique_ptr&lt; cudf::table &gt; points_in_spatial_window(double window_min_x, double window_max_x, double window_min_y, double window_max_y, cudf::column_view const &amp;x, cudf::column_view const &amp;y, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Find all points (x,y) that fall within a rectangular query window.</div></div>
<div class="ttc" id="aerror_8hpp_html_ae11b6562fe29fefbd9255c33b879c0b3"><div class="ttname"><a href="error_8hpp.html#ae11b6562fe29fefbd9255c33b879c0b3">CUSPATIAL_FAIL</a></div><div class="ttdeci">#define CUSPATIAL_FAIL(reason)</div><div class="ttdoc">Indicates that an erroneous code path has been taken.</div><div class="ttdef"><b>Definition:</b> <a href="error_8hpp_source.html#l00092">error.hpp:92</a></div></div>
<div class="ttc" id="aerror_8hpp_html_acfc1039c29661ff7f37f5b83b2b7a6fd"><div class="ttname"><a href="error_8hpp.html#acfc1039c29661ff7f37f5b83b2b7a6fd">CUSPATIAL_CUDA_TRY</a></div><div class="ttdeci">#define CUSPATIAL_CUDA_TRY(call)</div><div class="ttdoc">Error checking macro for CUDA runtime API functions.</div><div class="ttdef"><b>Definition:</b> <a href="error_8hpp_source.html#l00116">error.hpp:116</a></div></div>
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>