<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcuspatial: Spatial Relationship</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcuspatial</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">stable (23.02)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcuspatial/nightly">nightly (23.04)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuspatial/stable">stable (23.02)</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/legacy">legacy (22.12)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Spatial Relationship<div class="ingroups"><a class="el" href="group__spatial__api.html">Spatial APIs</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>APIs related to spatial relationship.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:point__in__polygon_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="point__in__polygon_8hpp.html">point_in_polygon.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:point__in__polygon_8cuh"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="point__in__polygon_8cuh.html">point_in_polygon.cuh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:polygon__bounding__box_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polygon__bounding__box_8hpp.html">polygon_bounding_box.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:linestring__bounding__box_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="linestring__bounding__box_8hpp.html">linestring_bounding_box.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:spatial__window_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spatial__window_8hpp.html">spatial_window.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga232cdb60292ea4a9aad0eae0cef679b9"><td class="memTemplParams" colspan="2">template&lt;typename IdInputIt , typename PointInputIt , typename BoundingBoxOutputIt , typename T  = iterator_vec_base_type&lt;PointInputIt&gt;&gt; </td></tr>
<tr class="memitem:ga232cdb60292ea4a9aad0eae0cef679b9"><td align="right" class="memTemplItemLeft" valign="top">BoundingBoxOutputIt&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#ga232cdb60292ea4a9aad0eae0cef679b9">cuspatial::point_bounding_boxes</a> (IdInputIt ids_first, IdInputIt ids_last, PointInputIt points_first, BoundingBoxOutputIt bounding_boxes_first, T expansion_radius=T{0}, rmm::cuda_stream_view stream=rmm::cuda_stream_default)</td></tr>
<tr class="memdesc:ga232cdb60292ea4a9aad0eae0cef679b9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the spatial bounding boxes of sequences of points.  <a href="group__spatial__relationship.html#ga232cdb60292ea4a9aad0eae0cef679b9">More...</a><br></td></tr>
<tr class="separator:ga232cdb60292ea4a9aad0eae0cef679b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga840f056255521b594ff76dcfecea2420"><td class="memTemplParams" colspan="2">template&lt;class LinestringOffsetIterator , class VertexIterator , class BoundingBoxIterator , class T  = iterator_vec_base_type&lt;VertexIterator&gt;, class IndexT  = iterator_value_type&lt;LinestringOffsetIterator&gt;&gt; </td></tr>
<tr class="memitem:ga840f056255521b594ff76dcfecea2420"><td align="right" class="memTemplItemLeft" valign="top">BoundingBoxIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#ga840f056255521b594ff76dcfecea2420">cuspatial::linestring_bounding_boxes</a> (LinestringOffsetIterator linestring_offsets_first, LinestringOffsetIterator linestring_offsets_last, VertexIterator linestring_vertices_first, VertexIterator linestring_vertices_last, BoundingBoxIterator bounding_boxes_first, T expansion_radius=T{0}, rmm::cuda_stream_view stream=rmm::cuda_stream_default)</td></tr>
<tr class="memdesc:ga840f056255521b594ff76dcfecea2420"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute minimum bounding box for each linestring.  <a href="group__spatial__relationship.html#ga840f056255521b594ff76dcfecea2420">More...</a><br></td></tr>
<tr class="separator:ga840f056255521b594ff76dcfecea2420"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga19ebc8167e1c8f5da623a62bb93e4160"><td class="memTemplParams" colspan="2">template&lt;class Cart2dItA , class Cart2dItB , class OffsetIteratorA , class OffsetIteratorB , class OutputIt &gt; </td></tr>
<tr class="memitem:ga19ebc8167e1c8f5da623a62bb93e4160"><td align="right" class="memTemplItemLeft" valign="top">OutputIt&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#ga19ebc8167e1c8f5da623a62bb93e4160">cuspatial::pairwise_point_in_polygon</a> (Cart2dItA test_points_first, Cart2dItA test_points_last, OffsetIteratorA polygon_offsets_first, OffsetIteratorA polygon_offsets_last, OffsetIteratorB poly_ring_offsets_first, OffsetIteratorB poly_ring_offsets_last, Cart2dItB polygon_points_first, Cart2dItB polygon_points_last, OutputIt output, rmm::cuda_stream_view stream=rmm::cuda_stream_default)</td></tr>
<tr class="memdesc:ga19ebc8167e1c8f5da623a62bb93e4160"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given (point, polygon) pairs, tests whether the point of each pair is inside the polygon of the pair.  <a href="group__spatial__relationship.html#ga19ebc8167e1c8f5da623a62bb93e4160">More...</a><br></td></tr>
<tr class="separator:ga19ebc8167e1c8f5da623a62bb93e4160"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaa85dc3aafb04c02e6dca08edccf6fd92"><td class="memTemplParams" colspan="2">template&lt;class Cart2dItA , class Cart2dItB , class OffsetIteratorA , class OffsetIteratorB , class OutputIt &gt; </td></tr>
<tr class="memitem:gaa85dc3aafb04c02e6dca08edccf6fd92"><td align="right" class="memTemplItemLeft" valign="top">OutputIt&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#gaa85dc3aafb04c02e6dca08edccf6fd92">cuspatial::point_in_polygon</a> (Cart2dItA test_points_first, Cart2dItA test_points_last, OffsetIteratorA polygon_offsets_first, OffsetIteratorA polygon_offsets_last, OffsetIteratorB poly_ring_offsets_first, OffsetIteratorB poly_ring_offsets_last, Cart2dItB polygon_points_first, Cart2dItB polygon_points_last, OutputIt output, rmm::cuda_stream_view stream=rmm::cuda_stream_default)</td></tr>
<tr class="memdesc:gaa85dc3aafb04c02e6dca08edccf6fd92"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests whether the specified points are inside any of the specified polygons.  <a href="group__spatial__relationship.html#gaa85dc3aafb04c02e6dca08edccf6fd92">More...</a><br></td></tr>
<tr class="separator:gaa85dc3aafb04c02e6dca08edccf6fd92"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3dddce88ff610262003b49d68b6d51cc"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class T &gt; </td></tr>
<tr class="memitem:ga3dddce88ff610262003b49d68b6d51cc"><td align="right" class="memTemplItemLeft" valign="top">thrust::iterator_traits&lt; InputIt &gt;::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#ga3dddce88ff610262003b49d68b6d51cc">cuspatial::count_points_in_range</a> (<a class="el" href="classcuspatial_1_1vec__2d.html">vec_2d</a>&lt; T &gt; vertex_1, <a class="el" href="classcuspatial_1_1vec__2d.html">vec_2d</a>&lt; T &gt; vertex_2, InputIt points_first, InputIt points_last, rmm::cuda_stream_view stream=rmm::cuda_stream_default)</td></tr>
<tr class="memdesc:ga3dddce88ff610262003b49d68b6d51cc"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count of points (x,y) that fall within a query range.  <a href="group__spatial__relationship.html#ga3dddce88ff610262003b49d68b6d51cc">More...</a><br></td></tr>
<tr class="separator:ga3dddce88ff610262003b49d68b6d51cc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaabc1e4b45fbe5c8bd0473b97fe94d5fd"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class OutputIt , class T &gt; </td></tr>
<tr class="memitem:gaabc1e4b45fbe5c8bd0473b97fe94d5fd"><td align="right" class="memTemplItemLeft" valign="top">OutputIt&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#gaabc1e4b45fbe5c8bd0473b97fe94d5fd">cuspatial::copy_points_in_range</a> (<a class="el" href="classcuspatial_1_1vec__2d.html">vec_2d</a>&lt; T &gt; vertex_1, <a class="el" href="classcuspatial_1_1vec__2d.html">vec_2d</a>&lt; T &gt; vertex_2, InputIt points_first, InputIt points_last, OutputIt output_points_first, rmm::cuda_stream_view stream=rmm::cuda_stream_default)</td></tr>
<tr class="memdesc:gaabc1e4b45fbe5c8bd0473b97fe94d5fd"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies points (x,y) that fall within a query range.  <a href="group__spatial__relationship.html#gaabc1e4b45fbe5c8bd0473b97fe94d5fd">More...</a><br></td></tr>
<tr class="separator:gaabc1e4b45fbe5c8bd0473b97fe94d5fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gac53138f1eb9fa9e47ffcafc886256305"><td class="memTemplParams" colspan="2">template&lt;class PolygonOffsetIterator , class RingOffsetIterator , class VertexIterator , class BoundingBoxIterator , class T  = iterator_vec_base_type&lt;VertexIterator&gt;, class IndexT  = iterator_value_type&lt;PolygonOffsetIterator&gt;&gt; </td></tr>
<tr class="memitem:gac53138f1eb9fa9e47ffcafc886256305"><td align="right" class="memTemplItemLeft" valign="top">BoundingBoxIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#gac53138f1eb9fa9e47ffcafc886256305">cuspatial::polygon_bounding_boxes</a> (PolygonOffsetIterator polygon_offsets_first, PolygonOffsetIterator polygon_offsets_last, RingOffsetIterator polygon_ring_offsets_first, RingOffsetIterator polygon_ring_offsets_last, VertexIterator polygon_vertices_first, VertexIterator polygon_vertices_last, BoundingBoxIterator bounding_boxes_first, T expansion_radius=T{0}, rmm::cuda_stream_view stream=rmm::cuda_stream_default)</td></tr>
<tr class="memdesc:gac53138f1eb9fa9e47ffcafc886256305"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute minimum bounding box for each polygon.  <a href="group__spatial__relationship.html#gac53138f1eb9fa9e47ffcafc886256305">More...</a><br></td></tr>
<tr class="separator:gac53138f1eb9fa9e47ffcafc886256305"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga99c52b855579395f6df48bd6601e2276"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; cudf::table &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#ga99c52b855579395f6df48bd6601e2276">cuspatial::linestring_bounding_boxes</a> (cudf::column_view const &amp;linestring_offsets, cudf::column_view const &amp;x, cudf::column_view const &amp;y, double expansion_radius, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga99c52b855579395f6df48bd6601e2276"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute minimum bounding boxes of a set of linestrings and an expansion radius.  <a href="group__spatial__relationship.html#ga99c52b855579395f6df48bd6601e2276">More...</a><br></td></tr>
<tr class="separator:ga99c52b855579395f6df48bd6601e2276"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga69d996594e4bfe249ae4608ad9d70642"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; cudf::column &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#ga69d996594e4bfe249ae4608ad9d70642">cuspatial::pairwise_point_in_polygon</a> (cudf::column_view const &amp;test_points_x, cudf::column_view const &amp;test_points_y, cudf::column_view const &amp;poly_offsets, cudf::column_view const &amp;poly_ring_offsets, cudf::column_view const &amp;poly_points_x, cudf::column_view const &amp;poly_points_y, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga69d996594e4bfe249ae4608ad9d70642"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given (point, polygon pairs), tests whether the point of each pair is inside the polygon of the pair.  <a href="group__spatial__relationship.html#ga69d996594e4bfe249ae4608ad9d70642">More...</a><br></td></tr>
<tr class="separator:ga69d996594e4bfe249ae4608ad9d70642"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga889dbc7d657fd83ba40dc572a94a5e48"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; cudf::column &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#ga889dbc7d657fd83ba40dc572a94a5e48">cuspatial::point_in_polygon</a> (cudf::column_view const &amp;test_points_x, cudf::column_view const &amp;test_points_y, cudf::column_view const &amp;poly_offsets, cudf::column_view const &amp;poly_ring_offsets, cudf::column_view const &amp;poly_points_x, cudf::column_view const &amp;poly_points_y, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga889dbc7d657fd83ba40dc572a94a5e48"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests whether the specified points are inside any of the specified polygons.  <a href="group__spatial__relationship.html#ga889dbc7d657fd83ba40dc572a94a5e48">More...</a><br></td></tr>
<tr class="separator:ga889dbc7d657fd83ba40dc572a94a5e48"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga7204b7f4b27b3883e97d6b5bc6322457"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; cudf::table &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#ga7204b7f4b27b3883e97d6b5bc6322457">cuspatial::polygon_bounding_boxes</a> (cudf::column_view const &amp;poly_offsets, cudf::column_view const &amp;ring_offsets, cudf::column_view const &amp;x, cudf::column_view const &amp;y, double expansion_radius=0.0, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7204b7f4b27b3883e97d6b5bc6322457"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute minimum bounding box for each polygon in a list.  <a href="group__spatial__relationship.html#ga7204b7f4b27b3883e97d6b5bc6322457">More...</a><br></td></tr>
<tr class="separator:ga7204b7f4b27b3883e97d6b5bc6322457"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gac6d17ba1201e752fbc6bd2770bb2fb2f"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; cudf::table &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spatial__relationship.html#gac6d17ba1201e752fbc6bd2770bb2fb2f">cuspatial::points_in_spatial_window</a> (double window_min_x, double window_max_x, double window_min_y, double window_max_y, cudf::column_view const &amp;x, cudf::column_view const &amp;y, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac6d17ba1201e752fbc6bd2770bb2fb2f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all points (x,y) that fall within a rectangular query window.  <a href="group__spatial__relationship.html#gac6d17ba1201e752fbc6bd2770bb2fb2f">More...</a><br></td></tr>
<tr class="separator:gac6d17ba1201e752fbc6bd2770bb2fb2f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>APIs related to spatial relationship. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaabc1e4b45fbe5c8bd0473b97fe94d5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabc1e4b45fbe5c8bd0473b97fe94d5fd">◆&nbsp;</a></span>copy_points_in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class OutputIt , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">OutputIt cuspatial::copy_points_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcuspatial_1_1vec__2d.html">vec_2d</a>&lt; T &gt;&nbsp;</td>
          <td class="paramname"><em>vertex_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcuspatial_1_1vec__2d.html">vec_2d</a>&lt; T &gt;&nbsp;</td>
          <td class="paramname"><em>vertex_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&nbsp;</td>
          <td class="paramname"><em>points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&nbsp;</td>
          <td class="paramname"><em>points_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&nbsp;</td>
          <td class="paramname"><em>output_points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em> = <code>rmm::cuda_stream_default</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies points (x,y) that fall within a query range. </p>
<p>The query range is defined by a pair of opposite vertices of a quadrilateral within the coordinate system of the input points, <code>v1</code> and <code>v2</code>. A point (x, y) is in the range if <code>x</code> lies between <code>v1.x</code> and <code>v2.x</code> and <code>y</code> lies between <code>v1.y</code> and <code>v2.y</code>. A point is only counted if it is strictly within the interior of the query range. Points exactly on an edge or vertex of the range are not copied.</p>
<p>The query range vertices and the input points are assumed to be defined in the same coordinate system.</p>
<p><code>output_points_first</code> must be an iterator to storage of sufficient size for the points that will be copied. cuspatial::count_points_in_range may be used to determine the size required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">vertex_1</td><td>Vertex of the query range quadrilateral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_2</td><td>Vertex of the query range quadrilateral opposite <code>vertex_1</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points_first</td><td>beginning of sequence of (x, y) coordinates of points to be queried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points_last</td><td>end of sequence of (x, y) coordinates of points to be queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_points_first</td><td>beginning of output range of (x, y) coordinates within the query range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The CUDA stream on which to perform computations and allocate memory.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">InputIt</td><td>Iterator to input points. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">OutputIt</td><td>Output iterator. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible and mutable. </td></tr>
    <tr><td class="paramname">T</td><td>The underlying coordinate type. Must be a floating-point type.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The range <code>[points_first, points_last)</code> may equal the range `[output_points_first, output_points_first + std::distance(points_first, points_last)), but the ranges may not partially overlap. </dd>
<dd>
All iterators must have the same <code>value_type</code>, with the same underlying floating-point coordinate type (e.g. <code><a class="el" href="classcuspatial_1_1vec__2d.html" title="A generic 2D vector type.">cuspatial::vec_2d</a>&lt;float&gt;</code>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element past the last output point. </dd></dl>

</div>
</div>
<a id="ga3dddce88ff610262003b49d68b6d51cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dddce88ff610262003b49d68b6d51cc">◆&nbsp;</a></span>count_points_in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">thrust::iterator_traits&lt;InputIt&gt;::difference_type cuspatial::count_points_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcuspatial_1_1vec__2d.html">vec_2d</a>&lt; T &gt;&nbsp;</td>
          <td class="paramname"><em>vertex_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcuspatial_1_1vec__2d.html">vec_2d</a>&lt; T &gt;&nbsp;</td>
          <td class="paramname"><em>vertex_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&nbsp;</td>
          <td class="paramname"><em>points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&nbsp;</td>
          <td class="paramname"><em>points_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em> = <code>rmm::cuda_stream_default</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Count of points (x,y) that fall within a query range. </p>
<p>The query range is defined by a pair of opposite vertices within the coordinate system of the input points, <code>v1</code> and <code>v2</code>. A point (x, y) is in the range if <code>x</code> lies between <code>v1.x</code> and <code>v2.x</code> and <code>y</code> lies between <code>v1.y</code> and <code>v2.y</code>. A point is only counted if it is strictly within the interior of the query range. Points exactly on an edge or vertex of the range are not counted.</p>
<p>The query range vertices and the input points are assumed to be defined in the same coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">vertex_1</td><td>Vertex of the query range quadrilateral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_2</td><td>Vertex of the query range quadrilateral opposite <code>vertex_1</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points_first</td><td>beginning of sequence of (x, y) coordinates of points to be queried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points_last</td><td>end of sequence of (x, y) coordinates of points to be queried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The CUDA stream on which to perform computations</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">InputIt</td><td>Iterator to input points. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">T</td><td>The underlying coordinate type. Must be a floating-point type.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All iterators must have the same <code>value_type</code>, with the same underlying floating-point coordinate type (e.g. <code><a class="el" href="classcuspatial_1_1vec__2d.html" title="A generic 2D vector type.">cuspatial::vec_2d</a>&lt;float&gt;</code>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of input points that fall within the specified query range. </dd></dl>

</div>
</div>
<a id="ga99c52b855579395f6df48bd6601e2276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c52b855579395f6df48bd6601e2276">◆&nbsp;</a></span>linestring_bounding_boxes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;cudf::table&gt; cuspatial::linestring_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>linestring_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>expansion_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute minimum bounding boxes of a set of linestrings and an expansion radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">linestring_offsets</td><td>Begin indices of the first point in each linestring (i.e. prefix-sum) </td></tr>
    <tr><td class="paramname">x</td><td>Linestring point x-coordinates </td></tr>
    <tr><td class="paramname">y</td><td>Linestring point y-coordinates </td></tr>
    <tr><td class="paramname">expansion_radius</td><td>Radius of each linestring point</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a cudf table of bounding boxes as four columns of the same type as <code>x</code> and <code>y</code>: x_min - the minimum x-coordinate of each bounding box y_min - the minimum y-coordinate of each bounding box x_max - the maximum x-coordinate of each bounding box y_max - the maximum y-coordinate of each bounding box</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>For compatibility with GeoArrow, the size of <code>linestring_offsets</code> should be one more than the number of linestrings to process. The final offset is not used by this function, but the number of offsets determines the output size. </dd></dl>

</div>
</div>
<a id="ga840f056255521b594ff76dcfecea2420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga840f056255521b594ff76dcfecea2420">◆&nbsp;</a></span>linestring_bounding_boxes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LinestringOffsetIterator , class VertexIterator , class BoundingBoxIterator , class T  = iterator_vec_base_type&lt;VertexIterator&gt;, class IndexT  = iterator_value_type&lt;LinestringOffsetIterator&gt;&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">BoundingBoxIterator cuspatial::linestring_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">LinestringOffsetIterator&nbsp;</td>
          <td class="paramname"><em>linestring_offsets_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinestringOffsetIterator&nbsp;</td>
          <td class="paramname"><em>linestring_offsets_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>linestring_vertices_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>linestring_vertices_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundingBoxIterator&nbsp;</td>
          <td class="paramname"><em>bounding_boxes_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>expansion_radius</em> = <code>T{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em> = <code>rmm::cuda_stream_default</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute minimum bounding box for each linestring. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">LinestringOffsetIterator</td><td>Iterator type to linestring offsets. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-readable. </td></tr>
    <tr><td class="paramname">VertexIterator</td><td>Iterator type to linestring vertices. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-readable. </td></tr>
    <tr><td class="paramname">BoundingBoxIterator</td><td>Iterator type to bounding boxes. Must be writable using data of type <code><a class="el" href="classcuspatial_1_1box.html" title="A generic axis-aligned box type.">cuspatial::box</a>&lt;T&gt;</code>. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-writeable. </td></tr>
    <tr><td class="paramname">T</td><td>The coordinate data value type. </td></tr>
    <tr><td class="paramname">IndexT</td><td>The offset data value type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">linestring_offsets_first</td><td>Iterator to beginning of the range of input polygon offsets. </td></tr>
    <tr><td class="paramname">linestring_offsets_last</td><td>Iterator to end of the range of input polygon offsets. </td></tr>
    <tr><td class="paramname">linestring_vertices_first</td><td>Iterator to beginning of the range of input polygon vertices. </td></tr>
    <tr><td class="paramname">linestring_vertices_last</td><td>Iterator to end of the range of input polygon vertices. </td></tr>
    <tr><td class="paramname">bounding_boxes_first</td><td>Iterator to beginning of the range of output bounding boxes. </td></tr>
    <tr><td class="paramname">expansion_radius</td><td>Optional radius to expand each vertex of the output bounding boxes. </td></tr>
    <tr><td class="paramname">stream</td><td>the CUDA stream on which to perform computations and allocate memory.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the range of output bounding boxes.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>For compatibility with GeoArrow, the number of linestring offsets <code>std::distance(linestring_offsets_first, linestring_offsets_last)</code> should be one more than the number of linestrings. The final offset is not used by this function, but the number of offsets determines the output size. </dd></dl>

</div>
</div>
<a id="ga19ebc8167e1c8f5da623a62bb93e4160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19ebc8167e1c8f5da623a62bb93e4160">◆&nbsp;</a></span>pairwise_point_in_polygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cart2dItA , class Cart2dItB , class OffsetIteratorA , class OffsetIteratorB , class OutputIt &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">OutputIt cuspatial::pairwise_point_in_polygon </td>
          <td>(</td>
          <td class="paramtype">Cart2dItA&nbsp;</td>
          <td class="paramname"><em>test_points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cart2dItA&nbsp;</td>
          <td class="paramname"><em>test_points_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetIteratorA&nbsp;</td>
          <td class="paramname"><em>polygon_offsets_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetIteratorA&nbsp;</td>
          <td class="paramname"><em>polygon_offsets_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetIteratorB&nbsp;</td>
          <td class="paramname"><em>poly_ring_offsets_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetIteratorB&nbsp;</td>
          <td class="paramname"><em>poly_ring_offsets_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cart2dItB&nbsp;</td>
          <td class="paramname"><em>polygon_points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cart2dItB&nbsp;</td>
          <td class="paramname"><em>polygon_points_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&nbsp;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em> = <code>rmm::cuda_stream_default</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Given (point, polygon) pairs, tests whether the point of each pair is inside the polygon of the pair. </p>
<p>Tests whether each point is inside a corresponding polygon. Points on the edges of the polygon are not considered to be inside. Polygons are a collection of one or more rings. Rings are a collection of three or more vertices.</p>
<p>Each input point will map to one <code>int32_t</code> element in the output.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">Cart2dItA</td><td>iterator type for point array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">Cart2dItB</td><td>iterator type for point array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">OffsetIteratorA</td><td>iterator type for offset array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">OffsetIteratorB</td><td>iterator type for offset array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">OutputIt</td><td>iterator type for output array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a>, be device-accessible, mutable and iterate on <code>int32_t</code> type.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">test_points_first</td><td>begin of range of test points </td></tr>
    <tr><td class="paramname">test_points_last</td><td>end of range of test points </td></tr>
    <tr><td class="paramname">polygon_offsets_first</td><td>begin of range of indices to the first ring in each polygon </td></tr>
    <tr><td class="paramname">polygon_offsets_last</td><td>end of range of indices to the first ring in each polygon </td></tr>
    <tr><td class="paramname">ring_offsets_first</td><td>begin of range of indices to the first point in each ring </td></tr>
    <tr><td class="paramname">ring_offsets_last</td><td>end of range of indices to the first point in each ring </td></tr>
    <tr><td class="paramname">polygon_points_first</td><td>begin of range of polygon points </td></tr>
    <tr><td class="paramname">polygon_points_last</td><td>end of range of polygon points </td></tr>
    <tr><td class="paramname">output</td><td>begin iterator to the output buffer </td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream to use for kernel launches. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to one past the last element in the output buffer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Direction of rings does not matter. </dd>
<dd>
This algorithm supports the ESRI shapefile format, but assumes all polygons are "clean" (as defined by the format), and does <em>not</em> verify whether the input adheres to the shapefile format. </dd>
<dd>
The points of the rings must be explicitly closed. </dd>
<dd>
Overlapping rings negate each other. This behavior is not limited to a single negation, allowing for "islands" within the same polygon. </dd>
<dd>
<code>poly_ring_offsets</code> must contain only the rings that make up the polygons indexed by <code>poly_offsets</code>. If there are rings in <code>poly_ring_offsets</code> that are not part of the polygons in <code>poly_offsets</code>, results are likely to be incorrect and behavior is undefined.</dd></dl>
<div class="fragment"><div class="line">  poly w/two rings         poly w/four rings</div>
<div class="line">+-----------+          +------------------------+</div>
<div class="line">:&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:          :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:          :&block;&block;+------------------+&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;+----:------+   :&block;&block;:  +----+  +----+  :&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;:    :&block;&block;&block;&block;&block;&block;:   :&block;&block;:  :&block;&block;&block;&block;:  :&block;&block;&block;&block;:  :&block;&block;:</div>
<div class="line">+------;----+&block;&block;&block;&block;&block;&block;:   :&block;&block;:  :----:  :----:  :&block;&block;:</div>
<div class="line">       :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:   :&block;&block;+------------------+&block;&block;:</div>
<div class="line">       :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:   :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:</div>
<div class="line">       +-----------+   +------------------------+</div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>All point iterators must have the same <code><a class="el" href="classcuspatial_1_1vec__2d.html" title="A generic 2D vector type.">vec_2d</a></code> value type, with the same underlying floating-point coordinate type (e.g. <code><a class="el" href="classcuspatial_1_1vec__2d.html" title="A generic 2D vector type.">cuspatial::vec_2d</a>&lt;float&gt;</code>). </dd>
<dd>
All offset iterators must have the same integral value type. </dd>
<dd>
Output iterator must be mutable and iterate on int32_t type.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcuspatial_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cuspatial::logic_error</a></td><td>polygon has less than 1 ring. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcuspatial_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cuspatial::logic_error</a></td><td>polygon has less than 4 vertices. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga69d996594e4bfe249ae4608ad9d70642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69d996594e4bfe249ae4608ad9d70642">◆&nbsp;</a></span>pairwise_point_in_polygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;cudf::column&gt; cuspatial::pairwise_point_in_polygon </td>
          <td>(</td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>test_points_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>test_points_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_ring_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_points_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_points_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Given (point, polygon pairs), tests whether the point of each pair is inside the polygon of the pair. </p>
<p>Tests that each point is or is not inside of the polygon in the corresponding index. Polygons are a collection of one or more * rings. Rings are a collection of three or more vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">test_points_x</td><td>x-coordinates of points to test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test_points_y</td><td>y-coordinates of points to test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_offsets</td><td>beginning index of the first ring in each polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_ring_offsets</td><td>beginning index of the first point in each ring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_points_x</td><td>x-coordinates of polygon points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_points_y</td><td>y-coordinates of polygon points</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A column of booleans for each point/polygon pair.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Direction of rings does not matter. </dd>
<dd>
Supports open or closed polygon formats. </dd>
<dd>
This algorithm supports the ESRI shapefile format, but assumes all polygons are "clean" (as defined by the format), and does <em>not</em> verify whether the input adheres to the shapefile format. </dd>
<dd>
Overlapping rings negate each other. This behavior is not limited to a single negation, allowing for "islands" within the same polygon. </dd>
<dd>
<code>poly_ring_offsets</code> must contain only the rings that make up the polygons indexed by <code>poly_offsets</code>. If there are rings in <code>poly_ring_offsets</code> that are not part of the polygons in <code>poly_offsets</code>, results are likely to be incorrect and behavior is undefined.</dd></dl>
<div class="fragment"><div class="line">  poly w/two rings         poly w/four rings</div>
<div class="line">+-----------+          +------------------------+</div>
<div class="line">:&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:          :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:          :&block;&block;+------------------+&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;+----:------+   :&block;&block;:  +----+  +----+  :&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;:    :&block;&block;&block;&block;&block;&block;:   :&block;&block;:  :&block;&block;&block;&block;:  :&block;&block;&block;&block;:  :&block;&block;:</div>
<div class="line">+------;----+&block;&block;&block;&block;&block;&block;:   :&block;&block;:  :----:  :----:  :&block;&block;:</div>
<div class="line">       :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:   :&block;&block;+------------------+&block;&block;:</div>
<div class="line">       :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:   :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:</div>
<div class="line">       +-----------+   +------------------------+</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga232cdb60292ea4a9aad0eae0cef679b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga232cdb60292ea4a9aad0eae0cef679b9">◆&nbsp;</a></span>point_bounding_boxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IdInputIt , typename PointInputIt , typename BoundingBoxOutputIt , typename T  = iterator_vec_base_type&lt;PointInputIt&gt;&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">BoundingBoxOutputIt cuspatial::point_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">IdInputIt&nbsp;</td>
          <td class="paramname"><em>ids_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IdInputIt&nbsp;</td>
          <td class="paramname"><em>ids_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointInputIt&nbsp;</td>
          <td class="paramname"><em>points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundingBoxOutputIt&nbsp;</td>
          <td class="paramname"><em>bounding_boxes_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>expansion_radius</em> = <code>T{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em> = <code>rmm::cuda_stream_default</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute the spatial bounding boxes of sequences of points. </p>
<p>Computes a bounding box around all points within each group (consecutive points with the same ID). This function can be applied to trajectory data, polygon vertices, linestring vertices, or any grouped point data.</p>
<p>Before merging bounding boxes, each point may be expanded into a bounding box using an optional <code>expansion_radius</code>. The point is expanded to a box with coordinates <code>(point.x - expansion_radius, point.y - expansion_radius)</code> and <code>(point.x + expansion_radius, point.y + expansion_radius)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Assumes Object IDs and points are presorted by ID.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">IdInputIt</td><td>Iterator over object IDs. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-readable. </td></tr>
    <tr><td class="paramname">PointInputIt</td><td>Iterator over points. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-readable. </td></tr>
    <tr><td class="paramname">BoundingBoxOutputIt</td><td>Iterator over output bounding boxes. Each element is a tuple of two points representing corners of the axis-aligned bounding box. The type of the points is the same as the <code>value_type</code> of PointInputIt. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-writeable.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ids_first</td><td>beginning of the range of input object ids </td></tr>
    <tr><td class="paramname">ids_last</td><td>end of the range of input object ids </td></tr>
    <tr><td class="paramname">points_first</td><td>beginning of the range of input point (x,y) coordinates </td></tr>
    <tr><td class="paramname">bounding_boxes_first</td><td>beginning of the range of output bounding boxes, one per trajectory </td></tr>
    <tr><td class="paramname">expansion_radius</td><td>radius to add to each point when computing its bounding box. </td></tr>
    <tr><td class="paramname">stream</td><td>the CUDA stream on which to perform computations.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the range of output bounding boxes. </dd></dl>

</div>
</div>
<a id="gaa85dc3aafb04c02e6dca08edccf6fd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa85dc3aafb04c02e6dca08edccf6fd92">◆&nbsp;</a></span>point_in_polygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cart2dItA , class Cart2dItB , class OffsetIteratorA , class OffsetIteratorB , class OutputIt &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">OutputIt cuspatial::point_in_polygon </td>
          <td>(</td>
          <td class="paramtype">Cart2dItA&nbsp;</td>
          <td class="paramname"><em>test_points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cart2dItA&nbsp;</td>
          <td class="paramname"><em>test_points_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetIteratorA&nbsp;</td>
          <td class="paramname"><em>polygon_offsets_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetIteratorA&nbsp;</td>
          <td class="paramname"><em>polygon_offsets_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetIteratorB&nbsp;</td>
          <td class="paramname"><em>poly_ring_offsets_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetIteratorB&nbsp;</td>
          <td class="paramname"><em>poly_ring_offsets_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cart2dItB&nbsp;</td>
          <td class="paramname"><em>polygon_points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cart2dItB&nbsp;</td>
          <td class="paramname"><em>polygon_points_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&nbsp;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em> = <code>rmm::cuda_stream_default</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Tests whether the specified points are inside any of the specified polygons. </p>
<p>Tests whether points are inside at most 31 polygons. Polygons are a collection of one or more rings. Rings are a collection of three or more vertices.</p>
<p>Each input point will map to one <code>int32_t</code> element in the output. Each bit (except the sign bit) represents a hit or miss for each of the input polygons in least-significant-bit order. i.e. <code>output[3] &amp; 0b0010</code> indicates a hit or miss for the 3rd point against the 2nd polygon.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">Cart2dItA</td><td>iterator type for point array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">Cart2dItB</td><td>iterator type for point array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">OffsetIteratorA</td><td>iterator type for offset array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">OffsetIteratorB</td><td>iterator type for offset array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-accessible. </td></tr>
    <tr><td class="paramname">OutputIt</td><td>iterator type for output array. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a>, be device-accessible, mutable and iterate on <code>int32_t</code> type.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">test_points_first</td><td>begin of range of test points </td></tr>
    <tr><td class="paramname">test_points_last</td><td>end of range of test points </td></tr>
    <tr><td class="paramname">polygon_offsets_first</td><td>begin of range of indices to the first ring in each polygon </td></tr>
    <tr><td class="paramname">polygon_offsets_last</td><td>end of range of indices to the first ring in each polygon </td></tr>
    <tr><td class="paramname">ring_offsets_first</td><td>begin of range of indices to the first point in each ring </td></tr>
    <tr><td class="paramname">ring_offsets_last</td><td>end of range of indices to the first point in each ring </td></tr>
    <tr><td class="paramname">polygon_points_first</td><td>begin of range of polygon points </td></tr>
    <tr><td class="paramname">polygon_points_last</td><td>end of range of polygon points </td></tr>
    <tr><td class="paramname">output</td><td>begin iterator to the output buffer </td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream to use for kernel launches. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to one past the last element in the output buffer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Limit 31 polygons per call. Polygons may contain multiple rings. </dd>
<dd>
Direction of rings does not matter. </dd>
<dd>
This algorithm supports the ESRI shapefile format, but assumes all polygons are "clean" (as defined by the format), and does <em>not</em> verify whether the input adheres to the shapefile format. </dd>
<dd>
The points of the rings can be either explicitly closed (the first and last vertex overlaps), or implicitly closed (not overlaps). Either input format is supported. </dd>
<dd>
Overlapping rings negate each other. This behavior is not limited to a single negation, allowing for "islands" within the same polygon. </dd>
<dd>
<code>poly_ring_offsets</code> must contain only the rings that make up the polygons indexed by <code>poly_offsets</code>. If there are rings in <code>poly_ring_offsets</code> that are not part of the polygons in <code>poly_offsets</code>, results are likely to be incorrect and behavior is undefined.</dd></dl>
<div class="fragment"><div class="line">  poly w/two rings         poly w/four rings</div>
<div class="line">+-----------+          +------------------------+</div>
<div class="line">:&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:          :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:          :&block;&block;+------------------+&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;+----:------+   :&block;&block;:  +----+  +----+  :&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;:    :&block;&block;&block;&block;&block;&block;:   :&block;&block;:  :&block;&block;&block;&block;:  :&block;&block;&block;&block;:  :&block;&block;:</div>
<div class="line">+------;----+&block;&block;&block;&block;&block;&block;:   :&block;&block;:  :----:  :----:  :&block;&block;:</div>
<div class="line">       :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:   :&block;&block;+------------------+&block;&block;:</div>
<div class="line">       :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:   :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:</div>
<div class="line">       +-----------+   +------------------------+</div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>All point iterators must have the same <code><a class="el" href="classcuspatial_1_1vec__2d.html" title="A generic 2D vector type.">vec_2d</a></code> value type, with the same underlying floating-point coordinate type (e.g. <code><a class="el" href="classcuspatial_1_1vec__2d.html" title="A generic 2D vector type.">cuspatial::vec_2d</a>&lt;float&gt;</code>). </dd>
<dd>
All offset iterators must have the same integral value type. </dd>
<dd>
Output iterator must be mutable and iterate on int32_t type.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcuspatial_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cuspatial::logic_error</a></td><td>if the number of polygons or rings exceeds 31. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcuspatial_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cuspatial::logic_error</a></td><td>polygon has less than 1 ring. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcuspatial_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cuspatial::logic_error</a></td><td>polygon has less than 4 vertices. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga889dbc7d657fd83ba40dc572a94a5e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga889dbc7d657fd83ba40dc572a94a5e48">◆&nbsp;</a></span>point_in_polygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;cudf::column&gt; cuspatial::point_in_polygon </td>
          <td>(</td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>test_points_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>test_points_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_ring_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_points_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_points_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Tests whether the specified points are inside any of the specified polygons. </p>
<p>Tests whether points are inside at most 31 polygons. Polygons are a collection of one or more rings. Rings are a collection of three or more vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">test_points_x</td><td>x-coordinates of points to test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test_points_y</td><td>y-coordinates of points to test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_offsets</td><td>beginning index of the first ring in each polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_ring_offsets</td><td>beginning index of the first point in each ring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_points_x</td><td>x-coordinates of polygon points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_points_y</td><td>y-coordinates of polygon points</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A column of INT32 containing one element per input point. Each bit (except the sign bit) represents a hit or miss for each of the input polygons in least-significant-bit order. i.e. <code>output[3] &amp; 0b0010</code> indicates a hit or miss for the 3rd point against the 2nd polygon.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Limit 31 polygons per call. Polygons may contain multiple rings. </dd>
<dd>
Direction of rings does not matter. </dd>
<dd>
This algorithm supports the ESRI shapefile format, but assumes all polygons are "clean" (as defined by the format), and does <em>not</em> verify whether the input adheres to the shapefile format. </dd>
<dd>
Overlapping rings negate each other. This behavior is not limited to a single negation, allowing for "islands" within the same polygon. </dd>
<dd>
<code>poly_ring_offsets</code> must contain only the rings that make up the polygons indexed by <code>poly_offsets</code>. If there are rings in <code>poly_ring_offsets</code> that are not part of the polygons in <code>poly_offsets</code>, results are likely to be incorrect and behavior is undefined.</dd></dl>
<div class="fragment"><div class="line">  poly w/two rings         poly w/four rings</div>
<div class="line">+-----------+          +------------------------+</div>
<div class="line">:&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:          :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:          :&block;&block;+------------------+&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;+----:------+   :&block;&block;:  +----+  +----+  :&block;&block;:</div>
<div class="line">:&block;&block;&block;&block;&block;&block;:    :&block;&block;&block;&block;&block;&block;:   :&block;&block;:  :&block;&block;&block;&block;:  :&block;&block;&block;&block;:  :&block;&block;:</div>
<div class="line">+------;----+&block;&block;&block;&block;&block;&block;:   :&block;&block;:  :----:  :----:  :&block;&block;:</div>
<div class="line">       :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:   :&block;&block;+------------------+&block;&block;:</div>
<div class="line">       :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:   :&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;&block;:</div>
<div class="line">       +-----------+   +------------------------+</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gac6d17ba1201e752fbc6bd2770bb2fb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6d17ba1201e752fbc6bd2770bb2fb2f">◆&nbsp;</a></span>points_in_spatial_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;cudf::table&gt; cuspatial::points_in_spatial_window </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>window_min_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>window_max_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>window_min_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>window_max_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Find all points (x,y) that fall within a rectangular query window. </p>
<p>A point (x, y) is in the window if <code>x &gt; window_min_x &amp;&amp; x &lt; window_min_y &amp;&amp; y &gt; window_min_y &amp;&amp; y &lt; window_max_y</code>.</p>
<p>Swaps <code>window_min_x</code> and <code>window_max_x</code> if <code>window_min_x &gt; window_max_x</code>. Swaps <code>window_min_y</code> and <code>window_max_y</code> if <code>window_min_y &gt; window_max_y</code>.</p>
<p>The window coordinates and the (x, y) points to be tested are assumed to be defined in the same coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">window_min_x</td><td>lower x-coordinate of the query window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">window_max_x</td><td>upper x-coordinate of the query window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">window_min_y</td><td>lower y-coordinate of the query window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">window_max_y</td><td>upper y-coordinate of the query window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x-coordinates of points to be queried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y-coordinates of points to be queried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional <code>device_memory_resource</code> to use for allocating the output table</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A table with two columns of the same type as the input columns. Columns 0, 1 are the (x, y) coordinates of the points in the input that fall within the query window. </dd></dl>

</div>
</div>
<a id="ga7204b7f4b27b3883e97d6b5bc6322457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7204b7f4b27b3883e97d6b5bc6322457">◆&nbsp;</a></span>polygon_bounding_boxes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;cudf::table&gt; cuspatial::polygon_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>poly_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>ring_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::column_view const &amp;&nbsp;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>expansion_radius</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute minimum bounding box for each polygon in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">poly_offsets</td><td>Begin indices of the first ring in each polygon (i.e. prefix-sum) </td></tr>
    <tr><td class="paramname">ring_offsets</td><td>Begin indices of the first point in each ring (i.e. prefix-sum) </td></tr>
    <tr><td class="paramname">x</td><td>Polygon point x-coordinates </td></tr>
    <tr><td class="paramname">y</td><td>Polygon point y-coordinates </td></tr>
    <tr><td class="paramname">expansion_radius</td><td>radius to add to each point when computing its bounding box.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a cudf table of bounding boxes as four columns of the same type as <code>x</code> and <code>y</code>: x_min - the minimum x-coordinate of each bounding box y_min - the minimum y-coordinate of each bounding box x_max - the maximum x-coordinate of each bounding box y_max - the maximum y-coordinate of each bounding box</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>For compatibility with GeoArrow, the size of <code>poly_offsets</code> should be one more than the number of polygons to process. The size of <code>ring_offsets</code> should be one more than the number of total rings. The final offset in each range is not used by this function, but the number of polygon offsets determines the output size. </dd></dl>

</div>
</div>
<a id="gac53138f1eb9fa9e47ffcafc886256305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac53138f1eb9fa9e47ffcafc886256305">◆&nbsp;</a></span>polygon_bounding_boxes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolygonOffsetIterator , class RingOffsetIterator , class VertexIterator , class BoundingBoxIterator , class T  = iterator_vec_base_type&lt;VertexIterator&gt;, class IndexT  = iterator_value_type&lt;PolygonOffsetIterator&gt;&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">BoundingBoxIterator cuspatial::polygon_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">PolygonOffsetIterator&nbsp;</td>
          <td class="paramname"><em>polygon_offsets_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonOffsetIterator&nbsp;</td>
          <td class="paramname"><em>polygon_offsets_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RingOffsetIterator&nbsp;</td>
          <td class="paramname"><em>polygon_ring_offsets_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RingOffsetIterator&nbsp;</td>
          <td class="paramname"><em>polygon_ring_offsets_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>polygon_vertices_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>polygon_vertices_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundingBoxIterator&nbsp;</td>
          <td class="paramname"><em>bounding_boxes_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>expansion_radius</em> = <code>T{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em> = <code>rmm::cuda_stream_default</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute minimum bounding box for each polygon. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">PolygonOffsetIterator</td><td>Iterator type to polygon offsets. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-readable. </td></tr>
    <tr><td class="paramname">RingOffsetIterator</td><td>Iterator type to polygon ring offsets. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-readable. </td></tr>
    <tr><td class="paramname">VertexIterator</td><td>Iterator type to polygon vertices. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-readable. </td></tr>
    <tr><td class="paramname">BoundingBoxIterator</td><td>Iterator type to bounding boxes. Must be writable using data of type <code><a class="el" href="classcuspatial_1_1box.html" title="A generic axis-aligned box type.">cuspatial::box</a>&lt;T&gt;</code>. Must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" title="LegacyRandomAccessIterator">LegacyRandomAccessIterator</a> and be device-writeable. </td></tr>
    <tr><td class="paramname">T</td><td>The coordinate data value type. </td></tr>
    <tr><td class="paramname">IndexT</td><td>The offset data value type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">polygon_offsets_first</td><td>Iterator to beginning of the range of input polygon offsets. </td></tr>
    <tr><td class="paramname">polygon_offsets_last</td><td>Iterator to end of the range of input polygon offsets. </td></tr>
    <tr><td class="paramname">polygon_ring_offsets_first</td><td>Iterator to beginning of the range of input polygon ring offsets. </td></tr>
    <tr><td class="paramname">polygon_ring_offsets_last</td><td>Iterator to end of the range of input polygon ring offsets. </td></tr>
    <tr><td class="paramname">polygon_vertices_first</td><td>Iterator to beginning of the range of input polygon vertices. </td></tr>
    <tr><td class="paramname">polygon_vertices_last</td><td>Iterator to end of the range of input polygon vertices. </td></tr>
    <tr><td class="paramname">bounding_boxes_first</td><td>Iterator to beginning of the range of output bounding boxes. </td></tr>
    <tr><td class="paramname">expansion_radius</td><td>Optional radius to expand each vertex of the output bounding boxes. </td></tr>
    <tr><td class="paramname">stream</td><td>the CUDA stream on which to perform computations and allocate memory.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the range of output bounding boxes.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>For compatibility with GeoArrow, the number of polygon offsets <code>std::distance(polygon_offsets_first, polygon_offsets_last)</code> should be one more than the number of polygons. The number of ring offsets <code>std::distance(polygon_ring_offsets_first, polygon_ring_offsets_last)</code> should be one more than the number of total rings. The final offset in each range is not used by this function, but the number of polygon offsets determines the output size. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>