

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cuGraph API Reference &mdash; cugraph 0.13.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/params.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Multi-GPU with cuGraph" href="dask-cugraph.html" />
    <link rel="prev" title="Welcome to cugraph’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cugraph
          

          
          </a>

          
            
            
              <div class="version">
                0.13
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">cuGraph API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#structure">Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph">Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.renumber">Renumbering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.symmetrize">Symmetrize</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.convert_matrix">Conversion from Other Formats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#centrality">Centrality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.centrality.katz_centrality">Katz Centrality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#community">Community</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.louvain">Louvain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.ecg">ECG</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.spectral_clustering">Spectral Clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.subgraph_extraction">Subgraph Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.triangle_count">Triangle Counting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#components">Components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.components.connectivity">Connected Components</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cores">Cores</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.cores.k_core">K-Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.cores.core_number">Core Number</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#link-analysis">Link Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_analysis.pagerank">Pagerank</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#link-prediction">Link Prediction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_prediction.jaccard">Jaccard Coefficient</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_prediction.overlap">Overlap Coefficient</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#traversal">Traversal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.bfs">Breadth-first-search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.sssp">Single-source-shortest-path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#r-mat-graph-generation">R-mat Graph Generation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dask-cugraph.html">Multi-GPU with cuGraph</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cugraph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>cuGraph API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cugraph-api-reference">
<h1>cuGraph API Reference<a class="headerlink" href="#cugraph-api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="structure">
<h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="graph">
<h3>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cugraph.structure.graph.Graph">
<em class="property">class </em><code class="sig-prename descclassname">cugraph.structure.graph.</code><code class="sig-name descname">Graph</code><span class="sig-paren">(</span><em class="sig-param">m_graph=None</em>, <em class="sig-param">edge_attr=None</em>, <em class="sig-param">symmetrized=False</em>, <em class="sig-param">bipartite=False</em>, <em class="sig-param">multi=False</em>, <em class="sig-param">dynamic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.clear" title="cugraph.structure.graph.Graph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>(self)</p></td>
<td><p>Empty this graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.degree" title="cugraph.structure.graph.Graph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Compute vertex degree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.degrees" title="cugraph.structure.graph.Graph.degrees"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degrees</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Compute vertex in-degree and out-degree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.delete_adj_list" title="cugraph.structure.graph.Graph.delete_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_adj_list</span></code></a>(self)</p></td>
<td><p>Delete the adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.delete_edge_list" title="cugraph.structure.graph.Graph.delete_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_edge_list</span></code></a>(self)</p></td>
<td><p>Delete the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_cudf_adjlist" title="cugraph.structure.graph.Graph.from_cudf_adjlist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_cudf_adjlist</span></code></a>(self, offset_col, index_col)</p></td>
<td><p>Initialize a graph from the adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_cudf_edgelist" title="cugraph.structure.graph.Graph.from_cudf_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_cudf_edgelist</span></code></a>(self, input_df[, source, …])</p></td>
<td><p>Initialize a graph from the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.get_two_hop_neighbors" title="cugraph.structure.graph.Graph.get_two_hop_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_two_hop_neighbors</span></code></a>(self)</p></td>
<td><p>Compute vertex pairs that are two hops apart.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.in_degree" title="cugraph.structure.graph.Graph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Compute vertex in-degree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.number_of_edges" title="cugraph.structure.graph.Graph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a>(self)</p></td>
<td><p>Get the number of edges in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.number_of_nodes" title="cugraph.structure.graph.Graph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a>(self)</p></td>
<td><p>An alias of number_of_vertices().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.out_degree" title="cugraph.structure.graph.Graph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Compute vertex out-degree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_adj_list" title="cugraph.structure.graph.Graph.view_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_adj_list</span></code></a>(self)</p></td>
<td><p>Display the adjacency list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_edge_list" title="cugraph.structure.graph.Graph.view_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_edge_list</span></code></a>(self)</p></td>
<td><p>Display the edge list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_transposed_adj_list" title="cugraph.structure.graph.Graph.view_transposed_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_transposed_adj_list</span></code></a>(self)</p></td>
<td><p>Display the transposed adjacency list.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 69%" />
<col style="width: 31%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>AdjList</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>EdgeList</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>add_adj_list</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>add_edge_list</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>number_of_vertices</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>transposedAdjList</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="cugraph.structure.graph.Graph.AdjList">
<em class="property">class </em><code class="sig-name descname">AdjList</code><span class="sig-paren">(</span><em class="sig-param">offsets</em>, <em class="sig-param">indices</em>, <em class="sig-param">value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.AdjList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="cugraph.structure.graph.Graph.EdgeList">
<em class="property">class </em><code class="sig-name descname">EdgeList</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">destination</em>, <em class="sig-param">edge_attr=None</em>, <em class="sig-param">renumber_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.EdgeList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.add_adj_list">
<code class="sig-name descname">add_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">offset_col</em>, <em class="sig-param">index_col</em>, <em class="sig-param">value_col=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.add_adj_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.add_edge_list">
<code class="sig-name descname">add_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">source</em>, <em class="sig-param">destination</em>, <em class="sig-param">value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.add_edge_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty this graph. This function is added for NetworkX compatibility.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.degree">
<code class="sig-name descname">degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex degree. By default, this method computes vertex
degrees for the entire set of vertices. If vertex_subset is provided,
this method optionally filters out all but those listed in
vertex_subset.
Parameters
———-
vertex_subset : cudf.Series or iterable container, optional</p>
<blockquote>
<div><p>A container of vertices for displaying corresponding degree. If not
set, degrees are computed for the entire set of vertices.</p>
</div></blockquote>
<dl>
<dt>df<span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size N (the default) or the size of the given
vertices (vertex_subset) containing the degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.
df[‘vertex’] : cudf.Series</p>
<blockquote>
<div><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</div></blockquote>
<dl class="simple">
<dt>df[‘degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.degrees">
<code class="sig-name descname">degrees</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex in-degree and out-degree. By default, this method
computes vertex degrees for the entire set of vertices. If
vertex_subset is provided, this method optionally filters out all but
those listed in vertex_subset.
Parameters
———-
vertex_subset : cudf.Series or iterable container, optional</p>
<blockquote>
<div><p>A container of vertices for displaying corresponding degree. If not
set, degrees are computed for the entire set of vertices.</p>
</div></blockquote>
<dl class="simple">
<dt>df<span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[‘in_degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The in-degree of the vertex.</p>
</dd>
<dt>df[‘out_degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The out-degree of the vertex.</p>
</dd>
</dl>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degrees</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.delete_adj_list">
<code class="sig-name descname">delete_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.delete_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the adjacency list.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.delete_edge_list">
<code class="sig-name descname">delete_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.delete_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the edge list.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.from_cudf_adjlist">
<code class="sig-name descname">from_cudf_adjlist</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">offset_col</em>, <em class="sig-param">index_col</em>, <em class="sig-param">value_col=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.from_cudf_adjlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph from the adjacency list. It is an error to call this
method on an initialized Graph object. The passed offset_col and
index_col arguments wrap gdf_column objects that represent a graph
using the adjacency list format.
If value_col is None, an unweighted graph is created. If value_col is
not None, a weighted graph is created.
If copy is False, this function stores references to the passed objects
pointed by offset_col and index_col. If copy is True, this funcion
stores references to the deep-copies of the passed objects pointed by
offset_col and index_col.
Undirected edges must be stored as directed edges in both directions.
Parameters
———-
offset_col : cudf.Series</p>
<blockquote>
<div><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets must be in the range [0, E] (E: number of edges).</p>
</div></blockquote>
<dl class="simple">
<dt>index_col<span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt>value_col<span class="classifier">cudf.Series, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>.
If not, this cudf.Series wraps a gdf_column of size E (E: number of
edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">],(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">],</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offsets</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_adjlist</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.from_cudf_edgelist">
<code class="sig-name descname">from_cudf_edgelist</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">input_df</em>, <em class="sig-param">source='source'</em>, <em class="sig-param">destination='destination'</em>, <em class="sig-param">edge_attr=None</em>, <em class="sig-param">renumber=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.from_cudf_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph from the edge list. It is an error to call this
method on an initialized Graph object. The passed input_df argument
wraps gdf_column objects that represent a graph using the edge list
format. source argument is source column name and destination argument
is destination column name.
Source and destination indices must be in the range [0, V) where V is
the number of vertices. If renumbering needs to be done, renumber
argument should be passed as True.
If weights are present, edge_attr argument is the weights column name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>This cudf.DataFrame wraps source, destination and weight
gdf_column of size E (E: number of edges)
The ‘src’ column contains the source index for each edge.
Source indices are in the range [0, V) (V: number of vertices).
The ‘dst’ column contains the destination index for each edge.
Destination indices are in the range [0, V) (V: number of
vertices).
If renumbering needs to be done, renumber
argument should be passed as True.
For weighted graphs, dataframe contains ‘weight’ column
containing the weight value for each edge.</p>
</dd>
<dt><strong>source</strong><span class="classifier">str</span></dt><dd><p>source argument is source column name</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str</span></dt><dd><p>destination argument is destination column name.</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">str</span></dt><dd><p>edge_attr argument is the weights column name.</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>If source and destination indices are not in range 0 to V where V
is number of vertices, renumber argument should be True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">,</span>
<span class="go">                         renumber=False)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.get_two_hop_neighbors">
<code class="sig-name descname">get_two_hop_neighbors</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.get_two_hop_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex pairs that are two hops apart. The resulting pairs are
sorted before returning.
Returns
——-
df : cudf.DataFrame</p>
<blockquote>
<div><dl class="simple">
<dt>df[‘first’]<span class="classifier">cudf.Series</span></dt><dd><p>the first vertex id of a pair.</p>
</dd>
<dt>df[‘second’]<span class="classifier">cudf.Series</span></dt><dd><p>the second vertex id of a pair.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.in_degree">
<code class="sig-name descname">in_degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.in_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex in-degree. Vertex in-degree is the number of edges
pointing into the vertex. By default, this method computes vertex
degrees for the entire set of vertices. If vertex_subset is provided,
this method optionally filters out all but those listed in
vertex_subset.
Parameters
———-
vertex_subset : cudf.Series or iterable container, optional</p>
<blockquote>
<div><p>A container of vertices for displaying corresponding in-degree.
If not set, degrees are computed for the entire set of vertices.</p>
</div></blockquote>
<dl>
<dt>df<span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size N (the default) or the size of the given
vertices (vertex_subset) containing the in_degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.
df[‘vertex’] : cudf.Series</p>
<blockquote>
<div><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</div></blockquote>
<dl class="simple">
<dt>df[‘degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed in-degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.number_of_edges">
<code class="sig-name descname">number_of_edges</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of edges in the graph.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.number_of_nodes">
<code class="sig-name descname">number_of_nodes</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias of number_of_vertices(). This function is added for NetworkX
compatibility.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.number_of_vertices">
<code class="sig-name descname">number_of_vertices</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_vertices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.out_degree">
<code class="sig-name descname">out_degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.out_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex out-degree. Vertex out-degree is the number of edges
pointing out from the vertex. By default, this method computes vertex
degrees for the entire set of vertices. If vertex_subset is provided,
this method optionally filters out all but those listed in
vertex_subset.
Parameters
———-
vertex_subset : cudf.Series or iterable container, optional</p>
<blockquote>
<div><p>A container of vertices for displaying corresponding out-degree.
If not set, degrees are computed for the entire set of vertices.</p>
</div></blockquote>
<dl>
<dt>df<span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size N (the default) or the size of the given
vertices (vertex_subset) containing the out_degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.
df[‘vertex’] : cudf.Series</p>
<blockquote>
<div><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</div></blockquote>
<dl class="simple">
<dt>df[‘degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed out-degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="cugraph.structure.graph.Graph.transposedAdjList">
<em class="property">class </em><code class="sig-name descname">transposedAdjList</code><span class="sig-paren">(</span><em class="sig-param">offsets</em>, <em class="sig-param">indices</em>, <em class="sig-param">value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.transposedAdjList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.view_adj_list">
<code class="sig-name descname">view_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.view_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the adjacency list. Compute it if needed.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets are in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices are in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>This pointer is <code class="docutils literal notranslate"><span class="pre">None</span></code> for unweighted graphs.
For weighted graphs, this cudf.Series wraps a gdf_column of size E
(E: number of edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.view_edge_list">
<code class="sig-name descname">view_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.view_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the edge list. Compute it if needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edgelist_df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>This cudf.DataFrame wraps source, destination and weight
gdf_column of size E (E: number of edges)
The ‘src’ column contains the source index for each edge.
Source indices are in the range [0, V) (V: number of vertices).
The ‘dst’ column contains the destination index for each edge.
Destination indices are in the range [0, V) (V: number of
vertices).
For weighted graphs, dataframe contains ‘weight’ column
containing the weight value for each edge.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.view_transposed_adj_list">
<code class="sig-name descname">view_transposed_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.view_transposed_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the transposed adjacency list. Compute it if needed.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets are in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices are in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>This pointer is <code class="docutils literal notranslate"><span class="pre">None</span></code> for unweighted graphs.
For weighted graphs, this cudf.Series wraps a gdf_column of size E
(E: number of edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cugraph.structure.renumber">
<span id="renumbering"></span><h3>Renumbering<a class="headerlink" href="#module-cugraph.structure.renumber" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.structure.renumber.renumber">
<code class="sig-prename descclassname">cugraph.structure.renumber.</code><code class="sig-name descname">renumber</code><span class="sig-paren">(</span><em class="sig-param">source_col</em>, <em class="sig-param">dest_col</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.renumber.renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a (potentially sparse) set of source and destination vertex ids and
renumber the vertices to create a dense set of vertex ids using all values
contiguously from 0 to the number of unique vertices - 1.</p>
<p>Input columns can be either int64 or int32.  The output will be mapped to
int32, since many of the cugraph functions are limited to int32. If the
number of unique values in source_col and dest_col &gt; 2^31-1 then this
function will return an error.</p>
<p>Return from this call will be three cudf Series - the renumbered
source_col, the renumbered dest_col and a numbering map that maps the new
ids to the original ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices must be an integer type.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be an integer type.</p>
</dd>
<dt><strong>numbering_map</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf column of size V (V: number of vertices).
The gdf column contains a numbering map that mpas the new ids to the
original ids.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">source_col</span><span class="p">,</span> <span class="n">dest_col</span><span class="p">,</span> <span class="n">numbering_map</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">renumber</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                       <span class="n">destinations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">source_col</span><span class="p">,</span> <span class="n">dest_col</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.structure.renumber.renumber_from_cudf">
<code class="sig-prename descclassname">cugraph.structure.renumber.</code><code class="sig-name descname">renumber_from_cudf</code><span class="sig-paren">(</span><em class="sig-param">_df</em>, <em class="sig-param">source_cols_names</em>, <em class="sig-param">dest_cols_names</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.renumber.renumber_from_cudf" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a set, collection (lists) of source and destination columns, and
renumber the vertices to create a dense set of contiguously vertex ids
from 0 to the number of unique vertices - 1.</p>
<p>Input columns can be any data type.</p>
<p>The output will be mapped to int32, since many of the cugraph functions
are limited to int32. If the number of unique values is &gt; 2^31-1 then
this function will return an error.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src_ids</strong><span class="classifier">cudf.Series</span></dt><dd><p>The new source vertex IDs</p>
</dd>
<dt><strong>dst_ids</strong><span class="classifier">cudf.Series</span></dt><dd><p>The new destination vertex IDs</p>
</dd>
<dt><strong>numbering_df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>a dataframe that maps a vertex ID to the unique values</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">source_col</span><span class="p">,</span> <span class="n">dest_col</span><span class="p">,</span> <span class="n">numbering_map</span> <span class="o">=</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="n">cugraph</span><span class="o">.</span><span class="n">renumber_from_cudf</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">source_col</span><span class="p">,</span> <span class="n">dest_col</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.structure.symmetrize">
<span id="symmetrize"></span><h3>Symmetrize<a class="headerlink" href="#module-cugraph.structure.symmetrize" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.structure.symmetrize.symmetrize">
<code class="sig-prename descclassname">cugraph.structure.symmetrize.</code><code class="sig-name descname">symmetrize</code><span class="sig-paren">(</span><em class="sig-param">source_col</em>, <em class="sig-param">dest_col</em>, <em class="sig-param">value_col=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.symmetrize.symmetrize" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a COO set of source destination pairs along with associated values and
create a new COO set of source destination pairs along with values where
all edges exist in both directions.</p>
<p>Return from this call will be a COO stored as two cudf Series - the
symmetrized source column and the symmetrized dest column, along with
an optional cudf Series containing the associated values (only if the
values are passed in).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices must be an integer type.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be an integer type.</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series (optional)</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains values associated with this edge.
For this function the values can be any type, they are not
examined, just copied.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.structure.symmetrize.symmetrize_df">
<code class="sig-prename descclassname">cugraph.structure.symmetrize.</code><code class="sig-name descname">symmetrize_df</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">src_name</em>, <em class="sig-param">dst_name</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.symmetrize.symmetrize_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a COO stored in a DataFrame, along with the column names of
the source and destination columns and create a new data frame
using the same column names that symmetrize the graph so that all
edges appear in both directions.</p>
<p>Note that if other columns exist in the data frame (e.g. edge weights)
the other columns will also be replicated.  That is, if (u,v,data)
represents the source value (u), destination value (v) and some
set of other columns (data) in the input data, then the output
data will contain both (u,v,data) and (v,u,data) with matching
data.</p>
<p>If (u,v,data1) and (v,u,data2) exist in the input data where data1
!= data2 then this code will arbitrarily pick the smaller data
element to keep, if this is not desired then the caller should
should correct the data prior to calling symmetrize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Input data frame containing COO.  Columns should contain source
ids, destination ids and any properties associated with the
edges.</p>
</dd>
<dt><strong>src_name</strong><span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the source ids</p>
</dd>
<dt><strong>dst_name</strong><span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the destination ids</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym_df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sym_df</span><span class="p">[</span><span class="s1">&#39;0]&#39;</span><span class="p">,</span> <span class="n">sym_df</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span> <span class="n">sym_df</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.structure.convert_matrix">
<span id="conversion-from-other-formats"></span><h3>Conversion from Other Formats<a class="headerlink" href="#module-cugraph.structure.convert_matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.structure.convert_matrix.from_cudf_edgelist">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_cudf_edgelist</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">source='source'</em>, <em class="sig-param">destination='destination'</em>, <em class="sig-param">edge_attr=None</em>, <em class="sig-param">create_using=&lt;class 'cugraph.structure.graph.Graph'&gt;</em>, <em class="sig-param">renumber=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.convert_matrix.from_cudf_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new graph created from the edge list representaion. This function
is added for NetworkX compatibility (this function is a RAPIDS version of
NetworkX’s from_pandas_edge_list()).
Parameters
———-
df : cudf.DataFrame</p>
<blockquote>
<div><p>This cudf.DataFrame contains columns storing edge source vertices,
destination (or target following NetworkX’s terminology) vertices, and
(optional) weights.</p>
</div></blockquote>
<dl class="simple">
<dt>source<span class="classifier">string or integer</span></dt><dd><p>This is used to index the source column.</p>
</dd>
<dt>target<span class="classifier">string or integer</span></dt><dd><p>This is used to index the destination (or target following NetworkX’s
terminology) column.</p>
</dd>
<dt>weight<span class="classifier">string or integer, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>. If not, this is used to index the weight
column.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="centrality">
<h2>Centrality<a class="headerlink" href="#centrality" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.centrality.katz_centrality">
<span id="katz-centrality"></span><h3>Katz Centrality<a class="headerlink" href="#module-cugraph.centrality.katz_centrality" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.centrality.katz_centrality.katz_centrality">
<code class="sig-prename descclassname">cugraph.centrality.katz_centrality.</code><code class="sig-name descname">katz_centrality</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">alpha=0.1</em>, <em class="sig-param">max_iter=100</em>, <em class="sig-param">tol=1e-06</em>, <em class="sig-param">nstart=None</em>, <em class="sig-param">normalized=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.centrality.katz_centrality.katz_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Katz centrality for the nodes of the graph G. cuGraph does not
currently support the ‘beta’ and ‘weight’ parameters as seen in the
corresponding networkX call. This implementation is based on a relaxed
version of Katz defined by Foster with a reduced computational complexity
of O(n+m)</p>
<p>Foster, K.C., Muth, S.Q., Potterat, J.J. et al.
Computational &amp; Mathematical Organization Theory (2001) 7: 275.
<a class="reference external" href="https://doi.org/10.1023/A:1013470632383">https://doi.org/10.1023/A:1013470632383</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. The graph can
contain either directed or undirected edges where undirected edges are
represented as directed edges in both directions.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Attenuation factor with a default value of 0.1.  If alpha is not less
than 1/(lambda_max) where lambda_max is the maximum degree
GDF_CUDA_ERROR is returned</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can
be used to limit the execution time and do an early exit before the
solver reaches the convergence tolerance.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0e-6.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 1e-2 and 1e-6 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for katz centrality.</p>
<dl class="simple">
<dt>nstart[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>nstart[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the katz centrality values of vertices</p>
</dd>
</dl>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool</span></dt><dd><p>If True normalize the resulting katz centrality values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding katz centrality values.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘katz_centrality’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the katz centrality of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kc</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">katz_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="community">
<h2>Community<a class="headerlink" href="#community" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.community.louvain">
<span id="louvain"></span><h3>Louvain<a class="headerlink" href="#module-cugraph.community.louvain" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.louvain.louvain">
<code class="sig-prename descclassname">cugraph.community.louvain.</code><code class="sig-name descname">louvain</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.louvain.louvain" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity optimizing partition of the input graph using the
Louvain heuristic</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list.
The adjacency list will be computed if not already present. The graph
should be undirected where an undirected edge is represented by a
directed edge in both direction.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>This controls the maximum number of levels/iterations of the Louvain
algorithm. When specified the algorithm will terminate after no more
than the specified number of iterations. No error occurs when the
algorithm terminates early in this manner.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing two columns the vertex id and the
partition id it is assigned to.</p>
</dd>
<dt><strong>modularity_score</strong><span class="classifier">float</span></dt><dd><p>a floating point number containing the modularity score of the
partitioning.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span><span class="p">,</span> <span class="n">modularity_score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">louvain</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.community.ecg">
<span id="ecg"></span><h3>ECG<a class="headerlink" href="#module-cugraph.community.ecg" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.ecg.ecg">
<code class="sig-prename descclassname">cugraph.community.ecg.</code><code class="sig-name descname">ecg</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">min_weight=0.05</em>, <em class="sig-param">ensemble_size=16</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.ecg.ecg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the ensemble clustering for graphs (ECG) partition of the input
graph ECG runs truncated Louvain on an ensemble of permutations of the
input graph, then uses the ensemble partitions to determine weights for
the input graph.The final result is found by running full Louvain on
the input graph using the determined weights.
See <a class="reference external" href="https://arxiv.org/abs/1809.05578">https://arxiv.org/abs/1809.05578</a> for further information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
and weights.The adjacency list will be computed if not already
present.</p>
</dd>
<dt><strong>min_weight</strong><span class="classifier">floating point</span></dt><dd><p>The minimum value to assign as an edgeweight in the ECG algorithm.
It should be a value in the range (0,1] usually left as the default
value of .05</p>
</dd>
<dt><strong>ensemble_size</strong><span class="classifier">integer</span></dt><dd><p>The number of graph permutations to use for the ensemble.
The default value is 16, larger values may produce higher quality
partitions for some graphs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing two columns, the vertex id and
the partition id it is assigned to.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span>
<span class="go">                      delimiter = &#39; &#39;,</span>
<span class="go">                      dtype=[&#39;int32&#39;, &#39;int32&#39;, &#39;float32&#39;],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">ecg</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.community.spectral_clustering">
<span id="spectral-clustering"></span><h3>Spectral Clustering<a class="headerlink" href="#module-cugraph.community.spectral_clustering" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_edge_cut">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_edge_cut</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_edge_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edge cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed edge cut score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_edge_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_modularity">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_modularity</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_modularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed modularity score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_ratio_cut">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_ratio_cut</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_ratio_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the ratio cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed ratio cut score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_ratio_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.community.spectral_clustering.spectralBalancedCutClustering">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">spectralBalancedCutClustering</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">num_clusters</em>, <em class="sig-param">num_eigen_vects=2</em>, <em class="sig-param">evs_tolerance=1e-05</em>, <em class="sig-param">evs_max_iter=100</em>, <em class="sig-param">kmean_tolerance=1e-05</em>, <em class="sig-param">kmean_max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.spectralBalancedCutClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral
balanced cut method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to
num_clusters.</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding cluster assignments.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the vertex identifiers</p>
</dd>
<dt>df[‘cluster’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.community.spectral_clustering.spectralModularityMaximizationClustering">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">spectralModularityMaximizationClustering</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">num_clusters</em>, <em class="sig-param">num_eigen_vects=2</em>, <em class="sig-param">evs_tolerance=1e-05</em>, <em class="sig-param">evs_max_iter=100</em>, <em class="sig-param">kmean_tolerance=1e-05</em>, <em class="sig-param">kmean_max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.spectralModularityMaximizationClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral
modularity maximization method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to
num_clusters</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the vertex identifiers</p>
</dd>
<dt>df[‘cluster’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralModularityMaximizationClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.community.subgraph_extraction">
<span id="subgraph-extraction"></span><h3>Subgraph Extraction<a class="headerlink" href="#module-cugraph.community.subgraph_extraction" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.subgraph_extraction.subgraph">
<code class="sig-prename descclassname">cugraph.community.subgraph_extraction.</code><code class="sig-name descname">subgraph</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">vertices</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.subgraph_extraction.subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a subgraph of the existing graph including only the specified
vertices.  This algorithm works for both directed and undirected graphs,
it does not actually traverse the edges, simply pulls out any edges that
are incident on vertices that are both contained in the vertices list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the vertices of the induced subgraph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Sg</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>A graph object containing the subgraph induced by the given vertex set.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sverts</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">sverts</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.community.triangle_count">
<span id="triangle-counting"></span><h3>Triangle Counting<a class="headerlink" href="#module-cugraph.community.triangle_count" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.triangle_count.triangles">
<code class="sig-prename descclassname">cugraph.community.triangle_count.</code><code class="sig-name descname">triangles</code><span class="sig-paren">(</span><em class="sig-param">G</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.triangle_count.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the triangle (number of cycles of length three) count of the
input graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information,
(edge weights are not used in this algorithm)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>count</strong><span class="classifier">int64</span></dt><dd><p>A 64 bit integer whose value gives the number of triangles in the
graph.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">triangles</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="components">
<h2>Components<a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.components.connectivity">
<span id="connected-components"></span><h3>Connected Components<a class="headerlink" href="#module-cugraph.components.connectivity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.components.connectivity.strongly_connected_components">
<code class="sig-prename descclassname">cugraph.components.connectivity.</code><code class="sig-name descname">strongly_connected_components</code><span class="sig-paren">(</span><em class="sig-param">G</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.components.connectivity.strongly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the stronlgly connected components and attach a component label to
each vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information as
an edge list (edge weights are not used for this algorithm). The graph
can be either directed or undirected where an undirected edge is
represented by a directed edge in both directions.
The adjacency list will be computed if not already present.
The number of vertices should fit into a 32b int.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘labels’][i] gives the label id of the i’th vertex
df[‘vertices’][i] gives the vertex id of the i’th vertex</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span><span class="n">destinations</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.components.connectivity.weakly_connected_components">
<code class="sig-prename descclassname">cugraph.components.connectivity.</code><code class="sig-name descname">weakly_connected_components</code><span class="sig-paren">(</span><em class="sig-param">G</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.components.connectivity.weakly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the weakly connected components and attach a component label to
each vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm).
Currently, the graph should be undirected where an undirected edge is
represented by a directed edge in both directions. The adjacency list
will be computed if not already present. The number of vertices should
fit into a 32b int.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘labels’][i] gives the label id of the i’th vertex
df[‘vertices’][i] gives the vertex id of the i’th vertex</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">weakly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="cores">
<h2>Cores<a class="headerlink" href="#cores" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.cores.k_core">
<span id="k-core"></span><h3>K-Core<a class="headerlink" href="#module-cugraph.cores.k_core" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.cores.k_core.k_core">
<code class="sig-prename descclassname">cugraph.cores.k_core.</code><code class="sig-name descname">k_core</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">k=None</em>, <em class="sig-param">core_number=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.cores.k_core.k_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the k-core of the graph G based on the out degree of its nodes. A
k-core of a graph is a maximal subgraph that contains nodes of degree k or
more. This call does not support a graph with self-loops and parallel
edges.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. The graph
should contain undirected edges where undirected edges are represented
as directed edges in both directions. While this graph can contain edge
weights, they don’t participate in the calculation of the k-core.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int, optional</span></dt><dd><p>Order of the core. This value must not be negative. If set to None, the
main core is returned.</p>
</dd>
<dt><strong>core_number</strong><span class="classifier">cudf.DataFrame, optional</span></dt><dd><p>Precomputed core number of the nodes of the graph G containing two
cudf.Series of size V: the vertex identifiers and the corresponding
core number values. If set to None, the core numbers of the nodes are
calculated internally.</p>
<dl class="simple">
<dt>core_number[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>core_number[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the core number of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>KCoreGraph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>K Core of the input graph</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">KCoreGraph</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">k_core</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.cores.core_number">
<span id="core-number"></span><h3>Core Number<a class="headerlink" href="#module-cugraph.cores.core_number" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.cores.core_number.core_number">
<code class="sig-prename descclassname">cugraph.cores.core_number.</code><code class="sig-name descname">core_number</code><span class="sig-paren">(</span><em class="sig-param">G</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.cores.core_number.core_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the core numbers for the nodes of the graph G. A k-core of a graph
is a maximal subgraph that contains nodes of degree k or more.
A node has a core number of k if it belongs a k-core but not to k+1-core.
This call does not support a graph with self-loops and parallel
edges.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. The graph
should contain undirected edges where undirected edges are represented
as directed edges in both directions. While this graph can contain edge
weights, they don’t participate in the calculation of the core numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding core number values.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘core_number’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the core number of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cn</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">core_number</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="link-analysis">
<h2>Link Analysis<a class="headerlink" href="#link-analysis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.link_analysis.pagerank">
<span id="pagerank"></span><h3>Pagerank<a class="headerlink" href="#module-cugraph.link_analysis.pagerank" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.link_analysis.pagerank.pagerank">
<code class="sig-prename descclassname">cugraph.link_analysis.pagerank.</code><code class="sig-name descname">pagerank</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">alpha=0.85</em>, <em class="sig-param">personalization=None</em>, <em class="sig-param">max_iter=100</em>, <em class="sig-param">tol=1e-05</em>, <em class="sig-param">nstart=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_analysis.pagerank.pagerank" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the PageRank vertex values for a graph. cuGraph computes an
approximation of the Pagerank eigenvector using the power method. The
number of iterations depends on the properties of the network itself; it
increases when the tolerance descreases and/or alpha increases toward the
limiting value of 1. The user is free to use default values or to provide
inputs for the initial guess, tolerance and maximum number of iterations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm).
The transposed adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>The damping factor alpha represents the probability to follow an
outgoing edge, standard value is 0.85.
Thus, 1.0-alpha is the probability to “teleport” to a random vertex.
Alpha should be greater than 0.0 and strictly lower than 1.0.</p>
</dd>
<dt><strong>personalization</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the personalizatoin information.</p>
<dl class="simple">
<dt>personalization[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for personalization</p>
</dd>
<dt>personalization[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Personalization values for vertices</p>
</dd>
</dl>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can
be used to limit the execution time and do an early exit before the
solver reaches the convergence tolerance.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0E-5.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 0.01 and 0.00001 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for pagerank.</p>
<dl class="simple">
<dt>nstart[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for initial guess for pagerank values</p>
</dd>
<dt>nstart[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Pagerank values for vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>PageRank</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding PageRank values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pr</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-05</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="link-prediction">
<h2>Link Prediction<a class="headerlink" href="#link-prediction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.link_prediction.jaccard">
<span id="jaccard-coefficient"></span><h3>Jaccard Coefficient<a class="headerlink" href="#module-cugraph.link_prediction.jaccard" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.link_prediction.jaccard.jaccard">
<code class="sig-prename descclassname">cugraph.link_prediction.jaccard.</code><code class="sig-name descname">jaccard</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">vertex_pair=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_prediction.jaccard.jaccard" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Jaccard similarity between each pair of vertices connected by
an edge, or between arbitrary pairs of vertices specified by the user.
Jaccard similarity is defined between two sets as the ratio of the volume
of their intersection divided by the volume of their union. In the context
of graphs, the neighborhood of a vertex is seen as a set. The Jaccard
similarity weight of each edge represents the strength of connection
between vertices based on the relative similarity of their neighbors. If
first is specified but second is not, or vice versa, an exception will be
thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
graph should be undirected where an undirected edge is represented by a
directed edge in both direction. The adjacency list will be computed if
not already present.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the jaccard coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified)</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified)</p>
</dd>
<dt>df[‘jaccard_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Jaccard coefficient between the source and destination
vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cugraph.link_prediction.wjaccard"></span><dl class="function">
<dt id="cugraph.link_prediction.wjaccard.jaccard_w">
<code class="sig-prename descclassname">cugraph.link_prediction.wjaccard.</code><code class="sig-name descname">jaccard_w</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">weights</em>, <em class="sig-param">vertex_pair=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_prediction.wjaccard.jaccard_w" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted Jaccard similarity between each pair of vertices
connected by an edge, or between arbitrary pairs of vertices specified by
the user. Jaccard similarity is defined between two sets as the ratio of
the volume of their intersection divided by the volume of their union. In
the context of graphs, the neighborhood of a vertex is seen as a set. The
Jaccard similarity weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the weights to be used for each vertex.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the jaccard coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID</p>
</dd>
<dt>df[‘jaccard_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed weighted Jaccard coefficient between the source and
destination vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">max</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">destinations</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard_w</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.link_prediction.overlap">
<span id="overlap-coefficient"></span><h3>Overlap Coefficient<a class="headerlink" href="#module-cugraph.link_prediction.overlap" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.link_prediction.overlap.overlap">
<code class="sig-prename descclassname">cugraph.link_prediction.overlap.</code><code class="sig-name descname">overlap</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">vertex_pair=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_prediction.overlap.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Overlap Coefficient between each pair of vertices connected by
an edge, or between arbitrary pairs of vertices specified by the user.
Overlap Coefficient is defined between two sets as the ratio of the volume
of their intersection divided by the smaller of their two volumes. In the
context of graphs, the neighborhood of a vertex is seen as a set. The
Overlap Coefficient weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the overlap coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Overlap coefficients. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified).</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified).</p>
</dd>
<dt>df[‘overlap_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Overlap coefficient between the source and destination
vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cugraph.link_prediction.woverlap"></span><dl class="function">
<dt id="cugraph.link_prediction.woverlap.overlap_w">
<code class="sig-prename descclassname">cugraph.link_prediction.woverlap.</code><code class="sig-name descname">overlap_w</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">weights</em>, <em class="sig-param">vertex_pair=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_prediction.woverlap.overlap_w" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted Overlap Coefficient between each pair of vertices
connected by an edge, or between arbitrary pairs of vertices specified by
the user. Overlap Coefficient is defined between two sets as the ratio of
the volume of their intersection divided by the smaller of their volumes.
In the context of graphs, the neighborhood of a vertex is seen as a set.
The Overlap Coefficient weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the weights to be used for each vertex.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the overlap coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the overlap coefficients. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID</p>
</dd>
<dt>df[‘overlap_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed weighted Overlap coefficient between the source and
destination vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">max</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">destinations</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">overlap_w</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="traversal">
<h2>Traversal<a class="headerlink" href="#traversal" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.traversal.bfs">
<span id="breadth-first-search"></span><h3>Breadth-first-search<a class="headerlink" href="#module-cugraph.traversal.bfs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.traversal.bfs.bfs">
<code class="sig-prename descclassname">cugraph.traversal.bfs.</code><code class="sig-name descname">bfs</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">start</em>, <em class="sig-param">directed=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.traversal.bfs.bfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the distances and predecessors for a breadth first traversal of a
graph.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an adjacency list.</p>
</dd>
<dt><strong>start</strong><span class="classifier">Integer</span></dt><dd><p>The index of the graph vertex from which the traversal begins</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool</span></dt><dd><p>Indicates whether the graph in question is a directed graph, or whether
each edge has a corresponding reverse edge. (Allows optimizations if
the graph is undirected)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex</p>
<p>df[‘distance’][i] gives the path distance for the i’th vertex from the
starting vertex</p>
<p>df[‘predecessor’][i] gives for the i’th vertex the vertex it was
reached from in the traversal</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.traversal.sssp">
<span id="single-source-shortest-path"></span><h3>Single-source-shortest-path<a class="headerlink" href="#module-cugraph.traversal.sssp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.traversal.sssp.filter_unreachable">
<code class="sig-prename descclassname">cugraph.traversal.sssp.</code><code class="sig-name descname">filter_unreachable</code><span class="sig-paren">(</span><em class="sig-param">df</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.traversal.sssp.filter_unreachable" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove unreachable vertices from the result of SSSP or BFS</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>cudf.DataFrame that is the output of SSSP or BFS</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">filtered cudf.DataFrame with only reachable vertices</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex.
df[‘distance’][i] gives the path distance for the i’th vertex from the
starting vertex.
df[‘predecessor’][i] gives the vertex that was reached before the i’th
vertex in the traversal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cugraph.traversal.sssp.sssp">
<code class="sig-prename descclassname">cugraph.traversal.sssp.</code><code class="sig-name descname">sssp</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">source</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.traversal.sssp.sssp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the distance and predecessors for shortest paths from the specified
source to all the vertices in the graph. The distances column will store
the distance from the source to each vertex. The predecessors column will
store each vertex’s predecessor in the shortest path. Vertices that are
unreachable will have a distance of infinity denoted by the maximum value
of the data type and the predecessor set as -1. The source vertex’s
predecessor is also set to -1. Graphs with negative weight cycles are not
supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. Edge weights,
if present, should be single or double precision floating point values.</p>
</dd>
<dt><strong>source</strong><span class="classifier">int</span></dt><dd><p>Index of the source vertex.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex.
df[‘distance’][i] gives the path distance for the i’th vertex from the
starting vertex.
df[‘predecessor’][i] gives the vertex id of the vertex that was reached
before the i’th vertex in the traversal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">sssp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="r-mat-graph-generation">
<h3>R-mat Graph Generation<a class="headerlink" href="#r-mat-graph-generation" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dask-cugraph.html" class="btn btn-neutral float-right" title="Multi-GPU with cuGraph" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to cugraph’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>