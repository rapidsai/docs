

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cuGraph API Reference &mdash; cugraph 0.9.0a documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/params.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Multi-GPU with cuGraph" href="dask-cugraph.html" />
    <link rel="prev" title="Welcome to cugraph’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cugraph
          

          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">cuGraph API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#structure">Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph">Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.renumber">Renumbering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.convert_matrix">Conversion from Other Formats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#community">Community</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.louvain">Louvain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.spectral_clustering">Spectral Clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.subgraph_extraction">Subgraph Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.triangle_count">Tirangle Counting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#components">Components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.components.connectivity">Connected Components</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#link-analysis">Link Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_analysis.pagerank">Pagerank</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#link-prediction">Link Prediction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_prediction.jaccard">Jaccard Coefficient</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_prediction.overlap">Overlap Coefficient</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#traversal">Traversal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.bfs">Breadth-first-search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.sssp">Single-source-shortest-path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.utilities.grmat">R-mat Graph Generation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dask-cugraph.html">Multi-GPU with cuGraph</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cugraph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>cuGraph API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cugraph-api-reference">
<h1>cuGraph API Reference<a class="headerlink" href="#cugraph-api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="structure">
<h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="graph">
<h3>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cugraph.structure.graph.Graph">
<em class="property">class </em><code class="sig-prename descclassname">cugraph.structure.graph.</code><code class="sig-name descname">Graph</code><a class="headerlink" href="#cugraph.structure.graph.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p>cuGraph graph class containing basic graph creation and transformation
operations.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.add_adj_list" title="cugraph.structure.graph.Graph.add_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_adj_list</span></code></a>(self, offset_col, index_col[, …])</p></td>
<td><p>Initialize a graph from the adjacency list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.add_edge_list" title="cugraph.structure.graph.Graph.add_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge_list</span></code></a>(self, source_col, dest_col[, …])</p></td>
<td><p>Initialize a graph from the edge list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.add_transposed_adj_list" title="cugraph.structure.graph.Graph.add_transposed_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_transposed_adj_list</span></code></a>(self)</p></td>
<td><p>Compute the transposed adjacency list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.clear" title="cugraph.structure.graph.Graph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>(self)</p></td>
<td><p>Empty this graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.degree" title="cugraph.structure.graph.Graph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Compute veretx degree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.degrees" title="cugraph.structure.graph.Graph.degrees"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degrees</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Compute veretx in-degree and out-degree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.delete_adj_list" title="cugraph.structure.graph.Graph.delete_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_adj_list</span></code></a>(self)</p></td>
<td><p>Delete the adjacency list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.delete_edge_list" title="cugraph.structure.graph.Graph.delete_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_edge_list</span></code></a>(self)</p></td>
<td><p>Delete the edge list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.delete_transposed_adj_list" title="cugraph.structure.graph.Graph.delete_transposed_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_transposed_adj_list</span></code></a>(self)</p></td>
<td><p>Delete the transposed adjacency list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.get_two_hop_neighbors" title="cugraph.structure.graph.Graph.get_two_hop_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_two_hop_neighbors</span></code></a>(self)</p></td>
<td><p>Compute vertex pairs that are two hops apart.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.in_degree" title="cugraph.structure.graph.Graph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Compute veretx in-degree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.number_of_edges" title="cugraph.structure.graph.Graph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a>(self)</p></td>
<td><p>Get the number of edges in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.number_of_nodes" title="cugraph.structure.graph.Graph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a>(self)</p></td>
<td><p>An alias of number_of_vertices().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.number_of_vertices" title="cugraph.structure.graph.Graph.number_of_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_vertices</span></code></a>(self)</p></td>
<td><p>Get the number of vertices in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.out_degree" title="cugraph.structure.graph.Graph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Compute veretx out-degree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_adj_list" title="cugraph.structure.graph.Graph.view_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_adj_list</span></code></a>(self)</p></td>
<td><p>Display the adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_edge_list" title="cugraph.structure.graph.Graph.view_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_edge_list</span></code></a>(self)</p></td>
<td><p>Display the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_transposed_adj_list" title="cugraph.structure.graph.Graph.view_transposed_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_transposed_adj_list</span></code></a>(self)</p></td>
<td><p>Display the transposed adjacency list.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cugraph.structure.graph.Graph.add_adj_list">
<code class="sig-name descname">add_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">offset_col</em>, <em class="sig-param">index_col</em>, <em class="sig-param">value_col=None</em>, <em class="sig-param">copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.add_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph from the adjacency list. It is an error to call this
method on an initialized Graph object. The passed offset_col and
index_col arguments wrap gdf_column objects that represent a graph
using the adjacency list format.
If value_col is None, an unweighted graph is created. If value_col is
not None, a weighted graph is created.
If copy is False, this function stores references to the passed objects
pointed by offset_col and index_col. If copy is True, this funcion
stores references to the deep-copies of the passed objects pointed by
offset_col and index_col.
Undirected edges must be stored as directed edges in both directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets must be in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>.
If not, this cudf.Series wraps a gdf_column of size E (E: number of
edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">],(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">],</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offsets</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_adj_list</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.add_edge_list">
<code class="sig-name descname">add_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">source_col</em>, <em class="sig-param">dest_col</em>, <em class="sig-param">value_col=None</em>, <em class="sig-param">copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.add_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph from the edge list. It is an error to call this
method on an initialized Graph object. The passed source_col and
dest_col arguments wrap gdf_column objects that represent a graph
using the edge list format.
Source and destination indices must be in the range [0, V) where V is
the number of vertices. They must be 32 bit integers. Please refer to
cuGraph’s renumbering feature if your input does not match these
requierments. When using cudf.read_csv to load a CSV edge list,
make sure to set dtype to int32 for the source and destination
columns.
If value_col is None, an unweighted graph is created. If value_col is
not None, a weighted graph is created.
If copy is False, this function stores references to the passed objects
pointed by source_col and dest_col. If copy is True, this funcion
stores references to the deep-copies of the passed objects pointed by
source_col and dest_col.
Undirected edges must be stored as directed edges in both directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices must be in the range [0, V) (V: number of vertices).
Source indices must be 32 bit integers.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be in the range [0, V) (V: number of
vertices).
Destination indices must be 32 bit integers.</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>.
If not, this cudf.Series wraps a gdf_column of size E (E: number of
edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.add_transposed_adj_list">
<code class="sig-name descname">add_transposed_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.add_transposed_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the transposed adjacency list. It is an error to call this
method on an uninitialized Graph object or a Graph object without an
existing edge list.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty this graph. This function is added for NetworkX compatibility.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.degree">
<code class="sig-name descname">degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute veretx degree. By default, this method computes vertex
degrees for the entire set of vertices. If vertex_subset is provided,
this method optionally filters out all but those listed in
vertex_subset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset</strong><span class="classifier">cudf.Series or iterable container, optional</span></dt><dd><p>A container of vertices for displaying corresponding degree. If not
set, degrees are computed for the entire set of vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size N (the default) or the size of the given
vertices (vertex_subset) containing the degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[‘degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.degrees">
<code class="sig-name descname">degrees</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute veretx in-degree and out-degree. By default, this method
computes vertex degrees for the entire set of vertices. If
vertex_subset is provided, this method optionally filters out all but
those listed in vertex_subset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset</strong><span class="classifier">cudf.Series or iterable container, optional</span></dt><dd><p>A container of vertices for displaying corresponding degree. If not
set, degrees are computed for the entire set of vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[‘in_degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The in-degree of the vertex.</p>
</dd>
<dt>df[‘out_degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The out-degree of the vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degrees</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.delete_adj_list">
<code class="sig-name descname">delete_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.delete_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the adjacency list.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.delete_edge_list">
<code class="sig-name descname">delete_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.delete_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the edge list.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.delete_transposed_adj_list">
<code class="sig-name descname">delete_transposed_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.delete_transposed_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the transposed adjacency list.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.get_two_hop_neighbors">
<code class="sig-name descname">get_two_hop_neighbors</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.get_two_hop_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex pairs that are two hops apart. The resulting pairs are
sorted before returning.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[‘first’]<span class="classifier">cudf.Series</span></dt><dd><p>the first vertex id of a pair.</p>
</dd>
<dt>df[‘second’]<span class="classifier">cudf.Series</span></dt><dd><p>the second vertex id of a pair.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.in_degree">
<code class="sig-name descname">in_degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.in_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute veretx in-degree. Vertex in-degree is the number of edges
pointing into the vertex. By default, this method computes vertex
degrees for the entire set of vertices. If vertex_subset is provided,
this method optionally filters out all but those listed in
vertex_subset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset</strong><span class="classifier">cudf.Series or iterable container, optional</span></dt><dd><p>A container of vertices for displaying corresponding in-degree.
If not set, degrees are computed for the entire set of vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size N (the default) or the size of the given
vertices (vertex_subset) containing the in_degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[‘degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed in-degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.number_of_edges">
<code class="sig-name descname">number_of_edges</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of edges in the graph.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.number_of_nodes">
<code class="sig-name descname">number_of_nodes</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias of number_of_vertices(). This function is added for NetworkX
compatibility.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.number_of_vertices">
<code class="sig-name descname">number_of_vertices</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of vertices in the graph.</p>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.out_degree">
<code class="sig-name descname">out_degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.out_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute veretx out-degree. Vertex out-degree is the number of edges
pointing out from the vertex. By default, this method computes vertex
degrees for the entire set of vertices. If vertex_subset is provided,
this method optionally filters out all but those listed in
vertex_subset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset</strong><span class="classifier">cudf.Series or iterable container, optional</span></dt><dd><p>A container of vertices for displaying corresponding out-degree.
If not set, degrees are computed for the entire set of vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size N (the default) or the size of the given
vertices (vertex_subset) containing the out_degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[‘degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed out-degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.view_adj_list">
<code class="sig-name descname">view_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.view_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the adjacency list. Compute it if needed.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets are in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices are in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>This pointer is <code class="docutils literal notranslate"><span class="pre">None</span></code> for unweighted graphs.
For weighted graphs, this cudf.Series wraps a gdf_column of size E
(E: number of edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.view_edge_list">
<code class="sig-name descname">view_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.view_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the edge list. Compute it if needed.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>source_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices are in the range [0, V) (V: number of vertices).
Source indices must be 32 bit integers.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices are in the range [0, V) (V: number of
vertices).
Destination indices must be 32 bit integers.</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>This pointer is <code class="docutils literal notranslate"><span class="pre">None</span></code> for unweighted graphs.
For weighted graphs, this cudf.Series wraps a gdf_column of size E
(E: number of edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cugraph.structure.graph.Graph.view_transposed_adj_list">
<code class="sig-name descname">view_transposed_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.graph.Graph.view_transposed_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the transposed adjacency list. Compute it if needed.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets are in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices are in the range [0, V) (V: number of vertices).</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>This pointer is <code class="docutils literal notranslate"><span class="pre">None</span></code> for unweighted graphs.
For weighted graphs, this cudf.Series wraps a gdf_column of size E
(E: number of edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cugraph.structure.renumber">
<span id="renumbering"></span><h3>Renumbering<a class="headerlink" href="#module-cugraph.structure.renumber" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.structure.renumber.renumber">
<code class="sig-prename descclassname">cugraph.structure.renumber.</code><code class="sig-name descname">renumber</code><span class="sig-paren">(</span><em class="sig-param">source_col</em>, <em class="sig-param">dest_col</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.renumber.renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a (potentially sparse) set of source and destination vertex ids and
renumber the vertices to create a dense set of vertex ids using all values
contiguously from 0 to the number of unique vertices - 1.</p>
<p>Input columns can be either int64 or int32.  The output will be mapped to
int32, since many of the cugraph functions are limited to int32. If the
number of unique values in source_col and dest_col &gt; 2^31-1 then this
function will return an error.</p>
<p>Return from this call will be three cudf Series - the renumbered
source_col, the renumbered dest_col and a numbering map that maps the new
ids to the original ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices must be an integer type.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be an integer type.</p>
</dd>
<dt><strong>numbering_map</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf column of size V (V: number of vertices).
The gdf column contains a numbering map that mpas the new ids to the
original ids.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">source_col</span><span class="p">,</span> <span class="n">dest_col</span><span class="p">,</span> <span class="n">numbering_map</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">renumber</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                       <span class="n">destinations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">source_col</span><span class="p">,</span> <span class="n">dest_col</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.structure.convert_matrix">
<span id="conversion-from-other-formats"></span><h3>Conversion from Other Formats<a class="headerlink" href="#module-cugraph.structure.convert_matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.structure.convert_matrix.from_cudf_edgelist">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_cudf_edgelist</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">source='source'</em>, <em class="sig-param">target='target'</em>, <em class="sig-param">weight=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.structure.convert_matrix.from_cudf_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new graph created from the edge list representaion. This function
is added for NetworkX compatibility (this function is a RAPIDS version of
NetworkX’s from_pandas_edge_list()).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>This cudf.DataFrame contains columns storing edge source vertices,
destination (or target following NetworkX’s terminology) vertices, and
(optional) weights.</p>
</dd>
<dt><strong>source</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the source column.</p>
</dd>
<dt><strong>target</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the destination (or target following NetworkX’s
terminology) column.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string or integer, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>. If not, this is used to index the weight
column.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="community">
<h2>Community<a class="headerlink" href="#community" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.community.louvain">
<span id="louvain"></span><h3>Louvain<a class="headerlink" href="#module-cugraph.community.louvain" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.louvain.louvain">
<code class="sig-prename descclassname">cugraph.community.louvain.</code><code class="sig-name descname">louvain</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.louvain.louvain" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity optimizing partition of the input graph using the
Louvain heuristic</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list.
The adjacency list will be computed if not already present. The graph
should be undirected where an undirected edge is represented by a
directed edge in both direction.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing two columns the vertex id and the
partition id it is assigned to.</p>
</dd>
<dt><strong>modularity_score</strong><span class="classifier">float</span></dt><dd><p>a floating point number containing the modularity score of the
partitioning.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span><span class="p">,</span> <span class="n">modularity_score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">louvain</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.community.spectral_clustering">
<span id="spectral-clustering"></span><h3>Spectral Clustering<a class="headerlink" href="#module-cugraph.community.spectral_clustering" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_edge_cut">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_edge_cut</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_edge_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edge cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed edge cut score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_edge_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_modularity">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_modularity</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_modularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed modularity score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_ratio_cut">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_ratio_cut</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_ratio_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the ratio cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed ratio cut score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_ratio_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.community.spectral_clustering.spectralBalancedCutClustering">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">spectralBalancedCutClustering</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">num_clusters</em>, <em class="sig-param">num_eigen_vects=2</em>, <em class="sig-param">evs_tolerance=1e-05</em>, <em class="sig-param">evs_max_iter=100</em>, <em class="sig-param">kmean_tolerance=1e-05</em>, <em class="sig-param">kmean_max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.spectralBalancedCutClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral
balanced cut method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to
num_clusters.</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding cluster assignments.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the vertex identifiers</p>
</dd>
<dt>df[‘cluster’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.community.spectral_clustering.spectralModularityMaximizationClustering">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">spectralModularityMaximizationClustering</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">num_clusters</em>, <em class="sig-param">num_eigen_vects=2</em>, <em class="sig-param">evs_tolerance=1e-05</em>, <em class="sig-param">evs_max_iter=100</em>, <em class="sig-param">kmean_tolerance=1e-05</em>, <em class="sig-param">kmean_max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.spectral_clustering.spectralModularityMaximizationClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral
modularity maximization method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to
num_clusters</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the vertex identifiers</p>
</dd>
<dt>df[‘cluster’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralModularityMaximizationClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.community.subgraph_extraction">
<span id="subgraph-extraction"></span><h3>Subgraph Extraction<a class="headerlink" href="#module-cugraph.community.subgraph_extraction" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.subgraph_extraction.subgraph">
<code class="sig-prename descclassname">cugraph.community.subgraph_extraction.</code><code class="sig-name descname">subgraph</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">vertices</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.subgraph_extraction.subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a subgraph of the existing graph including only the specified
vertices.  This algorithm works for both directed and undirected graphs,
it does not actually traverse the edges, simply pulls out any edges that
are incident on vertices that are both contained in the vertices list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the vertices of the induced subgraph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Sg</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>A graph object containing the subgraph induced by the given vertex set.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sverts</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">sverts</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.community.triangle_count">
<span id="tirangle-counting"></span><h3>Tirangle Counting<a class="headerlink" href="#module-cugraph.community.triangle_count" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.community.triangle_count.triangles">
<code class="sig-prename descclassname">cugraph.community.triangle_count.</code><code class="sig-name descname">triangles</code><span class="sig-paren">(</span><em class="sig-param">G</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.community.triangle_count.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the triangle (number of cycles of length three) count of the
input graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information,
(edge weights are not used in this algorithm)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>count</strong><span class="classifier">int64</span></dt><dd><p>A 64 bit integer whose value gives the number of triangles in the
graph.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">triangles</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="components">
<h2>Components<a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.components.connectivity">
<span id="connected-components"></span><h3>Connected Components<a class="headerlink" href="#module-cugraph.components.connectivity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.components.connectivity.strongly_connected_components">
<code class="sig-prename descclassname">cugraph.components.connectivity.</code><code class="sig-name descname">strongly_connected_components</code><span class="sig-paren">(</span><em class="sig-param">G</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.components.connectivity.strongly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the stronlgly connected components and attach a component label to
each vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information as
an edge list (edge weights are not used for this algorithm). The graph
can be either directed or undirected where an undirected edge is
represented by a directed edge in both directions.
The adjacency list will be computed if not already present.
The number of vertices should fit into a 32b int.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘labels’][i] gives the label id of the i’th vertex
df[‘vertices’][i] gives the vertex id of the i’th vertex</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span><span class="n">destinations</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cugraph.components.connectivity.weakly_connected_components">
<code class="sig-prename descclassname">cugraph.components.connectivity.</code><code class="sig-name descname">weakly_connected_components</code><span class="sig-paren">(</span><em class="sig-param">G</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.components.connectivity.weakly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the weakly connected components and attach a component label to
each vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm).
Currently, the graph should be undirected where an undirected edge is
represented by a directed edge in both directions. The adjacency list
will be computed if not already present. The number of vertices should
fit into a 32b int.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘labels’][i] gives the label id of the i’th vertex
df[‘vertices’][i] gives the vertex id of the i’th vertex</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">weakly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="link-analysis">
<h2>Link Analysis<a class="headerlink" href="#link-analysis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.link_analysis.pagerank">
<span id="pagerank"></span><h3>Pagerank<a class="headerlink" href="#module-cugraph.link_analysis.pagerank" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.link_analysis.pagerank.pagerank">
<code class="sig-prename descclassname">cugraph.link_analysis.pagerank.</code><code class="sig-name descname">pagerank</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">alpha=0.85</em>, <em class="sig-param">personalization=None</em>, <em class="sig-param">max_iter=100</em>, <em class="sig-param">tol=1e-05</em>, <em class="sig-param">nstart=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_analysis.pagerank.pagerank" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the PageRank vertex values for a graph. cuGraph computes an
approximation of the Pagerank eigenvector using the power method. The
number of iterations depends on the properties of the network itself; it
increases when the tolerance descreases and/or alpha increases toward the
limiting value of 1. The user is free to use default values or to provide
inputs for the initial guess, tolerance and maximum number of iterations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm).
The transposed adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>The damping factor alpha represents the probability to follow an
outgoing edge, standard value is 0.85.
Thus, 1.0-alpha is the probability to “teleport” to a random vertex.
Alpha should be greater than 0.0 and strictly lower than 1.0.</p>
</dd>
<dt><strong>personalization</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the personalizatoin information.</p>
<dl class="simple">
<dt>personalization[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for personalization</p>
</dd>
<dt>personalization[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Personalization values for vertices</p>
</dd>
</dl>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can
be used to limit the execution time and do an early exit before the
solver reaches the convergence tolerance.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0E-5.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 0.01 and 0.00001 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for pagerank.</p>
<dl class="simple">
<dt>nstart[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for initial guess for pagerank values</p>
</dd>
<dt>nstart[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Pagerank values for vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>PageRank</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding PageRank values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pr</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-05</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="link-prediction">
<h2>Link Prediction<a class="headerlink" href="#link-prediction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.link_prediction.jaccard">
<span id="jaccard-coefficient"></span><h3>Jaccard Coefficient<a class="headerlink" href="#module-cugraph.link_prediction.jaccard" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.link_prediction.jaccard.jaccard">
<code class="sig-prename descclassname">cugraph.link_prediction.jaccard.</code><code class="sig-name descname">jaccard</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">first=None</em>, <em class="sig-param">second=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_prediction.jaccard.jaccard" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Jaccard similarity between each pair of vertices connected by
an edge, or between arbitrary pairs of vertices specified by the user.
Jaccard similarity is defined between two sets as the ratio of the volume
of their intersection divided by the volume of their union. In the context
of graphs, the neighborhood of a vertex is seen as a set. The Jaccard
similarity weight of each edge represents the strength of connection
between vertices based on the relative similarity of their neighbors. If
first is specified but second is not, or vice versa, an exception will be
thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
graph should be undirected where an undirected edge is represented by a
directed edge in both direction. The adjacency list will be computed if
not already present.</p>
</dd>
<dt><strong>first</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the first vertices of each pair of vertices to compute for,
must be specified along with second.</p>
</dd>
<dt><strong>second</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the second vertices of each pair of vertices to compute for,
must be specified along with first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified)</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified)</p>
</dd>
<dt>df[‘jaccard_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Jaccard coefficient between the source and destination
vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cugraph.link_prediction.wjaccard"></span><dl class="function">
<dt id="cugraph.link_prediction.wjaccard.jaccard_w">
<code class="sig-prename descclassname">cugraph.link_prediction.wjaccard.</code><code class="sig-name descname">jaccard_w</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">weights</em>, <em class="sig-param">first=None</em>, <em class="sig-param">second=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_prediction.wjaccard.jaccard_w" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted Jaccard similarity between each pair of vertices
connected by an edge, or between arbitrary pairs of vertices specified by
the user. Jaccard similarity is defined between two sets as the ratio of
the volume of their intersection divided by the volume of their union. In
the context of graphs, the neighborhood of a vertex is seen as a set. The
Jaccard similarity weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the weights to be used for each vertex.</p>
</dd>
<dt><strong>first</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the first vertices of each pair of vertices to compute for,
must be specified along with second.</p>
</dd>
<dt><strong>second</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the second vertices of each pair of vertices to compute for,
must be specified along with first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID</p>
</dd>
<dt>df[‘jaccard_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed weighted Jaccard coefficient between the source and
destination vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">max</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">destinations</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard_w</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.link_prediction.overlap">
<span id="overlap-coefficient"></span><h3>Overlap Coefficient<a class="headerlink" href="#module-cugraph.link_prediction.overlap" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.link_prediction.overlap.overlap">
<code class="sig-prename descclassname">cugraph.link_prediction.overlap.</code><code class="sig-name descname">overlap</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">first=None</em>, <em class="sig-param">second=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_prediction.overlap.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Overlap Coefficient between each pair of vertices connected by
an edge, or between arbitrary pairs of vertices specified by the user.
Overlap Coefficient is defined between two sets as the ratio of the volume
of their intersection divided by the smaller of their two volumes. In the
context of graphs, the neighborhood of a vertex is seen as a set. The
Overlap Coefficient weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>first</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the first vertices of each pair of vertices to compute for,
must be specified along with second.</p>
</dd>
<dt><strong>second</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the second vertices of each pair of vertices to compute for,
must be specified along with first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Overlap coefficients. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified).</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified).</p>
</dd>
<dt>df[‘overlap_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Overlap coefficient between the source and destination
vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cugraph.link_prediction.woverlap"></span><dl class="function">
<dt id="cugraph.link_prediction.woverlap.overlap_w">
<code class="sig-prename descclassname">cugraph.link_prediction.woverlap.</code><code class="sig-name descname">overlap_w</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em>, <em class="sig-param">weights</em>, <em class="sig-param">first=None</em>, <em class="sig-param">second=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.link_prediction.woverlap.overlap_w" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted Overlap Coefficient between each pair of vertices
connected by an edge, or between arbitrary pairs of vertices specified by
the user. Overlap Coefficient is defined between two sets as the ratio of
the volume of their intersection divided by the smaller of their volumes.
In the context of graphs, the neighborhood of a vertex is seen as a set.
The Overlap Coefficient weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the weights to be used for each vertex.</p>
</dd>
<dt><strong>first</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the first vertices of each pair of vertices to compute for,
must be specified along with second.</p>
</dd>
<dt><strong>second</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the second vertices of each pair of vertices to compute for,
must be specified along with first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the overlap coefficients. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID</p>
</dd>
<dt>df[‘overlap_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed weighted Overlap coefficient between the source and
destination vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">max</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">destinations</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">overlap_w</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="traversal">
<h2>Traversal<a class="headerlink" href="#traversal" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.traversal.bfs">
<span id="breadth-first-search"></span><h3>Breadth-first-search<a class="headerlink" href="#module-cugraph.traversal.bfs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.traversal.bfs.bfs">
<code class="sig-prename descclassname">cugraph.traversal.bfs.</code><code class="sig-name descname">bfs</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">start</em>, <em class="sig-param">directed=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.traversal.bfs.bfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the distances and predecessors for a breadth first traversal of a
graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an adjacency list.</p>
</dd>
<dt><strong>start</strong><span class="classifier">Integer</span></dt><dd><p>The index of the graph vertex from which the traversal begins</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool</span></dt><dd><p>Indicates whether the graph in question is a directed graph, or whether
each edge has a corresponding reverse edge. (Allows optimizations if
the graph is undirected)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex
df[‘distance’][i] gives the path distance for the i’th vertex from the
starting vertex
df[‘predecessor’][i] gives for the i’th vertex the vertex it was
reached from in the traversal</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph.traversal.sssp">
<span id="single-source-shortest-path"></span><h3>Single-source-shortest-path<a class="headerlink" href="#module-cugraph.traversal.sssp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.traversal.sssp.filter_unreachable">
<code class="sig-prename descclassname">cugraph.traversal.sssp.</code><code class="sig-name descname">filter_unreachable</code><span class="sig-paren">(</span><em class="sig-param">df</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.traversal.sssp.filter_unreachable" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove unreachable vertices from the result of SSSP or BFS</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>cudf.DataFrame that is the output of SSSP or BFS</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">filtered cudf.DataFrame with only reachable vertices</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex.
df[‘distance’][i] gives the path distance for the i’th vertex from the
starting vertex.
df[‘predecessor’][i] gives the vertex that was reached before the i’th
vertex in the traversal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cugraph.traversal.sssp.sssp">
<code class="sig-prename descclassname">cugraph.traversal.sssp.</code><code class="sig-name descname">sssp</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">source</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.traversal.sssp.sssp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the distance and predecessors for shortest paths from the specified
source to all the vertices in the graph. The distances column will store
the distance from the source to each vertex. The predecessors column will
store each vertex’s predecessor in the shortest path. Vertices that are
unreachable will have a distance of infinity denoted by the maximum value
of the data type and the predecessor set as -1. The source vertex’s
predecessor is also set to -1. Graphs with negative weight cycles are not
supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. Edge weights,
if present, should be single or double precision floating point values.</p>
</dd>
<dt><strong>source</strong><span class="classifier">int</span></dt><dd><p>Index of the source vertex.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex.
df[‘distance’][i] gives the path distance for the i’th vertex from the
starting vertex.
df[‘predecessor’][i] gives the vertex id of the vertex that was reached
before the i’th vertex in the traversal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;datasets/karate.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">sssp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.utilities.grmat">
<span id="r-mat-graph-generation"></span><h3>R-mat Graph Generation<a class="headerlink" href="#module-cugraph.utilities.grmat" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="cugraph.utilities.grmat.grmat_gen">
<code class="sig-prename descclassname">cugraph.utilities.grmat.</code><code class="sig-name descname">grmat_gen</code><span class="sig-paren">(</span><em class="sig-param">argv</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.utilities.grmat.grmat_gen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dask-cugraph.html" class="btn btn-neutral float-right" title="Multi-GPU with cuGraph" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to cugraph’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>