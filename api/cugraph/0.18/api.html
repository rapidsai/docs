
<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>cuGraph API Reference — cugraph 0.17.0 documentation</title>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/copybutton.css" rel="stylesheet" type="text/css"/>
<link href="_static/params.css" rel="stylesheet" type="text/css"/>
<link href="_static/references.css" rel="stylesheet" type="text/css"/>
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script src="_static/language_data.js"></script>
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script src="_static/js/theme.js" type="text/javascript"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="dask-cugraph.html" rel="next" title="Multi-GPU with cuGraph"/>
<link href="cugraph_intro.html" rel="prev" title="cuGraph Introduction"/>
<link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search"><div id="rapids-sphinx-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">cugraph</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf-java/legacy">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (0.18)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cugraph/nightly/api.html">nightly (0.18)</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">stable (0.17)</a><a class="rapids-selector__menu-item" href="/api/cugraph/legacy/api.html">legacy (0.16)</a></div></div></div>
<div role="search">
<form action="search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="cugraph_intro.html">cuGraph Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">cuGraph API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#structure">Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph">Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.symmetrize">Symmetrize</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.convert_matrix">Conversion from Other Formats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#centrality">Centrality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.centrality.betweenness_centrality">Betweenness Centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.centrality.edge_betweenness_centrality">Edge Betweenness Centrality</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#returns">Returns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.centrality.katz_centrality">Katz Centrality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#community">Community</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.ecg">Ensemble clustering for graphs (ECG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.ktruss_subgraph">K-Truss</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.leiden">Leiden</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.louvain">Louvain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.spectral_clustering">Spectral Clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.subgraph_extraction">Subgraph Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.triangle_count">Triangle Counting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#components">Components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.components.connectivity">Connected Components</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cores">Cores</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.cores.core_number">Core Number</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.cores.k_core">K-Core</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#layout">Layout</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.layout.force_atlas2">Force Atlas 2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#link-analysis">Link Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_analysis.hits">HITS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_analysis.pagerank">Pagerank</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#link-prediction">Link Prediction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_prediction.jaccard">Jaccard Coefficient</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_prediction.overlap">Overlap Coefficient</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#traversal">Traversal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.bfs">Breadth-first-search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.sssp">Single-source-shortest-path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tree">Tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.tree.minimum_spanning_tree">Minimum Spanning Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.tree.maximum_spanning_tree">Maximum Spanning Tree</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Returns</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dask-cugraph.html">Multi-GPU with cuGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="cugraph_blogs.html">cuGraph BLOGS and Presentations</a></li>
<li class="toctree-l1"><a class="reference internal" href="cugraph_ref.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="nx_transition.html">NetworkX Compatibility and Transition</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="index.html">cugraph</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a class="icon icon-home" href="index.html"></a> »</li>
<li>cuGraph API Reference</li>
<li class="wy-breadcrumbs-aside">
<a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="cugraph-api-reference">
<h1>cuGraph API Reference<a class="headerlink" href="#cugraph-api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="structure">
<h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="graph">
<h3>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="cugraph.structure.graph.Graph">
<em class="property">class </em><code class="sig-prename descclassname">cugraph.structure.graph.</code><code class="sig-name descname">Graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m_graph</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">edge_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">symmetrized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">bipartite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">multi</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">dynamic</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L32"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.add_internal_vertex_id" title="cugraph.structure.graph.Graph.add_internal_vertex_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_internal_vertex_id</span></code></a>(df, …[, drop, …])</p></td>
<td><p>Given a DataFrame containing external vertex ids in the identified columns, return a DataFrame containing the internal vertex ids as the specified column name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.add_nodes_from" title="cugraph.structure.graph.Graph.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a>(nodes[, bipartite, multipartite])</p></td>
<td><p>Add nodes information to the Graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.clear" title="cugraph.structure.graph.Graph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</p></td>
<td><p>Empty this graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.compute_local_data" title="cugraph.structure.graph.Graph.compute_local_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_local_data</span></code></a>(by[, load_balance])</p></td>
<td><p>Compute the local edges, vertices and offsets for a distributed graph stored as a dask-cudf dataframe and initialize the communicator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.compute_renumber_edge_list" title="cugraph.structure.graph.Graph.compute_renumber_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_renumber_edge_list</span></code></a>([transposed])</p></td>
<td><p>Compute a renumbered edge list</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.degree" title="cugraph.structure.graph.Graph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a>([vertex_subset])</p></td>
<td><p>Compute vertex degree, which is the total number of edges incident to a vertex (both in and out edges).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.degrees" title="cugraph.structure.graph.Graph.degrees"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degrees</span></code></a>([vertex_subset])</p></td>
<td><p>Compute vertex in-degree and out-degree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.delete_adj_list" title="cugraph.structure.graph.Graph.delete_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_adj_list</span></code></a>()</p></td>
<td><p>Delete the adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.delete_edge_list" title="cugraph.structure.graph.Graph.delete_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_edge_list</span></code></a>()</p></td>
<td><p>Delete the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.edges" title="cugraph.structure.graph.Graph.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a>()</p></td>
<td><p>Returns all the edges in the graph as a cudf.DataFrame containing sources and destinations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_cudf_adjlist" title="cugraph.structure.graph.Graph.from_cudf_adjlist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_cudf_adjlist</span></code></a>(offset_col, index_col[, …])</p></td>
<td><p>Initialize a graph from the adjacency list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_cudf_edgelist" title="cugraph.structure.graph.Graph.from_cudf_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_cudf_edgelist</span></code></a>(input_df[, source, …])</p></td>
<td><p>Initialize a graph from the edge list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_dask_cudf_edgelist" title="cugraph.structure.graph.Graph.from_dask_cudf_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_dask_cudf_edgelist</span></code></a>(input_ddf[, source, …])</p></td>
<td><p>Initializes the distributed graph from the dask_cudf.DataFrame edgelist.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_numpy_array" title="cugraph.structure.graph.Graph.from_numpy_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_numpy_array</span></code></a>(np_array[, nodes])</p></td>
<td><p>Initializes the graph from numpy array containing adjacency matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_numpy_matrix" title="cugraph.structure.graph.Graph.from_numpy_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_numpy_matrix</span></code></a>(np_matrix)</p></td>
<td><p>Initializes the graph from numpy matrix containing adjacency matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_pandas_adjacency" title="cugraph.structure.graph.Graph.from_pandas_adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas_adjacency</span></code></a>(pdf)</p></td>
<td><p>Initializes the graph from pandas adjacency matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.from_pandas_edgelist" title="cugraph.structure.graph.Graph.from_pandas_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas_edgelist</span></code></a>(pdf[, source, …])</p></td>
<td><p>Initialize a graph from the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.get_two_hop_neighbors" title="cugraph.structure.graph.Graph.get_two_hop_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_two_hop_neighbors</span></code></a>()</p></td>
<td><p>Compute vertex pairs that are two hops apart.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.has_edge" title="cugraph.structure.graph.Graph.has_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_edge</span></code></a>(u, v)</p></td>
<td><p>Returns True if the graph contains the edge (u,v).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.has_node" title="cugraph.structure.graph.Graph.has_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_node</span></code></a>(n)</p></td>
<td><p>Returns True if the graph contains the node n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.in_degree" title="cugraph.structure.graph.Graph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a>([vertex_subset])</p></td>
<td><p>Compute vertex in-degree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.is_bipartite" title="cugraph.structure.graph.Graph.is_bipartite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_bipartite</span></code></a>()</p></td>
<td><p>Checks if Graph is bipartite.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.is_multipartite" title="cugraph.structure.graph.Graph.is_multipartite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_multipartite</span></code></a>()</p></td>
<td><p>Checks if Graph is multipartite.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.lookup_internal_vertex_id" title="cugraph.structure.graph.Graph.lookup_internal_vertex_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lookup_internal_vertex_id</span></code></a>(df[, column_name])</p></td>
<td><p>Given a DataFrame containing external vertex ids in the identified columns, or a Series containing external vertex ids, return a Series with the internal vertex ids.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.nodes" title="cugraph.structure.graph.Graph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a>()</p></td>
<td><p>Returns all the nodes in the graph as a cudf.Series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.number_of_edges" title="cugraph.structure.graph.Graph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a>([directed_edges])</p></td>
<td><p>Get the number of edges in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.number_of_nodes" title="cugraph.structure.graph.Graph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a>()</p></td>
<td><p>An alias of number_of_vertices().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.number_of_vertices" title="cugraph.structure.graph.Graph.number_of_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_vertices</span></code></a>()</p></td>
<td><p>Get the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.out_degree" title="cugraph.structure.graph.Graph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a>([vertex_subset])</p></td>
<td><p>Compute vertex out-degree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.sets" title="cugraph.structure.graph.Graph.sets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sets</span></code></a>()</p></td>
<td><p>Returns the bipartite set of nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.to_directed" title="cugraph.structure.graph.Graph.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed</span></code></a>()</p></td>
<td><p>Return a directed representation of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.to_numpy_array" title="cugraph.structure.graph.Graph.to_numpy_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_numpy_array</span></code></a>()</p></td>
<td><p>Returns the graph adjacency matrix as a NumPy array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.to_numpy_matrix" title="cugraph.structure.graph.Graph.to_numpy_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_numpy_matrix</span></code></a>()</p></td>
<td><p>Returns the graph adjacency matrix as a NumPy matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.to_pandas_adjacency" title="cugraph.structure.graph.Graph.to_pandas_adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas_adjacency</span></code></a>()</p></td>
<td><p>Returns the graph adjacency matrix as a Pandas DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.to_pandas_edgelist" title="cugraph.structure.graph.Graph.to_pandas_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas_edgelist</span></code></a>([source, destination])</p></td>
<td><p>Returns the graph edge list as a Pandas DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.to_undirected" title="cugraph.structure.graph.Graph.to_undirected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected</span></code></a>()</p></td>
<td><p>Return an undirected copy of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.unrenumber" title="cugraph.structure.graph.Graph.unrenumber"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unrenumber</span></code></a>(df, column_name[, preserve_order])</p></td>
<td><p>Given a DataFrame containing internal vertex ids in the identified column, replace this with external vertex ids.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_adj_list" title="cugraph.structure.graph.Graph.view_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_adj_list</span></code></a>()</p></td>
<td><p>Display the adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_edge_list" title="cugraph.structure.graph.Graph.view_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_edge_list</span></code></a>()</p></td>
<td><p>Display the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph.Graph.view_transposed_adj_list" title="cugraph.structure.graph.Graph.view_transposed_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_transposed_adj_list</span></code></a>()</p></td>
<td><p>Display the transposed adjacency list.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 68%"/>
<col style="width: 32%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>AdjList</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>EdgeList</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>enable_batch</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>is_directed</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>neighbors</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>transposedAdjList</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="cugraph.structure.graph.Graph.AdjList">
<em class="property">class </em><code class="sig-name descname">AdjList</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">offsets</span></em>, <em class="sig-param"><span class="n">indices</span></em>, <em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L58"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.AdjList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py class">
<dt id="cugraph.structure.graph.Graph.EdgeList">
<em class="property">class </em><code class="sig-name descname">EdgeList</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.EdgeList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.add_internal_vertex_id">
<code class="sig-name descname">add_internal_vertex_id</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">internal_column_name</span></em>, <em class="sig-param"><span class="n">external_column_name</span></em>, <em class="sig-param"><span class="n">drop</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">preserve_order</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1466"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.add_internal_vertex_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a DataFrame containing external vertex ids in the identified
columns, return a DataFrame containing the internal vertex ids as the
specified column name.  Optionally drop the external vertex id columns.
Optionally preserve the order of the original DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: cudf.DataFrame or dask_cudf.DataFrame</strong></dt><dd><p>A DataFrame containing external vertex identifiers that will be
converted into internal vertex identifiers.</p>
</dd>
<dt><strong>internal_column_name: string</strong></dt><dd><p>Name of column to contain the internal vertex id</p>
</dd>
<dt><strong>external_column_name: string or list of strings</strong></dt><dd><p>Name of the column(s) containing the external vertex ids</p>
</dd>
<dt><strong>drop: (optional) bool, defaults to True</strong></dt><dd><p>Drop the external columns from the returned DataFrame</p>
</dd>
<dt><strong>preserve_order: (optional) bool, defaults to False</strong></dt><dd><p>Preserve the order of the data frame (requires an extra sort)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or dask_cudf.DataFrame</span></dt><dd><p>Original DataFrame with new column containing internal vertex
id</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.add_nodes_from">
<code class="sig-name descname">add_nodes_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nodes</span></em>, <em class="sig-param"><span class="n">bipartite</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">multipartite</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L220"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.add_nodes_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Add nodes information to the Graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes</strong><span class="classifier">list or cudf.Series</span></dt><dd><p>The nodes of the graph to be stored. If bipartite and multipartite
arguments are not passed, the nodes are considered to be a list of
all the nodes present in the Graph.</p>
</dd>
<dt><strong>bipartite</strong><span class="classifier">str</span></dt><dd><p>Sets the Graph as bipartite. The nodes are stored as a set of nodes
of the partition named as bipartite argument.</p>
</dd>
<dt><strong>multipartite</strong><span class="classifier">str</span></dt><dd><p>Sets the Graph as multipartite. The nodes are stored as a set of
nodes of the partition named as multipartite argument.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L208"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty this graph. This function is added for NetworkX compatibility.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.compute_local_data">
<code class="sig-name descname">compute_local_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">by</span></em>, <em class="sig-param"><span class="n">load_balance</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L656"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.compute_local_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the local edges, vertices and offsets for a distributed
graph stored as a dask-cudf dataframe and initialize the
communicator. Performs global sorting and load_balancing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">str</span></dt><dd><p>by argument is the column by which we want to sort and
partition. It should be the source column name for generating
CSR format and destination column name for generating CSC
format.</p>
</dd>
<dt><strong>load_balance</strong><span class="classifier">bool</span></dt><dd><p>Set as True to perform load_balancing after global sorting of
dask-cudf DataFrame. This ensures that the data is uniformly
distributed among multiple GPUs to avoid over-loading.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.compute_renumber_edge_list">
<code class="sig-name descname">compute_renumber_edge_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transposed</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L795"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.compute_renumber_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a renumbered edge list</p>
<p>This function works in the MNMG pipeline and will transform
the input dask_cudf.DataFrame into a renumbered edge list
in the prescribed direction.</p>
<p>This function will be called by the algorithms to ensure
that the graph is renumbered properly.  The graph object will
cache the most recent renumbering attempt.  For benchmarking
purposes, this function can be called prior to calling a
graph algorithm so we can measure the cost of computing
the renumbering separately from the cost of executing the
algorithm.</p>
<p>When creating a CSR-like structure, set transposed to False.
When creating a CSC-like structure, set transposed to True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transposed</strong><span class="classifier">(optional) bool</span></dt><dd><p>If True, renumber with the intent to make a CSC-like
structure.  If False, renumber with the intent to make
a CSR-like structure.  Defaults to False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.degree">
<code class="sig-name descname">degree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertex_subset</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1119"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex degree, which is the total number of edges incident
to a vertex (both in and out edges). By default, this method computes
degrees for the entire set of vertices. If vertex_subset is provided,
then this method optionally filters out all but those listed in
vertex_subset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset</strong><span class="classifier">cudf.Series or iterable container, optional</span></dt><dd><p>a container of vertices for displaying corresponding degree. If not
set, degrees are computed for the entire set of vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU DataFrame of size N (the default) or the size of the given
vertices (vertex_subset) containing the degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[‘degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">all_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.degrees">
<code class="sig-name descname">degrees</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertex_subset</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1162"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex in-degree and out-degree. By default, this method
computes vertex degrees for the entire set of vertices. If
vertex_subset is provided, this method optionally filters out all but
those listed in vertex_subset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset</strong><span class="classifier">cudf.Series or iterable container, optional</span></dt><dd><p>A container of vertices for displaying corresponding degree. If not
set, degrees are computed for the entire set of vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU DataFrame of size N (the default) or the size of the given
vertices (vertex_subset) containing the degrees. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[‘in_degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The in-degree of the vertex.</p>
</dd>
<dt>df[‘out_degree’]<span class="classifier">cudf.Series</span></dt><dd><p>The out-degree of the vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degrees</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.delete_adj_list">
<code class="sig-name descname">delete_adj_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L947"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.delete_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the adjacency list.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.delete_edge_list">
<code class="sig-name descname">delete_edge_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L737"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.delete_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the edge list.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.edges">
<code class="sig-name descname">edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1351"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all the edges in the graph as a cudf.DataFrame containing
sources and destinations. It does not return the edge weights.
For viewing edges with weights use view_edge_list()</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.enable_batch">
<code class="sig-name descname">enable_batch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L135"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.enable_batch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.from_cudf_adjlist">
<code class="sig-name descname">from_cudf_adjlist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">offset_col</span></em>, <em class="sig-param"><span class="n">index_col</span></em>, <em class="sig-param"><span class="n">value_col</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L745"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.from_cudf_adjlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph from the adjacency list. It is an error to call this
method on an initialized Graph object. The passed offset_col and
index_col arguments wrap gdf_column objects that represent a graph
using the adjacency list format.
If value_col is None, an unweighted graph is created. If value_col is
not None, a weighted graph is created.
Undirected edges must be stored as directed edges in both directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets must be in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>.
If not, this cudf.Series wraps a gdf_column of size E (E: number of
edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">M</span><span class="p">[</span><span class="s1">'2'</span><span class="p">],(</span><span class="n">M</span><span class="p">[</span><span class="s1">'0'</span><span class="p">],</span><span class="n">M</span><span class="p">[</span><span class="s1">'1'</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offsets</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_adjlist</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.from_cudf_edgelist">
<code class="sig-name descname">from_cudf_edgelist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_df</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">'source'</span></em>, <em class="sig-param"><span class="n">destination</span><span class="o">=</span><span class="default_value">'destination'</span></em>, <em class="sig-param"><span class="n">edge_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">renumber</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L303"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.from_cudf_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph from the edge list. It is an error to call this
method on an initialized Graph object. The passed input_df argument
wraps gdf_column objects that represent a graph using the edge list
format. source argument is source column name and destination argument
is destination column name.</p>
<p>By default, renumbering is enabled to map the source and destination
vertices into an index in the range [0, V) where V is the number
of vertices.  If the input vertices are a single column of integers
in the range [0, V), renumbering can be disabled and the original
external vertex ids will be used.</p>
<p>If weights are present, edge_attr argument is the weights column name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_df</strong><span class="classifier">cudf.DataFrame or dask_cudf.DataFrame</span></dt><dd><p>A DataFrame that contains edge information
If a dask_cudf.DataFrame is passed it will be reinterpreted as
a cudf.DataFrame. For the distributed path please use
from_dask_cudf_edgelist.</p>
</dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd><p>source column name or array of column names</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd><p>destination column name or array of column names</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">str or None</span></dt><dd><p>the weights column name. Default is None</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>Indicate whether or not to renumber the source and destination
vertex IDs. Default is True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span>
<span class="go">                         edge_attr='2', renumber=False)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.from_dask_cudf_edgelist">
<code class="sig-name descname">from_dask_cudf_edgelist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_ddf</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">'source'</span></em>, <em class="sig-param"><span class="n">destination</span><span class="o">=</span><span class="default_value">'destination'</span></em>, <em class="sig-param"><span class="n">edge_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">renumber</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L571"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.from_dask_cudf_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the distributed graph from the dask_cudf.DataFrame
edgelist. Undirected Graphs are not currently supported.</p>
<p>By default, renumbering is enabled to map the source and destination
vertices into an index in the range [0, V) where V is the number
of vertices.  If the input vertices are a single column of integers
in the range [0, V), renumbering can be disabled and the original
external vertex ids will be used.</p>
<p>Note that the graph object will store a reference to the
dask_cudf.DataFrame provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_ddf</strong><span class="classifier">dask_cudf.DataFrame</span></dt><dd><p>The edgelist as a dask_cudf.DataFrame</p>
</dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd><p>source column name or array of column names</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str</span></dt><dd><p>destination column name or array of column names</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">str</span></dt><dd><p>weights column name.</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>If source and destination indices are not in range 0 to V where V
is number of vertices, renumber argument should be True.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.from_numpy_array">
<code class="sig-name descname">from_numpy_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">np_array</span></em>, <em class="sig-param"><span class="n">nodes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L548"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.from_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the graph from numpy array containing adjacency matrix.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.from_numpy_matrix">
<code class="sig-name descname">from_numpy_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">np_matrix</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L564"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.from_numpy_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the graph from numpy matrix containing adjacency matrix.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.from_pandas_adjacency">
<code class="sig-name descname">from_pandas_adjacency</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pdf</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L505"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.from_pandas_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the graph from pandas adjacency matrix</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.from_pandas_edgelist">
<code class="sig-name descname">from_pandas_edgelist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pdf</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">'source'</span></em>, <em class="sig-param"><span class="n">destination</span><span class="o">=</span><span class="default_value">'destination'</span></em>, <em class="sig-param"><span class="n">edge_attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">renumber</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L438"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.from_pandas_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph from the edge list. It is an error to call this
method on an initialized Graph object. Source argument is source
column name and destination argument is destination column name.</p>
<p>By default, renumbering is enabled to map the source and destination
vertices into an index in the range [0, V) where V is the number
of vertices.  If the input vertices are a single column of integers
in the range [0, V), renumbering can be disabled and the original
external vertex ids will be used.</p>
<p>If weights are present, edge_attr argument is the weights column name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_df</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>A DataFrame that contains edge information</p>
</dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd><p>source column name or array of column names</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd><p>destination column name or array of column names</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">str or None</span></dt><dd><p>the weights column name. Default is None</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>Indicate whether or not to renumber the source and destination
vertex IDs. Default is True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span>
<span class="go">                         edge_attr='2', renumber=False)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.get_two_hop_neighbors">
<code class="sig-name descname">get_two_hop_neighbors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L953"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.get_two_hop_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex pairs that are two hops apart. The resulting pairs are
sorted before returning.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[first]<span class="classifier">cudf.Series</span></dt><dd><p>the first vertex id of a pair, if an external vertex id
is defined by only one column</p>
</dd>
<dt>df[second]<span class="classifier">cudf.Series</span></dt><dd><p>the second vertex id of a pair, if an external vertex id
is defined by only one column</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.has_edge">
<code class="sig-name descname">has_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1330"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.has_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the graph contains the edge (u,v).</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.has_node">
<code class="sig-name descname">has_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1314"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.has_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the graph contains the node n.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.in_degree">
<code class="sig-name descname">in_degree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertex_subset</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1039"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.in_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex in-degree. Vertex in-degree is the number of edges
pointing into the vertex. By default, this method computes vertex
degrees for the entire set of vertices. If vertex_subset is provided,
this method optionally filters out all but those listed in
vertex_subset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset</strong><span class="classifier">cudf.Series or iterable container, optional</span></dt><dd><p>A container of vertices for displaying corresponding in-degree.
If not set, degrees are computed for the entire set of vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU DataFrame of size N (the default) or the size of the given
vertices (vertex_subset) containing the in_degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.</p>
<dl class="simple">
<dt>df[vertex]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[degree]<span class="classifier">cudf.Series</span></dt><dd><p>The computed in-degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.is_bipartite">
<code class="sig-name descname">is_bipartite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L263"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.is_bipartite" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if Graph is bipartite. This solely relies on the user call of
add_nodes_from with the bipartite parameter. This does not parse the
graph to check if it is bipartite.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.is_directed">
<code class="sig-name descname">is_directed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1308"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.is_directed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.is_multipartite">
<code class="sig-name descname">is_multipartite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L272"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.is_multipartite" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if Graph is multipartite. This solely relies on the user call
of add_nodes_from with the partition parameter. This does not parse
the graph to check if it is multipartite.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.lookup_internal_vertex_id">
<code class="sig-name descname">lookup_internal_vertex_id</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">column_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1441"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.lookup_internal_vertex_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a DataFrame containing external vertex ids in the identified
columns, or a Series containing external vertex ids, return a
Series with the internal vertex ids.</p>
<p>Note that this function does not guarantee order in single GPU mode,
and does not guarantee order or partitioning in multi-GPU mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: cudf.DataFrame, cudf.Series, dask_cudf.DataFrame, dask_cudf.Series</strong></dt><dd><p>A DataFrame containing external vertex identifiers that will be
converted into internal vertex identifiers.</p>
</dd>
<dt><strong>column_name: (optional) string</strong></dt><dd><p>Name of the column containing the external vertex ids</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>series</strong><span class="classifier">cudf.Series or dask_cudf.Series</span></dt><dd><p>The internal vertex identifiers</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.neighbors">
<code class="sig-name descname">neighbors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1385"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.neighbors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.nodes">
<code class="sig-name descname">nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1359"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all the nodes in the graph as a cudf.Series</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.number_of_edges">
<code class="sig-name descname">number_of_edges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">directed_edges</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1008"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of edges in the graph.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.number_of_nodes">
<code class="sig-name descname">number_of_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1000"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias of number_of_vertices(). This function is added for NetworkX
compatibility.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.number_of_vertices">
<code class="sig-name descname">number_of_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L977"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.number_of_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of nodes in the graph.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.out_degree">
<code class="sig-name descname">out_degree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertex_subset</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1078"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.out_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex out-degree. Vertex out-degree is the number of edges
pointing out from the vertex. By default, this method computes vertex
degrees for the entire set of vertices. If vertex_subset is provided,
this method optionally filters out all but those listed in
vertex_subset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset</strong><span class="classifier">cudf.Series or iterable container, optional</span></dt><dd><p>A container of vertices for displaying corresponding out-degree.
If not set, degrees are computed for the entire set of vertices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU DataFrame of size N (the default) or the size of the given
vertices (vertex_subset) containing the out_degree. The ordering is
relative to the adjacency list, or that given by the specified
vertex_subset.</p>
<dl class="simple">
<dt>df[vertex]<span class="classifier">cudf.Series</span></dt><dd><p>The vertex IDs (will be identical to vertex_subset if
specified).</p>
</dd>
<dt>df[degree]<span class="classifier">cudf.Series</span></dt><dd><p>The computed out-degree of the corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.sets">
<code class="sig-name descname">sets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L281"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bipartite set of nodes. This solely relies on the user’s
call of add_nodes_from with the bipartite parameter. This does not
parse the graph to compute bipartite sets. If bipartite argument was
not provided during add_nodes_from(), it raise an exception that the
graph is not bipartite.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.to_directed">
<code class="sig-name descname">to_directed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1235"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.to_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a directed representation of the graph.
This function sets the type of graph as DiGraph() and returns the
directed view.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">DiGraph</span></dt><dd><p>A directed graph with the same nodes, and each edge (u,v,weights)
replaced by two directed edges (u,v,weights) and (v,u,weights).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DiG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.to_numpy_array">
<code class="sig-name descname">to_numpy_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L527"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.to_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph adjacency matrix as a NumPy array.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.to_numpy_matrix">
<code class="sig-name descname">to_numpy_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L541"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.to_numpy_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph adjacency matrix as a NumPy matrix.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.to_pandas_adjacency">
<code class="sig-name descname">to_pandas_adjacency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L513"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.to_pandas_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph adjacency matrix as a Pandas DataFrame.</p>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.to_pandas_edgelist">
<code class="sig-name descname">to_pandas_edgelist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">'source'</span></em>, <em class="sig-param"><span class="n">destination</span><span class="o">=</span><span class="default_value">'destination'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L486"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.to_pandas_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph edge list as a Pandas DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd><p>source column name or array of column names</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd><p>destination column name or array of column names</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">pandas.DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.to_undirected">
<code class="sig-name descname">to_undirected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1269"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.to_undirected" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an undirected copy of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">Graph</span></dt><dd><p>A undirected graph with the same nodes, and each directed edge
(u,v,weights) replaced by an undirected edge (u,v,weights).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DiG</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DiG</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiG</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>
<dl class="py class">
<dt id="cugraph.structure.graph.Graph.transposedAdjList">
<em class="property">class </em><code class="sig-name descname">transposedAdjList</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">offsets</span></em>, <em class="sig-param"><span class="n">indices</span></em>, <em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L64"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.transposedAdjList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.unrenumber">
<code class="sig-name descname">unrenumber</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">column_name</span></em>, <em class="sig-param"><span class="n">preserve_order</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L1405"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.unrenumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a DataFrame containing internal vertex ids in the identified
column, replace this with external vertex ids.  If the renumbering
is from a single column, the output dataframe will use the same
name for the external vertex identifiers.  If the renumbering is from
a multi-column input, the output columns will be labeled 0 through
n-1 with a suffix of _column_name.</p>
<p>Note that this function does not guarantee order in single GPU mode,
and does not guarantee order or partitioning in multi-GPU mode.  If you
wish to preserve ordering, add an index column to df and sort the
return by that index column.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: cudf.DataFrame or dask_cudf.DataFrame</strong></dt><dd><p>A DataFrame containing internal vertex identifiers that will be
converted into external vertex identifiers.</p>
</dd>
<dt><strong>column_name: string</strong></dt><dd><p>Name of the column containing the internal vertex id.</p>
</dd>
<dt><strong>preserve_order: (optional) bool</strong></dt><dd><p>If True, preserve the order of the rows in the output
DataFrame to match the input DataFrame</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or dask_cudf.DataFrame</span></dt><dd><p>The original DataFrame columns exist unmodified.  The external
vertex identifiers are added to the DataFrame, the internal
vertex identifier column is removed from the dataframe.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.view_adj_list">
<code class="sig-name descname">view_adj_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L853"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.view_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the adjacency list. Compute it if needed.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets are in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices are in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>This pointer is <code class="docutils literal notranslate"><span class="pre">None</span></code> for unweighted graphs.
For weighted graphs, this cudf.Series wraps a gdf_column of size E
(E: number of edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.view_edge_list">
<code class="sig-name descname">view_edge_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L682"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.view_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the edge list. Compute it if needed.</p>
<p>NOTE: If the graph is of type Graph() then the displayed undirected
edges are the same as displayed by networkx Graph(), but the direction
could be different i.e. an edge displayed by cugraph as (src, dst)
could be displayed as (dst, src) by networkx.</p>
<p>cugraph.Graph stores symmetrized edgelist internally. For displaying
undirected edgelist for a Graph the upper trianglar matrix of the
symmetrized edgelist is returned.</p>
<p>networkx.Graph renumbers the input and stores the upper triangle of
this renumbered input. Since the internal renumbering of networx and
cugraph is different, the upper triangular matrix of networkx
renumbered input may not be the same as cugraph’s upper trianglar
matrix of the symmetrized edgelist. Hence the displayed source and
destination pairs in both will represent the same edge but node values
could be swapped.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>This cudf.DataFrame wraps source, destination and weight</p>
<dl class="simple">
<dt>df[src]<span class="classifier">cudf.Series</span></dt><dd><p>contains the source index for each edge</p>
</dd>
<dt>df[dst]<span class="classifier">cudf.Series</span></dt><dd><p>contains the destination index for each edge</p>
</dd>
<dt>df[weight]<span class="classifier">cusd.Series</span></dt><dd><p>Column is only present for weighted Graph,
then containing the weight value for each edge</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cugraph.structure.graph.Graph.view_transposed_adj_list">
<code class="sig-name descname">view_transposed_adj_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/graph.py#L896"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.graph.Graph.view_transposed_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the transposed adjacency list. Compute it if needed.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets are in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices are in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>This pointer is <code class="docutils literal notranslate"><span class="pre">None</span></code> for unweighted graphs.
For weighted graphs, this cudf.Series wraps a gdf_column of size E
(E: number of edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="module-cugraph.structure.symmetrize">
<span id="symmetrize"></span><h3>Symmetrize<a class="headerlink" href="#module-cugraph.structure.symmetrize" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.structure.symmetrize.symmetrize">
<code class="sig-prename descclassname">cugraph.structure.symmetrize.</code><code class="sig-name descname">symmetrize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source_col</span></em>, <em class="sig-param"><span class="n">dest_col</span></em>, <em class="sig-param"><span class="n">value_col</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/symmetrize.py#L132"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.symmetrize.symmetrize" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a COO set of source destination pairs along with associated values
stored in a single GPU or distributed
create a new COO set of source destination pairs along with values where
all edges exist in both directions.</p>
<p>Return from this call will be a COO stored as two cudf Series or
dask_cudf.Series -the symmetrized source column and the symmetrized dest
column, along with
an optional cudf Series containing the associated values (only if the
values are passed in).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source_col</strong><span class="classifier">cudf.Series or dask_cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices must be an integer type.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series or dask_cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be an integer type.</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or dask_cudf.Series (optional)</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains values associated with this edge.
For this function the values can be any type, they are not
examined, just copied.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">'0'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">'1'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">'2'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.symmetrize.symmetrize_ddf">
<code class="sig-prename descclassname">cugraph.structure.symmetrize.</code><code class="sig-name descname">symmetrize_ddf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">src_name</span></em>, <em class="sig-param"><span class="n">dst_name</span></em>, <em class="sig-param"><span class="n">weight_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/symmetrize.py#L79"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.symmetrize.symmetrize_ddf" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a COO stored in a distributed DataFrame, and the column names of
the source and destination columns and create a new data frame
using the same column names that symmetrize the graph so that all
edges appear in both directions.</p>
<p>Note that if other columns exist in the data frame (e.g. edge weights)
the other columns will also be replicated.  That is, if (u,v,data)
represents the source value (u), destination value (v) and some
set of other columns (data) in the input data, then the output
data will contain both (u,v,data) and (v,u,data) with matching
data.</p>
<p>If (u,v,data1) and (v,u,data2) exist in the input data where data1
!= data2 then this code will arbitrarily pick the smaller data
element to keep, if this is not desired then the caller should
should correct the data prior to calling symmetrize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">dask_cudf.DataFrame</span></dt><dd><p>Input data frame containing COO.  Columns should contain source
ids, destination ids and any properties associated with the
edges.</p>
</dd>
<dt><strong>src_name</strong><span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the source ids</p>
</dd>
<dt><strong>dst_name</strong><span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the destination ids</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym_df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.symmetrize.symmetrize_df">
<code class="sig-prename descclassname">cugraph.structure.symmetrize.</code><code class="sig-name descname">symmetrize_df</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">src_name</span></em>, <em class="sig-param"><span class="n">dst_name</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/symmetrize.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.symmetrize.symmetrize_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a COO stored in a DataFrame, along with the column names of
the source and destination columns and create a new data frame
using the same column names that symmetrize the graph so that all
edges appear in both directions.
Note that if other columns exist in the data frame (e.g. edge weights)
the other columns will also be replicated.  That is, if (u,v,data)
represents the source value (u), destination value (v) and some
set of other columns (data) in the input data, then the output
data will contain both (u,v,data) and (v,u,data) with matching
data.
If (u,v,data1) and (v,u,data2) exist in the input data where data1
!= data2 then this code will arbitrarily pick the smaller data
element to keep, if this is not desired then the caller should
should correct the data prior to calling symmetrize.
Parameters
———-
df : cudf.DataFrame</p>
<blockquote>
<div><p>Input data frame containing COO.  Columns should contain source
ids, destination ids and any properties associated with the
edges.</p>
</div></blockquote>
<dl class="simple">
<dt>src_name<span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the source ids</p>
</dd>
<dt>dst_name<span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the destination ids</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph.dask</span> <span class="k">as</span> <span class="nn">dcg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Comms</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">get_chunksize</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
<span class="go">                             delimiter=' ',</span>
<span class="go">                             names=['src', 'dst', 'weight'],</span>
<span class="go">                             dtype=['int32', 'int32', 'float32'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym_ddf</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">symmetrize_ddf</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="s2">"src"</span><span class="p">,</span> <span class="s2">"dst"</span><span class="p">,</span> <span class="s2">"weight"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Comms</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.structure.convert_matrix">
<span id="conversion-from-other-formats"></span><h3>Conversion from Other Formats<a class="headerlink" href="#module-cugraph.structure.convert_matrix" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.from_adjlist">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_adjlist</code><span class="sig-paren">(</span><em class="sig-param">offsets</em>, <em class="sig-param">indices</em>, <em class="sig-param">values=None</em>, <em class="sig-param">create_using=&lt;class 'cugraph.structure.graph.Graph'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L86"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_adjlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the graph from cuDF or Pandas Series representing adjacency
matrix CSR data and returns a new cugraph.Graph object if ‘create_using’ is
set to cugraph.Graph (the default), or cugraph.DiGraph if ‘create_using’ is
set to cugraph.DiGraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offsets</strong><span class="classifier">cudf.Series, pandas.Series</span></dt><dd><p>The offsets of a CSR adjacency matrix.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">cudf.Series, pandas.Series</span></dt><dd><p>The indices of a CSR adjacency matrix.</p>
</dd>
<dt><strong>values</strong><span class="classifier">cudf.Series, pandas.Series, or None (default), optional</span></dt><dd><p>The values in a CSR adjacency matrix, which represent edge weights in a
graph. If not provided, the resulting graph is considered unweighted.</p>
</dd>
<dt><strong>create_using</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>Specify the type of Graph to create.  Default is cugraph.Graph</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">'int32'</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">'int32'</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s1">'float32'</span><span class="p">},</span>
<span class="gp">... </span>                  <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">pdf</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="n">pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offsets</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">from_adjlist</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.from_cudf_edgelist">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_cudf_edgelist</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">source='source'</em>, <em class="sig-param">destination='destination'</em>, <em class="sig-param">edge_attr=None</em>, <em class="sig-param">create_using=&lt;class 'cugraph.structure.graph.Graph'&gt;</em>, <em class="sig-param">renumber=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L146"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_cudf_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new graph created from the edge list representaion. This function
is added for NetworkX compatibility (this function is a RAPIDS version of
NetworkX’s from_pandas_edge_list()).  This function does not support
multiple source or destination columns.  But does support renumbering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>This cudf.DataFrame contains columns storing edge source vertices,
destination (or target following NetworkX’s terminology) vertices, and
(optional) weights.</p>
</dd>
<dt><strong>source</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the source column.</p>
</dd>
<dt><strong>destination</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the destination (or target following NetworkX’s
terminology) column.</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">string or integer, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>. If not, this is used to index the weight
column.</p>
</dd>
<dt><strong>create_using</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>Specify the type of Graph to create.  Default is cugraph.Graph</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>If source and destination indices are not in range 0 to V where V
is number of vertices, renumber argument should be True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.from_edgelist">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_edgelist</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">source='source'</em>, <em class="sig-param">destination='destination'</em>, <em class="sig-param">edge_attr=None</em>, <em class="sig-param">create_using=&lt;class 'cugraph.structure.graph.Graph'&gt;</em>, <em class="sig-param">renumber=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L30"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new graph created from the edge list representaion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame, pandas.DataFrame, dask_cudf.core.DataFrame</span></dt><dd><p>This DataFrame contains columns storing edge source vertices,
destination (or target following NetworkX’s terminology) vertices, and
(optional) weights.</p>
</dd>
<dt><strong>source</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the source column.</p>
</dd>
<dt><strong>destination</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the destination (or target following NetworkX’s
terminology) column.</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">string or integer, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>. If not, this is used to index the weight
column.</p>
</dd>
<dt><strong>create_using</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>Specify the type of Graph to create.  Default is cugraph.Graph</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>If source and destination indices are not in range 0 to V where V
is number of vertices, renumber argument should be True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span>
<span class="go">                              edge_attr='2')</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.from_numpy_array">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_numpy_array</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">create_using=&lt;class 'cugraph.structure.graph.Graph'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L303"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the graph from numpy array containing adjacency matrix.
Set create_using to cugraph.DiGraph for directed graph and
cugraph.Graph for undirected Graph.</p>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.from_numpy_matrix">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_numpy_matrix</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">create_using=&lt;class 'cugraph.structure.graph.Graph'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L328"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_numpy_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the graph from numpy matrix containing adjacency matrix.
Set create_using to cugraph.DiGraph for directed graph and
cugraph.Graph for undirected Graph.</p>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.from_pandas_adjacency">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_pandas_adjacency</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">create_using=&lt;class 'cugraph.structure.graph.Graph'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L277"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_pandas_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the graph from pandas adjacency matrix.
Set create_using to cugraph.DiGraph for directed graph and
cugraph.Graph for undirected Graph.</p>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.from_pandas_edgelist">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">from_pandas_edgelist</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">source='source'</em>, <em class="sig-param">destination='destination'</em>, <em class="sig-param">edge_attr=None</em>, <em class="sig-param">create_using=&lt;class 'cugraph.structure.graph.Graph'&gt;</em>, <em class="sig-param">renumber=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L194"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_pandas_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph from the edge list. It is an error to call this
method on an initialized Graph object. Source argument is source
column name and destination argument is destination column name.</p>
<p>By default, renumbering is enabled to map the source and destination
vertices into an index in the range [0, V) where V is the number
of vertices.  If the input vertices are a single column of integers
in the range [0, V), renumbering can be disabled and the original
external vertex ids will be used.</p>
<p>If weights are present, edge_attr argument is the weights column name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_df</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>A DataFrame that contains edge information</p>
</dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd><p>source column name or array of column names</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd><p>destination column name or array of column names</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">str or None</span></dt><dd><p>the weights column name. Default is None</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>Indicate whether or not to renumber the source and destination
vertex IDs. Default is True.</p>
</dd>
<dt><strong>create_using: cugraph.DiGraph or cugraph.Graph</strong></dt><dd><p>Indicate whether to create a directed or undirected graph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.DiGraph or cugraph.Graph</span></dt><dd><p>graph containing edges from the pandas edgelist</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span>
<span class="go">                           edge_attr='2', renumber=False)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.to_numpy_array">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">to_numpy_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L320"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.to_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph adjacency matrix as a NumPy array.</p>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.to_numpy_matrix">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">to_numpy_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L344"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.to_numpy_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph adjacency matrix as a NumPy matrix.</p>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.to_pandas_adjacency">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">to_pandas_adjacency</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L294"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.to_pandas_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph adjacency matrix as a Pandas DataFrame.
The row indices denote source and column names denote destination.</p>
</dd></dl>
<dl class="py function">
<dt id="cugraph.structure.convert_matrix.to_pandas_edgelist">
<code class="sig-prename descclassname">cugraph.structure.convert_matrix.</code><code class="sig-name descname">to_pandas_edgelist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">'source'</span></em>, <em class="sig-param"><span class="n">destination</span><span class="o">=</span><span class="default_value">'destination'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/structure/convert_matrix.py#L254"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.to_pandas_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph edge list as a Pandas DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph or cugraph.DiGraph</span></dt><dd><p>Graph containg the edgelist.</p>
</dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd><p>source column name or array of column names</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd><p>destination column name or array of column names</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——</strong></dt><dd></dd>
<dt><strong>df</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>pandas dataframe containing the edgelist as source and
destination columns.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
</div>
</div>
<div class="section" id="centrality">
<h2>Centrality<a class="headerlink" href="#centrality" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.centrality.betweenness_centrality">
<span id="betweenness-centrality"></span><h3>Betweenness Centrality<a class="headerlink" href="#module-cugraph.centrality.betweenness_centrality" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.centrality.betweenness_centrality.betweenness_centrality">
<code class="sig-prename descclassname">cugraph.centrality.betweenness_centrality.</code><code class="sig-name descname">betweenness_centrality</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">k=None</em>, <em class="sig-param">normalized=True</em>, <em class="sig-param">weight=None</em>, <em class="sig-param">endpoints=False</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">result_dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/centrality/betweenness_centrality.py#L25"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.centrality.betweenness_centrality.betweenness_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the betweenness centrality for all vertices of the graph G.
Betweenness centrality is a measure of the number of shortest paths that
pass through a vertex.  A vertex with a high betweenness centrality score
has more paths passing through it and is therefore believed to be more
important. Rather than doing an all-pair shortest path, a sample of k
starting vertices can be used.</p>
<p>CuGraph does not currently support the ‘endpoints’ and ‘weight’ parameters
as seen in the corresponding networkX call.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>The graph can be either directed (DiGraph) or undirected (Graph).
Weights in the graph are ignored, the current implementation uses
BFS traversals. Use weight parameter if weights need to be considered
(currently not supported)</p>
</dd>
<dt><strong>k</strong><span class="classifier">int or list or None, optional, default=None</span></dt><dd><p>If k is not None, use k node samples to estimate betweenness.  Higher
values give better approximation
If k is a list, use the content of the list for estimation: the list
should contain vertices identifiers.
If k is None (the default), all the vertices are used to estimate
betweenness.
Vertices obtained through sampling or defined as a list will be used as
sources for traversals inside the algorithm.</p>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool, optional</span></dt><dd><p>Default is True.
If true, the betweenness values are normalized by
2 / ((n - 1) * (n - 2)) for Graphs (undirected), and
1 / ((n - 1) * (n - 2)) for DiGraphs (directed graphs)
where n is the number of nodes in G.
Normalization will ensure that values are in [0, 1],
this normalization scales for the highest possible value where one
node is crossed by every single shortest path.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">cudf.DataFrame, optional, default=None</span></dt><dd><p>Specifies the weights to be used for each edge.
Should contain a mapping between
edges and weights.
(Not Supported)</p>
</dd>
<dt><strong>endpoints</strong><span class="classifier">bool, optional, default=False</span></dt><dd><p>If true, include the endpoints in the shortest path counts.
(Not Supported)</p>
</dd>
<dt><strong>seed</strong><span class="classifier">optional</span></dt><dd><p>if k is specified and k is an integer, use seed to initialize the
random number generator.
Using None as seed relies on random.seed() behavior: using current
system time
If k is either None or list: seed parameter is ignored</p>
</dd>
<dt><strong>result_dtype</strong><span class="classifier">np.float32 or np.float64, optional, default=np.float64</span></dt><dd><p>Indicate the data type of the betweenness centrality scores</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or Dictionary if using NetworkX</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding betweenness centrality values.
Please note that the resulting the ‘vertex’ column might not be
in ascending order.  The Dictionary conatains the same two columns</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘betweenness_centrality’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the betweenness centrality of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bc</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.centrality.betweenness_centrality.edge_betweenness_centrality">
<code class="sig-prename descclassname">cugraph.centrality.betweenness_centrality.</code><code class="sig-name descname">edge_betweenness_centrality</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">k=None</em>, <em class="sig-param">normalized=True</em>, <em class="sig-param">weight=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">result_dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/centrality/betweenness_centrality.py#L147"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.centrality.betweenness_centrality.edge_betweenness_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edge betweenness centrality for all edges of the graph G.
Betweenness centrality is a measure of the number of shortest paths
that pass over an edge.  An edge with a high betweenness centrality
score has more paths passing over it and is therefore believed to be
more important. Rather than doing an all-pair shortest path, a sample
of k starting vertices can be used.</p>
<p>CuGraph does not currently support the ‘weight’ parameter
as seen in the corresponding networkX call.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>The graph can be either directed (DiGraph) or undirected (Graph).
Weights in the graph are ignored, the current implementation uses
BFS traversals. Use weight parameter if weights need to be considered
(currently not supported)</p>
</dd>
<dt><strong>k</strong><span class="classifier">int or list or None, optional, default=None</span></dt><dd><p>If k is not None, use k node samples to estimate betweenness.  Higher
values give better approximation
If k is a list, use the content of the list for estimation: the list
should contain vertices identifiers.
Vertices obtained through sampling or defined as a list will be used as
sources for traversals inside the algorithm.</p>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool, optional</span></dt><dd><p>Default is True.
If true, the betweenness values are normalized by
2 / (n * (n - 1)) for Graphs (undirected), and
1 / (n * (n - 1)) for DiGraphs (directed graphs)
where n is the number of nodes in G.
Normalization will ensure that values are in [0, 1],
this normalization scales for the highest possible value where one
edge is crossed by every single shortest path.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">cudf.DataFrame, optional, default=None</span></dt><dd><p>Specifies the weights to be used for each edge.
Should contain a mapping between
edges and weights.
(Not Supported)</p>
</dd>
<dt><strong>seed</strong><span class="classifier">optional</span></dt><dd><p>if k is specified and k is an integer, use seed to initialize the
random number generator.
Using None as seed relies on random.seed() behavior: using current
system time
If k is either None or list: seed parameter is ignored</p>
</dd>
<dt><strong>result_dtype</strong><span class="classifier">np.float32 or np.float64, optional, default=np.float64</span></dt><dd><p>Indicate the data type of the betweenness centrality scores
Using double automatically switch implementation to “default”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or Dictionary if using NetworkX</span></dt><dd><p>GPU data frame containing three cudf.Series of size E: the vertex
identifiers of the sources, the vertex identifies of the destinations
and the corresponding betweenness centrality values.
Please note that the resulting the ‘src’, ‘dst’ column might not be
in ascending order.</p>
<dl class="simple">
<dt>df[‘src’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers of the source of each edge</p>
</dd>
<dt>df[‘dst’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers of the destination of each edge</p>
</dd>
<dt>df[‘edge_betweenness_centrality’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the betweenness centrality of edges</p>
</dd>
</dl>
<p>When using undirected graphs, ‘src’ and ‘dst’ only contains elements
such that ‘src’ &lt; ‘dst’, which might differ from networkx and user’s
input. Namely edge (1 -&gt; 0) is transformed into (0 -&gt; 1) but
contains the betweenness centrality of edge (1 -&gt; 0).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ebc</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">edge_betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.centrality.edge_betweenness_centrality">
<span id="edge-betweenness-centrality"></span><h3>Edge Betweenness Centrality<a class="headerlink" href="#module-cugraph.centrality.edge_betweenness_centrality" title="Permalink to this headline">¶</a></h3>
<p>Compute the edge betweenness centrality for all edges of the graph G.
Betweenness centrality is a measure of the number of shortest paths
that pass over an edge.  An edge with a high betweenness centrality
score has more paths passing over it and is therefore believed to be
more important. Rather than doing an all-pair shortest path, a sample
of k starting vertices can be used.</p>
<p>CuGraph does not currently support the ‘weight’ parameter
as seen in the corresponding networkX call.</p>
<div class="section" id="parameters">
<h4>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt>G<span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>The graph can be either directed (DiGraph) or undirected (Graph).
Weights in the graph are ignored, the current implementation uses
BFS traversals. Use weight parameter if weights need to be considered
(currently not supported)</p>
</dd>
<dt>k<span class="classifier">int or list or None, optional, default=None</span></dt><dd><p>If k is not None, use k node samples to estimate betweenness.  Higher
values give better approximation
If k is a list, use the content of the list for estimation: the list
should contain vertices identifiers.
Vertices obtained through sampling or defined as a list will be used as
sources for traversals inside the algorithm.</p>
</dd>
<dt>normalized<span class="classifier">bool, optional</span></dt><dd><p>Default is True.
If true, the betweenness values are normalized by
2 / (n * (n - 1)) for Graphs (undirected), and
1 / (n * (n - 1)) for DiGraphs (directed graphs)
where n is the number of nodes in G.
Normalization will ensure that values are in [0, 1],
this normalization scales for the highest possible value where one
edge is crossed by every single shortest path.</p>
</dd>
<dt>weight<span class="classifier">cudf.DataFrame, optional, default=None</span></dt><dd><p>Specifies the weights to be used for each edge.
Should contain a mapping between
edges and weights.
(Not Supported)</p>
</dd>
<dt>seed<span class="classifier">optional</span></dt><dd><p>if k is specified and k is an integer, use seed to initialize the
random number generator.
Using None as seed relies on random.seed() behavior: using current
system time
If k is either None or list: seed parameter is ignored</p>
</dd>
<dt>result_dtype<span class="classifier">np.float32 or np.float64, optional, default=np.float64</span></dt><dd><p>Indicate the data type of the betweenness centrality scores
Using double automatically switch implementation to “default”</p>
</dd>
</dl>
</div>
<div class="section" id="returns">
<h4>Returns<a class="headerlink" href="#returns" title="Permalink to this headline">¶</a></h4>
<dl>
<dt>df<span class="classifier">cudf.DataFrame or Dictionary if using NetworkX</span></dt><dd><p>GPU data frame containing three cudf.Series of size E: the vertex
identifiers of the sources, the vertex identifies of the destinations
and the corresponding betweenness centrality values.
Please note that the resulting the ‘src’, ‘dst’ column might not be
in ascending order.</p>
<dl class="simple">
<dt>df[‘src’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers of the source of each edge</p>
</dd>
<dt>df[‘dst’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers of the destination of each edge</p>
</dd>
<dt>df[‘edge_betweenness_centrality’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the betweenness centrality of edges</p>
</dd>
</dl>
<p>When using undirected graphs, ‘src’ and ‘dst’ only contains elements
such that ‘src’ &lt; ‘dst’, which might differ from networkx and user’s
input. Namely edge (1 -&gt; 0) is transformed into (0 -&gt; 1) but
contains the betweenness centrality of edge (1 -&gt; 0).</p>
</dd>
</dl>
</div>
<div class="section" id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ebc</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">edge_betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="module-cugraph.centrality.katz_centrality">
<span id="katz-centrality"></span><h3>Katz Centrality<a class="headerlink" href="#module-cugraph.centrality.katz_centrality" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.centrality.katz_centrality.katz_centrality">
<code class="sig-prename descclassname">cugraph.centrality.katz_centrality.</code><code class="sig-name descname">katz_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">nstart</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/centrality/katz_centrality.py#L18"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.centrality.katz_centrality.katz_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Katz centrality for the nodes of the graph G. cuGraph does not
currently support the ‘beta’ and ‘weight’ parameters as seen in the
corresponding networkX call. This implementation is based on a relaxed
version of Katz defined by Foster with a reduced computational complexity
of O(n+m)</p>
<p>Foster, K.C., Muth, S.Q., Potterat, J.J. et al.
Computational &amp; Mathematical Organization Theory (2001) 7: 275.
<a class="reference external" href="https://doi.org/10.1023/A:1013470632383">https://doi.org/10.1023/A:1013470632383</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. The graph can
contain either directed (DiGraph) or undirected edges (Graph).</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Attenuation factor defaulted to None. If alpha is not specified then
it is internally calculated as 1/(degree_max) where degree_max is the
maximum out degree.
NOTE : The maximum acceptable value of alpha for convergence
alpha_max = 1/(lambda_max) where lambda_max is the largest eigenvalue
of the graph.
Since lambda_max is always lesser than or equal to degree_max for a
graph, alpha_max will always be greater than or equal to
(1/degree_max). Therefore, setting alpha to (1/degree_max) will
guarantee that it will never exceed alpha_max thus in turn fulfilling
the requirement for convergence.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">None</span></dt><dd><p>A weight scalar - currently Not Supported</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can
be used to limit the execution time and do an early exit before the
solver reaches the convergence tolerance.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0e-6.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 1e-2 and 1e-6 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for katz centrality.</p>
<dl class="simple">
<dt>nstart[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>nstart[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the katz centrality values of vertices</p>
</dd>
</dl>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool</span></dt><dd><p>If True normalize the resulting katz centrality values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or Dictionary if using NetworkX</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding katz centrality values.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘katz_centrality’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the katz centrality of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kc</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">katz_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
<div class="section" id="community">
<h2>Community<a class="headerlink" href="#community" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.community.ecg">
<span id="ensemble-clustering-for-graphs-ecg"></span><h3>Ensemble clustering for graphs (ECG)<a class="headerlink" href="#module-cugraph.community.ecg" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.community.ecg.ecg">
<code class="sig-prename descclassname">cugraph.community.ecg.</code><code class="sig-name descname">ecg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_graph</span></em>, <em class="sig-param"><span class="n">min_weight</span><span class="o">=</span><span class="default_value">0.05</span></em>, <em class="sig-param"><span class="n">ensemble_size</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/ecg.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.ecg.ecg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Ensemble Clustering for Graphs (ECG) partition of the input
graph. ECG runs truncated Louvain on an ensemble of permutations of the
input graph, then uses the ensemble partitions to determine weights for
the input graph. The final result is found by running full Louvain on
the input graph using the determined weights.</p>
<p>See <a class="reference external" href="https://arxiv.org/abs/1809.05578">https://arxiv.org/abs/1809.05578</a> for further information.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph or NetworkX Graph</span></dt><dd><p>The graph descriptor should contain the connectivity information
and weights. The adjacency list will be computed if not already
present.</p>
</dd>
<dt><strong>min_weight</strong><span class="classifier">floating point</span></dt><dd><p>The minimum value to assign as an edgeweight in the ECG algorithm.
It should be a value in the range [0,1] usually left as the default
value of .05</p>
</dd>
<dt><strong>ensemble_size</strong><span class="classifier">integer</span></dt><dd><p>The number of graph permutations to use for the ensemble.
The default value is 16, larger values may produce higher quality
partitions for some graphs.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">str</span></dt><dd><p>This parameter is here for NetworkX compatibility and
represents which NetworkX data column represents Edge weights.
Default is None</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame or python dictionary</span></dt><dd><p>GPU data frame of size V containing two columns, the vertex id and
the partition id it is assigned to.</p>
<dl class="simple">
<dt>df[vertex]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[partition]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the partition assigned to the vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="s1">' '</span><span class="p">,</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">ecg</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.community.ktruss_subgraph">
<span id="k-truss"></span><h3>K-Truss<a class="headerlink" href="#module-cugraph.community.ktruss_subgraph" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.community.ktruss_subgraph.k_truss">
<code class="sig-prename descclassname">cugraph.community.ktruss_subgraph.</code><code class="sig-name descname">k_truss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/ktruss_subgraph.py#L20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.ktruss_subgraph.k_truss" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the K-Truss subgraph of a graph for a specific k.</p>
<p>The k-truss of a graph is a subgraph where each edge is part of at least
(k−2) triangles. K-trusses are used for finding tighlty knit groups of
vertices in a graph. A k-truss is a relaxation of a k-clique in the graph
and was define in [1]. Finding cliques is computationally demanding and
finding the maximal k-clique is known to be NP-Hard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. k-Trusses are
defined for only undirected graphs as they are defined for
undirected triangle in a graph.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The desired k to be used for extracting the k-truss subgraph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G_truss</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>A cugraph graph descriptor with the k-truss subgraph for the given k.
The networkx graph will NOT have all attributes copied over</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cugraph.community.ktruss_subgraph.ktruss_subgraph">
<code class="sig-prename descclassname">cugraph.community.ktruss_subgraph.</code><code class="sig-name descname">ktruss_subgraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">use_weights</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/ktruss_subgraph.py#L59"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.ktruss_subgraph.ktruss_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the K-Truss subgraph of a graph for a specific k.</p>
<p>The k-truss of a graph is a subgraph where each edge is part of at least
(k−2) triangles. K-trusses are used for finding tighlty knit groups of
vertices in a graph. A k-truss is a relaxation of a k-clique in the graph
and was define in [1]. Finding cliques is computationally demanding and
finding the maximal k-clique is known to be NP-Hard.</p>
<p>In contrast, finding a k-truss is computationally tractable as its
key building block, namely triangle counting counting, can be executed
in polnymomial time.Typically, it takes many iterations of triangle
counting to find the k-truss of a graph. Yet these iterations operate
on a weakly monotonically shrinking graph.
Therefore, finding the k-truss of a graph can be done in a fairly
reasonable amount of time. The solution in cuGraph is based on a
GPU algorithm first shown in [2] and uses the triangle counting algorithm
from [3].</p>
<p>[1] Cohen, J.,
“Trusses: Cohesive subgraphs for social network analysis”
National security agency technical report, 2008</p>
<p>[2] O. Green, J. Fox, E. Kim, F. Busato, et al.
“Quickly Finding a Truss in a Haystack”
IEEE High Performance Extreme Computing Conference (HPEC), 2017
<a class="reference external" href="https://doi.org/10.1109/HPEC.2017.8091038">https://doi.org/10.1109/HPEC.2017.8091038</a></p>
<p>[3] O. Green, P. Yalamanchili, L.M. Munguia,
“Fast Triangle Counting on GPU”
Irregular Applications: Architectures and Algorithms (IA3), 2014</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. k-Trusses are
defined for only undirected graphs as they are defined for
undirected triangle in a graph.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The desired k to be used for extracting the k-truss subgraph.</p>
</dd>
<dt><strong>use_weights</strong><span class="classifier">Bool</span></dt><dd><p>whether the output should contain the edge weights if G has them</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G_truss</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>A cugraph graph descriptor with the k-truss subgraph for the given k.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k_subgraph</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">ktruss_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.community.leiden">
<span id="leiden"></span><h3>Leiden<a class="headerlink" href="#module-cugraph.community.leiden" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.community.leiden.leiden">
<code class="sig-prename descclassname">cugraph.community.leiden.</code><code class="sig-name descname">leiden</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">resolution</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/leiden.py#L20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.leiden.leiden" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity optimizing partition of the input graph using the
Leiden algorithm</p>
<p>It uses the Louvain method described in:</p>
<p>Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From Louvain to Leiden:
guaranteeing well-connected communities. Scientific reports, 9(1), 5233.
doi: 10.1038/s41598-019-41695-z</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor of type Graph</p>
<p>The adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>This controls the maximum number of levels/iterations of the Leiden
algorithm. When specified the algorithm will terminate after no more
than the specified number of iterations. No error occurs when the
algorithm terminates early in this manner.</p>
</dd>
<dt><strong>resolution: float/double, optional</strong></dt><dd><p>Called gamma in the modularity formula, this changes the size
of the communities.  Higher resolutions lead to more smaller
communities, lower resolutions lead to fewer larger communities.
Defaults to 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing two columns the vertex id and the
partition id it is assigned to.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘partition’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the partition assigned to the vertices</p>
</dd>
</dl>
</dd>
<dt><strong>modularity_score</strong><span class="classifier">float</span></dt><dd><p>a floating point number containing the global modularity score of the
partitioning.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span><span class="p">,</span> <span class="n">modularity_score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">leiden</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.community.louvain">
<span id="louvain"></span><h3>Louvain<a class="headerlink" href="#module-cugraph.community.louvain" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.community.louvain.louvain">
<code class="sig-prename descclassname">cugraph.community.louvain.</code><code class="sig-name descname">louvain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">resolution</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/louvain.py#L20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.louvain.louvain" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity optimizing partition of the input graph using the
Louvain method</p>
<p>It uses the Louvain method described in:</p>
<p>VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of
community hierarchies in large networks, J Stat Mech P10008 (2008),
<a class="reference external" href="http://arxiv.org/abs/0803.0476">http://arxiv.org/abs/0803.0476</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph or NetworkX Graph</span></dt><dd><p>The graph descriptor should contain the connectivity information
and weights. The adjacency list will be computed if not already
present.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>This controls the maximum number of levels/iterations of the Louvain
algorithm. When specified the algorithm will terminate after no more
than the specified number of iterations. No error occurs when the
algorithm terminates early in this manner.</p>
</dd>
<dt><strong>resolution: float/double, optional</strong></dt><dd><p>Called gamma in the modularity formula, this changes the size
of the communities.  Higher resolutions lead to more smaller
communities, lower resolutions lead to fewer larger communities.
Defaults to 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing two columns the vertex id and the
partition id it is assigned to.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘partition’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the partition assigned to the vertices</p>
</dd>
</dl>
</dd>
<dt><strong>modularity_score</strong><span class="classifier">float</span></dt><dd><p>a floating point number containing the global modularity score of the
partitioning.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span><span class="p">,</span> <span class="n">modularity_score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">louvain</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.community.spectral_clustering">
<span id="spectral-clustering"></span><h3>Spectral Clustering<a class="headerlink" href="#module-cugraph.community.spectral_clustering" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_edge_cut">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_edge_cut</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">n_clusters</span></em>, <em class="sig-param"><span class="n">clustering</span></em>, <em class="sig-param"><span class="n">vertex_col_name</span><span class="o">=</span><span class="default_value">'vertex'</span></em>, <em class="sig-param"><span class="n">cluster_col_name</span><span class="o">=</span><span class="default_value">'cluster'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/spectral_clustering.py#L226"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_edge_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edge cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
<dt><strong>vertex_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the external vertex id</p>
</dd>
<dt><strong>cluster_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the cluster id</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed edge cut score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_edge_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="s1">'vertex'</span><span class="p">,</span> <span class="s1">'cluster'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_modularity">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_modularity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">n_clusters</span></em>, <em class="sig-param"><span class="n">clustering</span></em>, <em class="sig-param"><span class="n">vertex_col_name</span><span class="o">=</span><span class="default_value">'vertex'</span></em>, <em class="sig-param"><span class="n">cluster_col_name</span><span class="o">=</span><span class="default_value">'cluster'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/spectral_clustering.py#L172"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_modularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
<dt><strong>vertex_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the external vertex id</p>
</dd>
<dt><strong>cluster_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the cluster id</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed modularity score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="s1">'vertex'</span><span class="p">,</span> <span class="s1">'cluster'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.community.spectral_clustering.analyzeClustering_ratio_cut">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">analyzeClustering_ratio_cut</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">n_clusters</span></em>, <em class="sig-param"><span class="n">clustering</span></em>, <em class="sig-param"><span class="n">vertex_col_name</span><span class="o">=</span><span class="default_value">'vertex'</span></em>, <em class="sig-param"><span class="n">cluster_col_name</span><span class="o">=</span><span class="default_value">'cluster'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/spectral_clustering.py#L282"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_ratio_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the ratio cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
<dt><strong>vertex_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the external vertex id</p>
</dd>
<dt><strong>cluster_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the cluster id</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed ratio cut score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_ratio_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="s1">'vertex'</span><span class="p">,</span> <span class="s1">'cluster'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.community.spectral_clustering.spectralBalancedCutClustering">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">spectralBalancedCutClustering</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">num_clusters</span></em>, <em class="sig-param"><span class="n">num_eigen_vects</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">evs_tolerance</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">evs_max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">kmean_tolerance</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">kmean_max_iter</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/spectral_clustering.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.spectralBalancedCutClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral
balanced cut method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to
num_clusters.</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver
Default is 0.00001</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver
Default is 100</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver
Default is 0.00001</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver
Default is 100</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding cluster assignments.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the vertex identifiers</p>
</dd>
<dt>df[‘cluster’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.community.spectral_clustering.spectralModularityMaximizationClustering">
<code class="sig-prename descclassname">cugraph.community.spectral_clustering.</code><code class="sig-name descname">spectralModularityMaximizationClustering</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">num_clusters</span></em>, <em class="sig-param"><span class="n">num_eigen_vects</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">evs_tolerance</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">evs_max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">kmean_tolerance</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">kmean_max_iter</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/spectral_clustering.py#L97"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.spectralModularityMaximizationClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral
modularity maximization method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to
num_clusters</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver
Default is 0.00001</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver
Default is 100</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver
Default is 0.00001</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver
Default is 100</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the vertex identifiers</p>
</dd>
<dt>df[‘cluster’]<span class="classifier">cudf.Series</span></dt><dd><p>contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralModularityMaximizationClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.community.subgraph_extraction">
<span id="subgraph-extraction"></span><h3>Subgraph Extraction<a class="headerlink" href="#module-cugraph.community.subgraph_extraction" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.community.subgraph_extraction.subgraph">
<code class="sig-prename descclassname">cugraph.community.subgraph_extraction.</code><code class="sig-name descname">subgraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">vertices</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/subgraph_extraction.py#L20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.subgraph_extraction.subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a subgraph of the existing graph including only the specified
vertices.  This algorithm works for both directed and undirected graphs,
it does not actually traverse the edges, simply pulls out any edges that
are incident on vertices that are both contained in the vertices list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the vertices of the induced subgraph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Sg</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>A graph object containing the subgraph induced by the given vertex set.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sverts</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">sverts</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.community.triangle_count">
<span id="triangle-counting"></span><h3>Triangle Counting<a class="headerlink" href="#module-cugraph.community.triangle_count" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.community.triangle_count.triangles">
<code class="sig-prename descclassname">cugraph.community.triangle_count.</code><code class="sig-name descname">triangles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/community/triangle_count.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.community.triangle_count.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the number of triangles (cycles of length three) in the
input graph.</p>
<p>Unlike NetworkX, this algorithm simply returns the total number of
triangle and not the number per vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information,
(edge weights are not used in this algorithm)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>count</strong><span class="classifier">int64</span></dt><dd><p>A 64 bit integer whose value gives the number of triangles in the
graph.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">triangles</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
<div class="section" id="components">
<h2>Components<a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.components.connectivity">
<span id="connected-components"></span><h3>Connected Components<a class="headerlink" href="#module-cugraph.components.connectivity" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.components.connectivity.connected_components">
<code class="sig-prename descclassname">cugraph.components.connectivity.</code><code class="sig-name descname">connected_components</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">directed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">connection</span><span class="o">=</span><span class="default_value">'weak'</span></em>, <em class="sig-param"><span class="n">return_labels</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/components/connectivity.py#L307"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.components.connectivity.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate either the stronlgly or weakly connected components and attach a
component label to each vertex.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information (edge weights are not used for this algorithm). If using a
graph object, the graph can be either directed or undirected where an
undirected edge is represented by a directed edge in both directions.
The adjacency list will be computed if not already present.  The number
of vertices should fit into a 32b int.</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE: For non-Graph-type (eg. sparse matrix) values of G only. Raises</dt><dd><p>TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then convert the input matrix to a cugraph.DiGraph
and only move from point i to point j along paths csgraph[i, j]. If
False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</p>
</dd>
<dt><strong>connection</strong><span class="classifier">str, optional</span></dt><dd><p>[‘weak’|’strong’]. Return either weakly or strongly connected
components.</p>
</dd>
<dt><strong>return_labels</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE: For non-Graph-type (eg. sparse matrix) values of G only. Raises</dt><dd><p>TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then return the labels for each of the connected
components.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding component identifier.</p>
<dl class="simple">
<dt>df[‘vertex’]</dt><dd><p>Contains the vertex identifier</p>
</dd>
<dt>df[‘labels’]</dt><dd><p>The component identifier</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>python dictionary, where keys are vertices and values are the component
identifiers.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>CuPy ndarray (if CuPy matrix input) or Numpy ndarray (if SciPy matrix
input) of shape (&lt;num vertices&gt;, 2), where column 0 contains component
identifiers and column 1 contains vertices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.components.connectivity.strongly_connected_components">
<code class="sig-prename descclassname">cugraph.components.connectivity.</code><code class="sig-name descname">strongly_connected_components</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">directed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">connection</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_labels</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/components/connectivity.py#L213"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.components.connectivity.strongly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Strongly Connected Components and attach a component label to
each vertex.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information (edge weights are not used for this algorithm). If using a
graph object, the graph can be either directed or undirected where an
undirected edge is represented by a directed edge in both directions.
The adjacency list will be computed if not already present.  The number
of vertices should fit into a 32b int.</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE: For non-Graph-type (eg. sparse matrix) values of G only. Raises</dt><dd><p>TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then convert the input matrix to a cugraph.DiGraph
and only move from point i to point j along paths csgraph[i, j]. If
False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</p>
</dd>
<dt><strong>connection</strong><span class="classifier">str, optional</span></dt><dd><p>Added for SciPy compatibility, can only be specified for non-Graph-type
(eg. sparse matrix) values of G only (raises TypeError if used with a
Graph object), and can only be set to “strong” for this API.</p>
</dd>
<dt><strong>return_labels</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE: For non-Graph-type (eg. sparse matrix) values of G only. Raises</dt><dd><p>TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then return the labels for each of the connected
components.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding component identifier.</p>
<dl class="simple">
<dt>df[‘vertex’]</dt><dd><p>Contains the vertex identifier</p>
</dd>
<dt>df[‘labels’]</dt><dd><p>The component identifier</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>python dictionary, where keys are vertices and values are the component
identifiers.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>CuPy ndarray (if CuPy matrix input) or Numpy ndarray (if SciPy matrix
input) of shape (&lt;num vertices&gt;, 2), where column 0 contains component
identifiers and column 1 contains vertices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.components.connectivity.weakly_connected_components">
<code class="sig-prename descclassname">cugraph.components.connectivity.</code><code class="sig-name descname">weakly_connected_components</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">directed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">connection</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_labels</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/components/connectivity.py#L120"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.components.connectivity.weakly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Weakly Connected Components and attach a component label to
each vertex.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information (edge weights are not used for this algorithm). If using a
graph object, the graph can be either directed or undirected where an
undirected edge is represented by a directed edge in both directions.
The adjacency list will be computed if not already present.  The number
of vertices should fit into a 32b int.</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE: For non-Graph-type (eg. sparse matrix) values of G only. Raises</dt><dd><p>TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then convert the input matrix to a cugraph.DiGraph
and only move from point i to point j along paths csgraph[i, j]. If
False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</p>
</dd>
<dt><strong>connection</strong><span class="classifier">str, optional</span></dt><dd><p>Added for SciPy compatibility, can only be specified for non-Graph-type
(eg. sparse matrix) values of G only (raises TypeError if used with a
Graph object), and can only be set to “weak” for this API.</p>
</dd>
<dt><strong>return_labels</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE: For non-Graph-type (eg. sparse matrix) values of G only. Raises</dt><dd><p>TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then return the labels for each of the connected
components.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding component identifier.</p>
<dl class="simple">
<dt>df[‘vertex’]</dt><dd><p>Contains the vertex identifier</p>
</dd>
<dt>df[‘labels’]</dt><dd><p>The component identifier</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>python dictionary, where keys are vertices and values are the component
identifiers.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>CuPy ndarray (if CuPy matrix input) or Numpy ndarray (if SciPy matrix
input) of shape (&lt;num vertices&gt;, 2), where column 0 contains component
identifiers and column 1 contains vertices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">weakly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
<div class="section" id="cores">
<h2>Cores<a class="headerlink" href="#cores" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.cores.core_number">
<span id="core-number"></span><h3>Core Number<a class="headerlink" href="#module-cugraph.cores.core_number" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.cores.core_number.core_number">
<code class="sig-prename descclassname">cugraph.cores.core_number.</code><code class="sig-name descname">core_number</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/cores/core_number.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.cores.core_number.core_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the core numbers for the nodes of the graph G. A k-core of a graph
is a maximal subgraph that contains nodes of degree k or more.
A node has a core number of k if it belongs a k-core but not to k+1-core.
This call does not support a graph with self-loops and parallel
edges.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>The graph should contain undirected edges where undirected edges are
represented as directed edges in both directions. While this graph
can contain edge weights, they don’t participate in the calculation
of the core numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or python dictionary (in NetworkX input)</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding core number values.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘core_number’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the core number of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cn</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">core_number</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.cores.k_core">
<span id="k-core"></span><h3>K-Core<a class="headerlink" href="#module-cugraph.cores.k_core" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.cores.k_core.k_core">
<code class="sig-prename descclassname">cugraph.cores.k_core.</code><code class="sig-name descname">k_core</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">core_number</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/cores/k_core.py#L20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.cores.k_core.k_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the k-core of the graph G based on the out degree of its nodes. A
k-core of a graph is a maximal subgraph that contains nodes of degree k or
more. This call does not support a graph with self-loops and parallel
edges.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. The graph
should contain undirected edges where undirected edges are represented
as directed edges in both directions. While this graph can contain edge
weights, they don’t participate in the calculation of the k-core.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int, optional</span></dt><dd><p>Order of the core. This value must not be negative. If set to None, the
main core is returned.</p>
</dd>
<dt><strong>core_number</strong><span class="classifier">cudf.DataFrame, optional</span></dt><dd><p>Precomputed core number of the nodes of the graph G containing two
cudf.Series of size V: the vertex identifiers and the corresponding
core number values. If set to None, the core numbers of the nodes are
calculated internally.</p>
<dl class="simple">
<dt>core_number[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>core_number[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the core number of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>KCoreGraph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>K Core of the input graph</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">KCoreGraph</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">k_core</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
<div class="section" id="layout">
<h2>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.layout.force_atlas2">
<span id="force-atlas-2"></span><h3>Force Atlas 2<a class="headerlink" href="#module-cugraph.layout.force_atlas2" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.layout.force_atlas2.force_atlas2">
<code class="sig-prename descclassname">cugraph.layout.force_atlas2.</code><code class="sig-name descname">force_atlas2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_graph</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">pos_list</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">outbound_attraction_distribution</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">lin_log_mode</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">prevent_overlapping</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">edge_weight_influence</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">jitter_tolerance</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">barnes_hut_optimize</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">barnes_hut_theta</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">scaling_ratio</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">strong_gravity_mode</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">gravity</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">callback</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/layout/force_atlas2.py#L18"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.layout.force_atlas2.force_atlas2" title="Permalink to this definition">¶</a></dt>
<dd><p>ForceAtlas2 is a continuous graph layout algorithm for handy network
visualization.</p>
<p>NOTE: Peak memory allocation occurs at 30*V.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information.
Edge weights, if present, should be single or double precision
floating point values.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>This controls the maximum number of levels/iterations of the Force
Atlas algorithm. When specified the algorithm will terminate after
no more than the specified number of iterations.
No error occurs when the algorithm terminates in this manner.
Good short-term quality can be achieved with 50-100 iterations.
Above 1000 iterations is discouraged.</p>
</dd>
<dt><strong>pos_list: cudf.DataFrame</strong></dt><dd><p>Data frame with initial vertex positions containing two columns:
‘x’ and ‘y’ positions.</p>
</dd>
<dt><strong>outbound_attraction_distribution: bool</strong></dt><dd><p>Distributes attraction along outbound edges.
Hubs attract less and thus are pushed to the borders.</p>
</dd>
<dt><strong>lin_log_mode: bool</strong></dt><dd><p>Switch Force Atlas model from lin-lin to lin-log.
Makes clusters more tight.</p>
</dd>
<dt><strong>prevent_overlapping: bool</strong></dt><dd><p>Prevent nodes to overlap.</p>
</dd>
<dt><strong>edge_weight_influence: float</strong></dt><dd><p>How much influence you give to the edges weight.
0 is “no influence” and 1 is “normal”.</p>
</dd>
<dt><strong>jitter_tolerance: float</strong></dt><dd><p>How much swinging you allow. Above 1 discouraged.
Lower gives less speed and more precision.</p>
</dd>
<dt><strong>barnes_hut_optimize: bool</strong></dt><dd><p>Whether to use the Barnes Hut approximation or the slower
exact version.</p>
</dd>
<dt><strong>barnes_hut_theta: float</strong></dt><dd><p>Float between 0 and 1. Tradeoff for speed (1) vs
accuracy (0) for Barnes Hut only.</p>
</dd>
<dt><strong>scaling_ratio: float</strong></dt><dd><p>How much repulsion you want. More makes a more sparse graph.
Switching from regular mode to LinLog mode needs a readjustment
of the scaling parameter.</p>
</dd>
<dt><strong>strong_gravity_mode: bool</strong></dt><dd><p>Sets a force that attracts the nodes that are distant from the
center more. It is so strong that it can sometimes dominate other
forces.</p>
</dd>
<dt><strong>gravity</strong><span class="classifier">float</span></dt><dd><p>Attracts nodes to the center. Prevents islands from drifting away.</p>
</dd>
<dt><strong>verbose: bool</strong></dt><dd><p>Output convergence info at each interation.</p>
</dd>
<dt><strong>callback: GraphBasedDimRedCallback</strong></dt><dd><p>An instance of GraphBasedDimRedCallback class to intercept
the internal state of positions while they are being trained.</p>
<dl class="simple">
<dt>Example of callback usage:</dt><dd><dl class="simple">
<dt>from cugraph.internals import GraphBasedDimRedCallback</dt><dd><dl class="simple">
<dt>class CustomCallback(GraphBasedDimRedCallback):</dt><dd><dl class="simple">
<dt>def on_preprocess_end(self, positions):</dt><dd><p>print(positions.copy_to_host())</p>
</dd>
<dt>def on_epoch_end(self, positions):</dt><dd><p>print(positions.copy_to_host())</p>
</dd>
<dt>def on_train_end(self, positions):</dt><dd><p>print(positions.copy_to_host())</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pos</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing three columns:
the vertex identifiers and the x and y positions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
</div>
</div>
<div class="section" id="link-analysis">
<h2>Link Analysis<a class="headerlink" href="#link-analysis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.link_analysis.hits">
<span id="hits"></span><h3>HITS<a class="headerlink" href="#module-cugraph.link_analysis.hits" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.link_analysis.hits.hits">
<code class="sig-prename descclassname">cugraph.link_analysis.hits.</code><code class="sig-name descname">hits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">nstart</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/link_analysis/hits.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.link_analysis.hits.hits" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute HITS hubs and authorities values for each vertex</p>
<p>The HITS algorithm computes two numbers for a node.  Authorities
estimates the node value based on the incoming links.  Hubs estimates
the node value based on outgoing links.</p>
<p>The cuGraph implementation of HITS is a wrapper around the gunrock
implementation of HITS.</p>
<p>Note that the gunrock implementation uses a 2-norm, while networkx
uses a 1-norm.  The raw scores will be different, but the rank ordering
should be comparable with networkx.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm).
The adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned.
The gunrock implementation does not currently support tolerance,
so this will in fact be the number of iterations the HITS algorithm
executes.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.  This parameter is not currently supported.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>Not currently supported</p>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool</span></dt><dd><p>Not currently supported, always used as True</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>HubsAndAuthorities</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing three cudf.Series of size V: the vertex
identifiers and the corresponding hubs values and the corresponding
authorities values.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘hubs’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the hubs score</p>
</dd>
<dt>df[‘authorities’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the authorities score</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hits</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">hits</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.link_analysis.pagerank">
<span id="pagerank"></span><h3>Pagerank<a class="headerlink" href="#module-cugraph.link_analysis.pagerank" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.link_analysis.pagerank.pagerank">
<code class="sig-prename descclassname">cugraph.link_analysis.pagerank.</code><code class="sig-name descname">pagerank</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.85</span></em>, <em class="sig-param"><span class="n">personalization</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">nstart</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dangling</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/link_analysis/pagerank.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.link_analysis.pagerank.pagerank" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the PageRank score for every vertex in a graph. cuGraph computes an
approximation of the Pagerank eigenvector using the power method. The
number of iterations depends on the properties of the network itself; it
increases when the tolerance descreases and/or alpha increases toward the
limiting value of 1. The user is free to use default values or to provide
inputs for the initial guess, tolerance and maximum number of iterations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>graph</strong><span class="classifier">cugraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm).
The transposed adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>The damping factor alpha represents the probability to follow an
outgoing edge, standard value is 0.85.
Thus, 1.0-alpha is the probability to “teleport” to a random vertex.
Alpha should be greater than 0.0 and strictly lower than 1.0.</p>
</dd>
<dt><strong>personalization</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the personalization information.</p>
<dl class="simple">
<dt>personalization[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for personalization</p>
</dd>
<dt>personalization[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Personalization values for vertices</p>
</dd>
</dl>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can
be used to limit the execution time and do an early exit before the
solver reaches the convergence tolerance.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0E-5.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 0.01 and 0.00001 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for pagerank.</p>
<dl class="simple">
<dt>nstart[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for initial guess for pagerank values</p>
</dd>
<dt>nstart[‘values’]<span class="classifier">cudf.Series</span></dt><dd><p>Pagerank values for vertices</p>
</dd>
</dl>
</dd>
<dt><strong>weight</strong><span class="classifier">str</span></dt><dd><p>Edge data column to use.  Default is None
This version of PageRank current does not use edge weight.
This parameter is here for NetworkX compatibility</p>
</dd>
<dt><strong>dangling</strong><span class="classifier">dict</span></dt><dd><p>This parameter is here for NetworkX compatibility and ignored</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>PageRank</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding PageRank values.</p>
<dl class="simple">
<dt>df[‘vertex’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[‘pagerank’]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the PageRank score</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pr</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-05</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
<div class="section" id="link-prediction">
<h2>Link Prediction<a class="headerlink" href="#link-prediction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.link_prediction.jaccard">
<span id="jaccard-coefficient"></span><h3>Jaccard Coefficient<a class="headerlink" href="#module-cugraph.link_prediction.jaccard" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.link_prediction.jaccard.jaccard">
<code class="sig-prename descclassname">cugraph.link_prediction.jaccard.</code><code class="sig-name descname">jaccard</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_graph</span></em>, <em class="sig-param"><span class="n">vertex_pair</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/link_prediction/jaccard.py#L23"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.link_prediction.jaccard.jaccard" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Jaccard similarity between each pair of vertices connected by
an edge, or between arbitrary pairs of vertices specified by the user.
Jaccard similarity is defined between two sets as the ratio of the volume
of their intersection divided by the volume of their union. In the context
of graphs, the neighborhood of a vertex is seen as a set. The Jaccard
similarity weight of each edge represents the strength of connection
between vertices based on the relative similarity of their neighbors. If
first is specified but second is not, or vice versa, an exception will be
thrown.</p>
<p>NOTE: If the vertex_pair parameter is not specified then the behavior
of cugraph.jaccard is different from the behavior of
networkx.jaccard_coefficient.</p>
<p>cugraph.jaccard, in the absence of a specified vertex pair list, will
use the edges of the graph to construct a vertex pair list and will
return the jaccard coefficient for those vertex pairs.</p>
<p>networkx.jaccard_coefficient, in the absence of a specified vertex
pair list, will return an upper triangular dense matrix, excluding
the diagonal as well as vertex pairs that are directly connected
by an edge in the graph, of jaccard coefficients.  Technically, networkx
returns a lazy iterator across this upper triangular matrix where
the actual jaccard coefficient is computed when the iterator is
dereferenced.  Computing a dense matrix of results is not feasible
if the number of vertices in the graph is large (100,000 vertices
would result in 4.9 billion values in that iterator).</p>
<p>If your graph is small enough (or you have enough memory and patience)
you can get the interesting (non-zero) values that are part of the networkx
solution by doing the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">get_two_hop_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pairs</span><span class="p">)</span>
</pre></div>
</div>
<p>But please remember that cugraph will fill the dataframe with the entire
solution you request, so you’ll need enough memory to store the 2-hop
neighborhood dataframe.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
graph should be undirected where an undirected edge is represented by a
directed edge in both direction. The adjacency list will be computed if
not already present.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the jaccard coefficient is computed for the
given vertex pairs.  If the vertex_pair is not provided then the
current implementation computes the jaccard coefficient for all
adjacent vertices in the graph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified)</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified)</p>
</dd>
<dt>df[‘jaccard_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Jaccard coefficient between the source and destination
vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.link_prediction.jaccard.jaccard_coefficient">
<code class="sig-prename descclassname">cugraph.link_prediction.jaccard.</code><code class="sig-name descname">jaccard_coefficient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">ebunch</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/link_prediction/jaccard.py#L135"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.link_prediction.jaccard.jaccard_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>For NetworkX Compatability.  See <cite>jaccard</cite></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
graph should be undirected where an undirected edge is represented by a
directed edge in both direction. The adjacency list will be computed if
not already present.</p>
</dd>
<dt><strong>ebunch</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the jaccard coefficient is computed for the
given vertex pairs.  If the vertex_pair is not provided then the
current implementation computes the jaccard coefficient for all
adjacent vertices in the graph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified)</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified)</p>
</dd>
<dt>df[‘jaccard_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Jaccard coefficient between the source and destination
vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard_coefficient</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<span class="target" id="module-cugraph.link_prediction.wjaccard"></span><dl class="py function">
<dt id="cugraph.link_prediction.wjaccard.jaccard_w">
<code class="sig-prename descclassname">cugraph.link_prediction.wjaccard.</code><code class="sig-name descname">jaccard_w</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_graph</span></em>, <em class="sig-param"><span class="n">weights</span></em>, <em class="sig-param"><span class="n">vertex_pair</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/link_prediction/wjaccard.py#L20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.link_prediction.wjaccard.jaccard_w" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted Jaccard similarity between each pair of vertices
connected by an edge, or between arbitrary pairs of vertices specified by
the user. Jaccard similarity is defined between two sets as the ratio of
the volume of their intersection divided by the volume of their union. In
the context of graphs, the neighborhood of a vertex is seen as a set. The
Jaccard similarity weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the weights to be used for each vertex.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the jaccard coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID</p>
</dd>
<dt>df[‘jaccard_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed weighted Jaccard coefficient between the source and
destination vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard_w</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.link_prediction.overlap">
<span id="overlap-coefficient"></span><h3>Overlap Coefficient<a class="headerlink" href="#module-cugraph.link_prediction.overlap" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.link_prediction.overlap.overlap">
<code class="sig-prename descclassname">cugraph.link_prediction.overlap.</code><code class="sig-name descname">overlap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_graph</span></em>, <em class="sig-param"><span class="n">vertex_pair</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/link_prediction/overlap.py#L45"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.link_prediction.overlap.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Overlap Coefficient between each pair of vertices connected by
an edge, or between arbitrary pairs of vertices specified by the user.
Overlap Coefficient is defined between two sets as the ratio of the volume
of their intersection divided by the smaller of their two volumes. In the
context of graphs, the neighborhood of a vertex is seen as a set. The
Overlap Coefficient weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the overlap coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Overlap coefficients. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified).</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified).</p>
</dd>
<dt>df[‘overlap_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Overlap coefficient between the source and destination
vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.link_prediction.overlap.overlap_coefficient">
<code class="sig-prename descclassname">cugraph.link_prediction.overlap.</code><code class="sig-name descname">overlap_coefficient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">ebunch</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/link_prediction/overlap.py#L22"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.link_prediction.overlap.overlap_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>NetworkX similar API.  See ‘jaccard’ for a description</p>
</dd></dl>
<span class="target" id="module-cugraph.link_prediction.woverlap"></span><dl class="py function">
<dt id="cugraph.link_prediction.woverlap.overlap_w">
<code class="sig-prename descclassname">cugraph.link_prediction.woverlap.</code><code class="sig-name descname">overlap_w</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_graph</span></em>, <em class="sig-param"><span class="n">weights</span></em>, <em class="sig-param"><span class="n">vertex_pair</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/link_prediction/woverlap.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.link_prediction.woverlap.overlap_w" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted Overlap Coefficient between each pair of vertices
connected by an edge, or between arbitrary pairs of vertices specified by
the user. Overlap Coefficient is defined between two sets as the ratio of
the volume of their intersection divided by the smaller of their volumes.
In the context of graphs, the neighborhood of a vertex is seen as a set.
The Overlap Coefficient weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the weights to be used for each vertex.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the overlap coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the overlap coefficients. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[‘source’]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID</p>
</dd>
<dt>df[‘destination’]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID</p>
</dd>
<dt>df[‘overlap_coeff’]<span class="classifier">cudf.Series</span></dt><dd><p>The computed weighted Overlap coefficient between the source and
destination vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">overlap_w</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
<div class="section" id="traversal">
<h2>Traversal<a class="headerlink" href="#traversal" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.traversal.bfs">
<span id="breadth-first-search"></span><h3>Breadth-first-search<a class="headerlink" href="#module-cugraph.traversal.bfs" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.traversal.bfs.bfs">
<code class="sig-prename descclassname">cugraph.traversal.bfs.</code><code class="sig-name descname">bfs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_sp_counter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">i_start</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">directed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_predecessors</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/traversal/bfs.py#L112"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.traversal.bfs.bfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the distances and predecessors for a breadth first traversal of a
graph.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information. Edge weights, if present, should be single or double
precision floating point values.</p>
</dd>
<dt><strong>start</strong><span class="classifier">Integer</span></dt><dd><p>The index of the graph vertex from which the traversal begins</p>
</dd>
<dt><strong>return_sp_counter</strong><span class="classifier">bool, optional, default=False</span></dt><dd><p>Indicates if shortest path counters should be returned</p>
</dd>
<dt><strong>i_start</strong><span class="classifier">Integer, optional</span></dt><dd><p>Identical to start, added for API compatibility. Only start or i_start
can be set, not both.</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE: For non-Graph-type (eg. sparse matrix) values of G only. Raises</dt><dd><p>TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then convert the input matrix to a cugraph.DiGraph,
otherwise a cugraph.Graph object will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>df[‘vertex’] vertex IDs</p>
<p>df[‘distance’] path distance for each vertex from the starting vertex</p>
<p>df[‘predecessor’] for each i’th position in the column, the vertex ID
immediately preceding the vertex at position i in the ‘vertex’ column</p>
<p>df[‘sp_counter’] for each i’th position in the column, the number of
shortest paths leading to the vertex at position i in the ‘vertex’
column (Only if retrun_sp_counter is True)</p>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>pandas.DataFrame with contents equivalent to the cudf.DataFrame
described above.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>a 2-tuple of CuPy ndarrays (if CuPy matrix input) or Numpy ndarrays (if
SciPy matrix input) representing:</p>
<dl class="simple">
<dt>distance: cupy or numpy ndarray</dt><dd><p>ndarray of shortest distances between source and vertex.</p>
</dd>
<dt>predecessor: cupy or numpy ndarray</dt><dd><p>ndarray of predecessors of a vertex on the path from source, which
can be used to reconstruct the shortest paths.</p>
</dd>
</dl>
<p>…or if return_sp_counter is True, returns a 3-tuple with the above two
arrays plus:</p>
<dl class="simple">
<dt>sp_counter: cupy or numpy ndarray</dt><dd><p>ndarray of number of shortest paths leading to each vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cugraph.traversal.bfs.bfs_edges">
<code class="sig-prename descclassname">cugraph.traversal.bfs.</code><code class="sig-name descname">bfs_edges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">depth_limit</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sort_neighbors</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_sp_counter</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/traversal/bfs.py#L218"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.traversal.bfs.bfs_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the distances and predecessors for a breadth first traversal of a
graph.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information. Edge weights, if present, should be single or double
precision floating point values.</p>
</dd>
<dt><strong>source</strong><span class="classifier">Integer</span></dt><dd><p>The starting vertex index</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">boolean</span></dt><dd><p>If a directed graph, then process edges in a reverse direction
Currently not implemented</p>
</dd>
<dt><strong>depth_limit</strong><span class="classifier">Int or None</span></dt><dd><p>Limit the depth of the search
Currently not implemented</p>
</dd>
<dt><strong>sort_neighbors</strong><span class="classifier">None or Function</span></dt><dd><p>Currently not implemented</p>
</dd>
<dt><strong>return_sp_counter</strong><span class="classifier">bool, optional, default=False</span></dt><dd><p>Indicates if shortest path counters should be returned</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>df[‘vertex’] vertex IDs</p>
<p>df[‘distance’] path distance for each vertex from the starting vertex</p>
<p>df[‘predecessor’] for each i’th position in the column, the vertex ID
immediately preceding the vertex at position i in the ‘vertex’ column</p>
<p>df[‘sp_counter’] for each i’th position in the column, the number of
shortest paths leading to the vertex at position i in the ‘vertex’
column (Only if retrun_sp_counter is True)</p>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>pandas.DataFrame with contents equivalent to the cudf.DataFrame
described above.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>a 2-tuple of CuPy ndarrays (if CuPy matrix input) or Numpy ndarrays (if
SciPy matrix input) representing:</p>
<dl class="simple">
<dt>distance: cupy or numpy ndarray</dt><dd><p>ndarray of shortest distances between source and vertex.</p>
</dd>
<dt>predecessor: cupy or numpy ndarray</dt><dd><p>ndarray of predecessors of a vertex on the path from source, which
can be used to reconstruct the shortest paths.</p>
</dd>
</dl>
<p>…or if return_sp_counter is True, returns a 3-tuple with the above two
arrays plus:</p>
<dl class="simple">
<dt>sp_counter: cupy or numpy ndarray</dt><dd><p>ndarray of number of shortest paths leading to each vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-cugraph.traversal.sssp">
<span id="single-source-shortest-path"></span><h3>Single-source-shortest-path<a class="headerlink" href="#module-cugraph.traversal.sssp" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.traversal.sssp.filter_unreachable">
<code class="sig-prename descclassname">cugraph.traversal.sssp.</code><code class="sig-name descname">filter_unreachable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/traversal/sssp.py#L231"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.traversal.sssp.filter_unreachable" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove unreachable vertices from the result of SSSP or BFS</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>cudf.DataFrame that is the output of SSSP or BFS</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">filtered cudf.DataFrame with only reachable vertices</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex.
df[‘distance’][i] gives the path distance for the i’th vertex from the
starting vertex.
df[‘predecessor’][i] gives the vertex that was reached before the i’th
vertex in the traversal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cugraph.traversal.sssp.shortest_path">
<code class="sig-prename descclassname">cugraph.traversal.sssp.</code><code class="sig-name descname">shortest_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">directed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_predecessors</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unweighted</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/traversal/sssp.py#L261"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.traversal.sssp.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for sssp(), provided for API compatibility with NetworkX. See sssp()
for details.</p>
</dd></dl>
<dl class="py function">
<dt id="cugraph.traversal.sssp.shortest_path_length">
<code class="sig-prename descclassname">cugraph.traversal.sssp.</code><code class="sig-name descname">shortest_path_length</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/traversal/sssp.py#L277"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.traversal.sssp.shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the distance from a source vertex to one or all vertexes in graph.
Uses Single Source Shortest Path (SSSP).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph, NetworkX.Graph, or CuPy sparse COO matrix</span></dt><dd><p>cuGraph graph descriptor with connectivity information. Edge weights,
if present, should be single or double precision floating point values.</p>
</dd>
<dt><strong>source</strong><span class="classifier">Dependant on graph type. Index of the source vertex.</span></dt><dd></dd>
<dt><strong>If graph is an instance of cuGraph.Graph or CuPy sparse COO matrix:</strong></dt><dd><p>int</p>
</dd>
<dt><strong>If graph is an instance of a NetworkX.Graph:</strong></dt><dd><p>str</p>
</dd>
<dt><strong>target: Dependant on graph type. Vertex to find distance to.</strong></dt><dd></dd>
<dt><strong>If graph is an instance of cuGraph.Graph or CuPy sparse COO matrix:</strong></dt><dd><p>int</p>
</dd>
<dt><strong>If graph is an instance of a NetworkX.Graph:</strong></dt><dd><p>str</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Return value type is based on the input type.</dt><dd></dd>
<dt>If target is None, returns:</dt><dd><dl class="simple">
<dt>cudf.DataFrame</dt><dd><dl class="simple">
<dt>df[‘vertex’]</dt><dd><p>vertex id</p>
</dd>
<dt>df[‘distance’]</dt><dd><p>gives the path distance from the starting vertex</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If target is not None, returns:</dt><dd><p>Distance from source to target vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cugraph.traversal.sssp.sssp">
<code class="sig-prename descclassname">cugraph.traversal.sssp.</code><code class="sig-name descname">sssp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">directed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_predecessors</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unweighted</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/traversal/sssp.py#L139"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.traversal.sssp.sssp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the distance and predecessors for shortest paths from the specified
source to all the vertices in the graph. The distances column will store
the distance from the source to each vertex. The predecessors column will
store each vertex’s predecessor in the shortest path. Vertices that are
unreachable will have a distance of infinity denoted by the maximum value
of the data type and the predecessor set as -1. The source vertex’s
predecessor is also set to -1. Graphs with negative weight cycles are not
supported.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix Graph or</span></dt><dd><p>matrix object, which should contain the connectivity information. Edge
weights, if present, should be single or double precision floating
point values.</p>
</dd>
<dt><strong>source</strong><span class="classifier">int</span></dt><dd><p>Index of the source vertex.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl class="simple">
<dt>cudf.DataFrame</dt><dd><dl class="simple">
<dt>df[‘vertex’]</dt><dd><p>vertex id</p>
</dd>
<dt>df[‘distance’]</dt><dd><p>gives the path distance from the starting vertex</p>
</dd>
<dt>df[‘predecessor’]</dt><dd><p>the vertex it was reached from</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>pandas.DataFrame with contents equivalent to the cudf.DataFrame
described above.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>a 2-tuple of CuPy ndarrays (if CuPy matrix input) or Numpy ndarrays (if
SciPy matrix input) representing:</p>
<dl class="simple">
<dt>distance: cupy or numpy ndarray</dt><dd><p>ndarray of shortest distances between source and vertex.</p>
</dd>
<dt>predecessor: cupy or numpy ndarray</dt><dd><p>ndarray of predecessors of a vertex on the path from source, which
can be used to reconstruct the shortest paths.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">sssp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
</div>
<div class="section" id="tree">
<h2>Tree<a class="headerlink" href="#tree" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-cugraph.tree.minimum_spanning_tree">
<span id="minimum-spanning-tree"></span><h3>Minimum Spanning Tree<a class="headerlink" href="#module-cugraph.tree.minimum_spanning_tree" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="cugraph.tree.minimum_spanning_tree.maximum_spanning_tree">
<code class="sig-prename descclassname">cugraph.tree.minimum_spanning_tree.</code><code class="sig-name descname">maximum_spanning_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'boruvka'</span></em>, <em class="sig-param"><span class="n">ignore_nan</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/tree/minimum_spanning_tree.py#L95"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.tree.minimum_spanning_tree.maximum_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a maximum spanning tree (MST) or forest (MSF) on an undirected
graph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string</span></dt><dd><p>default to the weights in the graph, if the graph edges do not have a
weight attribute a default weight of 1 will be used.</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier">string</span></dt><dd><p>Default to ‘boruvka’. The parallel algorithm to use when finding a
maximum spanning tree.</p>
</dd>
<dt><strong>ignore_nan</strong><span class="classifier">bool</span></dt><dd><p>Default to False</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>G_mst</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>A graph descriptor with a maximum spanning tree or forest.
The networkx graph will not have all attributes copied over</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cugraph.tree.minimum_spanning_tree.maximum_spanning_tree_subgraph">
<code class="sig-prename descclassname">cugraph.tree.minimum_spanning_tree.</code><code class="sig-name descname">maximum_spanning_tree_subgraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/tree/minimum_spanning_tree.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.tree.minimum_spanning_tree.maximum_spanning_tree_subgraph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py function">
<dt id="cugraph.tree.minimum_spanning_tree.minimum_spanning_tree">
<code class="sig-prename descclassname">cugraph.tree.minimum_spanning_tree.</code><code class="sig-name descname">minimum_spanning_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'boruvka'</span></em>, <em class="sig-param"><span class="n">ignore_nan</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/tree/minimum_spanning_tree.py#L60"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.tree.minimum_spanning_tree.minimum_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a minimum spanning tree (MST) or forest (MSF) on an undirected
graph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string</span></dt><dd><p>default to the weights in the graph, if the graph edges do not have a
weight attribute a default weight of 1 will be used.</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier">string</span></dt><dd><p>Default to ‘boruvka’. The parallel algorithm to use when finding a
minimum spanning tree.</p>
</dd>
<dt><strong>ignore_nan</strong><span class="classifier">bool</span></dt><dd><p>Default to False</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>G_mst</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>A graph descriptor with a minimum spanning tree or forest.
The networkx graph will not have all attributes copied over</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cugraph.tree.minimum_spanning_tree.minimum_spanning_tree_subgraph">
<code class="sig-prename descclassname">cugraph.tree.minimum_spanning_tree.</code><code class="sig-name descname">minimum_spanning_tree_subgraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/5cff397/python/cugraph/tree/minimum_spanning_tree.py#L20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cugraph.tree.minimum_spanning_tree.minimum_spanning_tree_subgraph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</div>
<div class="section" id="module-cugraph.tree.maximum_spanning_tree">
<span id="maximum-spanning-tree"></span><h3>Maximum Spanning Tree<a class="headerlink" href="#module-cugraph.tree.maximum_spanning_tree" title="Permalink to this headline">¶</a></h3>
<p>Returns a maximum spanning tree (MST) or forest (MSF) on an undirected
graph</p>
<div class="section" id="id1">
<h4>Parameters<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt>G<span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information.</p>
</dd>
<dt>weight<span class="classifier">string</span></dt><dd><p>default to the weights in the graph, if the graph edges do not have a
weight attribute a default weight of 1 will be used.</p>
</dd>
<dt>algorithm<span class="classifier">string</span></dt><dd><p>Default to ‘boruvka’. The parallel algorithm to use when finding a
maximum spanning tree.</p>
</dd>
<dt>ignore_nan<span class="classifier">bool</span></dt><dd><p>Default to False</p>
</dd>
</dl>
</div>
<div class="section" id="id2">
<h4>Returns<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt>G_mst<span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>A graph descriptor with a maximum spanning tree or forest.
The networkx graph will not have all attributes copied over</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="dask-cugraph.html" rel="next" title="Multi-GPU with cuGraph">Next <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="cugraph_intro.html" rel="prev" title="cuGraph Introduction"><span class="fa fa-arrow-circle-left"></span> Previous</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        
        © Copyright 2019-2020, NVIDIA

    </p>
</div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>