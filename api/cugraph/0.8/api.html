

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; cugraph 0.8.0a documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/params.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to cugraph’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cugraph
          

          
          </a>

          
            
            
              <div class="version">
                0.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#graph">Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cugraph">Pagerank</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cugraph">Bfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cugraph">Jaccard</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cugraph">Louvain</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cugraph">Grmat</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cugraph">Spectral Clustering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cugraph">Sssp</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cugraph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="graph">
<h2>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cugraph.Graph">
<em class="property">class </em><code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">Graph</code><a class="headerlink" href="#cugraph.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p>cuGraph graph class containing basic graph creation and transformation operations.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.add_adj_list" title="cugraph.Graph.add_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_adj_list</span></code></a>(self, offset_col, index_col[, …])</p></td>
<td><p>Create the adjacency list representation of a Graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.add_edge_list" title="cugraph.Graph.add_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge_list</span></code></a>(self, source_col, dest_col[, …])</p></td>
<td><p>Create the edge list representation of a Graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.add_transposed_adj_list" title="cugraph.Graph.add_transposed_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_transposed_adj_list</span></code></a>(self)</p></td>
<td><p>Compute the transposed adjacency list from the edge list and add it to the existing graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.clear" title="cugraph.Graph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>(self)</p></td>
<td><p>Empty this graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.degree" title="cugraph.Graph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Calculates and returns the degree of vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.delete_adj_list" title="cugraph.Graph.delete_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_adj_list</span></code></a>(self)</p></td>
<td><p>Delete the adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.delete_edge_list" title="cugraph.Graph.delete_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_edge_list</span></code></a>(self)</p></td>
<td><p>Delete the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.delete_transposed_adj_list" title="cugraph.Graph.delete_transposed_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete_transposed_adj_list</span></code></a>(self)</p></td>
<td><p>Delete the transposed adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.get_two_hop_neighbors" title="cugraph.Graph.get_two_hop_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_two_hop_neighbors</span></code></a>(self)</p></td>
<td><p>Return a dataframe containing vertex pairs such that each pair of vertices is connected by a path of two hops in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.in_degree" title="cugraph.Graph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Calculates and returns the in-degree of vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.number_of_edges" title="cugraph.Graph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a>(self)</p></td>
<td><p>Get the number of edges in the graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.number_of_nodes" title="cugraph.Graph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a>(self)</p></td>
<td><p>An alias of number_of_vertices().</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.number_of_vertices" title="cugraph.Graph.number_of_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_vertices</span></code></a>(self)</p></td>
<td><p>Get the number of vertices in the graph</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.out_degree" title="cugraph.Graph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a>(self[, vertex_subset])</p></td>
<td><p>Calculates and returns the out-degree of vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.renumber" title="cugraph.Graph.renumber"><code class="xref py py-obj docutils literal notranslate"><span class="pre">renumber</span></code></a>(self, source_col, dest_col)</p></td>
<td><p>Take a (potentially sparse) set of source and destination vertex ids and renumber the vertices to create a dense set of vertex ids using all values contiguously from 0 to the number of unique vertices - 1.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.view_adj_list" title="cugraph.Graph.view_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_adj_list</span></code></a>(self)</p></td>
<td><p>Display the adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.Graph.view_edge_list" title="cugraph.Graph.view_edge_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_edge_list</span></code></a>(self)</p></td>
<td><p>Display the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.Graph.view_transposed_adj_list" title="cugraph.Graph.view_transposed_adj_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_transposed_adj_list</span></code></a>(self)</p></td>
<td><p>Display the transposed adjacency list.</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="cugraph.Graph.add_adj_list">
<code class="sig-name descname">add_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">offset_col</em>, <em class="sig-param">index_col</em>, <em class="sig-param">value_col=None</em>, <em class="sig-param">copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.add_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the adjacency list representation of a Graph. The passed
offset_col and index_col arguments wrap gdf_column objects that
represent a graph using the adjacency list format. If value_col is
None, an unweighted graph is created. If value_col is not None, an
weighted graph is created. If copy is False, this function stores
references to the passed objects pointed by offset_col and index_col.
If copy is True, this funcion stores references to the deep-copies of
the passed objects pointed by offset_col and index_col. If this class
instance already stores a graph, invoking this function raises an
error. Undirected edges must be stored as directed edges in both 
directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).
The gdf column contains the offsets for the vertices in this graph.
Offsets must be in the range [0, E] (E: number of edges).</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be in the range [0, V) (V: number of
vertices).</p>
</dd>
<dt><strong>value_col(optional)</strong><span class="classifier">cudf.Series</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">none</span></code>.
If not, this cudf.Series wraps a gdf_column of size E (E: number of
edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pytest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.io</span> <span class="k">import</span> <span class="n">mmread</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm_file</span> <span class="o">=</span> <span class="s1">&#39;../datasets/karate.mtx&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">mm_file</span><span class="p">)</span><span class="o">.</span><span class="n">asfptype</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offsets</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_adj_list</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.add_edge_list">
<code class="sig-name descname">add_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">source_col</em>, <em class="sig-param">dest_col</em>, <em class="sig-param">value_col=None</em>, <em class="sig-param">copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.add_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the edge list representation of a Graph. The passed source_col
and dest_col arguments wrap gdf_column objects that represent a graph
using the edge list format. 
Source and destination indices must be in the range [0, V) where V is 
the number of vertices. They must be 32 bit integers. Please refer to 
cuGraph’s renumbering feature if your input does not match these 
requierments. When using cudf.read_csv to load a CSV edge list, 
make sure to set dtype to int32 for the source and destination
columns.
Undirected edges must be stored as directed edges in both directions.
If value_col is None, an unweighted graph is created. If value_col is 
not None, an weighted graph is created. 
If copy is False, this function stores references to the passed objects
pointed by source_col and dest_col. If copy is True, this funcion
stores references to the deep-copies of the passed objects pointed by
source_col and dest_col. If this class instance already stores a graph,
invoking this function raises an error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices must be in the range [0, V) (V: number of vertices). 
Source indices must be 32 bit integers.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be in the range [0, V) (V: number of
vertices).
Destination indices must be 32 bit integers.</p>
</dd>
<dt><strong>value_col(optional)</strong><span class="classifier">cudf.Series</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">none</span></code>.
If not, this cudf.Series wraps a gdf_column of size E (E: number of
edges).
The gdf column contains the weight value for each edge.
The expected type of the gdf_column element is floating point
number.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pytest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.io</span> <span class="k">import</span> <span class="n">mmread</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm_file</span> <span class="o">=</span> <span class="s1">&#39;../datasets/karate.mtx&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">mm_file</span><span class="p">)</span><span class="o">.</span><span class="n">asfptype</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.add_transposed_adj_list">
<code class="sig-name descname">add_transposed_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.add_transposed_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the transposed adjacency list from the edge list and add it to
the existing graph.</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty this graph. This function is added for NetworkX compatibility.</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.degree">
<code class="sig-name descname">degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the degree of vertices. Vertex degree
is the number of edges adjacent to that vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset(optional, default=all vertices)</strong><span class="classifier">cudf.Series or iterable container</span></dt><dd><p>A container of vertices for displaying corresponding degree</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd></dd>
<dt>GPU data frame of size N (the default) or the size of the given vertices (vertex_subset)</dt><dd></dd>
<dt>containing the degree. The ordering is relative to the adjacency list, or that</dt><dd></dd>
<dt>given by the specified vertex_subset.</dt><dd></dd>
<dt>df[‘vertex’]: The vertex IDs (will be identical to vertex_subset if specified)</dt><dd></dd>
<dt>df[‘degree’]: The computed degree of the corresponding vertex</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pytest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.io</span> <span class="k">import</span> <span class="n">mmread</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm_file</span> <span class="o">=</span> <span class="s1">&#39;/datasets/networks/karate.mtx&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">mm_file</span><span class="p">)</span><span class="o">.</span><span class="n">asfptype</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">degree_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.delete_adj_list">
<code class="sig-name descname">delete_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.delete_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the adjacency list.</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.delete_edge_list">
<code class="sig-name descname">delete_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.delete_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the edge list.</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.delete_transposed_adj_list">
<code class="sig-name descname">delete_transposed_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.delete_transposed_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the transposed adjacency list.</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.get_two_hop_neighbors">
<code class="sig-name descname">get_two_hop_neighbors</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.get_two_hop_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dataframe containing vertex pairs such that each pair of vertices is
connected by a path of two hops in the graph. The resulting pairs are
returned in sorted order.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Two hop neighbors</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘first’] the first vertex id of a pair
df[‘second’] the second vertex id of a pair</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.in_degree">
<code class="sig-name descname">in_degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.in_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the in-degree of vertices. Vertex in-degree
is the number of edges pointing in to the vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset(optional, default=all vertices)</strong><span class="classifier">cudf.Series or iterable container</span></dt><dd><p>A container of vertices for displaying corresponding in-degree</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd></dd>
<dt>GPU data frame of size N (the default) or the size of the given vertices (vertex_subset)</dt><dd></dd>
<dt>containing the in_degree. The ordering is relative to the adjacency list, or that</dt><dd></dd>
<dt>given by the specified vertex_subset.</dt><dd></dd>
<dt>df[‘vertex’]: The vertex IDs (will be identical to vertex_subset if specified)</dt><dd></dd>
<dt>df[‘degree’]: The computed in-degree of the corresponding vertex</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pytest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.io</span> <span class="k">import</span> <span class="n">mmread</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm_file</span> <span class="o">=</span> <span class="s1">&#39;/datasets/networks/karate.mtx&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">mm_file</span><span class="p">)</span><span class="o">.</span><span class="n">asfptype</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_degree_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.number_of_edges">
<code class="sig-name descname">number_of_edges</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.number_of_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of edges in the graph</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.number_of_nodes">
<code class="sig-name descname">number_of_nodes</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.number_of_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias of number_of_vertices(). This function is added for NetworkxX
compatibility.</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.number_of_vertices">
<code class="sig-name descname">number_of_vertices</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.number_of_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of vertices in the graph</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.out_degree">
<code class="sig-name descname">out_degree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vertex_subset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.out_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the out-degree of vertices. Vertex out-degree
is the number of edges pointing out from the vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_subset(optional, default=all vertices)</strong><span class="classifier">cudf.Series or iterable container</span></dt><dd><p>A container of vertices for displaying corresponding out-degree</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd></dd>
<dt>GPU data frame of size N (the default) or the size of the given vertices (vertex_subset)</dt><dd></dd>
<dt>containing the out_degree. The ordering is relative to the adjacency list, or that</dt><dd></dd>
<dt>given by the specified vertex_subset.</dt><dd></dd>
<dt>df[‘vertex’]: The vertex IDs (will be identical to vertex_subset if specified)</dt><dd></dd>
<dt>df[‘degree’]: The computed out-degree of the corresponding vertex</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pytest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.io</span> <span class="k">import</span> <span class="n">mmread</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm_file</span> <span class="o">=</span> <span class="s1">&#39;/datasets/networks/karate.mtx&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">mm_file</span><span class="p">)</span><span class="o">.</span><span class="n">asfptype</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out_degree_df</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.renumber">
<code class="sig-name descname">renumber</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">source_col</em>, <em class="sig-param">dest_col</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a (potentially sparse) set of source and destination vertex
ids and renumber the vertices to create a dense set of vertex ids
using all values contiguously from 0 to the number of unique vertices
- 1.</p>
<p>Input columns can be either int64 or int32.  The output will be mapped
to int32, since many of the cugraph functions are limited to int32.
If the number of unique values in source_col and dest_col &gt; 2^31-1
then this function will return an error.</p>
<p>Return from this call will be three cudf Series - the renumbered
source_col, the renumbered dest_col and a numbering map that maps the
new ids to the original ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices must be an integer type.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be an integer type.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pytest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.io</span> <span class="k">import</span> <span class="n">mmread</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm_file</span> <span class="o">=</span> <span class="s1">&#39;../datasets/karate.mtx&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">mmread</span><span class="p">(</span><span class="n">mm_file</span><span class="p">)</span><span class="o">.</span><span class="n">asfptype</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src_r</span><span class="p">,</span> <span class="n">dst_r</span><span class="p">,</span> <span class="n">numbering</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">renumber</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.view_adj_list">
<code class="sig-name descname">view_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.view_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the adjacency list. Compute it if needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.view_edge_list">
<code class="sig-name descname">view_edge_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.view_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the edge list. Compute it if needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="cugraph.Graph.view_transposed_adj_list">
<code class="sig-name descname">view_transposed_adj_list</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.Graph.view_transposed_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the transposed adjacency list. Compute it if needed.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cugraph">
<span id="pagerank"></span><h2>Pagerank<a class="headerlink" href="#module-cugraph" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cugraph.pagerank">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">pagerank</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">alpha=0.85</em>, <em class="sig-param">personalization=None</em>, <em class="sig-param">max_iter=100</em>, <em class="sig-param">tol=1.0e-5</em>, <em class="sig-param">nstart=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.pagerank" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the PageRank vertex values for a graph. cuGraph computes an approximation of the Pagerank eigenvector using the power method. 
The number of iterations depends on the properties of the network itself; it increases when the tolerance descreases and/or alpha increases toward the limiting value of 1.
The user is free to use default values or to provide inputs for the initial guess, tolerance and maximum number of iterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information as an edge list (edge weights are not used for this algorithm). 
The transposed adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>The damping factor alpha represents the probability to follow an outgoing edge, standard value is 0.85. 
Thus, 1.0-alpha is the probability to “teleport” to a random vertex. Alpha should be greater than 0.0 and strictly lower than 1.0.</p>
</dd>
<dt><strong>personalization</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the personalizatoin information.
personalization[‘vertex’]: Subset of vertices of graph for personalization
personalization[‘values’]: Personalization values for vertices</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can be used to limit the execution time and do an early exit before the solver reaches the convergence tolerance. 
If this value is lower or equal to 0 cuGraph will use the default value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small magnitude value. 
The lower the tolerance the better the approximation. If this value is 0.0f, cuGraph will use the default value which is 1.0E-5. 
Setting too small a tolerance can lead to non-convergence due to numerical roundoff. Usually values between 0.01 and 0.00001 are acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for pagerank.
nstart[‘vertex’]: Subset of vertices of graph for initial guess for pagerank values
nstart[‘values’]: Pagerank values for vertices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>PageRank</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex identifiers and the corresponding PageRank values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">read_mtx_file</span><span class="p">(</span><span class="n">graph_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cuGraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span><span class="n">destinations</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pr</span> <span class="o">=</span> <span class="n">cuGraph</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-05</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph">
<span id="bfs"></span><h2>Bfs<a class="headerlink" href="#module-cugraph" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cugraph.bfs">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">bfs</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">start</em>, <em class="sig-param">directed=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.bfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the distances and predecessors for a breadth first traversal of a graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information as an
adjacency list.</p>
</dd>
<dt><strong>start</strong><span class="classifier">Integer</span></dt><dd><p>The index of the graph vertex from which the traversal begins</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool</span></dt><dd><p>Indicates whether the graph in question is a directed graph, or whether
each edge has a corresponding reverse edge. (Allows optimizations if the
graph is undirected)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex
df[‘distance’][i] gives the path distance for the i’th vertex from the starting vertex
df[‘predecessor’][i] gives for the i’th vertex the vertex it was reached from in the traversal</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">read_mtx_file</span><span class="p">(</span><span class="n">graph_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cuGraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span><span class="n">destinations</span><span class="p">,</span><span class="n">none</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">cuGraph</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph">
<span id="jaccard"></span><h2>Jaccard<a class="headerlink" href="#module-cugraph" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-cugraph">
<span id="louvain"></span><h2>Louvain<a class="headerlink" href="#module-cugraph" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cugraph.nvLouvain">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">nvLouvain</code><span class="sig-paren">(</span><em class="sig-param">input_graph</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.nvLouvain" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity optimizing partition of the input graph using the Louvain heuristic</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information as an edge list.
The adjacency list will be computed if not already present. The graph should be undirected where 
an undirected edge is represented by a directed edge in both direction.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>louvain_parts, modularity_score</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>louvain_parts: GPU data frame of size V containing two columns: the vertex id </dt><dd><p>and the partition id it is assigned to.</p>
</dd>
</dl>
<p>modularity_score: a double value containing the modularity score of the partitioning</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">read_mtx_file</span><span class="p">(</span><span class="n">graph_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cuGraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span><span class="n">destinations</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">louvain_parts</span><span class="p">,</span> <span class="n">modularity_score</span> <span class="o">=</span> <span class="n">cuGraph</span><span class="o">.</span><span class="n">louvain</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-cugraph">
<span id="grmat"></span><h2>Grmat<a class="headerlink" href="#module-cugraph" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cugraph.grmat_gen">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">grmat_gen</code><span class="sig-paren">(</span><em class="sig-param">argv</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.grmat_gen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-cugraph">
<span id="spectral-clustering"></span><h2>Spectral Clustering<a class="headerlink" href="#module-cugraph" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cugraph.spectralBalancedCutClustering">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">spectralBalancedCutClustering</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">num_clusters</em>, <em class="sig-param">num_eigen_vects=2</em>, <em class="sig-param">evs_tolerance=.00001</em>, <em class="sig-param">evs_max_iter=100</em>, <em class="sig-param">kmean_tolerance=.00001</em>, <em class="sig-param">kmean_max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.spectralBalancedCutClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral balanced
cut method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to num_clusters.</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DF</strong><span class="classifier">GPU data frame containing two cudf.Series of size V: the vertex identifiers and the</span></dt><dd><dl class="simple">
<dt>corresponding cluster assignments.</dt><dd><p>DF[‘vertex’] contains the vertex identifiers
DF[‘cluster’] contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-cugraph"></span><dl class="function">
<dt id="cugraph.spectralModularityMaximizationClustering">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">spectralModularityMaximizationClustering</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">num_clusters</em>, <em class="sig-param">num_eigen_vects=2</em>, <em class="sig-param">evs_tolerance=.00001</em>, <em class="sig-param">evs_max_iter=100</em>, <em class="sig-param">kmean_tolerance=.00001</em>, <em class="sig-param">kmean_max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.spectralModularityMaximizationClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral modularity
maximization method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to num_clusters</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Clustering</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>DF[‘vertex’] contains the vertex identifiers
DF[‘cluster’] contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-cugraph"></span><dl class="function">
<dt id="cugraph.analyzeClustering_modularity">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">analyzeClustering_modularity</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.analyzeClustering_modularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the modularity score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed modularity score</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-cugraph"></span><dl class="function">
<dt id="cugraph.analyzeClustering_edge_cut">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">analyzeClustering_edge_cut</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.analyzeClustering_edge_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edge cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed edge cut score</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-cugraph"></span><dl class="function">
<dt id="cugraph.analyzeClustering_ratio_cut">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">analyzeClustering_ratio_cut</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">n_clusters</em>, <em class="sig-param">clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.analyzeClustering_ratio_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the ratio cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.Series</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed ratio cut score</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-cugraph">
<span id="sssp"></span><h2>Sssp<a class="headerlink" href="#module-cugraph" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cugraph.sssp">
<code class="sig-prename descclassname">cugraph.</code><code class="sig-name descname">sssp</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">source</em><span class="sig-paren">)</span><a class="headerlink" href="#cugraph.sssp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the distance and predecessors for shortest paths from the specified source to all the vertices in the graph. The distances column will
store the distance from the source to each vertex. The predecessors column will store each vertex’s predecessor in the shortest path. Vertices
that are unreachable will have a distance of infinity denoted by the maximum value of the data type and the predecessor set as -1. The source vertex’s 
predecessor is also set to -1. Graphs with negative weight cycles are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. Edge weights, if present, should be single or double precision floating point values</p>
</dd>
<dt><strong>source</strong><span class="classifier">int</span></dt><dd><p>Index of the source vertex</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>df[‘vertex’][i] gives the vertex id of the i’th vertex
df[‘distance’][i] gives the path distance for the i’th vertex from the starting vertex
df[‘predecessor’][i] gives the vertex id of the vertex that was reached before the i’th vertex in the traversal</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">read_mtx_file</span><span class="p">(</span><span class="n">graph_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cuGraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span><span class="n">destinations</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">cuGraph</span><span class="o">.</span><span class="n">sssp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to cugraph’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>