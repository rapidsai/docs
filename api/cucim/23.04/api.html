<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator">

    <title>cuCIM API Reference &mdash; cuCIM 23.04.00 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link as="font" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2">
<link as="font" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2">
<link as="font" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" rel="preload" type="font/woff2">

    <link href="_static/pygments.css" rel="stylesheet" type="text/css">
    <link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet" type="text/css">
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link as="script" href="_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94" rel="preload">
<link as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94" rel="preload">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script defer="defer" src="https://docs.rapids.ai/assets/js/custom.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'api';</script>
    <link href="genindex.html" rel="index" title="Index">
    <link href="search.html" rel="search" title="Search">
    <link href="index.html" rel="prev" title="Welcome to cuCIM&rsquo;s documentation!">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="en" name="docsearch:language">
  <script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
  
  
  <body data-default-mode data-offset="180" data-spy="scroll" data-target="#bd-toc-nav">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>

  
  <input class="sidebar-toggle" id="__primary" name="__primary" type="checkbox">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input class="sidebar-toggle" id="__secondary" name="__secondary" type="checkbox">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form action="search.html" class="bd-search d-flex align-items-center" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input aria-label="Search the docs ..." autocapitalize="off" autocomplete="off" autocorrect="off" class="form-control" id="search-input" name="q" placeholder="Search the docs ..." spellcheck="false" type="search">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="index.html">

  
  
  
  
  
  
  

  
  
    <p class="title logo__title">cuCIM 23.04.00 documentation</p>
  
</a>
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div class="mr-auto" id="navbar-center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p aria-label="Site Navigation" aria-level="1" class="sidebar-header-items__title" role="heading">
        Site Navigation
    </p>
    <ul class="navbar-nav" id="navbar-main-elements">
        
                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="#">
                        cuCIM API Reference
                      </a>
                    </li>
                
    </ul>
</nav>
      </div>
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button aria-label="Search" class="btn btn-sm navbar-btn search-button search-button__button" data-toggle="tooltip" title="Search">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
      <div class="navbar-end-item">
        <button aria-label="light/dark" class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" data-toggle="tooltip" title="light/dark">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul aria-label="Icon Links" class="navbar-nav" id="navbar-icon-links">
      </ul>
      </div>
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button aria-label="Search" class="btn btn-sm navbar-btn search-button search-button__button" data-toggle="tooltip" title="Search">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide"><div id="rapids-pydata-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">cucim</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (23.04)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cucim/nightly/api.html">nightly (23.04)</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">stable (23.02)</a><a class="rapids-selector__menu-item" href="/api/cucim/legacy/api.html">legacy (22.12)</a></div></div></div>
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p aria-label="Site Navigation" aria-level="1" class="sidebar-header-items__title" role="heading">
        Site Navigation
    </p>
    <ul class="navbar-nav" id="navbar-main-elements">
        
                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="#">
                        cuCIM API Reference
                      </a>
                    </li>
                
    </ul>
</nav>
      </div>
      
      </div>
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <button aria-label="light/dark" class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" data-toggle="tooltip" title="light/dark">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul aria-label="Icon Links" class="navbar-nav" id="navbar-icon-links">
      </ul>
      </div>
      
    </div>
    
  </div>

  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      <main class="bd-main" id="main-content">
        
        
        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                
            </div>
            
            
            <article class="bd-article" role="main">
              
  <section id="cucim-api-reference">
<h1>cuCIM API Reference<a class="headerlink" href="#cucim-api-reference" title="Permalink to this heading">#</a></h1>
<section id="module-cucim.clara">
<span id="clara-submodules"></span><h2>Clara Submodules<a class="headerlink" href="#module-cucim.clara" title="Permalink to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="cucim.clara.CuImage">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.clara.</span></span><span class="sig-name descname"><span class="pre">CuImage</span></span><a class="headerlink" href="#cucim.clara.CuImage" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cucim.clara.CuImage.associated_images" title="cucim.clara.CuImage.associated_images"><code class="xref py py-obj docutils literal notranslate"><span class="pre">associated_images</span></code></a></dt><dd><p>Returns a set of associated image names.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.channel_names" title="cucim.clara.CuImage.channel_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">channel_names</span></code></a></dt><dd><p>A channel name list.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.coord_sys" title="cucim.clara.CuImage.coord_sys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coord_sys</span></code></a></dt><dd><p>Coordinate frame in which the direction cosines are measured.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.device" title="cucim.clara.CuImage.device"><code class="xref py py-obj docutils literal notranslate"><span class="pre">device</span></code></a></dt><dd><p>A device type.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.dims" title="cucim.clara.CuImage.dims"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dims</span></code></a></dt><dd><p>A string containing a list of dimensions being requested.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.direction" title="cucim.clara.CuImage.direction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code></a></dt><dd><p>Direction cosines (size is always 3x3).</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.dtype" title="cucim.clara.CuImage.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt><dd><p>The data type of the image.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.is_loaded" title="cucim.clara.CuImage.is_loaded"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_loaded</span></code></a></dt><dd><p>True if image data is loaded &amp; available.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.metadata" title="cucim.clara.CuImage.metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metadata</span></code></a></dt><dd><p>A metadata object as <cite>dict</cite>.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.ndim" title="cucim.clara.CuImage.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></dt><dd><p>The number of dimensions.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.origin" title="cucim.clara.CuImage.origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origin</span></code></a></dt><dd><p>Physical location of (0, 0, 0) (size is always 3).</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.path" title="cucim.clara.CuImage.path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">path</span></code></a></dt><dd><p>Underlying file path for this object.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.raw_metadata" title="cucim.clara.CuImage.raw_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">raw_metadata</span></code></a></dt><dd><p>A raw metadata string.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.resolutions" title="cucim.clara.CuImage.resolutions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resolutions</span></code></a></dt><dd><p>Returns a dict that includes resolution information.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.shape" title="cucim.clara.CuImage.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>A tuple of dimension sizes (in the order of <cite>dims</cite>)</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.CuImage.typestr" title="cucim.clara.CuImage.typestr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">typestr</span></code></a></dt><dd><p>The data type of the image in string format.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.CuImage.associated_image" title="cucim.clara.CuImage.associated_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">associated_image</span></code></a>(self[,&nbsp;name,&nbsp;device])</p></td>
<td><p>Returns an associated image for the given name, as a CuImage object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.clara.CuImage.cache" title="cucim.clara.CuImage.cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache</span></code></a>([type])</p></td>
<td><p>Get cache object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.CuImage.close" title="cucim.clara.CuImage.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a>(self)</p></td>
<td><p>Closes the file handle.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.clara.CuImage.profiler" title="cucim.clara.CuImage.profiler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">profiler</span></code></a>(**kwargs)</p></td>
<td><p>Get profiler object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.CuImage.read_region" title="cucim.clara.CuImage.read_region"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_region</span></code></a>(self[,&nbsp;location,&nbsp;size,&nbsp;level,&nbsp;...])</p></td>
<td><p>Returns a subresolution image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.clara.CuImage.save" title="cucim.clara.CuImage.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(self,&nbsp;arg0)</p></td>
<td><p>Saves image data to the file path.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.CuImage.size" title="cucim.clara.CuImage.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a>(self[,&nbsp;dim_order])</p></td>
<td><p>Returns size as a tuple for the given dimension order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.clara.CuImage.spacing" title="cucim.clara.CuImage.spacing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spacing</span></code></a>(self[,&nbsp;dim_order])</p></td>
<td><p>Returns physical size in tuple.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.CuImage.spacing_units" title="cucim.clara.CuImage.spacing_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spacing_units</span></code></a>(self[,&nbsp;dim_order])</p></td>
<td><p>Units for each spacing element (size is same with <cite>ndim</cite>).</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.associated_image">
<span class="sig-name descname"><span class="pre">associated_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.CuImage" title="cucim.clara._cucim.CuImage"><span class="pre">cucim.clara._cucim.CuImage</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.io.Device" title="cucim.clara._cucim.io.Device"><span class="pre">cucim.clara._cucim.io.Device</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">cpu</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span></span><a class="headerlink" href="#cucim.clara.CuImage.associated_image" title="Permalink to this definition">#</a></dt>
<dd><p>Returns an associated image for the given name, as a CuImage object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.associated_images">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">associated_images</span></span><a class="headerlink" href="#cucim.clara.CuImage.associated_images" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a set of associated image names.</p>
<p>Digital Pathology image usually has a label/thumbnail or a macro image(low-power snapshot of the entire glass slide).
Names of those images (such as &lsquo;macro&rsquo; and &lsquo;label&rsquo;) are in <cite>associated_images</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.cache">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference internal" href="#cucim.clara.cache.ImageCache" title="cucim.clara._cucim.cache.ImageCache"><span class="pre">cucim.clara._cucim.cache.ImageCache</span></a></span></span><a class="headerlink" href="#cucim.clara.CuImage.cache" title="Permalink to this definition">#</a></dt>
<dd><p>Get cache object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.channel_names">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">channel_names</span></span><a class="headerlink" href="#cucim.clara.CuImage.channel_names" title="Permalink to this definition">#</a></dt>
<dd><p>A channel name list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.CuImage" title="cucim.clara._cucim.CuImage"><span class="pre">cucim.clara._cucim.CuImage</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.11)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#cucim.clara.CuImage.close" title="Permalink to this definition">#</a></dt>
<dd><p>Closes the file handle.</p>
<p>Once the file handle is closed, the image object (if loaded before) still exists but cannot read additional images
from the file.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.coord_sys">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coord_sys</span></span><a class="headerlink" href="#cucim.clara.CuImage.coord_sys" title="Permalink to this definition">#</a></dt>
<dd><p>Coordinate frame in which the direction cosines are measured.</p>
<p>Available Coordinate frame names are not finalized yet.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><a class="headerlink" href="#cucim.clara.CuImage.device" title="Permalink to this definition">#</a></dt>
<dd><p>A device type.</p>
<p>By default t is <cite>cpu</cite> (It will be changed since v0.19.0).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dims</span></span><a class="headerlink" href="#cucim.clara.CuImage.dims" title="Permalink to this definition">#</a></dt>
<dd><p>A string containing a list of dimensions being requested.</p>
<dl class="simple">
<dt>The default is to return the six standard dims (&lsquo;STCZYX&rsquo;) unless it is a DP multi-resolution image.</dt><dd><p>[sites, time, channel(or wavelength), z, y, x]. S - Sites or multiposition locations.</p>
</dd>
</dl>
<p>NOTE: in OME-TIFF&rsquo;s metadata, dimension order would be specified as &lsquo;XYZCTS&rsquo; (first one is fast-iterating dimension).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.direction">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">direction</span></span><a class="headerlink" href="#cucim.clara.CuImage.direction" title="Permalink to this definition">#</a></dt>
<dd><p>Direction cosines (size is always 3x3).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#cucim.clara.CuImage.dtype" title="Permalink to this definition">#</a></dt>
<dd><p>The data type of the image.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.is_loaded">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_loaded</span></span><a class="headerlink" href="#cucim.clara.CuImage.is_loaded" title="Permalink to this definition">#</a></dt>
<dd><p>True if image data is loaded &amp; available.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.CuImage.is_trace_enabled">
<span class="sig-name descname"><span class="pre">is_trace_enabled</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#cucim.clara.CuImage.is_trace_enabled" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.metadata">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">metadata</span></span><a class="headerlink" href="#cucim.clara.CuImage.metadata" title="Permalink to this definition">#</a></dt>
<dd><p>A metadata object as <cite>dict</cite>.</p>
<p>It would be a dictionary(key-value pair) in general but can be a complex object (e.g., OME-TIFF metadata).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.ndim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ndim</span></span><a class="headerlink" href="#cucim.clara.CuImage.ndim" title="Permalink to this definition">#</a></dt>
<dd><p>The number of dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.origin">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">origin</span></span><a class="headerlink" href="#cucim.clara.CuImage.origin" title="Permalink to this definition">#</a></dt>
<dd><p>Physical location of (0, 0, 0) (size is always 3).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.path">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#cucim.clara.CuImage.path" title="Permalink to this definition">#</a></dt>
<dd><p>Underlying file path for this object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.profiler">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">profiler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><span class="pre">cucim.clara._cucim.profiler.Profiler</span></span></span><a class="headerlink" href="#cucim.clara.CuImage.profiler" title="Permalink to this definition">#</a></dt>
<dd><p>Get profiler object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.raw_metadata">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">raw_metadata</span></span><a class="headerlink" href="#cucim.clara.CuImage.raw_metadata" title="Permalink to this definition">#</a></dt>
<dd><p>A raw metadata string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.read_region">
<span class="sig-name descname"><span class="pre">read_region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.CuImage" title="cucim.clara._cucim.CuImage"><span class="pre">cucim.clara._cucim.CuImage</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_workers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop_last</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefetch_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.io.Device" title="cucim.clara._cucim.io.Device"><span class="pre">cucim.clara._cucim.io.Device</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">cpu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shm_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span></span><a class="headerlink" href="#cucim.clara.CuImage.read_region" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a subresolution image.</p>
<ul class="simple">
<li><p><cite>location</cite> and <cite>size</cite>&rsquo;s dimension order is reverse of image&rsquo;s dimension order.</p></li>
<li><p>Need to specify (X,Y) and (Width, Height) instead of (Y,X) and (Height, Width).</p></li>
<li><p>If location is not specified, location would be (0, 0) if Z=0. Otherwise, location would be (0, 0, 0)</p></li>
<li><p>Like OpenSlide, location is level-0 based coordinates (using the level-0 reference frame)</p></li>
<li><p>If <cite>size</cite> is not specified, size would be (width, height) of the image at the specified <cite>level</cite>.</p></li>
<li><p><cite>&lt;not supported yet&gt;</cite> Additional parameters (S,T,C,Z) are similar to &lt;<a class="reference external" href="https://allencellmodeling.github.io/aicsimageio/aicsimageio.html#aicsimageio.aics_image.AICSImage.get_image_data">https://allencellmodeling.github.io/aicsimageio/aicsimageio.html#aicsimageio.aics_image.AICSImage.get_image_data</a>&gt;</p></li>
<li><p>Do not yet support indices/ranges for (S,T,C,Z).</p></li>
<li><p>Default value for level, S, T, Z are zero.</p></li>
<li><p>Default value for C is -1 (whole channels)</p></li>
<li><p><cite>&lt;not supported yet&gt;</cite> <cite>device</cite> could be one of the following strings or Device object: e.g., <cite>&lsquo;cpu&rsquo;</cite>, <cite>&lsquo;cuda&rsquo;</cite>, <cite>&lsquo;cuda:0&rsquo;</cite> (use index 0), <cite>cucim.clara.io.Device(cucim.clara.io.CUDA,0)</cite>.</p></li>
<li><p><cite>&lt;not supported yet&gt;</cite> If <cite>buf</cite> is specified (buf&rsquo;s type can be either numpy object that implements <cite>__array_interface__</cite>, or cupy-compatible object that implements <cite>__cuda_array_interface__</cite>), the read image would be saved into buf object without creating CPU/GPU memory.</p></li>
<li><p><cite>&lt;not supported yet&gt;</cite> If <cite>shm_name</cite> is specified, shared memory would be created and data would be read in the shared memory.</p></li>
</ul>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.resolutions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">resolutions</span></span><a class="headerlink" href="#cucim.clara.CuImage.resolutions" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a dict that includes resolution information.</p>
<ul class="simple">
<li><p>level_count: The number of levels</p></li>
<li><p>level_dimensions: A tuple of dimension tuples (width, height)</p></li>
<li><p>level_downsamples: A tuple of down-sample factors</p></li>
<li><p>level_tile_sizes: A tuple of tile size tuple (tile width, tile_height)</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.CuImage" title="cucim.clara._cucim.CuImage"><span class="pre">cucim.clara._cucim.CuImage</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.11)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#cucim.clara.CuImage.save" title="Permalink to this definition">#</a></dt>
<dd><p>Saves image data to the file path.</p>
<p>Currently it supports only .ppm file format that can be viewed by <cite>eog</cite> command in Ubuntu.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#cucim.clara.CuImage.shape" title="Permalink to this definition">#</a></dt>
<dd><p>A tuple of dimension sizes (in the order of <cite>dims</cite>)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.CuImage" title="cucim.clara._cucim.CuImage"><span class="pre">cucim.clara._cucim.CuImage</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#cucim.clara.CuImage.size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns size as a tuple for the given dimension order.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.spacing">
<span class="sig-name descname"><span class="pre">spacing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.CuImage" title="cucim.clara._cucim.CuImage"><span class="pre">cucim.clara._cucim.CuImage</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#cucim.clara.CuImage.spacing" title="Permalink to this definition">#</a></dt>
<dd><p>Returns physical size in tuple.</p>
<p>If <cite>dim_order</cite> is specified, it returns phisical size for the dimensions.
If a dimension given by the <cite>dim_order</cite> doesn&rsquo;t exist, it returns 1.0 by default for the missing dimension.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dim_order: A dimension string (e.g., &lsquo;XYZ&rsquo;)</p>
</dd>
<dt>Returns:</dt><dd><p>A tuple with physical size for each dimension</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.CuImage.spacing_units">
<span class="sig-name descname"><span class="pre">spacing_units</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.CuImage" title="cucim.clara._cucim.CuImage"><span class="pre">cucim.clara._cucim.CuImage</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#cucim.clara.CuImage.spacing_units" title="Permalink to this definition">#</a></dt>
<dd><p>Units for each spacing element (size is same with <cite>ndim</cite>).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.CuImage.typestr">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">typestr</span></span><a class="headerlink" href="#cucim.clara.CuImage.typestr" title="Permalink to this definition">#</a></dt>
<dd><p>The data type of the image in string format.</p>
<p>The value can be converted to NumPy&rsquo;s dtype using <cite>numpy.dtype()</cite>.
(e.g., <cite>numpy.dtype(img.typestr)</cite>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.clara.DLDataType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.clara.</span></span><span class="sig-name descname"><span class="pre">DLDataType</span></span><a class="headerlink" href="#cucim.clara.DLDataType" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cucim.clara.DLDataType.bits" title="cucim.clara.DLDataType.bits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bits</span></code></a></dt><dd><p>Number of bits, common choices are 8, 16, 32.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.DLDataType.code" title="cucim.clara.DLDataType.code"><code class="xref py py-obj docutils literal notranslate"><span class="pre">code</span></code></a></dt><dd><p>Type code of base types.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.DLDataType.lanes" title="cucim.clara.DLDataType.lanes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lanes</span></code></a></dt><dd><p>Number of lanes in the type, used for vector types.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.DLDataType.bits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bits</span></span><a class="headerlink" href="#cucim.clara.DLDataType.bits" title="Permalink to this definition">#</a></dt>
<dd><p>Number of bits, common choices are 8, 16, 32.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.DLDataType.code">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">code</span></span><a class="headerlink" href="#cucim.clara.DLDataType.code" title="Permalink to this definition">#</a></dt>
<dd><p>Type code of base types.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.DLDataType.lanes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lanes</span></span><a class="headerlink" href="#cucim.clara.DLDataType.lanes" title="Permalink to this definition">#</a></dt>
<dd><p>Number of lanes in the type, used for vector types.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.clara.DLDataTypeCode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.clara.</span></span><span class="sig-name descname"><span class="pre">DLDataTypeCode</span></span><a class="headerlink" href="#cucim.clara.DLDataTypeCode" title="Permalink to this definition">#</a></dt>
<dd><p>Members:</p>
<p>DLInt</p>
<p>DLUInt</p>
<p>DLFloat</p>
<p>DLBfloat</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cucim.clara.DLDataTypeCode.name" title="cucim.clara.DLDataTypeCode.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></dt><dd><p>name(self: handle) -&gt; str</p>
</dd>
<dt><strong>value</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.DLDataTypeCode.DLBfloat">
<span class="sig-name descname"><span class="pre">DLBfloat</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DLDataTypeCode.DLBfloat:</span> <span class="pre">4&gt;</span></em><a class="headerlink" href="#cucim.clara.DLDataTypeCode.DLBfloat" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.DLDataTypeCode.DLFloat">
<span class="sig-name descname"><span class="pre">DLFloat</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DLDataTypeCode.DLFloat:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#cucim.clara.DLDataTypeCode.DLFloat" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.DLDataTypeCode.DLInt">
<span class="sig-name descname"><span class="pre">DLInt</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DLDataTypeCode.DLInt:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#cucim.clara.DLDataTypeCode.DLInt" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.DLDataTypeCode.DLUInt">
<span class="sig-name descname"><span class="pre">DLUInt</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DLDataTypeCode.DLUInt:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#cucim.clara.DLDataTypeCode.DLUInt" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.DLDataTypeCode.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#cucim.clara.DLDataTypeCode.name" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.DLDataTypeCode.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#cucim.clara.DLDataTypeCode.value" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<section id="module-cucim.clara.cache">
<span id="cache"></span><h3>cache<a class="headerlink" href="#module-cucim.clara.cache" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cucim.clara.cache.CacheType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.clara.cache.</span></span><span class="sig-name descname"><span class="pre">CacheType</span></span><a class="headerlink" href="#cucim.clara.cache.CacheType" title="Permalink to this definition">#</a></dt>
<dd><p>Members:</p>
<p>NoCache</p>
<p>PerProcess</p>
<p>SharedMemory</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cucim.clara.cache.CacheType.name" title="cucim.clara.cache.CacheType.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></dt><dd><p>name(self: handle) -&gt; str</p>
</dd>
<dt><strong>value</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.cache.CacheType.NoCache">
<span class="sig-name descname"><span class="pre">NoCache</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CacheType.NoCache:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#cucim.clara.cache.CacheType.NoCache" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.cache.CacheType.PerProcess">
<span class="sig-name descname"><span class="pre">PerProcess</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CacheType.PerProcess:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#cucim.clara.cache.CacheType.PerProcess" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.cache.CacheType.SharedMemory">
<span class="sig-name descname"><span class="pre">SharedMemory</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CacheType.SharedMemory:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#cucim.clara.cache.CacheType.SharedMemory" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.CacheType.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#cucim.clara.cache.CacheType.name" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.CacheType.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#cucim.clara.cache.CacheType.value" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.clara.cache.</span></span><span class="sig-name descname"><span class="pre">ImageCache</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.capacity" title="cucim.clara.cache.ImageCache.capacity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">capacity</span></code></a></dt><dd><p>A capacity of list/hashmap.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.config" title="cucim.clara.cache.ImageCache.config"><code class="xref py py-obj docutils literal notranslate"><span class="pre">config</span></code></a></dt><dd><p>Returns the dictionary of configuration.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.free_memory" title="cucim.clara.cache.ImageCache.free_memory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">free_memory</span></code></a></dt><dd><p>A cache memory size available in the cache memory.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.hit_count" title="cucim.clara.cache.ImageCache.hit_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hit_count</span></code></a></dt><dd><p>A cache hit count.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.memory_capacity" title="cucim.clara.cache.ImageCache.memory_capacity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">memory_capacity</span></code></a></dt><dd><p>A capacity of cache memory.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.memory_size" title="cucim.clara.cache.ImageCache.memory_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">memory_size</span></code></a></dt><dd><p>A size of cache memory used.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.miss_count" title="cucim.clara.cache.ImageCache.miss_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">miss_count</span></code></a></dt><dd><p>A cache miss count.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.size" title="cucim.clara.cache.ImageCache.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></dt><dd><p>A size of list/hashmap.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.cache.ImageCache.type" title="cucim.clara.cache.ImageCache.type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code></a></dt><dd><p>A Cache type.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.cache.ImageCache.record" title="cucim.clara.cache.ImageCache.record"><code class="xref py py-obj docutils literal notranslate"><span class="pre">record</span></code></a>(self[,&nbsp;value])</p></td>
<td><p>Records the cache statistics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.clara.cache.ImageCache.reserve" title="cucim.clara.cache.ImageCache.reserve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reserve</span></code></a>(self,&nbsp;memory_capacity,&nbsp;**kwargs)</p></td>
<td><p>Reserves more memory if possible.</p></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.capacity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capacity</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.capacity" title="Permalink to this definition">#</a></dt>
<dd><p>A capacity of list/hashmap.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.config">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">config</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.config" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the dictionary of configuration.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.free_memory">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">free_memory</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.free_memory" title="Permalink to this definition">#</a></dt>
<dd><p>A cache memory size available in the cache memory.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.hit_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hit_count</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.hit_count" title="Permalink to this definition">#</a></dt>
<dd><p>A cache hit count.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.memory_capacity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">memory_capacity</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.memory_capacity" title="Permalink to this definition">#</a></dt>
<dd><p>A capacity of cache memory.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.memory_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">memory_size</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.memory_size" title="Permalink to this definition">#</a></dt>
<dd><p>A size of cache memory used.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.miss_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">miss_count</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.miss_count" title="Permalink to this definition">#</a></dt>
<dd><p>A cache miss count.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.record">
<span class="sig-name descname"><span class="pre">record</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.cache.ImageCache" title="cucim.clara._cucim.cache.ImageCache"><span class="pre">cucim.clara._cucim.cache.ImageCache</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.record" title="Permalink to this definition">#</a></dt>
<dd><p>Records the cache statistics.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.reserve">
<span class="sig-name descname"><span class="pre">reserve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.cache.ImageCache" title="cucim.clara._cucim.cache.ImageCache"><span class="pre">cucim.clara._cucim.cache.ImageCache</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_capacity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.11)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.reserve" title="Permalink to this definition">#</a></dt>
<dd><p>Reserves more memory if possible.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.size" title="Permalink to this definition">#</a></dt>
<dd><p>A size of list/hashmap.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.cache.ImageCache.type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#cucim.clara.cache.ImageCache.type" title="Permalink to this definition">#</a></dt>
<dd><p>A Cache type.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.clara.cache.preferred_memory_capacity">
<span class="sig-prename descclassname"><span class="pre">cucim.clara.cache.</span></span><span class="sig-name descname"><span class="pre">preferred_memory_capacity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tile_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bytes_per_pixel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#cucim.clara.cache.preferred_memory_capacity" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a good cache memory capacity value in MiB for the given conditions.</p>
<p>Please see how the value is calculated: <a class="reference external" href="https://godbolt.org/z/8vxnPfKM5">https://godbolt.org/z/8vxnPfKM5</a></p>
<dl class="simple">
<dt>Args:</dt><dd><p>img: A <cite>CuImage</cite> object that can provide <cite>image_size</cite>, <cite>tile_size</cite>, <cite>bytes_per_pixel</cite> information. If this argument is provided, only <cite>patch_size</cite> from the arguments is used for the calculation.
image_size: A list of values that presents the image size (width, height).
tile_size: A list of values that presents the tile size (width, height). The default value is (256, 256).
patch_size: A list of values that presents the patch size (width, height). The default value is (256, 256).
bytes_per_pixel: The number of bytes that each pixel in the 2D image takes place. The default value is 3.</p>
</dd>
<dt>Returns:</dt><dd><p>int: The suggested memory capacity in MiB.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.clara.filesystem">
<span id="filesystem"></span><h3>filesystem<a class="headerlink" href="#module-cucim.clara.filesystem" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cucim.clara.filesystem.CuFileDriver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.clara.filesystem.</span></span><span class="sig-name descname"><span class="pre">CuFileDriver</span></span><a class="headerlink" href="#cucim.clara.filesystem.CuFileDriver" title="Permalink to this definition">#</a></dt>
<dd><p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver.close" title="cucim.clara.filesystem.CuFileDriver.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a>(self)</p></td>
<td><p>Closes opened file if not closed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver.pread" title="cucim.clara.filesystem.CuFileDriver.pread"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pread</span></code></a>(self,&nbsp;buf,&nbsp;count,&nbsp;file_offset[,&nbsp;...])</p></td>
<td><p>Reads up to <cite>count</cite> bytes from the file driver at offset <cite>file_offset</cite> (from the start of the file) into the buffer <cite>buf</cite> starting at offset <cite>buf_offset</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver.pwrite" title="cucim.clara.filesystem.CuFileDriver.pwrite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pwrite</span></code></a>(self,&nbsp;buf,&nbsp;count,&nbsp;file_offset[,&nbsp;...])</p></td>
<td><p>Reads up to <cite>count</cite> bytes from the file driver at offset <cite>file_offset</cite> (from the start of the file) into the buffer <cite>buf</cite> starting at offset <cite>buf_offset</cite>.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.filesystem.CuFileDriver.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver" title="cucim.clara._cucim.filesystem.CuFileDriver"><span class="pre">cucim.clara._cucim.filesystem.CuFileDriver</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span></span><a class="headerlink" href="#cucim.clara.filesystem.CuFileDriver.close" title="Permalink to this definition">#</a></dt>
<dd><p>Closes opened file if not closed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.filesystem.CuFileDriver.pread">
<span class="sig-name descname"><span class="pre">pread</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver" title="cucim.clara._cucim.filesystem.CuFileDriver"><span class="pre">cucim.clara._cucim.filesystem.CuFileDriver</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#cucim.clara.filesystem.CuFileDriver.pread" title="Permalink to this definition">#</a></dt>
<dd><p>Reads up to <cite>count</cite> bytes from the file driver at offset <cite>file_offset</cite> (from the start of the file) into the buffer
<cite>buf</cite> starting at offset <cite>buf_offset</cite>. The file offset is not changed.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>buf: A buffer where read bytes are stored. Buffer can be either in CPU memory or (CUDA) GPU memory.
count: The number of bytes to read.
file_offset: An offset from the start of the file.
buf_offset: An offset from the start of the buffer. Default value is 0.</p>
</dd>
<dt>Returns:</dt><dd><p>The number of bytes read if succeed, -1 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.filesystem.CuFileDriver.pwrite">
<span class="sig-name descname"><span class="pre">pwrite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver" title="cucim.clara._cucim.filesystem.CuFileDriver"><span class="pre">cucim.clara._cucim.filesystem.CuFileDriver</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#cucim.clara.filesystem.CuFileDriver.pwrite" title="Permalink to this definition">#</a></dt>
<dd><p>Reads up to <cite>count</cite> bytes from the file driver at offset <cite>file_offset</cite> (from the start of the file) into the buffer
<cite>buf</cite> starting at offset <cite>buf_offset</cite>. The file offset is not changed.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>buf: A buffer where write bytes come from. Buffer can be either in CPU memory or (CUDA) GPU memory.
count: The number of bytes to write.
file_offset: An offset from the start of the file.
buf_offset: An offset from the start of the buffer. Default value is 0.</p>
</dd>
<dt>Returns:</dt><dd><p>The number of bytes written if succeed, -1 otherwise.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.clara.filesystem.close">
<span class="sig-prename descclassname"><span class="pre">cucim.clara.filesystem.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver" title="cucim.clara._cucim.filesystem.CuFileDriver"><span class="pre">cucim.clara._cucim.filesystem.CuFileDriver</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span></span><a class="headerlink" href="#cucim.clara.filesystem.close" title="Permalink to this definition">#</a></dt>
<dd><p>Closes the given file driver.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>fd: An CuFileDriver object.</p>
</dd>
<dt>Returns:</dt><dd><p>True if succeed, False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.clara.filesystem.discard_page_cache">
<span class="sig-prename descclassname"><span class="pre">cucim.clara.filesystem.</span></span><span class="sig-name descname"><span class="pre">discard_page_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span></span><a class="headerlink" href="#cucim.clara.filesystem.discard_page_cache" title="Permalink to this definition">#</a></dt>
<dd><p>Discards a system (page) cache for the given file path.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>file_path: A file path to drop system cache.</p>
</dd>
<dt>Returns:</dt><dd><p>True if succeed, False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.clara.filesystem.open">
<span class="sig-prename descclassname"><span class="pre">cucim.clara.filesystem.</span></span><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">420</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver" title="cucim.clara._cucim.filesystem.CuFileDriver"><span class="pre">cucim.clara._cucim.filesystem.CuFileDriver</span></a></span></span><a class="headerlink" href="#cucim.clara.filesystem.open" title="Permalink to this definition">#</a></dt>
<dd><p>Open file with specific flags and mode.</p>
<p>&lsquo;flags&rsquo; can be one of the following flag string:</p>
<ul class="simple">
<li><p>&ldquo;r&rdquo;: os.O_RDONLY</p></li>
<li><p>&ldquo;r+&rdquo;: os.O_RDWR</p></li>
<li><p>&ldquo;w&rdquo;: os.O_RDWR | os.O_CREAT | os.O_TRUNC</p></li>
<li><p>&ldquo;a&rdquo;: os.O_RDWR | os.O_CREAT</p></li>
</ul>
<p>In addition to above flags, the method append os.O_CLOEXEC and os.O_DIRECT by default.</p>
<p>The following is optional flags that can be added to above string:</p>
<ul class="simple">
<li><p>&lsquo;p&rsquo;: Use POSIX APIs only (first try to open with O_DIRECT). It does not use GDS.</p></li>
<li><p>&lsquo;n&rsquo;: Do not add O_DIRECT flag.</p></li>
<li><p>&lsquo;m&rsquo;: Use memory-mapped file. This flag is supported only for the read-only file descriptor.</p></li>
</ul>
<p>When &lsquo;m&rsquo; is used, <cite>PROT_READ</cite> and <cite>MAP_SHARED</cite> are used for the parameter of mmap() function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>file_path: A file path to open.
flags: File flags in string. Default value is &ldquo;r&rdquo;.
mode: A file mode. Default value is &lsquo;0o644&rsquo;.</p>
</dd>
<dt>Returns:</dt><dd><p>An object of CuFileDriver.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.clara.filesystem.pread">
<span class="sig-prename descclassname"><span class="pre">cucim.clara.filesystem.</span></span><span class="sig-name descname"><span class="pre">pread</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver" title="cucim.clara._cucim.filesystem.CuFileDriver"><span class="pre">cucim.clara._cucim.filesystem.CuFileDriver</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#cucim.clara.filesystem.pread" title="Permalink to this definition">#</a></dt>
<dd><p>Reads up to <cite>count</cite> bytes from file driver <cite>fd</cite> at offset <cite>offset</cite> (from the start of the file) into the buffer
<cite>buf</cite> starting at offset <cite>buf_offset</cite>. The file offset is not changed.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>fd: An object of CuFileDriver.
buf: A buffer where read bytes are stored. Buffer can be either in CPU memory or (CUDA) GPU memory.
count: The number of bytes to read.
file_offset: An offset from the start of the file.
buf_offset: An offset from the start of the buffer. Default value is 0.</p>
</dd>
<dt>Returns:</dt><dd><p>The number of bytes read if succeed, -1 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.clara.filesystem.pwrite">
<span class="sig-prename descclassname"><span class="pre">cucim.clara.filesystem.</span></span><span class="sig-name descname"><span class="pre">pwrite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#cucim.clara.filesystem.CuFileDriver" title="cucim.clara._cucim.filesystem.CuFileDriver"><span class="pre">cucim.clara._cucim.filesystem.CuFileDriver</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><span class="pre">object</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#cucim.clara.filesystem.pwrite" title="Permalink to this definition">#</a></dt>
<dd><p>Write up to <cite>count</cite> bytes from the buffer <cite>buf</cite> starting at offset <cite>buf_offset</cite> to the file driver <cite>fd</cite> at offset
<cite>offset</cite> (from the start of the file). The file offset is not changed.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>fd: An object of CuFileDriver.
buf: A buffer where write bytes come from. Buffer can be either in CPU memory or (CUDA) GPU memory.
count: The number of bytes to write.
file_offset: An offset from the start of the file.
buf_offset: An offset from the start of the buffer. Default value is 0.</p>
</dd>
<dt>Returns:</dt><dd><p>The number of bytes written if succeed, -1 otherwise.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.clara.io">
<span id="io"></span><h3>io<a class="headerlink" href="#module-cucim.clara.io" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cucim.clara.io.Device">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.clara.io.</span></span><span class="sig-name descname"><span class="pre">Device</span></span><a class="headerlink" href="#cucim.clara.io.Device" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cucim.clara.io.Device.index" title="cucim.clara.io.Device.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt><dd><p>Device index.</p>
</dd>
<dt><a class="reference internal" href="#cucim.clara.io.Device.type" title="cucim.clara.io.Device.type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code></a></dt><dd><p>Device type.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.clara.io.Device.parse_type" title="cucim.clara.io.Device.parse_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parse_type</span></code></a>(arg0)</p></td>
<td><p>Create <cite>DeviceType</cite> object from the device name string.</p></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.io.Device.index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">index</span></span><a class="headerlink" href="#cucim.clara.io.Device.index" title="Permalink to this definition">#</a></dt>
<dd><p>Device index.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.clara.io.Device.parse_type">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">parse_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference internal" href="#cucim.clara.io.DeviceType" title="cucim.clara._cucim.io.DeviceType"><span class="pre">cucim.clara._cucim.io.DeviceType</span></a></span></span><a class="headerlink" href="#cucim.clara.io.Device.parse_type" title="Permalink to this definition">#</a></dt>
<dd><p>Create <cite>DeviceType</cite> object from the device name string.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.io.Device.type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#cucim.clara.io.Device.type" title="Permalink to this definition">#</a></dt>
<dd><p>Device type.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.clara.io.</span></span><span class="sig-name descname"><span class="pre">DeviceType</span></span><a class="headerlink" href="#cucim.clara.io.DeviceType" title="Permalink to this definition">#</a></dt>
<dd><p>Members:</p>
<p>CPU</p>
<p>CUDA</p>
<p>CUDAHost</p>
<p>CUDAManaged</p>
<p>CPUShared</p>
<p>CUDAShared</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cucim.clara.io.DeviceType.name" title="cucim.clara.io.DeviceType.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></dt><dd><p>name(self: handle) -&gt; str</p>
</dd>
<dt><strong>value</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType.CPU">
<span class="sig-name descname"><span class="pre">CPU</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceType.CPU:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#cucim.clara.io.DeviceType.CPU" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType.CPUShared">
<span class="sig-name descname"><span class="pre">CPUShared</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceType.CPUShared:</span> <span class="pre">101&gt;</span></em><a class="headerlink" href="#cucim.clara.io.DeviceType.CPUShared" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType.CUDA">
<span class="sig-name descname"><span class="pre">CUDA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceType.CUDA:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#cucim.clara.io.DeviceType.CUDA" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType.CUDAHost">
<span class="sig-name descname"><span class="pre">CUDAHost</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceType.CUDAHost:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#cucim.clara.io.DeviceType.CUDAHost" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType.CUDAManaged">
<span class="sig-name descname"><span class="pre">CUDAManaged</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceType.CUDAManaged:</span> <span class="pre">13&gt;</span></em><a class="headerlink" href="#cucim.clara.io.DeviceType.CUDAManaged" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType.CUDAShared">
<span class="sig-name descname"><span class="pre">CUDAShared</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceType.CUDAShared:</span> <span class="pre">102&gt;</span></em><a class="headerlink" href="#cucim.clara.io.DeviceType.CUDAShared" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#cucim.clara.io.DeviceType.name" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.clara.io.DeviceType.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#cucim.clara.io.DeviceType.value" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
</section>
<section id="core-submodules">
<h2>core Submodules<a class="headerlink" href="#core-submodules" title="Permalink to this heading">#</a></h2>
<section id="module-cucim.core.operations.color">
<span id="color"></span><h3>color<a class="headerlink" href="#module-cucim.core.operations.color" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.color.color_jitter">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.color.</span></span><span class="sig-name descname"><span class="pre">color_jitter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">brightness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contrast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.core.operations.color.color_jitter" title="Permalink to this definition">#</a></dt>
<dd><p>Applies color jitter by random sequential application of
4 operations (brightness, contrast, saturation, hue).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">channel first, cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data of shape (C, H, W). Can also batch process input of shape
(N, C, H, W). Can be a numpy.ndarray or cupy.ndarray.</p>
</dd>
<dt><strong>brightness</strong><span class="classifier">float or 2-tuple of float, optional</span></dt><dd><p>Non-negative factor to jitter the brightness by. When <cite>brightness</cite> is a
scalar, scaling will be by a random value in range
<code class="docutils literal notranslate"><span class="pre">[max(0,</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">brightness),</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">brightness)]</span></code>. <cite>brightness</cite> can
also be a 2-tuple specifying the range for the random scaling factor.
A value of 0 or (1, 1) will result in no change.</p>
</dd>
<dt><strong>contrast</strong><span class="classifier">float or 2-tuple of float, optional</span></dt><dd><p>Non-negative factor to jitter the contrast by. When <cite>contrast</cite> is a
scalar, scaling will be by a random value between
<code class="docutils literal notranslate"><span class="pre">[max(0,</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">contrast),</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">contrast)]</span></code>. <cite>contrast</cite> can
also be a 2-tuple specifying the range for the random scaling factor.
A value of 0 or (1, 1) will result in no change.</p>
</dd>
<dt><strong>saturation</strong><span class="classifier">float or 2-tuple of float, optional</span></dt><dd><p>Non-negative factor to jitter the saturation by. When <cite>saturation</cite> is a
scalar, scaling will be by a random value between
<code class="docutils literal notranslate"><span class="pre">[max(0,</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">saturation),</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">saturation)]</span></code>. <cite>saturation</cite> can
also be a 2-tuple specifying the range for the random scaling factor.
A value of 0 or (1, 1) will result in no change.</p>
</dd>
<dt><strong>hue</strong><span class="classifier">float or 2-tuple of float, optional</span></dt><dd><p>Factor between [-0.5, 0.5] to jitter hue by. When <cite>hue</cite> is a
scalar, scaling will be by a random value between in the range
<code class="docutils literal notranslate"><span class="pre">[-hue,</span> <span class="pre">hue]</span></code>. <cite>hue</cite> can also be a 2-tuple specifying the range.
A value of 0 or (0, 0) will result in no change.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If &lsquo;brightness&rsquo;,&rsquo;contrast&rsquo;,&rsquo;saturation&rsquo; or &lsquo;hue&rsquo; is outside
of allowed range</p>
</dd>
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.color</span> <span class="k">as</span> <span class="nn">ccl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">ccl</span><span class="o">.</span><span class="n">color_jitter</span><span class="p">(</span><span class="n">input_arr</span><span class="p">,</span><span class="mf">.25</span><span class="p">,</span><span class="mf">.75</span><span class="p">,</span><span class="mf">.25</span><span class="p">,</span><span class="mf">.04</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.color.image_to_absorbance">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.color.</span></span><span class="sig-name descname"><span class="pre">image_to_absorbance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_intensity=255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.core.operations.color.image_to_absorbance" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image to units of absorbance (optical density).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The image to convert to absorbance. Can be single or multichannel.</p>
</dd>
<dt><strong>source_intensity</strong><span class="classifier">float, optional</span></dt><dd><p>Reference intensity for <cite>image</cite>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy.dtype, optional</span></dt><dd><p>The floating point precision at which to compute the absorbance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>absorbance</strong><span class="classifier">ndarray</span></dt><dd><p>The absorbance computed from image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>image</cite> has an integer dtype it will be clipped to range
<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">source_intensity]</span></code>, while float image inputs are clipped to range
<code class="docutils literal notranslate"><span class="pre">[source_intensity/255,</span> <span class="pre">source_intensity]</span></code>.
The minimum is to avoid log(0). Absorbance is then given by
<code class="docutils literal notranslate"><span class="pre">absorbance</span> <span class="pre">=</span> <span class="pre">log(image</span> <span class="pre">/</span> <span class="pre">source_intensity)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.color.normalize_colors_pca">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.color.</span></span><span class="sig-name descname"><span class="pre">normalize_colors_pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_intensity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">240.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.345</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_stain_coeff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.11)"><span class="pre">Union</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><span class="pre">tuple</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.cupy.dev/en/stable/reference/generated/cupy.ndarray.html#cupy.ndarray" title="(in CuPy v11.5.0)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">((0.5626,</span> <span class="pre">0.2159),</span> <span class="pre">(0.7201,</span> <span class="pre">0.8012),</span> <span class="pre">(0.4062,</span> <span class="pre">0.5581))</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_max_conc</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.11)"><span class="pre">Union</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><span class="pre">tuple</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.cupy.dev/en/stable/reference/generated/cupy.ndarray.html#cupy.ndarray" title="(in CuPy v11.5.0)"><span class="pre">ndarray</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">(1.9705,</span> <span class="pre">1.0308)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'intensity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.core.operations.color.normalize_colors_pca" title="Permalink to this definition">#</a></dt>
<dd><p>Extract the matrix of stain coefficient from the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">np.ndarray</span></dt><dd><p>RGB image to determine concentrations for. Intensities should typically
be within unsigned 8-bit integer intensity range ([0, 255]) when
<code class="docutils literal notranslate"><span class="pre">image_type</span> <span class="pre">==</span> <span class="pre">"intensity"</span></code>.</p>
</dd>
<dt><strong>source_intensity</strong><span class="classifier">float, optional</span></dt><dd><p>Transmitted light intensity. The algorithm will clip image intensities
above the specified <cite>source_intensity</cite> and then normalize by
<cite>source_intensity</cite> so that <cite>image</cite> intensities are &lt;= 1.0. Only used
when <cite>image_type==&rdquo;intensity&rdquo;</cite>.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Algorithm parameter controlling the <code class="docutils literal notranslate"><span class="pre">[alpha,</span> <span class="pre">100</span> <span class="pre">-</span> <span class="pre">alpha]</span></code>
percentile range used as a robust [min, max] estimate.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>Absorbance (optical density) threshold below which to consider pixels
as transparent. Transparent pixels are excluded from the estimation.</p>
</dd>
<dt><strong>ref_stain_coeff</strong><span class="classifier">array-like</span></dt><dd><p>Reference stain coefficients as determined by the output of
<cite>stain_extraction_pca</cite> for a reference image.</p>
</dd>
<dt><strong>ref_max_conc</strong><span class="classifier">tuple or cp.ndarray</span></dt><dd><p>The reference maximum concentrations.</p>
</dd>
<dt><strong>image_type</strong><span class="classifier">{&ldquo;intensity&rdquo;, &ldquo;absorbance&rdquo;}, optional</span></dt><dd><p>With the default <cite>image_type</cite> of <cite>&ldquo;intensity&rdquo;</cite>, the image will be
transformed to an <cite>absorbance</cite> using <code class="docutils literal notranslate"><span class="pre">image_to_absorbance</span></code>. If
the input <cite>image</cite> is already an absorbance image, then <cite>image_type</cite>
should be set to <cite>&ldquo;absorbance&rdquo;</cite> instead.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis corresponding to color channels (default is the last axis).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stain_coeff</strong><span class="classifier">np.ndarray</span></dt><dd><p>Stain attenuation coefficient matrix derived from the image, where
the first column corresponds to H, the second column is E and the rows
are RGB values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The default <cite>beta</cite> of 0.345 is equivalent to the use of 0.15 in <a class="reference internal" href="#re6f8c058493f-1" id="id1">[1]</a>. The
difference is due to our use of the natural log instead of a decadic log
(log10) when computing the absorbance.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re6f8c058493f-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>M. Macenko et al., &ldquo;A method for normalizing histology slides for
quantitative analysis,&rdquo; 2009 IEEE International Symposium on
Biomedical Imaging: From Nano to Macro, 2009, pp. 1107-1110,
doi: 10.1109/ISBI.2009.5193250.
<a class="reference external" href="http://wwwx.cs.unc.edu/~mn/sites/default/files/macenko2009.pdf">http://wwwx.cs.unc.edu/~mn/sites/default/files/macenko2009.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.color.stain_extraction_pca">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.color.</span></span><span class="sig-name descname"><span class="pre">stain_extraction_pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">240</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.345</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'intensity'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.core.operations.color.stain_extraction_pca" title="Permalink to this definition">#</a></dt>
<dd><p>Extract the matrix of H &amp; E stain coefficient from an image.</p>
<p>Uses a method that selects stain vectors based on the angle distribution
within a best-fit plane determined by principle component analysis (PCA)
<a class="reference internal" href="#r55f3accbd1ab-1" id="id3">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cp.ndarray</span></dt><dd><p>RGB image to perform stain extraction on. Intensities should typically
be within unsigned 8-bit integer intensity range ([0, 255]) when
<code class="docutils literal notranslate"><span class="pre">image_type</span> <span class="pre">==</span> <span class="pre">"intensity"</span></code>.</p>
</dd>
<dt><strong>source_intensity</strong><span class="classifier">float, optional</span></dt><dd><p>Transmitted light intensity. The algorithm will clip image intensities
above the specified <cite>source_intensity</cite> and then normalize by
<cite>source_intensity</cite> so that <cite>image</cite> intensities are &lt;= 1.0. Only used
when <cite>image_type==&rdquo;intensity&rdquo;</cite>.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Algorithm parameter controlling the <code class="docutils literal notranslate"><span class="pre">[alpha,</span> <span class="pre">100</span> <span class="pre">-</span> <span class="pre">alpha]</span></code>
percentile range used as a robust [min, max] estimate.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>Absorbance (optical density) threshold below which to consider pixels
as transparent. Transparent pixels are excluded from the estimation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stain_coeff</strong><span class="classifier">cp.ndarray</span></dt><dd><p>Stain attenuation coefficient matrix derived from the image, where
the first column corresponds to H, the second column is E and the rows
are RGB values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The default <cite>beta</cite> of 0.345 is equivalent to the use of 0.15 in <a class="reference internal" href="#r55f3accbd1ab-1" id="id4">[1]</a>. The
difference is due to our use of the natural log instead of a decadic log
(log10) when computing the absorbance.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r55f3accbd1ab-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>)</span></dt>
<dd><p>M. Macenko et al., &ldquo;A method for normalizing histology slides for
quantitative analysis,&rdquo; 2009 IEEE International Symposium on
Biomedical Imaging: From Nano to Macro, 2009, pp. 1107-1110,
doi: 10.1109/ISBI.2009.5193250.
<a class="reference external" href="http://wwwx.cs.unc.edu/~mn/sites/default/files/macenko2009.pdf">http://wwwx.cs.unc.edu/~mn/sites/default/files/macenko2009.pdf</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.core.operations.expose">
<span id="expose"></span><h3>expose<a class="headerlink" href="#module-cucim.core.operations.expose" title="Permalink to this heading">#</a></h3>
</section>
<section id="module-cucim.core.operations.intensity">
<span id="intensity"></span><h3>intensity<a class="headerlink" href="#module-cucim.core.operations.intensity" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.intensity.normalize_data">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.intensity.</span></span><span class="sig-name descname"><span class="pre">normalize_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_constant</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'range'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#cucim.core.operations.intensity.normalize_data" title="Permalink to this definition">#</a></dt>
<dd><p>Apply intensity normalization to the input array.
Normalize intensities to the range of [0, norm_constant].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">channel first, cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data of shape (C, H, W). Can also batch process input of shape
(N, C, H, W). Can be a numpy.ndarray or cupy.ndarray.</p>
</dd>
<dt><strong>norm_constant: float</strong></dt><dd><p>Normalization range of the input data. [0, norm_constant]</p>
</dd>
<dt><strong>min_value</strong><span class="classifier">float</span></dt><dd><p>Minimum intensity value in input data.</p>
</dd>
<dt><strong>max_value</strong><span class="classifier">float</span></dt><dd><p>Maximum intensity value in input data.</p>
</dd>
<dt><strong>type</strong><span class="classifier">{&lsquo;range&rsquo;, &lsquo;atan&rsquo;}</span></dt><dd><p>Type of normalization.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
<dt>ValueError</dt><dd><p>If input original intensity min and max are same</p>
</dd>
<dt>ValueError</dt><dd><p>If incorrect normalization type is invoked</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.intensity</span> <span class="k">as</span> <span class="nn">its</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">its</span><span class="o">.</span><span class="n">normalize_data</span><span class="p">(</span><span class="n">input_arr</span><span class="p">,</span>
<span class="go">                                      10, 0 , 255)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.intensity.rand_zoom">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.intensity.</span></span><span class="sig-name descname"><span class="pre">rand_zoom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_zoom</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.11)"><span class="pre">Union</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.11)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_zoom</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.11)"><span class="pre">Union</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.11)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whole_batch</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.core.operations.intensity.rand_zoom" title="Permalink to this definition">#</a></dt>
<dd><p>Randomly Calls zoom with random zoom factor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">channel first, cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data of shape (C, H, W). Can also batch process input of shape
(N, C, H, W). Can be a numpy.ndarray or cupy.ndarray.</p>
</dd>
<dt><strong>min_zoom: Min zoom factor. Can be float or sequence same size as image.</strong></dt><dd><p>If a float, select a random factor from <cite>[min_zoom, max_zoom]</cite> then
apply to all spatial dims to keep the original spatial shape ratio.
If a sequence, min_zoom should contain one value for each spatial axis.
If 2 values provided for 3D data, use the first value for both H &amp; W
dims to keep the same zoom ratio.</p>
</dd>
<dt><strong>max_zoom: Max zoom factor. Can be float or sequence same size as image.</strong></dt><dd><p>If a float, select a random factor from <cite>[min_zoom, max_zoom]</cite> then
apply to all spatial dims to keep the original spatial shape ratio.
If a sequence, max_zoom should contain one value for each spatial axis.
If 2 values provided for 3D data, use the first value for both H &amp; W
dims to keep the same zoom ratio.</p>
</dd>
<dt><strong>prob: Probability of zooming.</strong></dt><dd></dd>
<dt><strong>whole_batch: Flag to apply transform on whole batch.</strong></dt><dd><p>If False, each image in the batch is randomly transformed
It True, entire batch is transformed randomly.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.intensity</span> <span class="k">as</span> <span class="nn">its</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">its</span><span class="o">.</span><span class="n">rand_zoom</span><span class="p">(</span><span class="n">input_arr</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.intensity.scale_intensity_range">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.intensity.</span></span><span class="sig-name descname"><span class="pre">scale_intensity_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#cucim.core.operations.intensity.scale_intensity_range" title="Permalink to this definition">#</a></dt>
<dd><p>Apply intensity scaling to the input array.
Scaling from [a_min, a_max] to [b_min, b_max] with clip option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">channel first, cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data of shape (C, H, W). Can also batch process input of shape
(N, C, H, W). Can be a numpy.ndarray or cupy.ndarray.</p>
</dd>
<dt><strong>b_min</strong><span class="classifier">float</span></dt><dd><p>intensity target range min.</p>
</dd>
<dt><strong>b_max</strong><span class="classifier">float</span></dt><dd><p>intensity target range max.</p>
</dd>
<dt><strong>a_min</strong><span class="classifier">float</span></dt><dd><p>intensity original range min.</p>
</dd>
<dt><strong>a_max</strong><span class="classifier">float</span></dt><dd><p>intensity original range max.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">float</span></dt><dd><p>whether to perform clip after scaling.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
<dt>ValueError</dt><dd><p>If input original intensity min and max are same</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.intensity</span> <span class="k">as</span> <span class="nn">its</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">its</span><span class="o">.</span><span class="n">scale_intensity_range</span><span class="p">(</span><span class="n">input_arr</span><span class="p">,</span>
<span class="go">                                             0.0, 255.0,</span>
<span class="go">                                             -1.0, 1.0, False)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.intensity.zoom">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.intensity.</span></span><span class="sig-name descname"><span class="pre">zoom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(in Python v3.11)"><span class="pre">Sequence</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.core.operations.intensity.zoom" title="Permalink to this definition">#</a></dt>
<dd><p>Zooms an ND image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">channel first, cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data of shape (C, H, W). Can also batch process input of shape
(N, C, H, W). Can be a numpy.ndarray or cupy.ndarray.</p>
</dd>
<dt><strong>zoom_factor: Sequence[float]</strong></dt><dd><p>The zoom factor along the spatial axes.
Zoom factor should contain one value for each spatial axis.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>&mdash;&mdash;-</strong></dt><dd></dd>
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.intensity</span> <span class="k">as</span> <span class="nn">its</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">its</span><span class="o">.</span><span class="n">zoom</span><span class="p">(</span><span class="n">input_arr</span><span class="p">,[</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.core.operations.morphology">
<span id="morphology"></span><h3>morphology<a class="headerlink" href="#module-cucim.core.operations.morphology" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.morphology.distance_transform_edt">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.morphology.</span></span><span class="sig-name descname"><span class="pre">distance_transform_edt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">float64_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.core.operations.morphology.distance_transform_edt" title="Permalink to this definition">#</a></dt>
<dd><p>Exact Euclidean distance transform.</p>
<p>This function calculates the distance transform of the <cite>input</cite>, by
replacing each foreground (non-zero) element, with its shortest distance to
the background (any zero-valued element).</p>
<p>In addition to the distance transform, the feature transform can be
calculated. In this case the index of the closest background element to
each foreground element is returned in a separate array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array_like</span></dt><dd><p>Input data to transform. Can be any type but will be converted into
binary: 1 wherever image equates to True, 0 elsewhere.</p>
</dd>
<dt><strong>sampling</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension. If a sequence, must be of
length equal to the image rank; if a single number, this is used for
all axes. If not specified, a grid spacing of unity is implied.</p>
</dd>
<dt><strong>return_distances</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to calculate the distance transform.</p>
</dd>
<dt><strong>return_indices</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to calculate the feature transform.</p>
</dd>
<dt><strong>distances</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>An output array to store the calculated distance transform, instead of
returning it. <cite>return_distances</cite> must be <code class="docutils literal notranslate"><span class="pre">True</span></code>. It must be the same
shape as <cite>image</cite>. Should have dtype <code class="docutils literal notranslate"><span class="pre">cp.float32</span></code> if
<cite>float64_distances</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, otherwise it should be
<code class="docutils literal notranslate"><span class="pre">cp.float64</span></code>.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>An output array to store the calculated feature transform, instead of
returning it. <cite>return_indicies</cite> must be <code class="docutils literal notranslate"><span class="pre">True</span></code>. Its shape must be
<code class="docutils literal notranslate"><span class="pre">(image.ndim,)</span> <span class="pre">+</span> <span class="pre">image.shape</span></code>. Its dtype must be a signed or unsigned
integer type of at least 16-bits in 2D or 32-bits in 3D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distances</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The calculated distance transform. Returned only when
<cite>return_distances</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and <cite>distances</cite> is not supplied. It will
have the same shape as <cite>image</cite>. Will have dtype <cite>cp.float64</cite> if
<cite>float64_distances</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, otherwise it will have dtype
<code class="docutils literal notranslate"><span class="pre">cp.float32</span></code>.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The calculated feature transform. It has an image-shaped array for each
dimension of the image. See example below. Returned only when
<cite>return_indices</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and <cite>indices</cite> is not supplied.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>block_params</strong><span class="classifier">3-tuple of int</span></dt><dd><p>The m1, m2, m3 algorithm parameters as described in <a class="reference internal" href="#r8e5c1ce987ff-2" id="id6">[2]</a>. If None,
suitable defaults will be chosen. Note: This parameter is specific to
cuCIM and does not exist in SciPy.</p>
</dd>
<dt><strong>float64_distances</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, use double precision in the distance computation (to match
SciPy behavior). Otherwise, single precision will be used for
efficiency. Note: This parameter is specific to cuCIM and does not
exist in SciPy.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Euclidean distance transform gives values of the Euclidean distance.</p>
<div class="math notranslate nohighlight">
\[y_i = \sqrt{\sum_{i}^{n} (x[i] - b[i])^2}\]</div>
<p>where <span class="math notranslate nohighlight">\(b[i]\)</span> is the background point (value 0) with the smallest
Euclidean distance to input points <span class="math notranslate nohighlight">\(x[i]\)</span>, and <span class="math notranslate nohighlight">\(n\)</span> is the
number of dimensions.</p>
<p>Note that the <cite>indices</cite> output may differ from the one given by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="(in SciPy v1.10.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.ndimage.distance_transform_edt()</span></code></a> in the case of input pixels
that are equidistant from multiple background points.</p>
<p>The parallel banding algorithm implemented here was originally described in
<a class="reference internal" href="#r8e5c1ce987ff-1" id="id7">[1]</a>. The kernels used here correspond to the revised PBA+ implementation
that is described on the author&rsquo;s website <a class="reference internal" href="#r8e5c1ce987ff-2" id="id8">[2]</a>. The source code of the
author&rsquo;s PBA+ implementation is available at <a class="reference internal" href="#r8e5c1ce987ff-3" id="id9">[3]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8e5c1ce987ff-1"><span class="brackets"><a class="fn-backref" href="#id7">1</a></span></dt>
<dd><p>Thanh-Tung Cao, Ke Tang, Anis Mohamed, and Tiow-Seng Tan. 2010.
Parallel Banding Algorithm to compute exact distance transform with the
GPU. In Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive
3D Graphics and Games (I3D &rsquo;10). Association for Computing Machinery,
New York, NY, USA, 83&ndash;90.
DOI:https://doi.org/10.1145/1730804.1730818</p>
</dd>
<dt class="label" id="r8e5c1ce987ff-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id8">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://www.comp.nus.edu.sg/~tants/pba.html">https://www.comp.nus.edu.sg/~tants/pba.html</a></p>
</dd>
<dt class="label" id="r8e5c1ce987ff-3"><span class="brackets"><a class="fn-backref" href="#id9">3</a></span></dt>
<dd><p><a class="github reference external" href="https://github.com/orzzzjq/Parallel-Banding-Algorithm-plus">orzzzjq/Parallel-Banding-Algorithm-plus</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.core.operations</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphology</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],</span>
<span class="go">       [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],</span>
<span class="go">       [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],</span>
<span class="go">       [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],</span>
<span class="go">       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</span>
</pre></div>
</div>
<p>With a sampling of 2 units along x, 1 along y:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">morphology</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],</span>
<span class="go">       [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],</span>
<span class="go">       [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],</span>
<span class="go">       [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],</span>
<span class="go">       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</span>
</pre></div>
</div>
<p>Asking for indices as well:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">edt</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span>
<span class="go">array([[[0, 0, 1, 1, 3],</span>
<span class="go">        [1, 1, 1, 1, 3],</span>
<span class="go">        [2, 2, 1, 3, 3],</span>
<span class="go">        [3, 3, 4, 4, 3],</span>
<span class="go">        [4, 4, 4, 4, 4]],</span>
<span class="go">       [[0, 0, 1, 1, 4],</span>
<span class="go">        [0, 1, 1, 1, 4],</span>
<span class="go">        [0, 0, 1, 4, 4],</span>
<span class="go">        [0, 0, 3, 3, 4],</span>
<span class="go">        [0, 0, 3, 3, 4]]])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.core.operations.spatial">
<span id="spatial"></span><h3>spatial<a class="headerlink" href="#module-cucim.core.operations.spatial" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.spatial.image_flip">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.spatial.</span></span><span class="sig-name descname"><span class="pre">image_flip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">spatial_axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">)</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#cucim.core.operations.spatial.image_flip" title="Permalink to this definition">#</a></dt>
<dd><p>Shape preserving order reversal of elements in input array
along the given spatial axis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data. Can be numpy.ndarray or cupy.ndarray</p>
</dd>
<dt><strong>spatial_axis</strong><span class="classifier">tuple</span></dt><dd><p>spatial axis along which to flip over the input array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.spatial</span> <span class="k">as</span> <span class="nn">spt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">spt</span><span class="o">.</span><span class="n">image_flip</span><span class="p">(</span><span class="n">input_arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.spatial.image_rotate_90">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.spatial.</span></span><span class="sig-name descname"><span class="pre">image_rotate_90</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">spatial_axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">)</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#cucim.core.operations.spatial.image_rotate_90" title="Permalink to this definition">#</a></dt>
<dd><p>Rotate input array by 90 degress along the given axis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data. Can be numpy.ndarray or cupy.ndarray</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>number of times to rotate</p>
</dd>
<dt><strong>spatial_axis</strong><span class="classifier">tuple</span></dt><dd><p>spatial axis along which to rotate the input array by 90 degrees</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.spatial</span> <span class="k">as</span> <span class="nn">spt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">spt</span><span class="o">.</span><span class="n">image_rotate_90</span><span class="p">(</span><span class="n">input_arr</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.spatial.rand_image_flip">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.spatial.</span></span><span class="sig-name descname"><span class="pre">rand_image_flip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">spatial_axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">)</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whole_batch</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#cucim.core.operations.spatial.rand_image_flip" title="Permalink to this definition">#</a></dt>
<dd><p>Randomly flips the image along axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data. Can be numpy.ndarray or cupy.ndarray</p>
</dd>
<dt><strong>prob: Probability of flipping.</strong></dt><dd></dd>
<dt><strong>spatial_axis</strong><span class="classifier">tuple</span></dt><dd><p>spatial axis along which to flip over the input array</p>
</dd>
<dt><strong>whole_batch: Flag to apply transform on whole batch.</strong></dt><dd><p>If False, each image in the batch is randomly transformed
It True, entire batch is transformed randomly.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.spatial</span> <span class="k">as</span> <span class="nn">spt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">spt</span><span class="o">.</span><span class="n">rand_image_flip</span><span class="p">(</span><span class="n">input_arr</span><span class="p">,</span><span class="n">spatial_axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.core.operations.spatial.rand_image_rotate_90">
<span class="sig-prename descclassname"><span class="pre">cucim.core.operations.spatial.</span></span><span class="sig-name descname"><span class="pre">rand_image_rotate_90</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">spatial_axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">)</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whole_batch</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&rarr;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.11)"><span class="pre">Any</span></a></span></span><a class="headerlink" href="#cucim.core.operations.spatial.rand_image_rotate_90" title="Permalink to this definition">#</a></dt>
<dd><p>With probability <cite>prob</cite>, input arrays are rotated by 90 degrees
in the plane specified by <cite>spatial_axis</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>img</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Input data. Can be numpy.ndarray or cupy.ndarray</p>
</dd>
<dt><strong>prob: probability of rotating.</strong></dt><dd><p>(Default 0.1, with 10% probability it returns a rotated array)</p>
</dd>
<dt><strong>max_k: number of rotations</strong></dt><dd><p>will be sampled from <cite>np.random.randint(max_k) + 1</cite>, (Default 3).</p>
</dd>
<dt><strong>spatial_axis</strong><span class="classifier">tuple</span></dt><dd><p>spatial axis along which to rotate the input array by 90 degrees</p>
</dd>
<dt><strong>whole_batch: Flag to apply transform on whole batch.</strong></dt><dd><p>If False, each image in the batch is randomly transformed
It True, entire batch is transformed randomly.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray or numpy.ndarray</span></dt><dd><p>Output data. Same dimensions and type as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If input &lsquo;img&rsquo; is not cupy.ndarray or numpy.ndarray</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cucim.core.operations.spatial</span> <span class="k">as</span> <span class="nn">spt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input is channel first 3d array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_array</span> <span class="o">=</span> <span class="n">spt</span><span class="o">.</span><span class="n">rand_image_rotate_90</span><span class="p">(</span><span class="n">input_arr</span><span class="p">,</span> <span class="n">spatial_axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="skimage-submodules">
<h2>skimage Submodules<a class="headerlink" href="#skimage-submodules" title="Permalink to this heading">#</a></h2>
<section id="id13">
<h3>color<a class="headerlink" href="#id13" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-cucim.skimage.color"></span><dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.combine_stains">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">combine_stains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stains</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_matrix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.combine_stains" title="Permalink to this definition">#</a></dt>
<dd><p>Stain to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stains</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in stain color space. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>conv_matrix: ndarray</strong></dt><dd><p>The stain separation matrix as described by G. Landini <a class="reference internal" href="#rfb03de915426-1" id="id14">[1]</a>.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>stains</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Stain combination matrices available in the <code class="docutils literal notranslate"><span class="pre">color</span></code> module and their
respective colorspace:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_hed</span></code>: Hematoxylin + Eosin + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_hdx</span></code>: Hematoxylin + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_fgx</span></code>: Feulgen + Light Green</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_bex</span></code>: Giemsa stain : Methyl Blue + Eosin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_rbd</span></code>: FastRed + FastBlue +  DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_gdx</span></code>: Methyl Green + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_hax</span></code>: Hematoxylin + AEC</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_bro</span></code>: Blue matrix Anilline Blue + Red matrix Azocarmine                        + Orange matrix Orange-G</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_bpx</span></code>: Methyl Blue + Ponceau Fuchsin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_ahx</span></code>: Alcian Blue + Hematoxylin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_hpx</span></code>: Hematoxylin + PAS</p></li>
</ul>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rfb03de915426-1"><span class="brackets"><a class="fn-backref" href="#id14">1</a></span></dt>
<dd><p><a class="reference external" href="https://web.archive.org/web/20160624145052/http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html">https://web.archive.org/web/20160624145052/http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html</a></p>
</dd>
<dt class="label" id="rfb03de915426-2"><span class="brackets">2</span></dt>
<dd><p>A. C. Ruifrok and D. A. Johnston, &ldquo;Quantification of histochemical
staining by color deconvolution,&rdquo; Anal. Quant. Cytol. Histol., vol.
23, no. 4, pp. 291&ndash;299, Aug. 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="p">(</span><span class="n">separate_stains</span><span class="p">,</span> <span class="n">combine_stains</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">hdx_from_rgb</span><span class="p">,</span> <span class="n">rgb_from_hdx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">immunohistochemistry</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_hdx</span> <span class="o">=</span> <span class="n">separate_stains</span><span class="p">(</span><span class="n">ihc</span><span class="p">,</span> <span class="n">hdx_from_rgb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_rgb</span> <span class="o">=</span> <span class="n">combine_stains</span><span class="p">(</span><span class="n">ihc_hdx</span><span class="p">,</span> <span class="n">rgb_from_hdx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.convert_colorspace">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">convert_colorspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fromspace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tospace</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.convert_colorspace" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image array to a new color space.</p>
<dl class="simple">
<dt>Valid color spaces are:</dt><dd><p>&lsquo;RGB&rsquo;, &lsquo;HSV&rsquo;, &lsquo;RGB CIE&rsquo;, &lsquo;XYZ&rsquo;, &lsquo;YUV&rsquo;, &lsquo;YIQ&rsquo;, &lsquo;YPbPr&rsquo;, &lsquo;YCbCr&rsquo;, &lsquo;YDbDr&rsquo;</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image to convert. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>fromspace</strong><span class="classifier">str</span></dt><dd><p>The color space to convert from. Can be specified in lower case.</p>
</dd>
<dt><strong>tospace</strong><span class="classifier">str</span></dt><dd><p>The color space to convert to. Can be specified in lower case.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The converted image. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If fromspace is not a valid color space</p>
</dd>
<dt>ValueError</dt><dd><p>If tospace is not a valid color space</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Conversion is performed through the &ldquo;central&rdquo; RGB color space,
i.e. conversion from XYZ to HSV is implemented as <code class="docutils literal notranslate"><span class="pre">XYZ</span> <span class="pre">-&gt;</span> <span class="pre">RGB</span> <span class="pre">-&gt;</span> <span class="pre">HSV</span></code>
instead of directly.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_hsv</span> <span class="o">=</span> <span class="n">convert_colorspace</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="s1">'RGB'</span><span class="p">,</span> <span class="s1">'HSV'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.deltaE_cie76">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">deltaE_cie76</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.deltaE_cie76" title="Permalink to this definition">#</a></dt>
<dd><p>Euclidean distance between two points in Lab color space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab1</strong><span class="classifier">array_like</span></dt><dd><p>reference color (Lab colorspace)</p>
</dd>
<dt><strong>lab2</strong><span class="classifier">array_like</span></dt><dd><p>comparison color (Lab colorspace)</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the arrays corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dE</strong><span class="classifier">array_like</span></dt><dd><p>distance between colors <cite>lab1</cite> and <cite>lab2</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r98e40734704d-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Color_difference">https://en.wikipedia.org/wiki/Color_difference</a></p>
</dd>
<dt class="label" id="r98e40734704d-2"><span class="brackets">2</span></dt>
<dd><p>A. R. Robertson, &ldquo;The CIE 1976 color-difference formulae,&rdquo;
Color Res. Appl. 2, 7-11 (1977).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.deltaE_ciede2000">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">deltaE_ciede2000</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kC</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kH</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.deltaE_ciede2000" title="Permalink to this definition">#</a></dt>
<dd><p>Color difference as given by the CIEDE 2000 standard.</p>
<p>CIEDE 2000 is a major revision of CIDE94.  The perceptual calibration is
largely based on experience with automotive paint on smooth surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab1</strong><span class="classifier">array_like</span></dt><dd><p>reference color (Lab colorspace)</p>
</dd>
<dt><strong>lab2</strong><span class="classifier">array_like</span></dt><dd><p>comparison color (Lab colorspace)</p>
</dd>
<dt><strong>kL</strong><span class="classifier">float (range), optional</span></dt><dd><p>lightness scale factor, 1 for &ldquo;acceptably close&rdquo;; 2 for &ldquo;imperceptible&rdquo;
see deltaE_cmc</p>
</dd>
<dt><strong>kC</strong><span class="classifier">float (range), optional</span></dt><dd><p>chroma scale factor, usually 1</p>
</dd>
<dt><strong>kH</strong><span class="classifier">float (range), optional</span></dt><dd><p>hue scale factor, usually 1</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the arrays corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>deltaE</strong><span class="classifier">array_like</span></dt><dd><p>The distance between <cite>lab1</cite> and <cite>lab2</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>CIEDE 2000 assumes parametric weighting factors for the lightness, chroma,
and hue (<cite>kL</cite>, <cite>kC</cite>, <cite>kH</cite> respectively).  These default to 1.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbfde64bae038-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Color_difference">https://en.wikipedia.org/wiki/Color_difference</a></p>
</dd>
<dt class="label" id="rbfde64bae038-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://www.ece.rochester.edu/~gsharma/ciede2000/ciede2000noteCRNA.pdf">http://www.ece.rochester.edu/~gsharma/ciede2000/ciede2000noteCRNA.pdf</a>
<a class="reference external" href="https://doi.org/10.1364/AO.33.008069">DOI:10.1364/AO.33.008069</a></p>
</dd>
<dt class="label" id="rbfde64bae038-3"><span class="brackets">3</span></dt>
<dd><p>M. Melgosa, J. Quesada, and E. Hita, &ldquo;Uniformity of some recent
color metrics tested with an accurate color-difference tolerance
dataset,&rdquo; Appl. Opt. 33, 8069-8077 (1994).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.deltaE_ciede94">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">deltaE_ciede94</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kH</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kC</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.015</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.deltaE_ciede94" title="Permalink to this definition">#</a></dt>
<dd><p>Color difference according to CIEDE 94 standard</p>
<p>Accommodates perceptual non-uniformities through the use of application
specific scale factors (<cite>kH</cite>, <cite>kC</cite>, <cite>kL</cite>, <cite>k1</cite>, and <cite>k2</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab1</strong><span class="classifier">array_like</span></dt><dd><p>reference color (Lab colorspace)</p>
</dd>
<dt><strong>lab2</strong><span class="classifier">array_like</span></dt><dd><p>comparison color (Lab colorspace)</p>
</dd>
<dt><strong>kH</strong><span class="classifier">float, optional</span></dt><dd><p>Hue scale</p>
</dd>
<dt><strong>kC</strong><span class="classifier">float, optional</span></dt><dd><p>Chroma scale</p>
</dd>
<dt><strong>kL</strong><span class="classifier">float, optional</span></dt><dd><p>Lightness scale</p>
</dd>
<dt><strong>k1</strong><span class="classifier">float, optional</span></dt><dd><p>first scale parameter</p>
</dd>
<dt><strong>k2</strong><span class="classifier">float, optional</span></dt><dd><p>second scale parameter</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the arrays corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dE</strong><span class="classifier">array_like</span></dt><dd><p>color difference between <cite>lab1</cite> and <cite>lab2</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>deltaE_ciede94 is not symmetric with respect to lab1 and lab2.  CIEDE94
defines the scales for the lightness, hue, and chroma in terms of the first
color.  Consequently, the first color should be regarded as the &ldquo;reference&rdquo;
color.</p>
<p><cite>kL</cite>, <cite>k1</cite>, <cite>k2</cite> depend on the application and default to the values
suggested for graphic arts</p>
<table class="table">
<colgroup>
<col style="width: 29%">
<col style="width: 41%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Graphic Arts</p></th>
<th class="head"><p>Textiles</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>kL</cite></p></td>
<td><p>1.000</p></td>
<td><p>2.000</p></td>
</tr>
<tr class="row-odd"><td><p><cite>k1</cite></p></td>
<td><p>0.045</p></td>
<td><p>0.048</p></td>
</tr>
<tr class="row-even"><td><p><cite>k2</cite></p></td>
<td><p>0.015</p></td>
<td><p>0.014</p></td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rabb6f51f8faf-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Color_difference">https://en.wikipedia.org/wiki/Color_difference</a></p>
</dd>
<dt class="label" id="rabb6f51f8faf-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html">http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.deltaE_cmc">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">deltaE_cmc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kC</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.deltaE_cmc" title="Permalink to this definition">#</a></dt>
<dd><p>Color difference from the  CMC l:c standard.</p>
<p>This color difference was developed by the Colour Measurement Committee
(CMC) of the Society of Dyers and Colourists (United Kingdom). It is
intended for use in the textile industry.</p>
<p>The scale factors <cite>kL</cite>, <cite>kC</cite> set the weight given to differences in
lightness and chroma relative to differences in hue.  The usual values are
<code class="docutils literal notranslate"><span class="pre">kL=2</span></code>, <code class="docutils literal notranslate"><span class="pre">kC=1</span></code> for &ldquo;acceptability&rdquo; and <code class="docutils literal notranslate"><span class="pre">kL=1</span></code>, <code class="docutils literal notranslate"><span class="pre">kC=1</span></code> for
&ldquo;imperceptibility&rdquo;.  Colors with <code class="docutils literal notranslate"><span class="pre">dE</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> are &ldquo;different&rdquo; for the given
scale factors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab1</strong><span class="classifier">array_like</span></dt><dd><p>reference color (Lab colorspace)</p>
</dd>
<dt><strong>lab2</strong><span class="classifier">array_like</span></dt><dd><p>comparison color (Lab colorspace)</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the arrays corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dE</strong><span class="classifier">array_like</span></dt><dd><p>distance between colors <cite>lab1</cite> and <cite>lab2</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>deltaE_cmc the defines the scales for the lightness, hue, and chroma
in terms of the first color.  Consequently
<code class="docutils literal notranslate"><span class="pre">deltaE_cmc(lab1,</span> <span class="pre">lab2)</span> <span class="pre">!=</span> <span class="pre">deltaE_cmc(lab2,</span> <span class="pre">lab1)</span></code></p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r67a10bd0d57d-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Color_difference">https://en.wikipedia.org/wiki/Color_difference</a></p>
</dd>
<dt class="label" id="r67a10bd0d57d-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html">http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html</a></p>
</dd>
<dt class="label" id="r67a10bd0d57d-3"><span class="brackets">3</span></dt>
<dd><p>F. J. J. Clarke, R. McDonald, and B. Rigg, &ldquo;Modification to the
JPC79 colour-difference formula,&rdquo; J. Soc. Dyers Colour. 100, 128-132
(1984).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.gray2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">gray2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.gray2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>Create an RGB representation of a gray-level image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array_like</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the output array will correspond
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>RGB image. A new dimension of length 3 is added to input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the input is a 1-dimensional image of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">)</span></code>, the output
will be shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">3)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.gray2rgba">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">gray2rgba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.gray2rgba" title="Permalink to this definition">#</a></dt>
<dd><p>Create a RGBA representation of a gray-level image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array_like</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">array_like, optional</span></dt><dd><p>Alpha channel of the output image. It may be a scalar or an
array that can be broadcast to <code class="docutils literal notranslate"><span class="pre">image</span></code>. If not specified it is
set to the maximum limit corresponding to the <code class="docutils literal notranslate"><span class="pre">image</span></code> dtype.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the output array will correspond
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rgba</strong><span class="classifier">ndarray</span></dt><dd><p>RGBA image. A new dimension of length 4 is added to input
image shape.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.hed2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">hed2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hed</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.hed2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>Haematoxylin-Eosin-DAB (HED) to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hed</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in the HED color space. By default, the final dimension
denotes channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>hed</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rdaa655cd9550-1"><span class="brackets">1</span></dt>
<dd><p>A. C. Ruifrok and D. A. Johnston, &ldquo;Quantification of histochemical
staining by color deconvolution.,&rdquo; Analytical and quantitative
cytology and histology / the International Academy of Cytology [and]
American Society of Cytology, vol. 23, no. 4, pp. 291-9, Aug. 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2hed</span><span class="p">,</span> <span class="n">hed2rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">immunohistochemistry</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_hed</span> <span class="o">=</span> <span class="n">rgb2hed</span><span class="p">(</span><span class="n">ihc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_rgb</span> <span class="o">=</span> <span class="n">hed2rgb</span><span class="p">(</span><span class="n">ihc_hed</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.hsv2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">hsv2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hsv</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.hsv2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>HSV to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hsv</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in HSV format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>hsv</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Conversion between RGB and HSV color spaces results in some loss of
precision, due to integer arithmetic and rounding <a class="reference internal" href="#r9b32ad9e2308-1" id="id28">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9b32ad9e2308-1"><span class="brackets"><a class="fn-backref" href="#id28">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">https://en.wikipedia.org/wiki/HSL_and_HSV</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_hsv</span> <span class="o">=</span> <span class="n">rgb2hsv</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgb</span> <span class="o">=</span> <span class="n">hsv2rgb</span><span class="p">(</span><span class="n">img_hsv</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.lab2lch">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">lab2lch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.lab2lch" title="Permalink to this definition">#</a></dt>
<dd><p>CIE-LAB to CIE-LCH color space conversion.</p>
<p>LCH is the cylindrical representation of the LAB (Cartesian) colorspace</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The N-D image in CIE-LAB format. The last (<code class="docutils literal notranslate"><span class="pre">N+1</span></code>-th) dimension must
have at least 3 elements, corresponding to the <code class="docutils literal notranslate"><span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code>, and <code class="docutils literal notranslate"><span class="pre">b</span></code>
color channels. Subsequent elements are copied.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in LCH format, in a N-D array with same shape as input <cite>lab</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>lch</cite> does not have at least 3 color channels (i.e. l, a, b).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Hue is expressed as an angle between <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">2*pi)</span></code></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2lab</span><span class="p">,</span> <span class="n">lab2lch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lab</span> <span class="o">=</span> <span class="n">rgb2lab</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lch</span> <span class="o">=</span> <span class="n">lab2lch</span><span class="p">(</span><span class="n">img_lab</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.lab2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">lab2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.lab2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>Convert image in CIE-LAB to sRGB color space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The input image in CIE-LAB color space.
Unless <cite>channel_axis</cite> is set, the final dimension denotes the CIE-LAB
channels.
The L* values range from 0 to 100;
the a* and b* values range from -128 to 127.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;, &ldquo;R&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>lab</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses lab2xyz and xyz2rgb.
The CIE XYZ tristimulus values are x_ref = 95.047, y_ref = 100., and
z_ref = 108.883. See function <code class="xref py py-func docutils literal notranslate"><span class="pre">get_xyz_coords()</span></code> for a list of
supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4748a0929677-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Standard_illuminant">https://en.wikipedia.org/wiki/Standard_illuminant</a></p>
</dd>
<dt class="label" id="r4748a0929677-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIELAB_color_space">https://en.wikipedia.org/wiki/CIELAB_color_space</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.lab2xyz">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">lab2xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.lab2xyz" title="Permalink to this definition">#</a></dt>
<dd><p>Convert image in CIE-LAB to XYZ color space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The input image in CIE-LAB color space.
Unless <cite>channel_axis</cite> is set, the final dimension denotes the CIE-LAB
channels.
The L* values range from 0 to 100;
the a* and b* values range from -128 to 127.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;, &ldquo;R&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in XYZ color space. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>lab</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
<dt>ValueError</dt><dd><p>If either the illuminant or the observer angle are not supported or
unknown.</p>
</dd>
<dt>UserWarning</dt><dd><p>If any of the pixels are invalid (Z &lt; 0).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The CIE XYZ tristimulus values are x_ref = 95.047, y_ref = 100., and
z_ref = 108.883. See function <code class="xref py py-func docutils literal notranslate"><span class="pre">get_xyz_coords()</span></code> for a list of
supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r06a92c61e103-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=07">http://www.easyrgb.com/index.php?X=MATH&amp;H=07</a></p>
</dd>
<dt class="label" id="r06a92c61e103-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIELAB_color_space">https://en.wikipedia.org/wiki/CIELAB_color_space</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.label2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">label2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'overlay'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.label2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>Return an RGB image where color-coded labels are painted over the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">ndarray</span></dt><dd><p>Integer array of labels with the same shape as <cite>image</cite>.</p>
</dd>
<dt><strong>image</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Image used as underlay for labels. It should have the same shape as
<cite>labels</cite>, optionally with an additional RGB (channels) axis. If <cite>image</cite>
is an RGB image, it is converted to grayscale before coloring.</p>
</dd>
<dt><strong>colors</strong><span class="classifier">list, optional</span></dt><dd><p>List of colors. If the number of labels exceeds the number of colors,
then the colors are cycled.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float [0, 1], optional</span></dt><dd><p>Opacity of colorized labels. Ignored if image is <cite>None</cite>.</p>
</dd>
<dt><strong>bg_label</strong><span class="classifier">int, optional</span></dt><dd><p>Label that&rsquo;s treated as the background. If <cite>bg_label</cite> is specified,
<cite>bg_color</cite> is <cite>None</cite>, and <cite>kind</cite> is <cite>overlay</cite>,
background is not painted by any colors.</p>
</dd>
<dt><strong>bg_color</strong><span class="classifier">str or array, optional</span></dt><dd><p>Background color. Must be a name in <cite>color_dict</cite> or RGB float values
between [0, 1].</p>
</dd>
<dt><strong>image_alpha</strong><span class="classifier">float [0, 1], optional</span></dt><dd><p>Opacity of the image.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">string, one of {&lsquo;overlay&rsquo;, &lsquo;avg&rsquo;}</span></dt><dd><p>The kind of color image desired. &lsquo;overlay&rsquo; cycles over defined colors
and overlays the colored labels over the original image. &lsquo;avg&rsquo; replaces
each labeled segment with its average color, for a stained-class or
pastel painting appearance.</p>
</dd>
<dt><strong>saturation</strong><span class="classifier">float [0, 1], optional</span></dt><dd><p>Parameter to control the saturation applied to the original image
between fully saturated (original RGB, <cite>saturation=1</cite>) and fully
unsaturated (grayscale, <cite>saturation=0</cite>). Only applies when
<cite>kind=&rsquo;overlay&rsquo;</cite>.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the output array will correspond
to channels. If <cite>image</cite> is provided, this must also match the axis of
<cite>image</cite> that corresponds to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">array of float, shape (M, N, 3)</span></dt><dd><p>The result of blending a cycling colormap (<cite>colors</cite>) for each distinct
value in <cite>label</cite> with the image, at a certain alpha value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.lch2lab">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">lch2lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lch</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.lch2lab" title="Permalink to this definition">#</a></dt>
<dd><p>CIE-LCH to CIE-LAB color space conversion.</p>
<p>LCH is the cylindrical representation of the LAB (Cartesian) colorspace</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lch</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The N-D image in CIE-LCH format. The last (<code class="docutils literal notranslate"><span class="pre">N+1</span></code>-th) dimension must
have at least 3 elements, corresponding to the <code class="docutils literal notranslate"><span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code>, and <code class="docutils literal notranslate"><span class="pre">b</span></code>
color channels.  Subsequent elements are copied.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in LAB format, with same shape as input <cite>lch</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>lch</cite> does not have at least 3 color channels (i.e. l, c, h).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2lab</span><span class="p">,</span> <span class="n">lch2lab</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lab</span> <span class="o">=</span> <span class="n">rgb2lab</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lch</span> <span class="o">=</span> <span class="n">lab2lch</span><span class="p">(</span><span class="n">img_lab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lab2</span> <span class="o">=</span> <span class="n">lch2lab</span><span class="p">(</span><span class="n">img_lch</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.luv2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">luv2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">luv</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.luv2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>Luv to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>luv</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in CIE Luv format. By default, the final dimension denotes
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>luv</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses luv2xyz and xyz2rgb.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.luv2xyz">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">luv2xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">luv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.luv2xyz" title="Permalink to this definition">#</a></dt>
<dd><p>CIE-Luv to XYZ color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>luv</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in CIE-Luv format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;, &ldquo;R&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in XYZ format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>luv</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
<dt>ValueError</dt><dd><p>If either the illuminant or the observer angle are not supported or
unknown.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>XYZ conversion weights use observer=2A. Reference whitepoint for D65
Illuminant, with XYZ tristimulus values of <code class="docutils literal notranslate"><span class="pre">(95.047,</span> <span class="pre">100.,</span> <span class="pre">108.883)</span></code>. See
function &lsquo;get_xyz_coords&rsquo; for a list of supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf6e473b85d39-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16">http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16</a></p>
</dd>
<dt class="label" id="rf6e473b85d39-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIELUV">https://en.wikipedia.org/wiki/CIELUV</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2gray">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2gray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2gray" title="Permalink to this definition">#</a></dt>
<dd><p>Compute luminance of an RGB image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The luminance image - an array which is the same size as the input
array, but with the channel dimension removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The weights used in this conversion are calibrated for contemporary
CRT phosphors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">=</span> <span class="mf">0.2125</span> <span class="n">R</span> <span class="o">+</span> <span class="mf">0.7154</span> <span class="n">G</span> <span class="o">+</span> <span class="mf">0.0721</span> <span class="n">B</span>
</pre></div>
</div>
<p>If there is an alpha channel present, it is ignored.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7deaec9cd8c6-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://poynton.ca/PDFs/ColorFAQ.pdf">http://poynton.ca/PDFs/ColorFAQ.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2gray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_gray</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2hed">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2hed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2hed" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to Haematoxylin-Eosin-DAB (HED) color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in HED format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd1ab26ad5612-1"><span class="brackets">1</span></dt>
<dd><p>A. C. Ruifrok and D. A. Johnston, &ldquo;Quantification of histochemical
staining by color deconvolution.,&rdquo; Analytical and quantitative
cytology and histology / the International Academy of Cytology [and]
American Society of Cytology, vol. 23, no. 4, pp. 291-9, Aug. 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2hed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">immunohistochemistry</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_hed</span> <span class="o">=</span> <span class="n">rgb2hed</span><span class="p">(</span><span class="n">ihc</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2hsv">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2hsv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2hsv" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to HSV color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in HSV format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Conversion between RGB and HSV color spaces results in some loss of
precision, due to integer arithmetic and rounding <a class="reference internal" href="#r67d3a639daac-1" id="id38">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r67d3a639daac-1"><span class="brackets"><a class="fn-backref" href="#id38">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">https://en.wikipedia.org/wiki/HSL_and_HSV</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_hsv</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2hsv</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2lab">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2lab" title="Permalink to this definition">#</a></dt>
<dd><p>Conversion from the sRGB color space (IEC 61966-2-1:1999)
to the CIE Lab colorspace under the given illuminant and observer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;, &ldquo;R&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in Lab format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>RGB is a device-dependent color space so, if you use this function, be
sure that the image you are analyzing has been mapped to the sRGB color
space.</p>
<p>This function uses rgb2xyz and xyz2lab.
By default Observer=&rdquo;2&rdquo;, Illuminant=&rdquo;D65&rdquo;. CIE XYZ tristimulus values
x_ref=95.047, y_ref=100., z_ref=108.883. See function <cite>get_xyz_coords</cite> for
a list of supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc0871f9b8d8e-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Standard_illuminant">https://en.wikipedia.org/wiki/Standard_illuminant</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2luv">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2luv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2luv" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to CIE-Luv color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in CIE Luv format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses rgb2xyz and xyz2luv.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7f191d586ee8-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16">http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16</a></p>
</dd>
<dt class="label" id="r7f191d586ee8-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=02#text2">http://www.easyrgb.com/index.php?X=MATH&amp;H=02#text2</a></p>
</dd>
<dt class="label" id="r7f191d586ee8-3"><span class="brackets">3</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIELUV">https://en.wikipedia.org/wiki/CIELUV</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2rgbcie">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2rgbcie</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2rgbcie" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to RGB CIE color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB CIE format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb91e96098763-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2rgbcie</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgbcie</span> <span class="o">=</span> <span class="n">rgb2rgbcie</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2xyz">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2xyz" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to XYZ color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in XYZ format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The CIE XYZ color space is derived from the CIE RGB color space. Note
however that this function converts from sRGB.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd54030807848-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_xyz</span> <span class="o">=</span> <span class="n">rgb2xyz</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2ycbcr">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2ycbcr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2ycbcr" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to YCbCr color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in YCbCr format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Y is between 16 and 235. This is the color space commonly used by video
codecs; it is sometimes incorrectly called &ldquo;YUV&rdquo;.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1072114a30cf-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YCbCr">https://en.wikipedia.org/wiki/YCbCr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2ydbdr">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2ydbdr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2ydbdr" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to YDbDr color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in YDbDr format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is the color space commonly used by video codecs. It is also the
reversible color transform in JPEG2000.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r58826d6bd44c-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YDbDr">https://en.wikipedia.org/wiki/YDbDr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2yiq">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2yiq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2yiq" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to YIQ color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in YIQ format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2ypbpr">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2ypbpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2ypbpr" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to YPbPr color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in YPbPr format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r89d5df5bad40-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YPbPr">https://en.wikipedia.org/wiki/YPbPr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2yuv">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2yuv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2yuv" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to YUV color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in YUV format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Y is between 0 and 1.  Use YCbCr instead of YUV for the color space
commonly used by video codecs, where Y ranges from 16 to 235.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4cf337b1a585-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YUV">https://en.wikipedia.org/wiki/YUV</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgba2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgba2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgba</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgba2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>RGBA to RGB conversion using alpha blending <a class="reference internal" href="#r06de24b6b99b-1" id="id50">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgba</strong><span class="classifier">(&hellip;, 4, &hellip;) array_like</span></dt><dd><p>The image in RGBA format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>background</strong><span class="classifier">array_like</span></dt><dd><p>The color of the background to blend the image with (3 floats
between 0 to 1 - the RGB value of the background).</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgba</cite> is not at least 2D with shape (&hellip;, 4, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r06de24b6b99b-1"><span class="brackets"><a class="fn-backref" href="#id50">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgba</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">logo</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgb</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgba2rgb</span><span class="p">(</span><span class="n">img_rgba</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgbcie2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgbcie2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgbcie</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgbcie2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>RGB CIE to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgbcie</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB CIE format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgbcie</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="radd4167d6800-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2rgbcie</span><span class="p">,</span> <span class="n">rgbcie2rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgbcie</span> <span class="o">=</span> <span class="n">rgb2rgbcie</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgb</span> <span class="o">=</span> <span class="n">rgbcie2rgb</span><span class="p">(</span><span class="n">img_rgbcie</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.separate_stains">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">separate_stains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_matrix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.separate_stains" title="Permalink to this definition">#</a></dt>
<dd><p>RGB to stain color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in RGB format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>conv_matrix: ndarray</strong></dt><dd><p>The stain separation matrix as described by G. Landini <a class="reference internal" href="#rc537717e7931-1" id="id53">[1]</a>.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in stain color space. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Stain separation matrices available in the <code class="docutils literal notranslate"><span class="pre">color</span></code> module and their
respective colorspace:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hed_from_rgb</span></code>: Hematoxylin + Eosin + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hdx_from_rgb</span></code>: Hematoxylin + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fgx_from_rgb</span></code>: Feulgen + Light Green</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bex_from_rgb</span></code>: Giemsa stain : Methyl Blue + Eosin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rbd_from_rgb</span></code>: FastRed + FastBlue +  DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gdx_from_rgb</span></code>: Methyl Green + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hax_from_rgb</span></code>: Hematoxylin + AEC</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bro_from_rgb</span></code>: Blue matrix Anilline Blue + Red matrix Azocarmine                        + Orange matrix Orange-G</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bpx_from_rgb</span></code>: Methyl Blue + Ponceau Fuchsin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ahx_from_rgb</span></code>: Alcian Blue + Hematoxylin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hpx_from_rgb</span></code>: Hematoxylin + PAS</p></li>
</ul>
<p>This implementation borrows some ideas from DIPlib <a class="reference internal" href="#rc537717e7931-2" id="id54">[2]</a>, e.g. the
compensation using a small value to avoid log artifacts when
calculating the Beer-Lambert law.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc537717e7931-1"><span class="brackets"><a class="fn-backref" href="#id53">1</a></span></dt>
<dd><p><a class="reference external" href="https://web.archive.org/web/20160624145052/http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html">https://web.archive.org/web/20160624145052/http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html</a></p>
</dd>
<dt class="label" id="rc537717e7931-2"><span class="brackets"><a class="fn-backref" href="#id54">2</a></span></dt>
<dd><p><a class="github reference external" href="https://github.com/DIPlib/diplib/">DIPlib/diplib</a></p>
</dd>
<dt class="label" id="rc537717e7931-3"><span class="brackets">3</span></dt>
<dd><p>A. C. Ruifrok and D. A. Johnston, &ldquo;Quantification of histochemical
staining by color deconvolution,&rdquo; Anal. Quant. Cytol. Histol., vol.
23, no. 4, pp. 291&ndash;299, Aug. 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">separate_stains</span><span class="p">,</span> <span class="n">hdx_from_rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">immunohistochemistry</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_hdx</span> <span class="o">=</span> <span class="n">separate_stains</span><span class="p">(</span><span class="n">ihc</span><span class="p">,</span> <span class="n">hdx_from_rgb</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.xyz2lab">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">xyz2lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.xyz2lab" title="Permalink to this definition">#</a></dt>
<dd><p>XYZ to CIE-LAB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in XYZ format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;, &ldquo;R&rdquo;}, optional</span></dt><dd><p>One of: 2-degree observer, 10-degree observer, or &lsquo;R&rsquo; observer as in
R function grDevices::convertColor.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in CIE-LAB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>xyz</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
<dt>ValueError</dt><dd><p>If either the illuminant or the observer angle is unsupported or
unknown.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>By default Observer=&rdquo;2&rdquo;, Illuminant=&rdquo;D65&rdquo;. CIE XYZ tristimulus values
x_ref=95.047, y_ref=100., z_ref=108.883. See function <cite>get_xyz_coords</cite> for
a list of supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r712a707c3b18-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=07">http://www.easyrgb.com/index.php?X=MATH&amp;H=07</a></p>
</dd>
<dt class="label" id="r712a707c3b18-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Lab_color_space">https://en.wikipedia.org/wiki/Lab_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2xyz</span><span class="p">,</span> <span class="n">xyz2lab</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_xyz</span> <span class="o">=</span> <span class="n">rgb2xyz</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lab</span> <span class="o">=</span> <span class="n">xyz2lab</span><span class="p">(</span><span class="n">img_xyz</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.xyz2luv">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">xyz2luv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.xyz2luv" title="Permalink to this definition">#</a></dt>
<dd><p>XYZ to CIE-Luv color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in XYZ format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;C&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;, &ldquo;R&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in CIE-Luv format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>xyz</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
<dt>ValueError</dt><dd><p>If either the illuminant or the observer angle are not supported or
unknown.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>By default XYZ conversion weights use observer=2A. Reference whitepoint
for D65 Illuminant, with XYZ tristimulus values of <code class="docutils literal notranslate"><span class="pre">(95.047,</span> <span class="pre">100.,</span>
<span class="pre">108.883)</span></code>. See function &lsquo;get_xyz_coords&rsquo; for a list of supported
illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r48d81901c134-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16">http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16</a></p>
</dd>
<dt class="label" id="r48d81901c134-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIELUV">https://en.wikipedia.org/wiki/CIELUV</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2xyz</span><span class="p">,</span> <span class="n">xyz2luv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_xyz</span> <span class="o">=</span> <span class="n">rgb2xyz</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_luv</span> <span class="o">=</span> <span class="n">xyz2luv</span><span class="p">(</span><span class="n">img_xyz</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.xyz2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">xyz2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.xyz2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>XYZ to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in XYZ format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>xyz</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The CIE XYZ color space is derived from the CIE RGB color space. Note
however that this function converts to sRGB.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb72411d50c27-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2xyz</span><span class="p">,</span> <span class="n">xyz2rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_xyz</span> <span class="o">=</span> <span class="n">rgb2xyz</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgb</span> <span class="o">=</span> <span class="n">xyz2rgb</span><span class="p">(</span><span class="n">img_xyz</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.ycbcr2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">ycbcr2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ycbcr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.ycbcr2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>YCbCr to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ycbcr</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in YCbCr format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>ycbcr</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Y is between 16 and 235. This is the color space commonly used by video
codecs; it is sometimes incorrectly called &ldquo;YUV&rdquo;.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r6327037fe147-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YCbCr">https://en.wikipedia.org/wiki/YCbCr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.ydbdr2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">ydbdr2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ydbdr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.ydbdr2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>YDbDr to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ydbdr</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in YDbDr format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>ydbdr</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is the color space commonly used by video codecs, also called the
reversible color transform in JPEG2000.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r480b557ed432-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YDbDr">https://en.wikipedia.org/wiki/YDbDr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.yiq2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">yiq2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yiq</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.yiq2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>YIQ to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>yiq</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in YIQ format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>yiq</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.ypbpr2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">ypbpr2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ypbpr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.ypbpr2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>YPbPr to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ypbpr</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in YPbPr format. By default, the final dimension denotes
channels.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>This parameter indicates which axis of the array corresponds to
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>ypbpr</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1e0c80545ecc-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YPbPr">https://en.wikipedia.org/wiki/YPbPr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.yuv2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">yuv2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yuv</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.yuv2rgb" title="Permalink to this definition">#</a></dt>
<dd><p>YUV to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>yuv</strong><span class="classifier">(&hellip;, 3, &hellip;) array_like</span></dt><dd><p>The image in YUV format. By default, the final dimension denotes
channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3, &hellip;) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>yuv</cite> is not at least 2-D with shape (&hellip;, 3, &hellip;).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1f43f16bb221-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YUV">https://en.wikipedia.org/wiki/YUV</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.skimage.data">
<span id="data"></span><h3>data<a class="headerlink" href="#module-cucim.skimage.data" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.data.binary_blobs">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.data.</span></span><span class="sig-name descname"><span class="pre">binary_blobs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blob_size_fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volume_fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.data.binary_blobs" title="Permalink to this definition">#</a></dt>
<dd><p>Generate synthetic binary image with several rounded blob-like objects.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Linear size of output image.</p>
</dd>
<dt><strong>blob_size_fraction</strong><span class="classifier">float, optional</span></dt><dd><p>Typical linear size of blob, as a fraction of <code class="docutils literal notranslate"><span class="pre">length</span></code>, should be
smaller than 1.</p>
</dd>
<dt><strong>n_dim</strong><span class="classifier">int, optional</span></dt><dd><p>Number of dimensions of output image.</p>
</dd>
<dt><strong>volume_fraction</strong><span class="classifier">float, default 0.5</span></dt><dd><p>Fraction of image pixels covered by the blobs (where the output is 1).
Should be in [0, 1].</p>
</dd>
<dt><strong>seed</strong><span class="classifier">{None, int, <cite>cupy.random.Generator</cite>}, optional</span></dt><dd><p>If <cite>seed</cite> is None the <cite>cupy.random.Generator</cite> singleton is used.
If <cite>seed</cite> is an int, a new <code class="docutils literal notranslate"><span class="pre">Generator</span></code> instance is used,
seeded with <cite>seed</cite>.
If <cite>seed</cite> is already a <code class="docutils literal notranslate"><span class="pre">Generator</span></code> instance then that instance is
used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>blobs</strong><span class="classifier">ndarray of bools</span></dt><dd><p>Output binary image</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Warning: CuPy does not give identical randomly generated numbers as NumPy,
so using a specific seed here will not give an identical pattern to the
scikit-image implementation.</p>
<p>The behavior for a given random seed may also change across CuPy major
versions.
See: <a class="reference external" href="https://docs.cupy.dev/en/stable/reference/random.html">https://docs.cupy.dev/en/stable/reference/random.html</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># tiny size (5, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blobs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">binary_blobs</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">blob_size_fraction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># larger size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blobs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">binary_blobs</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">blob_size_fraction</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Finer structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blobs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">binary_blobs</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">blob_size_fraction</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Blobs cover a smaller volume fraction of the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blobs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">binary_blobs</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">volume_fraction</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.exposure">
<span id="exposure"></span><h3>exposure<a class="headerlink" href="#module-cucim.skimage.exposure" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.adjust_gamma">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">adjust_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.adjust_gamma" title="Permalink to this definition">#</a></dt>
<dd><p>Performs Gamma Correction on the input image.</p>
<p>Also known as Power Law Transform.
This function transforms the input image pixelwise according to the
equation <code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">=</span> <span class="pre">I**gamma</span></code> after scaling each pixel to the range 0 to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float, optional</span></dt><dd><p>Non negative real number. Default value is 1.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">float, optional</span></dt><dd><p>The constant multiplier. Default value is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Gamma corrected output image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.adjust_log" title="cucim.skimage.exposure.adjust_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjust_log</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For gamma greater than 1, the histogram will shift towards left and
the output image will be darker than the input image.</p>
<p>For gamma less than 1, the histogram will shift towards right and
the output image will be brighter than the input image.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b2d42bd838c-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_correction">https://en.wikipedia.org/wiki/Gamma_correction</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">moon</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gamma_corrected</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">adjust_gamma</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Output is darker for gamma &gt; 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">gamma_corrected</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">array(True)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.adjust_log">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">adjust_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.adjust_log" title="Permalink to this definition">#</a></dt>
<dd><p>Performs Logarithmic correction on the input image.</p>
<p>This function transforms the input image pixelwise according to the
equation <code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">=</span> <span class="pre">gain*log(1</span> <span class="pre">+</span> <span class="pre">I)</span></code> after scaling each pixel to the range
0 to 1.</p>
<p>For inverse logarithmic correction, the equation is
<code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">=</span> <span class="pre">gain*(2**I</span> <span class="pre">-</span> <span class="pre">1)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">float, optional</span></dt><dd><p>The constant multiplier. Default value is 1.</p>
</dd>
<dt><strong>inv</strong><span class="classifier">float, optional</span></dt><dd><p>If True, it performs inverse logarithmic correction,
else correction will be logarithmic. Defaults to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Logarithm corrected output image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.adjust_gamma" title="cucim.skimage.exposure.adjust_gamma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjust_gamma</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7be5bc73818c-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.ece.ucsb.edu/Faculty/Manjunath/courses/ece178W03/EnhancePart1.pdf">http://www.ece.ucsb.edu/Faculty/Manjunath/courses/ece178W03/EnhancePart1.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.adjust_sigmoid">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">adjust_sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.adjust_sigmoid" title="Permalink to this definition">#</a></dt>
<dd><p>Performs Sigmoid Correction on the input image.</p>
<p>Also known as Contrast Adjustment.
This function transforms the input image pixelwise according to the
equation <code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">=</span> <span class="pre">1/(1</span> <span class="pre">+</span> <span class="pre">exp*(gain*(cutoff</span> <span class="pre">-</span> <span class="pre">I)))</span></code> after scaling each pixel
to the range 0 to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float, optional</span></dt><dd><p>Cutoff of the sigmoid function that shifts the characteristic curve
in horizontal direction. Default value is 0.5.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">float, optional</span></dt><dd><p>The constant multiplier in exponential&rsquo;s power of sigmoid function.
Default value is 10.</p>
</dd>
<dt><strong>inv</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, returns the negative sigmoid correction. Defaults to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Sigmoid corrected output image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.adjust_gamma" title="cucim.skimage.exposure.adjust_gamma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjust_gamma</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0311c63269be-1"><span class="brackets">1</span></dt>
<dd><p>Gustav J. Braun, &ldquo;Image Lightness Rescaling Using Sigmoidal Contrast
Enhancement Functions&rdquo;,
<a class="reference external" href="http://markfairchild.org/PDFs/PAP07.pdf">http://markfairchild.org/PDFs/PAP07.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.cumulative_distribution">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">cumulative_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.cumulative_distribution" title="Permalink to this definition">#</a></dt>
<dd><p>Return cumulative distribution function (cdf) for the given image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins for image histogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>img_cdf</strong><span class="classifier">array</span></dt><dd><p>Values of cumulative distribution function.</p>
</dd>
<dt><strong>bin_centers</strong><span class="classifier">array</span></dt><dd><p>Centers of bins.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.histogram" title="cucim.skimage.exposure.histogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histogram</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r413c110ae5c3-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">https://en.wikipedia.org/wiki/Cumulative_distribution_function</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdf</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">cumulative_distribution</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">alltrue</span><span class="p">(</span><span class="n">cdf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
<span class="go">array(True)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.equalize_adapthist">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">equalize_adapthist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.equalize_adapthist" title="Permalink to this definition">#</a></dt>
<dd><p>Contrast Limited Adaptive Histogram Equalization (CLAHE).</p>
<p>An algorithm for local contrast enhancement, that uses histograms computed
over different tile regions of the image. Local details can therefore be
enhanced even in regions that are darker or lighter than most of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N1, &hellip;,NN[, C]) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>kernel_size</strong><span class="classifier">int or array_like, optional</span></dt><dd><p>Defines the shape of contextual regions used in the algorithm. If
iterable is passed, it must have the same number of elements as
<code class="docutils literal notranslate"><span class="pre">image.ndim</span></code> (without color channel). If integer, it is broadcasted
to each <cite>image</cite> dimension. By default, <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code> is 1/8 of
<code class="docutils literal notranslate"><span class="pre">image</span></code> height by 1/8 of its width.</p>
</dd>
<dt><strong>clip_limit</strong><span class="classifier">float, optional</span></dt><dd><p>Clipping limit, normalized between 0 and 1 (higher values give more
contrast).</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of gray bins for histogram (&ldquo;data range&rdquo;).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N1, &hellip;,NN[, C]) ndarray</span></dt><dd><p>Equalized image with float64 dtype.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.equalize_hist" title="cucim.skimage.exposure.equalize_hist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equalize_hist</span></code></a>, <a class="reference internal" href="#cucim.skimage.exposure.rescale_intensity" title="cucim.skimage.exposure.rescale_intensity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rescale_intensity</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>For color images, the following steps are performed:</dt><dd><ul>
<li><p>The image is converted to HSV color space</p></li>
<li><p>The CLAHE algorithm is run on the V (Value) channel</p></li>
<li><p>The image is converted back to RGB space and returned</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>For RGBA images, the original alpha channel is removed.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.17: </span>The values returned by this function are slightly shifted upwards
because of an internal change in rounding behavior.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re69247a61663-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://tog.acm.org/resources/GraphicsGems/">http://tog.acm.org/resources/GraphicsGems/</a></p>
</dd>
<dt class="label" id="re69247a61663-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CLAHE#CLAHE">https://en.wikipedia.org/wiki/CLAHE#CLAHE</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.equalize_hist">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">equalize_hist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.equalize_hist" title="Permalink to this definition">#</a></dt>
<dd><p>Return image after histogram equalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins for image histogram. Note: this argument is
ignored for integer images, for which each integer is its own
bin.</p>
</dd>
<dt><strong>mask: ndarray of bools or 0s and 1s, optional</strong></dt><dd><p>Array of same shape as <cite>image</cite>. Only points at which mask == True
are used for the equalization, which is applied to the whole image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">float array</span></dt><dd><p>Image array after histogram equalization.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is adapted from <a class="reference internal" href="#r0b3e7653afbe-1" id="id73">[1]</a> with the author&rsquo;s permission.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b3e7653afbe-1"><span class="brackets"><a class="fn-backref" href="#id73">1</a></span></dt>
<dd><p><a class="reference external" href="http://www.janeriksolem.net/histogram-equalization-with-python-and.html">http://www.janeriksolem.net/histogram-equalization-with-python-and.html</a></p>
</dd>
<dt class="label" id="r0b3e7653afbe-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Histogram_equalization">https://en.wikipedia.org/wiki/Histogram_equalization</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.histogram">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'image'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.histogram" title="Permalink to this definition">#</a></dt>
<dd><p>Return histogram of image.</p>
<p>Unlike <cite>numpy.histogram</cite>, this function returns the centers of bins and
does not rebin integer arrays. For integer arrays, each integer value has
its own bin, which improves speed and intensity-resolution.</p>
<p>If <cite>channel_axis</cite> is not set, the histogram is computed on the flattened
image. For color or multichannel images, set <code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> to use a
common binning for all channels. Alternatively, one may apply the function
separately on each channel to obtain a histogram for each color channel
with separate binning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>source_range</strong><span class="classifier">string, optional</span></dt><dd><p>&lsquo;image&rsquo; (default) determines the range from the input image.
&lsquo;dtype&rsquo; determines the range from the expected range of the images
of that data type.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, normalize the histogram by the sum of its values.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hist</strong><span class="classifier">array</span></dt><dd><p>The values of the histogram. When <code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> is not None, hist
will be a 2D array where the first axis corresponds to channels.</p>
</dd>
<dt><strong>bin_centers</strong><span class="classifier">array</span></dt><dd><p>The values at the center of the bins.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.cumulative_distribution" title="cucim.skimage.exposure.cumulative_distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumulative_distribution</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(array([ 93585, 168559]), array([0. , 0.5, 1. ]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exposure</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(array([ 93585, 168559]), array([0.25, 0.75]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.is_low_contrast">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">is_low_contrast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">99</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.is_low_contrast" title="Permalink to this definition">#</a></dt>
<dd><p>Determine if an image is low contrast.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array-like</span></dt><dd><p>The image under test.</p>
</dd>
<dt><strong>fraction_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>The low contrast fraction threshold. An image is considered low-
contrast when its range of brightness spans less than this
fraction of its data type&rsquo;s full range. <a class="reference internal" href="#r12f9fb47597e-1" id="id76">[1]</a></p>
</dd>
<dt><strong>lower_percentile</strong><span class="classifier">float, optional</span></dt><dd><p>Disregard values below this percentile when computing image contrast.</p>
</dd>
<dt><strong>upper_percentile</strong><span class="classifier">float, optional</span></dt><dd><p>Disregard values above this percentile when computing image contrast.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>The contrast determination method.  Right now the only available
option is &ldquo;linear&rdquo;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd><p>True when the image is determined to be low contrast.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For boolean images, this function returns False only if all values are
the same (the method, threshold, and percentile arguments are ignored).</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r12f9fb47597e-1"><span class="brackets"><a class="fn-backref" href="#id76">1</a></span></dt>
<dd><p><a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_low_contrast</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array(True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_low_contrast</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array(True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_low_contrast</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">upper_percentile</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">array(False)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.match_histograms">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">match_histograms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.match_histograms" title="Permalink to this definition">#</a></dt>
<dd><p>Adjust an image so that its cumulative histogram matches that of another.</p>
<p>The adjustment is applied separately for each channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. Can be gray-scale or in color.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">ndarray</span></dt><dd><p>Image to match histogram of. Must have the same number of channels as
image.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matched</strong><span class="classifier">ndarray</span></dt><dd><p>Transformed input image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Thrown when the number of channels in the input image and the reference
differ.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8109c05ff55e-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://paulbourke.net/miscellaneous/equalisation/">http://paulbourke.net/miscellaneous/equalisation/</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.rescale_intensity">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">rescale_intensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'image'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dtype'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.rescale_intensity" title="Permalink to this definition">#</a></dt>
<dd><p>Return image after stretching or shrinking its intensity levels.</p>
<p>The desired intensity range of the input and output, <cite>in_range</cite> and
<cite>out_range</cite> respectively, are used to stretch or shrink the intensity range
of the input image. See examples below.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>in_range, out_range</strong><span class="classifier">str or 2-tuple, optional</span></dt><dd><p>Min and max intensity values of input and output image.
The possible values for this parameter are enumerated below.</p>
<dl class="simple">
<dt>&lsquo;image&rsquo;</dt><dd><p>Use image min/max as the intensity range.</p>
</dd>
<dt>&lsquo;dtype&rsquo;</dt><dd><p>Use min/max of the image&rsquo;s dtype as the intensity range.</p>
</dd>
<dt>dtype-name</dt><dd><p>Use intensity range based on desired <cite>dtype</cite>. Must be valid key
in <cite>DTYPE_RANGE</cite>.</p>
</dd>
<dt>2-tuple</dt><dd><p>Use <cite>range_values</cite> as explicit min/max intensities.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Image array after rescaling its intensity. This image is the same dtype
as the input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.equalize_hist" title="cucim.skimage.exposure.equalize_hist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equalize_hist</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.17: </span>The dtype of the output array has changed to match the output dtype, or
float if the output range is specified by a pair of values.</p>
</div>
<p class="rubric">Examples</p>
<p>By default, the min/max intensities of the input image are stretched to
the limits allowed by the image&rsquo;s dtype, since <cite>in_range</cite> defaults to
&lsquo;image&rsquo; and <cite>out_range</cite> defaults to &lsquo;dtype&rsquo;:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">51</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">153</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([  0, 127, 255], dtype=uint8)</span>
</pre></div>
</div>
<p>It&rsquo;s easy to accidentally convert an image dtype from uint8 to float:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">image</span>
<span class="go">array([ 51., 102., 153.])</span>
</pre></div>
</div>
<p>Use <cite>rescale_intensity</cite> to rescale to the proper range for float dtypes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_float</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image_float</span><span class="p">)</span>
<span class="go">array([0. , 0.5, 1. ])</span>
</pre></div>
</div>
<p>To maintain the low contrast of the original, use the <cite>in_range</cite> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image_float</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
<span class="go">array([0.2, 0.4, 0.6])</span>
</pre></div>
</div>
<p>If the min/max value of <cite>in_range</cite> is more/less than the min/max image
intensity, then the intensity levels are clipped:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image_float</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">102</span><span class="p">))</span>
<span class="go">array([0.5, 1. , 1. ])</span>
</pre></div>
</div>
<p>If you have an image with signed integers but want to rescale the image to
just the positive range, use the <cite>out_range</cite> parameter. In that case, the
output dtype will be float:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">127</span><span class="p">))</span>
<span class="go">array([  0. ,  63.5, 127. ])</span>
</pre></div>
</div>
<p>To get the desired range with a specific dtype, use <code class="docutils literal notranslate"><span class="pre">.astype()</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">127</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">array([  0,  63, 127], dtype=int8)</span>
</pre></div>
</div>
<p>If the input image is constant, the output will be clipped directly to the
output range:
&gt;&gt;&gt; image = cp.asarray([130, 130, 130], dtype=np.int32)
&gt;&gt;&gt; rescale_intensity(image, out_range=(0, 127)).astype(np.int32)
array([127, 127, 127], dtype=int32)</p>
</dd></dl>

</section>
<section id="module-cucim.skimage.feature">
<span id="feature"></span><h3>feature<a class="headerlink" href="#module-cucim.skimage.feature" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.blob_dog">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">blob_dog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.blob_dog" title="Permalink to this definition">#</a></dt>
<dd><p>Finds blobs in the given grayscale image.
Blobs are found using the Difference of Gaussian (DoG) method <a class="reference internal" href="#rec0029c70586-1" id="id79">[1]</a>, <a class="reference internal" href="#rec0029c70586-2" id="id80">[2]</a>.
For each blob found, the method returns its coordinates and the standard
deviation of the Gaussian kernel that detected the blob.
Parameters
&mdash;&mdash;&mdash;-
image : ndarray</p>
<blockquote>
<div><p>Input grayscale image, blobs are assumed to be light on dark
background (white on black).</p>
</div></blockquote>
<dl class="simple">
<dt>min_sigma<span class="classifier">scalar or sequence of scalars, optional</span></dt><dd><p>The minimum standard deviation for Gaussian kernel. Keep this low to
detect smaller blobs. The standard deviations of the Gaussian filter
are given for each axis as a sequence, or as a single number, in
which case it is equal for all axes.</p>
</dd>
<dt>max_sigma<span class="classifier">scalar or sequence of scalars, optional</span></dt><dd><p>The maximum standard deviation for Gaussian kernel. Keep this high to
detect larger blobs. The standard deviations of the Gaussian filter
are given for each axis as a sequence, or as a single number, in
which case it is equal for all axes.</p>
</dd>
<dt>sigma_ratio<span class="classifier">float, optional</span></dt><dd><p>The ratio between the standard deviation of Gaussian Kernels used for
computing the Difference of Gaussians</p>
</dd>
<dt>threshold<span class="classifier">float or None, optional</span></dt><dd><p>The absolute lower bound for scale space maxima. Local maxima smaller
than <cite>threshold</cite> are ignored. Reduce this to detect blobs with lower
intensities. If <cite>threshold_rel</cite> is also specified, whichever threshold
is larger will be used. If None, <cite>threshold_rel</cite> is used instead.</p>
</dd>
<dt>overlap<span class="classifier">float, optional</span></dt><dd><p>A value between 0 and 1. If the area of two blobs overlaps by a
fraction greater than <cite>threshold</cite>, the smaller blob is eliminated.</p>
</dd>
<dt>threshold_rel<span class="classifier">float or None, optional</span></dt><dd><p>Minimum intensity of peaks, calculated as
<code class="docutils literal notranslate"><span class="pre">max(dog_space)</span> <span class="pre">*</span> <span class="pre">threshold_rel</span></code>, where <code class="docutils literal notranslate"><span class="pre">dog_space</span></code> refers to the
stack of Difference-of-Gaussian (DoG) images computed internally. This
should have a value between 0 and 1. If None, <cite>threshold</cite> is used
instead.</p>
</dd>
<dt>exclude_border<span class="classifier">tuple of ints, int, or False, optional</span></dt><dd><p>If tuple of ints, the length of the tuple must match the input array&rsquo;s
dimensionality.  Each element of the tuple will exclude peaks from
within <cite>exclude_border</cite>-pixels of the border of the image along that
dimension.
If nonzero int, <cite>exclude_border</cite> excludes peaks from within
<cite>exclude_border</cite>-pixels of the border of the image.
If zero or False, peaks are identified regardless of their
distance from the border.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">(n, image.ndim + sigma) ndarray</span></dt><dd><p>A 2d array with each row representing 2 coordinate values for a 2D
image, or 3 coordinate values for a 3D image, plus the sigma(s) used.
When a single sigma is passed, outputs are:
<code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">c,</span> <span class="pre">sigma)</span></code> or <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">r,</span> <span class="pre">c,</span> <span class="pre">sigma)</span></code> where <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">c)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">r,</span> <span class="pre">c)</span></code> are coordinates of the blob and <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is the standard
deviation of the Gaussian kernel which detected the blob. When an
anisotropic gaussian is used (sigmas per dimension), the detected sigma
is returned for each dimension.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.difference_of_gaussians" title="cucim.skimage.filters.difference_of_gaussians"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cucim.skimage.filters.difference_of_gaussians</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The radius of each blob is approximately <span class="math notranslate nohighlight">\(\sqrt{2}\sigma\)</span> for
a 2-D image and <span class="math notranslate nohighlight">\(\sqrt{3}\sigma\)</span> for a 3-D image.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rec0029c70586-1"><span class="brackets"><a class="fn-backref" href="#id79">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Blob_detection#The_difference_of_Gaussians_approach">https://en.wikipedia.org/wiki/Blob_detection#The_difference_of_Gaussians_approach</a>  # noqa</p>
</dd>
<dt class="label" id="rec0029c70586-2"><span class="brackets"><a class="fn-backref" href="#id80">2</a></span></dt>
<dd><p>Lowe, D. G. &ldquo;Distinctive Image Features from Scale-Invariant
Keypoints.&rdquo; International Journal of Computer Vision 60, 91&ndash;110 (2004).
<a class="reference external" href="https://www.cs.ubc.ca/~lowe/papers/ijcv04.pdf">https://www.cs.ubc.ca/~lowe/papers/ijcv04.pdf</a>
<a class="reference external" href="https://doi.org/10.1023/B:VISI.0000029664.99615.94">DOI:10.1023/B:VISI.0000029664.99615.94</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">feature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coins</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature</span><span class="o">.</span><span class="n">blob_dog</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">.05</span><span class="p">,</span> <span class="n">min_sigma</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_sigma</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="go">array([[128., 155.,  10.],</span>
<span class="go">       [198., 155.,  10.],</span>
<span class="go">       [124., 338.,  10.],</span>
<span class="go">       [127., 102.,  10.],</span>
<span class="go">       [193., 281.,  10.],</span>
<span class="go">       [126., 208.,  10.],</span>
<span class="go">       [267., 115.,  10.],</span>
<span class="go">       [197., 102.,  10.],</span>
<span class="go">       [198., 215.,  10.],</span>
<span class="go">       [123., 279.,  10.],</span>
<span class="go">       [126.,  46.,  10.],</span>
<span class="go">       [259., 247.,  10.],</span>
<span class="go">       [196.,  43.,  10.],</span>
<span class="go">       [ 54., 276.,  10.],</span>
<span class="go">       [267., 358.,  10.],</span>
<span class="go">       [ 58., 100.,  10.],</span>
<span class="go">       [259., 305.,  10.],</span>
<span class="go">       [185., 347.,  16.],</span>
<span class="go">       [261., 174.,  16.],</span>
<span class="go">       [ 46., 336.,  16.],</span>
<span class="go">       [ 54., 217.,  10.],</span>
<span class="go">       [ 55., 157.,  10.],</span>
<span class="go">       [ 57.,  41.,  10.],</span>
<span class="go">       [260.,  47.,  16.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.blob_doh">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">blob_doh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.blob_doh" title="Permalink to this definition">#</a></dt>
<dd><p>Finds blobs in the given grayscale image.</p>
<p>Blobs are found using the Determinant of Hessian method <a class="reference internal" href="#r1074719b9b14-1" id="id83">[1]</a>. For each blob
found, the method returns its coordinates and the standard deviation
of the Gaussian Kernel used for the Hessian matrix whose determinant
detected the blob. Determinant of Hessians is approximated using <a class="reference internal" href="#r1074719b9b14-2" id="id84">[2]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2D ndarray</span></dt><dd><p>Input grayscale image.Blobs can either be light on dark or vice versa.</p>
</dd>
<dt><strong>min_sigma</strong><span class="classifier">float, optional</span></dt><dd><p>The minimum standard deviation for Gaussian Kernel used to compute
Hessian matrix. Keep this low to detect smaller blobs.</p>
</dd>
<dt><strong>max_sigma</strong><span class="classifier">float, optional</span></dt><dd><p>The maximum standard deviation for Gaussian Kernel used to compute
Hessian matrix. Keep this high to detect larger blobs.</p>
</dd>
<dt><strong>num_sigma</strong><span class="classifier">int, optional</span></dt><dd><p>The number of intermediate values of standard deviations to consider
between <cite>min_sigma</cite> and <cite>max_sigma</cite>.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float or None, optional</span></dt><dd><p>The absolute lower bound for scale space maxima. Local maxima smaller
than <cite>threshold</cite> are ignored. Reduce this to detect blobs with lower
intensities. If <cite>threshold_rel</cite> is also specified, whichever threshold
is larger will be used. If None, <cite>threshold_rel</cite> is used instead.</p>
</dd>
<dt><strong>overlap</strong><span class="classifier">float, optional</span></dt><dd><p>A value between 0 and 1. If the area of two blobs overlaps by a
fraction greater than <cite>threshold</cite>, the smaller blob is eliminated.</p>
</dd>
<dt><strong>log_scale</strong><span class="classifier">bool, optional</span></dt><dd><p>If set intermediate values of standard deviations are interpolated
using a logarithmic scale to the base <cite>10</cite>. If not, linear
interpolation is used.</p>
</dd>
<dt><strong>threshold_rel</strong><span class="classifier">float or None, optional</span></dt><dd><p>Minimum intensity of peaks, calculated as
<code class="docutils literal notranslate"><span class="pre">max(doh_space)</span> <span class="pre">*</span> <span class="pre">threshold_rel</span></code>, where <code class="docutils literal notranslate"><span class="pre">doh_space</span></code> refers to the
stack of Determinant-of-Hessian (DoH) images computed internally. This
should have a value between 0 and 1. If None, <cite>threshold</cite> is used
instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A</strong><span class="classifier">(n, 3) ndarray</span></dt><dd><p>A 2d array with each row representing 3 values, <code class="docutils literal notranslate"><span class="pre">(y,x,sigma)</span></code>
where <code class="docutils literal notranslate"><span class="pre">(y,x)</span></code> are coordinates of the blob and <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is the
standard deviation of the Gaussian kernel of the Hessian Matrix whose
determinant detected the blob.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The radius of each blob is approximately <cite>sigma</cite>.
Computation of Determinant of Hessians is independent of the standard
deviation. Therefore detecting larger blobs won&rsquo;t take more time. In
methods line <a class="reference internal" href="#cucim.skimage.feature.blob_dog" title="cucim.skimage.feature.blob_dog"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blob_dog()</span></code></a> and <a class="reference internal" href="#cucim.skimage.feature.blob_log" title="cucim.skimage.feature.blob_log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blob_log()</span></code></a> the computation
of Gaussians for larger <cite>sigma</cite> takes more time. The downside is that
this method can&rsquo;t be used for detecting blobs of radius less than <cite>3px</cite>
due to the box filters used in the approximation of Hessian Determinant.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1074719b9b14-1"><span class="brackets"><a class="fn-backref" href="#id83">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Blob_detection#The_determinant_of_the_Hessian">https://en.wikipedia.org/wiki/Blob_detection#The_determinant_of_the_Hessian</a>  # noqa</p>
</dd>
<dt class="label" id="r1074719b9b14-2"><span class="brackets"><a class="fn-backref" href="#id84">2</a></span></dt>
<dd><p>Herbert Bay, Andreas Ess, Tinne Tuytelaars, Luc Van Gool,
&ldquo;SURF: Speeded Up Robust Features&rdquo;
<a class="reference external" href="ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf">ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">feature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature</span><span class="o">.</span><span class="n">blob_doh</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="go">array([[197.      , 153.      ,  20.333334],</span>
<span class="go">       [124.      , 336.      ,  20.333334],</span>
<span class="go">       [126.      , 153.      ,  20.333334],</span>
<span class="go">       [195.      , 100.      ,  23.555555],</span>
<span class="go">       [192.      , 212.      ,  23.555555],</span>
<span class="go">       [121.      , 271.      ,  30.      ],</span>
<span class="go">       [126.      , 101.      ,  20.333334],</span>
<span class="go">       [193.      , 275.      ,  23.555555],</span>
<span class="go">       [123.      , 205.      ,  20.333334],</span>
<span class="go">       [270.      , 363.      ,  30.      ],</span>
<span class="go">       [265.      , 113.      ,  23.555555],</span>
<span class="go">       [262.      , 243.      ,  23.555555],</span>
<span class="go">       [185.      , 348.      ,  30.      ],</span>
<span class="go">       [156.      , 302.      ,  30.      ],</span>
<span class="go">       [123.      ,  44.      ,  23.555555],</span>
<span class="go">       [260.      , 173.      ,  30.      ],</span>
<span class="go">       [197.      ,  44.      ,  20.333334]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.blob_log">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">blob_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.blob_log" title="Permalink to this definition">#</a></dt>
<dd><p>Finds blobs in the given grayscale image.
Blobs are found using the Laplacian of Gaussian (LoG) method <a class="reference internal" href="#rc8921dc5b222-1" id="id87">[1]</a>.
For each blob found, the method returns its coordinates and the standard
deviation of the Gaussian kernel that detected the blob.
Parameters
&mdash;&mdash;&mdash;-
image : ndarray</p>
<blockquote>
<div><p>Input grayscale image, blobs are assumed to be light on dark
background (white on black).</p>
</div></blockquote>
<dl class="simple">
<dt>min_sigma<span class="classifier">scalar or sequence of scalars, optional</span></dt><dd><p>the minimum standard deviation for Gaussian kernel. Keep this low to
detect smaller blobs. The standard deviations of the Gaussian filter
are given for each axis as a sequence, or as a single number, in
which case it is equal for all axes.</p>
</dd>
<dt>max_sigma<span class="classifier">scalar or sequence of scalars, optional</span></dt><dd><p>The maximum standard deviation for Gaussian kernel. Keep this high to
detect larger blobs. The standard deviations of the Gaussian filter
are given for each axis as a sequence, or as a single number, in
which case it is equal for all axes.</p>
</dd>
<dt>num_sigma<span class="classifier">int, optional</span></dt><dd><p>The number of intermediate values of standard deviations to consider
between <cite>min_sigma</cite> and <cite>max_sigma</cite>.</p>
</dd>
<dt>threshold<span class="classifier">float or None, optional</span></dt><dd><p>The absolute lower bound for scale space maxima. Local maxima smaller
than <cite>threshold</cite> are ignored. Reduce this to detect blobs with lower
intensities. If <cite>threshold_rel</cite> is also specified, whichever threshold
is larger will be used. If None, <cite>threshold_rel</cite> is used instead.</p>
</dd>
<dt>overlap<span class="classifier">float, optional</span></dt><dd><p>A value between 0 and 1. If the area of two blobs overlaps by a
fraction greater than <cite>threshold</cite>, the smaller blob is eliminated.</p>
</dd>
<dt>log_scale<span class="classifier">bool, optional</span></dt><dd><p>If set intermediate values of standard deviations are interpolated
using a logarithmic scale to the base <cite>10</cite>. If not, linear
interpolation is used.</p>
</dd>
<dt>threshold_rel<span class="classifier">float or None, optional</span></dt><dd><p>Minimum intensity of peaks, calculated as
<code class="docutils literal notranslate"><span class="pre">max(log_space)</span> <span class="pre">*</span> <span class="pre">threshold_rel</span></code>, where <code class="docutils literal notranslate"><span class="pre">log_space</span></code> refers to the
stack of Laplacian-of-Gaussian (LoG) images computed internally. This
should have a value between 0 and 1. If None, <cite>threshold</cite> is used
instead.</p>
</dd>
<dt>exclude_border<span class="classifier">tuple of ints, int, or False, optional</span></dt><dd><p>If tuple of ints, the length of the tuple must match the input array&rsquo;s
dimensionality.  Each element of the tuple will exclude peaks from
within <cite>exclude_border</cite>-pixels of the border of the image along that
dimension.
If nonzero int, <cite>exclude_border</cite> excludes peaks from within
<cite>exclude_border</cite>-pixels of the border of the image.
If zero or False, peaks are identified regardless of their
distance from the border.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">(n, image.ndim + sigma) ndarray</span></dt><dd><p>A 2d array with each row representing 2 coordinate values for a 2D
image, or 3 coordinate values for a 3D image, plus the sigma(s) used.
When a single sigma is passed, outputs are:
<code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">c,</span> <span class="pre">sigma)</span></code> or <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">r,</span> <span class="pre">c,</span> <span class="pre">sigma)</span></code> where <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">c)</span></code> or
<code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">r,</span> <span class="pre">c)</span></code> are coordinates of the blob and <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is the standard
deviation of the Gaussian kernel which detected the blob. When an
anisotropic gaussian is used (sigmas per dimension), the detected sigma
is returned for each dimension.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc8921dc5b222-1"><span class="brackets"><a class="fn-backref" href="#id87">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Blob_detection#The_Laplacian_of_Gaussian">https://en.wikipedia.org/wiki/Blob_detection#The_Laplacian_of_Gaussian</a>  # noqa</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">feature</span><span class="p">,</span> <span class="n">exposure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">equalize_hist</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>  <span class="c1"># improves detection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature</span><span class="o">.</span><span class="n">blob_log</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mf">.3</span><span class="p">)</span>
<span class="go">array([[124.        , 336.        ,  11.88888889],</span>
<span class="go">       [198.        , 155.        ,  11.88888889],</span>
<span class="go">       [194.        , 213.        ,  17.33333333],</span>
<span class="go">       [121.        , 272.        ,  17.33333333],</span>
<span class="go">       [263.        , 244.        ,  17.33333333],</span>
<span class="go">       [194.        , 276.        ,  17.33333333],</span>
<span class="go">       [266.        , 115.        ,  11.88888889],</span>
<span class="go">       [128.        , 154.        ,  11.88888889],</span>
<span class="go">       [260.        , 174.        ,  17.33333333],</span>
<span class="go">       [198.        , 103.        ,  11.88888889],</span>
<span class="go">       [126.        , 208.        ,  11.88888889],</span>
<span class="go">       [127.        , 102.        ,  11.88888889],</span>
<span class="go">       [263.        , 302.        ,  17.33333333],</span>
<span class="go">       [197.        ,  44.        ,  11.88888889],</span>
<span class="go">       [185.        , 344.        ,  17.33333333],</span>
<span class="go">       [126.        ,  46.        ,  11.88888889],</span>
<span class="go">       [113.        , 323.        ,   1.        ]])</span>
<span class="go">Notes</span>
<span class="go">-----</span>
<span class="go">The radius of each blob is approximately :math:`\sqrt{2}\sigma` for</span>
<span class="go">a 2-D image and :math:`\sqrt{3}\sigma` for a 3-D image.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.canny">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">canny</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_quantiles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.canny" title="Permalink to this definition">#</a></dt>
<dd><p>Edge filter an image using the Canny algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2D array</span></dt><dd><p>Grayscale input image to detect edges on; can be of any dtype.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation of the Gaussian filter.</p>
</dd>
<dt><strong>low_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Lower bound for hysteresis thresholding (linking edges).
If None, low_threshold is set to 10% of dtype&rsquo;s max.</p>
</dd>
<dt><strong>high_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Upper bound for hysteresis thresholding (linking edges).
If None, high_threshold is set to 20% of dtype&rsquo;s max.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array, dtype=bool, optional</span></dt><dd><p>Mask to limit the application of Canny to a certain area.</p>
</dd>
<dt><strong>use_quantiles</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> then treat low_threshold and high_threshold as
quantiles of the edge magnitude image, rather than absolute
edge magnitude values. If <code class="docutils literal notranslate"><span class="pre">True</span></code> then the thresholds must be
in the range [0, 1].</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, {&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter determines how the array borders are
handled during Gaussian filtering, where <code class="docutils literal notranslate"><span class="pre">cval</span></code> is the value when
mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if <cite>mode</cite> is &lsquo;constant&rsquo;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2D array (image)</span></dt><dd><p>The binary edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.filters.html#skimage.filters.sobel" title="(in skimage v0.19.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.filters.sobel</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The steps of the algorithm are as follows:</p>
<ul class="simple">
<li><p>Smooth the image using a Gaussian with <code class="docutils literal notranslate"><span class="pre">sigma</span></code> width.</p></li>
<li><p>Apply the horizontal and vertical Sobel operators to get the gradients
within the image. The edge strength is the norm of the gradient.</p></li>
<li><p>Thin potential edges to 1-pixel wide curves. First, find the normal
to the edge at each point. This is done by looking at the
signs and the relative magnitude of the X-Sobel and Y-Sobel
to sort the points into 4 categories: horizontal, vertical,
diagonal and antidiagonal. Then look in the normal and reverse
directions to see if the values in either of those directions are
greater than the point in question. Use interpolation to get a mix of
points instead of picking the one that&rsquo;s the closest to the normal.</p></li>
<li><p>Perform a hysteresis thresholding: first label all points above the
high threshold as edges. Then recursively label any point above the
low threshold that is 8-connected to a labeled point as an edge.</p></li>
</ul>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rda09548a1040-1"><span class="brackets">1</span></dt>
<dd><p>Canny, J., A Computational Approach To Edge Detection, IEEE Trans.
Pattern Analysis and Machine Intelligence, 8:679-714, 1986
<a class="reference external" href="https://doi.org/10.1109/TPAMI.1986.4767851">DOI:10.1109/TPAMI.1986.4767851</a></p>
</dd>
<dt class="label" id="rda09548a1040-2"><span class="brackets">2</span></dt>
<dd><p>William Green&rsquo;s Canny tutorial
<a class="reference external" href="https://en.wikipedia.org/wiki/Canny_edge_detector">https://en.wikipedia.org/wiki/Canny_edge_detector</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">feature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate noisy image of a square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">[</span><span class="mi">64</span><span class="p">:</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">:</span><span class="o">-</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">+=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># First trial with the Canny filter, with the default smoothing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges1</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">canny</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Increase the smoothing for better results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges2</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">canny</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_foerstner">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_foerstner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_foerstner" title="Permalink to this definition">#</a></dt>
<dd><p>Compute Foerstner corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   <span class="p">(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Axx</span> <span class="n">Axy</span><span class="p">]</span>
    <span class="p">[(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)</span>   <span class="p">(</span><span class="n">imy</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>   <span class="p">[</span><span class="n">Axy</span> <span class="n">Ayy</span><span class="p">]</span>
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>           <span class="p">(</span><span class="n">size</span> <span class="n">of</span> <span class="n">error</span> <span class="n">ellipse</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>    <span class="p">(</span><span class="n">roundness</span> <span class="n">of</span> <span class="n">error</span> <span class="n">ellipse</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>Error ellipse sizes.</p>
</dd>
<dt><strong>q</strong><span class="classifier">ndarray</span></dt><dd><p>Roundness of error ellipse.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b0ff10bd5c6-1"><span class="brackets">1</span></dt>
<dd><p>F&ouml;rstner, W., &amp; G&uuml;lch, E. (1987, June). A fast operator for
detection and precise location of distinct points, corners and
centres of circular features. In Proc. ISPRS intercommission
conference on fast processing of photogrammetric data (pp. 281-305).</p>
</dd>
<dt class="label" id="r0b0ff10bd5c6-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Corner_detection">https://en.wikipedia.org/wiki/Corner_detection</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">corner_foerstner</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">corner_foerstner</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_thresh</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roundness_thresh</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foerstner</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="n">roundness_thresh</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">accuracy_thresh</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">foerstner</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_harris">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_harris</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_harris" title="Permalink to this definition">#</a></dt>
<dd><p>Compute Harris corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   <span class="p">(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Axx</span> <span class="n">Axy</span><span class="p">]</span>
    <span class="p">[(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)</span>   <span class="p">(</span><span class="n">imy</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>   <span class="p">[</span><span class="n">Axy</span> <span class="n">Ayy</span><span class="p">]</span>
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="o">*</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{&lsquo;k&rsquo;, &lsquo;eps&rsquo;}, optional</span></dt><dd><p>Method to compute the response image from the auto-correlation matrix.</p>
</dd>
<dt><strong>k</strong><span class="classifier">float, optional</span></dt><dd><p>Sensitivity factor to separate corners from edges, typically in range
<cite>[0, 0.2]</cite>. Small values of k result in detection of sharp corners.</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Normalisation factor (Noble&rsquo;s corner measure).</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">ndarray</span></dt><dd><p>Harris response image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re3d0143ef51f-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Corner_detection">https://en.wikipedia.org/wiki/Corner_detection</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">corner_harris</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_harris</span><span class="p">(</span><span class="n">square</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_kitchen_rosenfeld">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_kitchen_rosenfeld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_kitchen_rosenfeld" title="Permalink to this definition">#</a></dt>
<dd><p>Compute Kitchen and Rosenfeld corner measure response image.</p>
<p>The corner measure is calculated as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">imxx</span> <span class="o">*</span> <span class="n">imy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">imyy</span> <span class="o">*</span> <span class="n">imx</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imxy</span> <span class="o">*</span> <span class="n">imx</span> <span class="o">*</span> <span class="n">imy</span><span class="p">)</span>
    <span class="o">/</span> <span class="p">(</span><span class="n">imx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">imy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Where imx and imy are the first and imxx, imxy, imyy the second
derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">ndarray</span></dt><dd><p>Kitchen and Rosenfeld response image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra14f0c3b8083-1"><span class="brackets">1</span></dt>
<dd><p>Kitchen, L., &amp; Rosenfeld, A. (1982). Gray-level corner detection.
Pattern recognition letters, 1(2), 95-102.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(82)90020-4">DOI:10.1016/0167-8655(82)90020-4</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_peaks">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_abs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks_per_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_peaks" title="Permalink to this definition">#</a></dt>
<dd><p>Find peaks in corner measure response image.</p>
<p>This differs from <cite>skimage.feature.peak_local_max</cite> in that it suppresses
multiple connected peaks with the same accumulator value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>min_distance</strong><span class="classifier">int, optional</span></dt><dd><p>The minimal allowed distance separating peaks.</p>
</dd>
<dt><strong>*</strong><span class="classifier">*</span></dt><dd><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">skimage.feature.peak_local_max()</span></code>.</p>
</dd>
<dt><strong>p_norm</strong><span class="classifier">float</span></dt><dd><p>Which Minkowski p-norm to use. Should be in the range [1, inf].
A finite large p may cause a ValueError if overflow can occur.
<code class="docutils literal notranslate"><span class="pre">inf</span></code> corresponds to the Chebyshev distance and 2 to the
Euclidean distance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray or ndarray of bools</span></dt><dd><ul class="simple">
<li><p>If <cite>indices = True</cite>  : (row, column, &hellip;) coordinates of peaks.</p></li>
<li><p>If <cite>indices = False</cite> : Boolean array shaped like <cite>image</cite>, with peaks
represented by True values.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.feature.html#skimage.feature.peak_local_max" title="(in skimage v0.19.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.feature.peak_local_max</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18: </span>The default value of <cite>threshold_rel</cite> has changed to None, which
corresponds to letting <cite>skimage.feature.peak_local_max</cite> decide on the
default. This is equivalent to <cite>threshold_rel=0</cite>.</p>
</div>
<p>The <cite>num_peaks</cite> limit is applied before suppression of connected peaks.
To limit the number of peaks after suppression, set <cite>num_peaks=np.inf</cite> and
post-process the output of this function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">peak_local_max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span>
<span class="go">array([[0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 0., 1., 1., 0.],</span>
<span class="go">       [0., 0., 1., 1., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 2],</span>
<span class="go">       [3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
<span class="go">array([[2, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_shi_tomasi">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_shi_tomasi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_shi_tomasi" title="Permalink to this definition">#</a></dt>
<dd><p>Compute Shi-Tomasi (Kanade-Tomasi) corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   <span class="p">(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Axx</span> <span class="n">Axy</span><span class="p">]</span>
    <span class="p">[(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)</span>   <span class="p">(</span><span class="n">imy</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>   <span class="p">[</span><span class="n">Axy</span> <span class="n">Ayy</span><span class="p">]</span>
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as the smaller eigenvalue of A:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="n">Axx</span> <span class="o">+</span> <span class="n">Ayy</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">Axx</span> <span class="o">-</span> <span class="n">Ayy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Axy</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">ndarray</span></dt><dd><p>Shi-Tomasi response image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1533b50bf70b-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Corner_detection">https://en.wikipedia.org/wiki/Corner_detection</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">corner_shi_tomasi</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_shi_tomasi</span><span class="p">(</span><span class="n">square</span><span class="p">),</span>
<span class="gp">... </span>             <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.daisy">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">daisy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">histograms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visualize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.daisy" title="Permalink to this definition">#</a></dt>
<dd><p>Extract DAISY feature descriptors densely for the given image.</p>
<p>DAISY is a feature descriptor similar to SIFT formulated in a way that
allows for fast dense extraction. Typically, this is practical for
bag-of-features image representations.</p>
<p>The implementation follows Tola et al. <a class="reference internal" href="#r755485c8391d-1" id="id96">[1]</a> but deviate on the following
points:</p>
<blockquote>
<div><ul class="simple">
<li><p>Histogram bin contribution are smoothed with a circular Gaussian
window over the tonal range (the angular range).</p></li>
<li><p>The sigma values of the spatial Gaussian smoothing in this code do not
match the sigma values in the original code by Tola et al. <a class="reference internal" href="#r755485c8391d-2" id="id97">[2]</a>. In
their code, spatial smoothing is applied to both the input image and
the center histogram. However, this smoothing is not documented in <a class="reference internal" href="#r755485c8391d-1" id="id98">[1]</a>
and, therefore, it is omitted.</p></li>
</ul>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N) array</span></dt><dd><p>Input image (grayscale).</p>
</dd>
<dt><strong>step</strong><span class="classifier">int, optional</span></dt><dd><p>Distance between descriptor sampling points.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int, optional</span></dt><dd><p>Radius (in pixels) of the outermost ring.</p>
</dd>
<dt><strong>rings</strong><span class="classifier">int, optional</span></dt><dd><p>Number of rings.</p>
</dd>
<dt><strong>histograms</strong><span class="classifier">int, optional</span></dt><dd><p>Number of histograms sampled per ring.</p>
</dd>
<dt><strong>orientations</strong><span class="classifier">int, optional</span></dt><dd><p>Number of orientations (bins) per histogram.</p>
</dd>
<dt><strong>normalization</strong><span class="classifier">[ &lsquo;l1&rsquo; | &lsquo;l2&rsquo; | &lsquo;daisy&rsquo; | &lsquo;off&rsquo; ], optional</span></dt><dd><p>How to normalize the descriptors</p>
<blockquote>
<div><ul class="simple">
<li><p>&lsquo;l1&rsquo;: L1-normalization of each descriptor.</p></li>
<li><p>&lsquo;l2&rsquo;: L2-normalization of each descriptor.</p></li>
<li><p>&lsquo;daisy&rsquo;: L2-normalization of individual histograms.</p></li>
<li><p>&lsquo;off&rsquo;: Disable normalization.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>sigmas</strong><span class="classifier">1D array of float, optional</span></dt><dd><p>Standard deviation of spatial Gaussian smoothing for the center
histogram and for each ring of histograms. The array of sigmas should
be sorted from the center and out. I.e. the first sigma value defines
the spatial smoothing of the center histogram and the last sigma value
defines the spatial smoothing of the outermost ring. Specifying sigmas
overrides the following parameter.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rings</span> <span class="pre">=</span> <span class="pre">len(sigmas)</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</div></blockquote>
</dd>
<dt><strong>ring_radii</strong><span class="classifier">1D array of int, optional</span></dt><dd><p>Radius (in pixels) for each ring. Specifying ring_radii overrides the
following two parameters.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rings</span> <span class="pre">=</span> <span class="pre">len(ring_radii)</span></code>
<code class="docutils literal notranslate"><span class="pre">radius</span> <span class="pre">=</span> <span class="pre">ring_radii[-1]</span></code></p>
</div></blockquote>
<p>If both sigmas and ring_radii are given, they must satisfy the
following predicate since no radius is needed for the center
histogram.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">len(ring_radii)</span> <span class="pre">==</span> <span class="pre">len(sigmas)</span> <span class="pre">+</span> <span class="pre">1</span></code></p>
</div></blockquote>
</dd>
<dt><strong>visualize</strong><span class="classifier">bool, optional</span></dt><dd><p>Generate a visualization of the DAISY descriptors</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>descs</strong><span class="classifier">array</span></dt><dd><p>Grid of DAISY descriptors for the given image as an array
dimensionality  (P, Q, R) where</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">ceil((M</span> <span class="pre">-</span> <span class="pre">radius*2)</span> <span class="pre">/</span> <span class="pre">step)</span></code>
<code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">=</span> <span class="pre">ceil((N</span> <span class="pre">-</span> <span class="pre">radius*2)</span> <span class="pre">/</span> <span class="pre">step)</span></code>
<code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">(rings</span> <span class="pre">*</span> <span class="pre">histograms</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">orientations</span></code></p>
</div></blockquote>
</dd>
<dt><strong>descs_img</strong><span class="classifier">(M, N, 3) array (only if visualize==True)</span></dt><dd><p>Visualization of the DAISY descriptors.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r755485c8391d-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id96">1</a>,<a href="#id98">2</a>)</span></dt>
<dd><p>Tola et al. &ldquo;Daisy: An efficient dense descriptor applied to wide-
baseline stereo.&rdquo; Pattern Analysis and Machine Intelligence, IEEE
Transactions on 32.5 (2010): 815-830.</p>
</dd>
<dt class="label" id="r755485c8391d-2"><span class="brackets"><a class="fn-backref" href="#id97">2</a></span></dt>
<dd><p><a class="reference external" href="http://cvlab.epfl.ch/software/daisy">http://cvlab.epfl.ch/software/daisy</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.hessian_matrix">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">hessian_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_gaussian_derivatives</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.hessian_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Hessian matrix.</p>
<p>In 2D, the Hessian matrix is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">Hrr</span> <span class="n">Hrc</span><span class="p">]</span>
    <span class="p">[</span><span class="n">Hrc</span> <span class="n">Hcc</span><span class="p">]</span>
</pre></div>
</div>
<p>which is computed by convolving the image with the second derivatives
of the Gaussian kernel in the respective r- and c-directions.</p>
<p>The implementation here also supports n-dimensional data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{&lsquo;rc&rsquo;, &lsquo;xy&rsquo;}, optional</span></dt><dd><p>NOTE: &lsquo;xy&rsquo; is only an option for 2D images, higher dimensions must
always use &lsquo;rc&rsquo; order. This parameter allows for the use of reverse or
forward order of the image axes in gradient computation. &lsquo;rc&rsquo; indicates
the use of the first axis initially (Hrr, Hrc, Hcc), whilst &lsquo;xy&rsquo;
indicates the usage of the last axis initially (Hxx, Hxy, Hyy).</p>
</dd>
<dt><strong>use_gaussian_derivatives</strong><span class="classifier">boolean, optional</span></dt><dd><p>Indicates whether the Hessian is computed by convolving with Gaussian
derivatives, or by a simple finite-difference operation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>H_elems</strong><span class="classifier">list of ndarray</span></dt><dd><p>Upper-diagonal elements of the hessian matrix for each pixel in the
input image. In 2D, this will be a three element list containing [Hrr,
Hrc, Hcc]. In nD, the list will contain <code class="docutils literal notranslate"><span class="pre">(n**2</span> <span class="pre">+</span> <span class="pre">n)</span> <span class="pre">/</span> <span class="pre">2</span></code> arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The distributive property of derivatives and convolutions allows us to
restate the derivative of an image, I, smoothed with a Gaussian kernel, G,
as the convolution of the image with the derivative of G.</p>
<div class="math notranslate nohighlight">
\[\frac{\partial }{\partial x_i}(I * G) =
I * \left( \frac{\partial }{\partial x_i} G \right)\]</div>
<p>When <code class="docutils literal notranslate"><span class="pre">use_gaussian_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this property is used to
compute the second order derivatives that make up the Hessian matrix.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">use_gaussian_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, simple finite differences
on a Gaussian-smoothed image are used instead.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">hessian_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hrr</span><span class="p">,</span> <span class="n">Hrc</span><span class="p">,</span> <span class="n">Hcc</span> <span class="o">=</span> <span class="n">hessian_matrix</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'rc'</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">use_gaussian_derivatives</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hrc</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0., -1.,  0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.hessian_matrix_det">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">hessian_matrix_det</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.hessian_matrix_det" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the approximate Hessian Determinant over an image.</p>
<p>The 2D approximate method uses box filters over integral images to
compute the approximate Hessian Determinant.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The image over which to compute the Hessian Determinant.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation of the Gaussian kernel used for the Hessian
matrix.</p>
</dd>
<dt><strong>approximate</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> and the image is 2D, use a much faster approximate
computation. This argument has no effect on 3D and higher images.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>The array of the Determinant of Hessians.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For 2D images when <code class="docutils literal notranslate"><span class="pre">approximate=True</span></code>, the running time of this method
only depends on size of the image. It is independent of <cite>sigma</cite> as one
would expect. The downside is that the result for <cite>sigma</cite> less than <cite>3</cite>
is not accurate, i.e., not similar to the result obtained if someone
computed the Hessian and took its determinant.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb0b31e8efc4c-1"><span class="brackets">1</span></dt>
<dd><p>Herbert Bay, Andreas Ess, Tinne Tuytelaars, Luc Van Gool,
&ldquo;SURF: Speeded Up Robust Features&rdquo;
<a class="reference external" href="ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf">ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.hessian_matrix_eigvals">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">hessian_matrix_eigvals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.hessian_matrix_eigvals" title="Permalink to this definition">#</a></dt>
<dd><p>Compute eigenvalues of Hessian matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H_elems</strong><span class="classifier">list of ndarray</span></dt><dd><p>The upper-diagonal elements of the Hessian matrix, as returned
by <cite>hessian_matrix</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigs</strong><span class="classifier">ndarray</span></dt><dd><p>The eigenvalues of the Hessian matrix, in decreasing order. The
eigenvalues are the leading dimension. That is, <code class="docutils literal notranslate"><span class="pre">eigs[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code>
contains the ith-largest eigenvalue at position (j, k).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="p">(</span><span class="n">hessian_matrix</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">hessian_matrix_eigvals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H_elems</span> <span class="o">=</span> <span class="n">hessian_matrix</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'rc'</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">use_gaussian_derivatives</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hessian_matrix_eigvals</span><span class="p">(</span><span class="n">H_elems</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0.,  0.,  2.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  1.,  0.],</span>
<span class="go">       [ 2.,  0., -2.,  0.,  2.],</span>
<span class="go">       [ 0.,  1.,  0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  2.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.match_descriptors">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">match_descriptors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descriptors1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descriptors2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.match_descriptors" title="Permalink to this definition">#</a></dt>
<dd><p>Brute-force matching of descriptors.</p>
<p>For each descriptor in the first set this matcher finds the closest
descriptor in the second set (and vice-versa in the case of enabled
cross-checking).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>descriptors1</strong><span class="classifier">(M, P) array</span></dt><dd><p>Descriptors of size P about M keypoints in the first image.</p>
</dd>
<dt><strong>descriptors2</strong><span class="classifier">(N, P) array</span></dt><dd><p>Descriptors of size P about N keypoints in the second image.</p>
</dd>
<dt><strong>metric</strong><span class="classifier">{&lsquo;euclidean&rsquo;, &lsquo;cityblock&rsquo;, &lsquo;minkowski&rsquo;, &lsquo;hamming&rsquo;, &hellip;} , optional</span></dt><dd><p>The metric to compute the distance between two descriptors. See
<cite>scipy.spatial.distance.cdist</cite> for all possible types. The hamming
distance should be used for binary descriptors. By default the L2-norm
is used for all descriptors of dtype float or double and the Hamming
distance is used for binary descriptors automatically.</p>
</dd>
<dt><strong>p</strong><span class="classifier">int, optional</span></dt><dd><p>The p-norm to apply for <code class="docutils literal notranslate"><span class="pre">metric='minkowski'</span></code>.</p>
</dd>
<dt><strong>max_distance</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum allowed distance between descriptors of two keypoints
in separate images to be regarded as a match.</p>
</dd>
<dt><strong>cross_check</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the matched keypoints are returned after cross checking i.e. a
matched pair (keypoint1, keypoint2) is returned if keypoint2 is the
best match for keypoint1 in second image and keypoint1 is the best
match for keypoint2 in first image.</p>
</dd>
<dt><strong>max_ratio</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum ratio of distances between first and second closest descriptor
in the second set of descriptors. This threshold is useful to filter
ambiguous matches between the two descriptor sets. The choice of this
value depends on the statistics of the chosen descriptor, e.g.,
for SIFT descriptors a value of 0.8 is usually chosen, see
D.G. Lowe, &ldquo;Distinctive Image Features from Scale-Invariant Keypoints&rdquo;,
International Journal of Computer Vision, 2004.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matches</strong><span class="classifier">(Q, 2) array</span></dt><dd><p>Indices of corresponding matches in first and second set of
descriptors, where <code class="docutils literal notranslate"><span class="pre">matches[:,</span> <span class="pre">0]</span></code> denote the indices in the first
and <code class="docutils literal notranslate"><span class="pre">matches[:,</span> <span class="pre">1]</span></code> the indices in the second set of descriptors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.match_template">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">match_template</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.match_template" title="Permalink to this definition">#</a></dt>
<dd><p>Match a template to a 2-D or 3-D image using normalized correlation.</p>
<p>The output is an array with values between -1.0 and 1.0. The value at a
given position corresponds to the correlation coefficient between the image
and the template.</p>
<p>For <cite>pad_input=True</cite> matches correspond to the center and otherwise to the
top-left corner of the template. To find the best match you must search for
peaks in the response (output) image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N[, D]) array</span></dt><dd><p>2-D or 3-D input image.</p>
</dd>
<dt><strong>template</strong><span class="classifier">(m, n[, d]) array</span></dt><dd><p>Template to locate. It must be <cite>(m &lt;= M, n &lt;= N[, d &lt;= D])</cite>.</p>
</dd>
<dt><strong>pad_input</strong><span class="classifier">bool</span></dt><dd><p>If True, pad <cite>image</cite> so that output is the same size as the image, and
output values correspond to the template center. Otherwise, the output
is an array with shape <cite>(M - m + 1, N - n + 1)</cite> for an <cite>(M, N)</cite> image
and an <cite>(m, n)</cite> template, and matches correspond to origin
(top-left corner) of the template.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">see <cite>numpy.pad</cite>, optional</span></dt><dd><p>Padding mode.</p>
</dd>
<dt><strong>constant_values</strong><span class="classifier">see <cite>numpy.pad</cite>, optional</span></dt><dd><p>Constant values used in conjunction with <code class="docutils literal notranslate"><span class="pre">mode='constant'</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array</span></dt><dd><p>Response image with correlation coefficients.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Details on the cross-correlation are presented in <a class="reference internal" href="#r9f67d2173c8e-1" id="id102">[1]</a>. This implementation
uses FFT convolutions of the image and the template. Reference <a class="reference internal" href="#r9f67d2173c8e-2" id="id103">[2]</a>
presents similar derivations but the approximation presented in this
reference is not used in our implementation.</p>
<p>This CuPy implementation does not force the image to float64 internally,
but will use float32 for single-precision inputs.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9f67d2173c8e-1"><span class="brackets"><a class="fn-backref" href="#id102">1</a></span></dt>
<dd><p>J. P. Lewis, &ldquo;Fast Normalized Cross-Correlation&rdquo;, Industrial Light
and Magic.</p>
</dd>
<dt class="label" id="r9f67d2173c8e-2"><span class="brackets"><a class="fn-backref" href="#id103">2</a></span></dt>
<dd><p>Briechle and Hanebeck, &ldquo;Template Matching using Fast Normalized
Cross Correlation&rdquo;, Proceedings of the SPIE (2001).
<a class="reference external" href="https://doi.org/10.1117/12.421129">DOI:10.1117/12.421129</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span>
<span class="go">array([[0., 0., 0.],</span>
<span class="go">       [0., 1., 0.],</span>
<span class="go">       [0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">match_template</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[ 1.   , -0.125,  0.   ,  0.   ],</span>
<span class="go">       [-0.125, -0.125,  0.   ,  0.   ],</span>
<span class="go">       [ 0.   ,  0.   ,  0.125,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.125, -1.   ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">match_template</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">pad_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[-0.125, -0.125, -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [-0.125,  1.   , -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [-0.125, -0.125, -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125,  0.125,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125, -1.   ,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125,  0.125,  0.125]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.multiscale_basic_features">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">multiscale_basic_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">texture</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.multiscale_basic_features" title="Permalink to this definition">#</a></dt>
<dd><p>Local features for a single- or multi-channel nd image.</p>
<p>Intensity, gradient intensity and local structure are computed at
different scales thanks to Gaussian blurring.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image, which can be grayscale or multichannel.</p>
</dd>
<dt><strong>intensity</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, pixel intensities averaged over the different scales
are added to the feature set.</p>
</dd>
<dt><strong>edges</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, intensities of local gradients averaged over the different
scales are added to the feature set.</p>
</dd>
<dt><strong>texture</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, eigenvalues of the Hessian matrix after Gaussian blurring
at different scales are added to the feature set.</p>
</dd>
<dt><strong>sigma_min</strong><span class="classifier">float, optional</span></dt><dd><p>Smallest value of the Gaussian kernel used to average local
neighborhoods before extracting features.</p>
</dd>
<dt><strong>sigma_max</strong><span class="classifier">float, optional</span></dt><dd><p>Largest value of the Gaussian kernel used to average local
neighborhoods before extracting features.</p>
</dd>
<dt><strong>num_sigma</strong><span class="classifier">int, optional</span></dt><dd><p>Number of values of the Gaussian kernel between sigma_min and sigma_max.
If None, sigma_min multiplied by powers of 2 are used.</p>
</dd>
<dt><strong>num_workers</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of parallel threads to use. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the full
set of available cores are used.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>features</strong><span class="classifier">np.ndarray</span></dt><dd><p>Array of shape <code class="docutils literal notranslate"><span class="pre">image.shape</span> <span class="pre">+</span> <span class="pre">(n_features,)</span></code>. When <cite>channel_axis</cite> is
not None, all channels are concatenated along the features dimension.
(i.e. <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">==</span> <span class="pre">n_features_singlechannel</span> <span class="pre">*</span> <span class="pre">n_channels</span></code>)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.peak_local_max">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">peak_local_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_abs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks_per_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.peak_local_max" title="Permalink to this definition">#</a></dt>
<dd><p>Find peaks in an image as coordinate list.</p>
<p>Peaks are the local maxima in a region of <cite>2 * min_distance + 1</cite>
(i.e. peaks are separated by at least <cite>min_distance</cite>).</p>
<p>If both <cite>threshold_abs</cite> and <cite>threshold_rel</cite> are provided, the maximum
of the two is chosen as the minimum intensity threshold of peaks.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18: </span>Prior to version 0.18, peaks of the same height within a radius of
<cite>min_distance</cite> were all returned, but this could cause unexpected
behaviour. From 0.18 onwards, an arbitrary peak within the region is
returned. See issue gh-2592.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>min_distance</strong><span class="classifier">int, optional</span></dt><dd><p>The minimal allowed distance separating peaks. To find the
maximum number of peaks, use <cite>min_distance=1</cite>.</p>
</dd>
<dt><strong>threshold_abs</strong><span class="classifier">float or None, optional</span></dt><dd><p>Minimum intensity of peaks. By default, the absolute threshold is
the minimum intensity of the image.</p>
</dd>
<dt><strong>threshold_rel</strong><span class="classifier">float or None, optional</span></dt><dd><p>Minimum intensity of peaks, calculated as
<code class="docutils literal notranslate"><span class="pre">max(image)</span> <span class="pre">*</span> <span class="pre">threshold_rel</span></code>.</p>
</dd>
<dt><strong>exclude_border</strong><span class="classifier">int, tuple of ints, or bool, optional</span></dt><dd><p>If positive integer, <cite>exclude_border</cite> excludes peaks from within
<cite>exclude_border</cite>-pixels of the border of the image.
If tuple of non-negative ints, the length of the tuple must match the
input array&rsquo;s dimensionality.  Each element of the tuple will exclude
peaks from within <cite>exclude_border</cite>-pixels of the border of the image
along that dimension.
If True, takes the <cite>min_distance</cite> parameter as value.
If zero or False, peaks are identified regardless of their distance
from the border.</p>
</dd>
<dt><strong>num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks. When the number of peaks exceeds <cite>num_peaks</cite>,
return <cite>num_peaks</cite> peaks based on highest peak intensity.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray of bools, optional</span></dt><dd><p>If provided, <cite>footprint == 1</cite> represents the local region within which
to search for peaks at every point in <cite>image</cite>.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">ndarray of ints, optional</span></dt><dd><p>If provided, each unique region <cite>labels == value</cite> represents a unique
region to search for peaks. Zero is reserved for background.</p>
</dd>
<dt><strong>num_peaks_per_label</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks for each label.</p>
</dd>
<dt><strong>p_norm</strong><span class="classifier">float</span></dt><dd><p>Which Minkowski p-norm to use. Should be in the range [1, inf].
A finite large p may cause a ValueError if overflow can occur.
<code class="docutils literal notranslate"><span class="pre">inf</span></code> corresponds to the Chebyshev distance and 2 to the
Euclidean distance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>The coordinates of the peaks.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.feature.html#skimage.feature.corner_peaks" title="(in skimage v0.19.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.feature.corner_peaks</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The peak local maximum function returns the coordinates of local peaks
(maxima) in an image. Internally, a maximum filter is used for finding
local maxima. This operation dilates the original image. After comparison
of the dilated and original images, this function returns the coordinates</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span>
<span class="go">array([[0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 1.5, 0. , 1. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[3, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[3, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span><span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_idx</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">img2</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_idx</span>
<span class="go">array([[10, 10, 10],</span>
<span class="go">       [15, 15, 15]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_mask</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">peak_idx</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">)</span>
<span class="go">array([[10, 10, 10],</span>
<span class="go">       [15, 15, 15]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.shape_index">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">shape_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.shape_index" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the shape index.</p>
<p>The shape index, as defined by Koenderink &amp; van Doorn <a class="reference internal" href="#r7fa02a84f5a7-1" id="id106">[1]</a>, is a
single valued measure of local curvature, assuming the image as a 3D plane
with intensities representing heights.</p>
<p>It is derived from the eigenvalues of the Hessian, and its
value ranges from -1 to 1 (and is undefined (=NaN) in <em>flat</em> regions),
with following ranges representing following shapes:</p>
<table class="table" id="id357">
<caption><span class="caption-text">Ranges of the shape index and corresponding shapes.</span><a class="headerlink" href="#id357" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 59%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Interval (s in &hellip;)</p></th>
<th class="head"><p>Shape</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>[  -1, -7/8)</p></td>
<td><p>Spherical cup</p></td>
</tr>
<tr class="row-odd"><td><p>[-7/8, -5/8)</p></td>
<td><p>Through</p></td>
</tr>
<tr class="row-even"><td><p>[-5/8, -3/8)</p></td>
<td><p>Rut</p></td>
</tr>
<tr class="row-odd"><td><p>[-3/8, -1/8)</p></td>
<td><p>Saddle rut</p></td>
</tr>
<tr class="row-even"><td><p>[-1/8, +1/8)</p></td>
<td><p>Saddle</p></td>
</tr>
<tr class="row-odd"><td><p>[+1/8, +3/8)</p></td>
<td><p>Saddle ridge</p></td>
</tr>
<tr class="row-even"><td><p>[+3/8, +5/8)</p></td>
<td><p>Ridge</p></td>
</tr>
<tr class="row-odd"><td><p>[+5/8, +7/8)</p></td>
<td><p>Dome</p></td>
</tr>
<tr class="row-even"><td><p>[+7/8,   +1]</p></td>
<td><p>Spherical cap</p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used for
smoothing the input data before Hessian eigen value calculation.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>s</strong><span class="classifier">ndarray</span></dt><dd><p>Shape index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7fa02a84f5a7-1"><span class="brackets"><a class="fn-backref" href="#id106">1</a></span></dt>
<dd><p>Koenderink, J. J. &amp; van Doorn, A. J.,
&ldquo;Surface shape and curvature scales&rdquo;,
Image and Vision Computing, 1992, 10, 557-564.
<a class="reference external" href="https://doi.org/10.1016/0262-8856(92)90076-F">DOI:10.1016/0262-8856(92)90076-F</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">shape_index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">shape_index</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">array([[ nan,  nan, -0.5,  nan,  nan],</span>
<span class="go">       [ nan, -0. ,  nan, -0. ,  nan],</span>
<span class="go">       [-0.5,  nan, -1. ,  nan, -0.5],</span>
<span class="go">       [ nan, -0. ,  nan, -0. ,  nan],</span>
<span class="go">       [ nan,  nan, -0.5,  nan,  nan]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.structure_tensor">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">structure_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rc'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.structure_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Compute structure tensor using sum of squared differences.</p>
<p>The (2-dimensional) structure tensor A is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">Arr</span> <span class="n">Arc</span><span class="p">]</span>
    <span class="p">[</span><span class="n">Arc</span> <span class="n">Acc</span><span class="p">]</span>
</pre></div>
</div>
<p>which is approximated by the weighted sum of squared differences in a local
window around each pixel in the image. This formula can be extended to a
larger number of dimensions (see <a class="reference internal" href="#rdb0ba267bece-1" id="id108">[1]</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float or array-like of float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as a
weighting function for the local summation of squared differences.
If sigma is an iterable, its length must be equal to <cite>image.ndim</cite> and
each element is used for the Gaussian kernel applied along its
respective axis.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{&lsquo;rc&rsquo;, &lsquo;xy&rsquo;}, optional</span></dt><dd><p>NOTE: &lsquo;xy&rsquo; is only an option for 2D images, higher dimensions must
always use &lsquo;rc&rsquo; order. This parameter allows for the use of reverse or
forward order of the image axes in gradient computation. &lsquo;rc&rsquo; indicates
the use of the first axis initially (Arr, Arc, Acc), whilst &lsquo;xy&rsquo;
indicates the usage of the last axis initially (Axx, Axy, Ayy).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A_elems</strong><span class="classifier">list of ndarray</span></dt><dd><p>Upper-diagonal elements of the structure tensor for each pixel in the
input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.feature.structure_tensor_eigenvalues" title="cucim.skimage.feature.structure_tensor_eigenvalues"><code class="xref py py-obj docutils literal notranslate"><span class="pre">structure_tensor_eigenvalues</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rdb0ba267bece-1"><span class="brackets"><a class="fn-backref" href="#id108">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Structure_tensor">https://en.wikipedia.org/wiki/Structure_tensor</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">structure_tensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Arr</span><span class="p">,</span> <span class="n">Arc</span><span class="p">,</span> <span class="n">Acc</span> <span class="o">=</span> <span class="n">structure_tensor</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">"rc"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Acc</span>
<span class="go">array([[0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 1., 0., 1., 0.],</span>
<span class="go">       [0., 4., 0., 4., 0.],</span>
<span class="go">       [0., 1., 0., 1., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.structure_tensor_eigenvalues">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">structure_tensor_eigenvalues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A_elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.structure_tensor_eigenvalues" title="Permalink to this definition">#</a></dt>
<dd><p>Compute eigenvalues of structure tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A_elems</strong><span class="classifier">list of ndarray</span></dt><dd><p>The upper-diagonal elements of the structure tensor, as returned
by <cite>structure_tensor</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>The eigenvalues of the structure tensor, in decreasing order. The
eigenvalues are the leading dimension. That is, the coordinate
[i, j, k] corresponds to the ith-largest eigenvalue at position (j, k).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.feature.structure_tensor" title="cucim.skimage.feature.structure_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">structure_tensor</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">structure_tensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">structure_tensor_eigenvalues</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_elems</span> <span class="o">=</span> <span class="n">structure_tensor</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'rc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure_tensor_eigenvalues</span><span class="p">(</span><span class="n">A_elems</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 2., 4., 2., 0.],</span>
<span class="go">       [0., 4., 0., 4., 0.],</span>
<span class="go">       [0., 2., 4., 2., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.]])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.filters">
<span id="filters"></span><h3>filters<a class="headerlink" href="#module-cucim.skimage.filters" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.filters.LPIFilter2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">LPIFilter2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">impulse_response</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">filter_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.LPIFilter2D" title="Permalink to this definition">#</a></dt>
<dd><p>Linear Position-Invariant Filter (2-dimensional)</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(data)</p></td>
<td><p>Apply the filter to the given data.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.apply_hysteresis_threshold">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">apply_hysteresis_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.apply_hysteresis_threshold" title="Permalink to this definition">#</a></dt>
<dd><p>Apply hysteresis thresholding to <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
<p>This algorithm finds regions where <code class="docutils literal notranslate"><span class="pre">image</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">high</span></code>
OR <code class="docutils literal notranslate"><span class="pre">image</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">low</span></code> <em>and</em> that region is connected to
a region greater than <code class="docutils literal notranslate"><span class="pre">high</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array, shape (M,[ N, &hellip;, P])</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>low</strong><span class="classifier">float, or array of same shape as <code class="docutils literal notranslate"><span class="pre">image</span></code></span></dt><dd><p>Lower threshold.</p>
</dd>
<dt><strong>high</strong><span class="classifier">float, or array of same shape as <code class="docutils literal notranslate"><span class="pre">image</span></code></span></dt><dd><p>Higher threshold.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>thresholded</strong><span class="classifier">array of bool, same shape as <code class="docutils literal notranslate"><span class="pre">image</span></code></span></dt><dd><p>Array in which <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates the locations where <code class="docutils literal notranslate"><span class="pre">image</span></code>
was above the hysteresis threshold.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0a2b64cbab75-1"><span class="brackets">1</span></dt>
<dd><p>J. Canny. A computational approach to edge detection.
IEEE Transactions on Pattern Analysis and Machine Intelligence.
1986; vol. 8, pp.679-698.
<a class="reference external" href="https://doi.org/10.1109/TPAMI.1986.4767851">DOI:10.1109/TPAMI.1986.4767851</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">apply_hysteresis_threshold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_hysteresis_threshold</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([0, 1, 1, 1, 0, 0, 0, 1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.butterworth">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">butterworth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_frequency_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squared_butterworth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.butterworth" title="Permalink to this definition">#</a></dt>
<dd><p>Apply a Butterworth filter to enhance high or low frequency features.</p>
<p>This filter is defined in the Fourier domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M[, N[, &hellip;, P]][, C]) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>cutoff_frequency_ratio</strong><span class="classifier">float, optional</span></dt><dd><p>Determines the position of the cut-off relative to the shape of the
FFT. Receives a value between [0, 0.5].</p>
</dd>
<dt><strong>high_pass</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to perform a high pass filter. If False, a low pass filter is
performed.</p>
</dd>
<dt><strong>order</strong><span class="classifier">float, optional</span></dt><dd><p>Order of the filter which affects the slope near the cut-off. Higher
order means steeper slope in frequency space.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int, optional</span></dt><dd><p>If there is a channel dimension, provide the index here. If None
(default) then all axes are assumed to be spatial dimensions.</p>
</dd>
<dt><strong>squared_butterworth</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, the square of a Butterworth filter is used. See notes below
for more details.</p>
</dd>
<dt><strong>npad</strong><span class="classifier">int, optional</span></dt><dd><p>Pad each edge of the image by <cite>npad</cite> pixels using <cite>numpy.pad</cite>&rsquo;s
<code class="docutils literal notranslate"><span class="pre">mode='edge'</span></code> extension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray</span></dt><dd><p>The Butterworth-filtered image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A band-pass filter can be achieved by combining a high-pass and low-pass
filter. The user can increase <cite>npad</cite> if boundary artifacts are apparent.</p>
<p>The &ldquo;Butterworth filter&rdquo; used in image processing textbooks (e.g. <a class="reference internal" href="#r049499a62648-1" id="id111">[1]</a>,
<a class="reference internal" href="#r049499a62648-2" id="id112">[2]</a>) is often the square of the traditional Butterworth filters as
described by <a class="reference internal" href="#r049499a62648-3" id="id113">[3]</a>, <a class="reference internal" href="#r049499a62648-4" id="id114">[4]</a>. The squared version will be used here if
<cite>squared_butterworth</cite> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. The lowpass, squared Butterworth
filter is given by the following expression for the lowpass case:</p>
<div class="math notranslate nohighlight">
\[H_{low}(f) = \frac{1}{1 + \left(\frac{f}{c f_s}\right)^{2n}}\]</div>
<p>with the highpass case given by</p>
<div class="math notranslate nohighlight">
\[H_{hi}(f) = 1 - H_{low}(f)\]</div>
<p>where <span class="math notranslate nohighlight">\(f=\sqrt{\sum_{d=0}^{\mathrm{ndim}} f_{d}^{2}}\)</span> is the
absolute value of the spatial frequency, <span class="math notranslate nohighlight">\(f_s\)</span> is the sampling
frequency, <span class="math notranslate nohighlight">\(c\)</span> the <code class="docutils literal notranslate"><span class="pre">cutoff_frequency_ratio</span></code>, and <span class="math notranslate nohighlight">\(n\)</span> is the
filter <cite>order</cite> <a class="reference internal" href="#r049499a62648-1" id="id115">[1]</a>. When <code class="docutils literal notranslate"><span class="pre">squared_butterworth=False</span></code>, the square root of
the above expressions are used instead.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">cutoff_frequency_ratio</span></code> is defined in terms of the sampling
frequency, <span class="math notranslate nohighlight">\(f_s\)</span>. The FFT spectrum covers the Nyquist range
(<span class="math notranslate nohighlight">\([-f_s/2, f_s/2]\)</span>) so <code class="docutils literal notranslate"><span class="pre">cutoff_frequency_ratio</span></code> should have a value
between 0 and 0.5. The frequency response (gain) at the cutoff is 0.5 when
<code class="docutils literal notranslate"><span class="pre">squared_butterworth</span></code> is true and <span class="math notranslate nohighlight">\(1/\sqrt{2}\)</span> when it is false.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r049499a62648-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id111">1</a>,<a href="#id115">2</a>)</span></dt>
<dd><p>Russ, John C., et al. The Image Processing Handbook, 3rd. Ed.
1999, CRC Press, LLC.</p>
</dd>
<dt class="label" id="r049499a62648-2"><span class="brackets"><a class="fn-backref" href="#id112">2</a></span></dt>
<dd><p>Birchfield, Stan. Image Processing and Analysis. 2018. Cengage
Learning.</p>
</dd>
<dt class="label" id="r049499a62648-3"><span class="brackets"><a class="fn-backref" href="#id113">3</a></span></dt>
<dd><p>Butterworth, Stephen. &ldquo;On the theory of filter amplifiers.&rdquo;
Wireless Engineer 7.6 (1930): 536-541.</p>
</dd>
<dt class="label" id="r049499a62648-4"><span class="brackets"><a class="fn-backref" href="#id114">4</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Butterworth_filter">https://en.wikipedia.org/wiki/Butterworth_filter</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Apply a high pass and low-pass Butterworth filter to a grayscale and
color image respectively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span><span class="p">,</span> <span class="n">astronaut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">butterworth</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">astro</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">high_pass</span> <span class="o">=</span> <span class="n">butterworth</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">low_pass</span> <span class="o">=</span> <span class="n">butterworth</span><span class="p">(</span><span class="n">astro</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">channel_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.correlate_sparse">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">correlate_sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.correlate_sparse" title="Permalink to this definition">#</a></dt>
<dd><p>Compute valid cross-correlation of <cite>padded_array</cite> and <cite>kernel</cite>.</p>
<p>This function is <em>fast</em> when <cite>kernel</cite> is large with many zeros.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.correlate</span></code> for a description of cross-correlation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, dtype float, shape (M, N,[ &hellip;,] P)</span></dt><dd><p>The input array. If mode is &lsquo;valid&rsquo;, this array should already be
padded, as a margin of the same shape as kernel will be stripped
off.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">ndarray, dtype float shape (Q, R,[ &hellip;,] S)</span></dt><dd><p>The kernel to be correlated. Must have the same number of
dimensions as <cite>padded_array</cite>. For high performance, it should
be sparse (few nonzero entries).</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string, optional</span></dt><dd><p>See <cite>scipy.ndimage.correlate</cite> for valid modes.
Additionally, mode &lsquo;valid&rsquo; is accepted, in which case no padding is
applied and the result is the result for the smaller image for which
the kernel is entirely inside the original data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">array of float, shape (M, N,[ &hellip;,] P)</span></dt><dd><p>The result of cross-correlating <cite>image</cite> with <cite>kernel</cite>. If mode
&lsquo;valid&rsquo; is used, the resulting shape is (M-Q+1, N-R+1,[ &hellip;,] P-S+1).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.difference_of_gaussians">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">difference_of_gaussians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">truncate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.difference_of_gaussians" title="Permalink to this definition">#</a></dt>
<dd><p>Find features between <code class="docutils literal notranslate"><span class="pre">low_sigma</span></code> and <code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> in size.</p>
<p>This function uses the Difference of Gaussians method for applying
band-pass filters to multi-dimensional arrays. The input array is
blurred with two Gaussian kernels of differing sigmas to produce two
intermediate, filtered images. The more-blurred image is then subtracted
from the less-blurred image. The final output image will therefore have
had high-frequency components attenuated by the smaller-sigma Gaussian, and
low frequency components will have been removed due to their presence in
the more-blurred intermediate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input array to filter.</p>
</dd>
<dt><strong>low_sigma</strong><span class="classifier">scalar or sequence of scalars</span></dt><dd><p>Standard deviation(s) for the Gaussian kernel with the smaller sigmas
across all axes. The standard deviations are given for each axis as a
sequence, or as a single number, in which case the single number is
used as the standard deviation value for all axes.</p>
</dd>
<dt><strong>high_sigma</strong><span class="classifier">scalar or sequence of scalars, optional (default is None)</span></dt><dd><p>Standard deviation(s) for the Gaussian kernel with the larger sigmas
across all axes. The standard deviations are given for each axis as a
sequence, or as a single number, in which case the single number is
used as the standard deviation value for all axes. If None is given
(default), sigmas for all axes are calculated as 1.6 * low_sigma.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter determines how the array borders are
handled, where <code class="docutils literal notranslate"><span class="pre">cval</span></code> is the value when mode is equal to
&lsquo;constant&rsquo;. Default is &lsquo;nearest&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <code class="docutils literal notranslate"><span class="pre">mode</span></code> is &lsquo;constant&rsquo;. Default
is 0.0</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
<dt><strong>truncate</strong><span class="classifier">float, optional (default is 4.0)</span></dt><dd><p>Truncate the filter at this many standard deviations.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered_image</strong><span class="classifier">ndarray</span></dt><dd><p>the filtered array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.feature.blog_dog</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function will subtract an array filtered with a Gaussian kernel
with sigmas given by <code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> from an array filtered with a
Gaussian kernel with sigmas provided by <code class="docutils literal notranslate"><span class="pre">low_sigma</span></code>. The values for
<code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> must always be greater than or equal to the corresponding
values in <code class="docutils literal notranslate"><span class="pre">low_sigma</span></code>, or a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> is none, the values for <code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> will be
calculated as 1.6x the corresponding values in <code class="docutils literal notranslate"><span class="pre">low_sigma</span></code>. This ratio
was originally proposed by Marr and Hildreth (1980) <a class="reference internal" href="#r74659d1d36f1-1" id="id120">[1]</a> and is commonly
used when approximating the inverted Laplacian of Gaussian, which is used
in edge and blob detection.</p>
<p>Input image is converted according to the conventions of <code class="docutils literal notranslate"><span class="pre">img_as_float</span></code>.</p>
<p>Except for sigma values, all parameters are used for both filters.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r74659d1d36f1-1"><span class="brackets"><a class="fn-backref" href="#id120">1</a></span></dt>
<dd><p>Marr, D. and Hildreth, E. Theory of Edge Detection. Proc. R. Soc.
Lond. Series B 207, 187-217 (1980).
<a class="reference external" href="https://doi.org/10.1098/rspb.1980.0020">https://doi.org/10.1098/rspb.1980.0020</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Apply a simple Difference of Gaussians filter to a color image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">astronaut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">difference_of_gaussians</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">astro</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_image</span> <span class="o">=</span> <span class="n">difference_of_gaussians</span><span class="p">(</span><span class="n">astro</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">channel_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply a Laplacian of Gaussian filter as approximated by the Difference
of Gaussians filter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_image</span> <span class="o">=</span> <span class="n">difference_of_gaussians</span><span class="p">(</span><span class="n">astro</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">channel_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply a Difference of Gaussians filter to a grayscale image using different
sigma values for each axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_image</span> <span class="o">=</span> <span class="n">difference_of_gaussians</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.farid">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">farid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.farid" title="Permalink to this definition">#</a></dt>
<dd><p>Find the edge magnitude using the Farid transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">cp.ndarray</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">cp.ndarray of bool, optional</span></dt><dd><p>Clip the output image to this mask. (Values where mask=0 will be set
to 0.)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>Compute the edge filter along this axis. If not provided, the edge
magnitude is computed. This is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">farid_mag</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">farid</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
<p>The magnitude is also computed if axis is a sequence.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or sequence of str, optional</span></dt><dd><p>The boundary mode for the convolution. See <cite>scipy.ndimage.convolve</cite>
for a description of the modes. This can be either a single boundary
mode or one boundary mode per axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>When <cite>mode</cite> is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>, this is the constant used in values
outside the boundary of the image data.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>&mdash;&mdash;-</strong></dt><dd></dd>
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Farid edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.farid_h" title="cucim.skimage.filters.farid_h"><code class="xref py py-obj docutils literal notranslate"><span class="pre">farid_h</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.farid_v" title="cucim.skimage.filters.farid_v"><code class="xref py py-obj docutils literal notranslate"><span class="pre">farid_v</span></code></a></dt><dd><p>horizontal and vertical edge detection.</p>
</dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.scharr" title="cucim.skimage.filters.scharr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.sobel" title="cucim.skimage.filters.sobel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.prewitt" title="cucim.skimage.filters.prewitt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt</span></code></a>, <a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.feature.html#skimage.feature.canny" title="(in skimage v0.19.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.feature.canny</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Take the square root of the sum of the squares of the horizontal and
vertical derivatives to get a magnitude that is somewhat insensitive to
direction. Similar to the Scharr operator, this operator is designed with
a rotation invariance constraint.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra08ed50a2f42-1"><span class="brackets">1</span></dt>
<dd><p>Farid, H. and Simoncelli, E. P., &ldquo;Differentiation of discrete
multidimensional signals&rdquo;, IEEE Transactions on Image Processing
13(4): 496-508, 2004. <a class="reference external" href="https://doi.org/10.1109/TIP.2004.823819">DOI:10.1109/TIP.2004.823819</a></p>
</dd>
<dt class="label" id="ra08ed50a2f42-2"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, &ldquo;Farid and Simoncelli Derivatives.&rdquo; Available at:
&lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Image_derivatives#Farid_and_Simoncelli_Derivatives">https://en.wikipedia.org/wiki/Image_derivatives#Farid_and_Simoncelli_Derivatives</a>&gt;</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">farid</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.farid_h">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">farid_h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.farid_h" title="Permalink to this definition">#</a></dt>
<dd><p>Find the horizontal edges of an image using the Farid transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Farid edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The kernel was constructed using the 5-tap weights from [1].</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd99656444817-1"><span class="brackets">1</span></dt>
<dd><p>Farid, H. and Simoncelli, E. P., &ldquo;Differentiation of discrete
multidimensional signals&rdquo;, IEEE Transactions on Image Processing
13(4): 496-508, 2004. <a class="reference external" href="https://doi.org/10.1109/TIP.2004.823819">DOI:10.1109/TIP.2004.823819</a></p>
</dd>
<dt class="label" id="rd99656444817-2"><span class="brackets">2</span></dt>
<dd><p>Farid, H. and Simoncelli, E. P. &ldquo;Optimally rotation-equivariant
directional derivative kernels&rdquo;, In: 7th International Conference on
Computer Analysis of Images and Patterns, Kiel, Germany. Sep, 1997.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.farid_v">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">farid_v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.farid_v" title="Permalink to this definition">#</a></dt>
<dd><p>Find the vertical edges of an image using the Farid transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Farid edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The kernel was constructed using the 5-tap weights from [1].</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd34cbb689d76-1"><span class="brackets">1</span></dt>
<dd><p>Farid, H. and Simoncelli, E. P., &ldquo;Differentiation of discrete
multidimensional signals&rdquo;, IEEE Transactions on Image Processing
13(4): 496-508, 2004. <a class="reference external" href="https://doi.org/10.1109/TIP.2004.823819">DOI:10.1109/TIP.2004.823819</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.filter_inverse">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">filter_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impulse_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predefined_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.filter_inverse" title="Permalink to this definition">#</a></dt>
<dd><p>Apply the filter in reverse to the given data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>impulse_response</strong><span class="classifier">callable <cite>f(r, c, **filter_params)</cite></span></dt><dd><p>Impulse response of the filter.  See LPIFilter2D.__init__.</p>
</dd>
<dt><strong>filter_params</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword parameters to the impulse_response function.</p>
</dd>
<dt><strong>max_gain</strong><span class="classifier">float</span></dt><dd><p>Limit the filter gain.  Often, the filter contains zeros, which would
cause the inverse filter to have infinite gain.  High gain causes
amplification of artefacts, so a conservative limit is recommended.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>predefined_filter</strong><span class="classifier">LPIFilter2D</span></dt><dd><p>If you need to apply the same filter multiple times over different
images, construct the LPIFilter2D and specify it here.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.frangi">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">frangi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_ridges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.frangi" title="Permalink to this definition">#</a></dt>
<dd><p>Filter an image with the Frangi vesselness filter.</p>
<p>This filter can be used to detect continuous ridges, e.g. vessels,
wrinkles, rivers. It can be used to calculate the fraction of the
whole image containing such objects.</p>
<p>Defined only for 2-D and 3-D images. Calculates the eigenvectors of the
Hessian to compute the similarity of an image region to vessels, according
to the method described in <a class="reference internal" href="#ree817c6d0d46-1" id="id127">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Array with input image data.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Sigmas used as scales of filter, i.e.,
np.arange(scale_range[0], scale_range[1], scale_step)</p>
</dd>
<dt><strong>scale_range</strong><span class="classifier">2-tuple of floats, optional</span></dt><dd><p>The range of sigmas used.</p>
</dd>
<dt><strong>scale_step</strong><span class="classifier">float, optional</span></dt><dd><p>Step size between sigmas.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to deviation from a plate-like structure.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to deviation from a blob-like structure.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to areas of high variance/texture/structure.
The default, None, uses half of the maximum Hessian norm.</p>
</dd>
<dt><strong>black_ridges</strong><span class="classifier">boolean, optional</span></dt><dd><p>When True (the default), the filter detects black ridges; when
False, it detects white ridges.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Filtered image (maximum of pixels across all scales).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.meijering" title="cucim.skimage.filters.meijering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meijering</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.sato" title="cucim.skimage.filters.sato"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sato</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.hessian" title="cucim.skimage.filters.hessian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Earlier versions of this filter were implemented by Marc Schrijver,
(November 2001), D. J. Kroon, University of Twente (May 2009) <a class="reference internal" href="#ree817c6d0d46-2" id="id128">[2]</a>, and
D. G. Ellis (January 2017) <a class="reference internal" href="#ree817c6d0d46-3" id="id129">[3]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ree817c6d0d46-1"><span class="brackets"><a class="fn-backref" href="#id127">1</a></span></dt>
<dd><p>Frangi, A. F., Niessen, W. J., Vincken, K. L., &amp; Viergever, M. A.
(1998,). Multiscale vessel enhancement filtering. In International
Conference on Medical Image Computing and Computer-Assisted
Intervention (pp. 130-137). Springer Berlin Heidelberg.
<a class="reference external" href="https://doi.org/10.1007/BFb0056195">DOI:10.1007/BFb0056195</a></p>
</dd>
<dt class="label" id="ree817c6d0d46-2"><span class="brackets"><a class="fn-backref" href="#id128">2</a></span></dt>
<dd><p>Kroon, D. J.: Hessian based Frangi vesselness filter.</p>
</dd>
<dt class="label" id="ree817c6d0d46-3"><span class="brackets"><a class="fn-backref" href="#id129">3</a></span></dt>
<dd><p>Ellis, D. G.: <a class="github reference external" href="https://github.com/ellisdg/frangi3d/tree/master/frangi">ellisdg/frangi3d</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.gabor">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">gabor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandwidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_stds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.gabor" title="Permalink to this definition">#</a></dt>
<dd><p>Return real and imaginary responses to Gabor filter.</p>
<p>The real and imaginary parts of the Gabor filter kernel are applied to the
image and the response is returned as a pair of arrays.</p>
<p>Gabor filter is a linear filter with a Gaussian kernel which is modulated
by a sinusoidal plane wave. Frequency and orientation representations of
the Gabor filter are similar to those of the human visual system.
Gabor filter banks are commonly used in computer vision and image
processing. They are especially suitable for edge detection and texture
classification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>frequency</strong><span class="classifier">float</span></dt><dd><p>Spatial frequency of the harmonic function. Specified in pixels.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float, optional</span></dt><dd><p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>
</dd>
<dt><strong>bandwidth</strong><span class="classifier">float, optional</span></dt><dd><p>The bandwidth captured by the filter. For fixed bandwidth, <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code>
and <code class="docutils literal notranslate"><span class="pre">sigma_y</span></code> will decrease with increasing frequency. This value is
ignored if <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code> and <code class="docutils literal notranslate"><span class="pre">sigma_y</span></code> are set by the user.</p>
</dd>
<dt><strong>sigma_x, sigma_y</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation in x- and y-directions. These directions apply to
the kernel <em>before</em> rotation. If <cite>theta = pi/2</cite>, then the kernel is
rotated 90 degrees so that <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code> controls the <em>vertical</em>
direction.</p>
</dd>
<dt><strong>n_stds</strong><span class="classifier">scalar, optional</span></dt><dd><p>The linear size of the kernel is n_stds (3 by default) standard
deviations.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">float, optional</span></dt><dd><p>Phase offset of harmonic function in radians.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;reflect&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Mode used to convolve image with a kernel, passed to <cite>ndi.convolve</cite></p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <code class="docutils literal notranslate"><span class="pre">mode</span></code> of convolution is
&lsquo;constant&rsquo;. The parameter is passed to <cite>ndi.convolve</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>real, imag</strong><span class="classifier">arrays</span></dt><dd><p>Filtered images using the real and imaginary parts of the Gabor filter
kernel. Images are of the same dimensions as the input one.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4de53cce5cad-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Gabor_filter">https://en.wikipedia.org/wiki/Gabor_filter</a></p>
</dd>
<dt class="label" id="r4de53cce5cad-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf">https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">gabor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># detecting edges in a coin image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt_real</span><span class="p">,</span> <span class="n">filt_imag</span> <span class="o">=</span> <span class="n">gabor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>                        
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">filt_real</span><span class="p">))</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                           
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># less sensitivity to finer details with the lower frequency kernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt_real</span><span class="p">,</span> <span class="n">filt_imag</span> <span class="o">=</span> <span class="n">gabor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>                       
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">filt_real</span><span class="p">)</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                          
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.gabor_kernel">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">gabor_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandwidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_stds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">float_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.gabor_kernel" title="Permalink to this definition">#</a></dt>
<dd><p>Return complex 2D Gabor filter kernel.</p>
<p>Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.
Harmonic function consists of an imaginary sine function and a real
cosine function. Spatial frequency is inversely proportional to the
wavelength of the harmonic and to the standard deviation of a Gaussian
kernel. The bandwidth is also inversely proportional to the standard
deviation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frequency</strong><span class="classifier">float</span></dt><dd><p>Spatial frequency of the harmonic function. Specified in pixels.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float, optional</span></dt><dd><p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>
</dd>
<dt><strong>bandwidth</strong><span class="classifier">float, optional</span></dt><dd><p>The bandwidth captured by the filter. For fixed bandwidth, <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code>
and <code class="docutils literal notranslate"><span class="pre">sigma_y</span></code> will decrease with increasing frequency. This value is
ignored if <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code> and <code class="docutils literal notranslate"><span class="pre">sigma_y</span></code> are set by the user.</p>
</dd>
<dt><strong>sigma_x, sigma_y</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation in x- and y-directions. These directions apply to
the kernel <em>before</em> rotation. If <cite>theta = pi/2</cite>, then the kernel is
rotated 90 degrees so that <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code> controls the <em>vertical</em>
direction.</p>
</dd>
<dt><strong>n_stds</strong><span class="classifier">scalar, optional</span></dt><dd><p>The linear size of the kernel is n_stds (3 by default) standard
deviations</p>
</dd>
<dt><strong>offset</strong><span class="classifier">float, optional</span></dt><dd><p>Phase offset of harmonic function in radians.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">{np.complex64, np.complex128}</span></dt><dd><p>Specifies if the filter is single or double precision complex.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g</strong><span class="classifier">complex array</span></dt><dd><p>Complex filter kernel.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0f4330e36c94-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Gabor_filter">https://en.wikipedia.org/wiki/Gabor_filter</a></p>
</dd>
<dt class="label" id="r0f4330e36c94-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf">https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">gabor_kernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">gabor_kernel</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>                    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">gk</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                       
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># more ripples (equivalent to increasing the size of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Gaussian spread)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">gabor_kernel</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>                    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">gk</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                       
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.gaussian">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode='nearest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">truncate=4.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis=&lt;ChannelAxisNotSet&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.gaussian" title="Permalink to this definition">#</a></dt>
<dd><p>Multi-dimensional Gaussian filter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array-like</span></dt><dd><p>Input image (grayscale or color) to filter.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">scalar or sequence of scalars, optional</span></dt><dd><p>Standard deviation for Gaussian kernel. The standard
deviations of the Gaussian filter are given for each axis as a
sequence, or as a single number, in which case it is equal for
all axes.</p>
</dd>
<dt><strong>output</strong><span class="classifier">array, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">output</span></code> parameter passes an array in which to store the
filter output.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter determines how the array borders are
handled, where <code class="docutils literal notranslate"><span class="pre">cval</span></code> is the value when mode is equal to
&lsquo;constant&rsquo;. Default is &lsquo;nearest&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <code class="docutils literal notranslate"><span class="pre">mode</span></code> is &lsquo;constant&rsquo;. Default
is 0.0</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <code class="docutils literal notranslate"><span class="pre">img_as_float</span></code>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>truncate</strong><span class="classifier">float, optional</span></dt><dd><p>Truncate the filter at this many standard deviations.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Automatic detection of the color channel based on the old deprecated
<code class="docutils literal notranslate"><span class="pre">multichannel=None</span></code> was broken in version 0.19. In 0.20 this
behavior is recovered. The last axis of an <cite>image</cite> with dimensions
(M, N, 3) is interpreted as a color channel if <cite>channel_axis</cite> is
not set. Starting with 2023.03.06, <code class="docutils literal notranslate"><span class="pre">channel_axis=None</span></code> will be
used as the new default value.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered_image</strong><span class="classifier">ndarray</span></dt><dd><p>the filtered array</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is a wrapper around <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.ndi.gaussian_filter()</span></code>.</p>
<p>Integer arrays are converted to float.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">output</span></code> should be floating point data type since gaussian converts
to float provided <code class="docutils literal notranslate"><span class="pre">image</span></code>. If <code class="docutils literal notranslate"><span class="pre">output</span></code> is not provided, another array
will be allocated and returned as the result.</p>
<p>The multi-dimensional filter is implemented as a sequence of
one-dimensional convolution filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for output
types with a limited precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0., 0., 0.],</span>
<span class="go">       [0., 1., 0.],</span>
<span class="go">       [0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>  <span class="c1"># mild smoothing</span>
<span class="go">array([[0.00163116, 0.03712502, 0.00163116],</span>
<span class="go">       [0.03712502, 0.84496158, 0.03712502],</span>
<span class="go">       [0.00163116, 0.03712502, 0.00163116]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># more smoothing</span>
<span class="go">array([[0.05855018, 0.09653293, 0.05855018],</span>
<span class="go">       [0.09653293, 0.15915589, 0.09653293],</span>
<span class="go">       [0.05855018, 0.09653293, 0.05855018]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Several modes are possible for handling boundaries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'reflect'</span><span class="p">)</span>
<span class="go">array([[0.08767308, 0.12075024, 0.08767308],</span>
<span class="go">       [0.12075024, 0.16630671, 0.12075024],</span>
<span class="go">       [0.08767308, 0.12075024, 0.08767308]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># For RGB images, each is filtered separately</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">astronaut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_img</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">channel_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.hessian">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_ridges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.hessian" title="Permalink to this definition">#</a></dt>
<dd><p>Filter an image with the Hybrid Hessian filter.</p>
<p>This filter can be used to detect continuous edges, e.g. vessels,
wrinkles, rivers. It can be used to calculate the fraction of the whole
image containing such objects.</p>
<p>Defined only for 2-D and 3-D images. Almost equal to Frangi filter, but
uses alternative method of smoothing. Refer to <a class="reference internal" href="#r664d4133c7b0-1" id="id137">[1]</a> to find the differences
between Frangi and Hessian filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Array with input image data.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Sigmas used as scales of filter, i.e.,
np.arange(scale_range[0], scale_range[1], scale_step)</p>
</dd>
<dt><strong>scale_range</strong><span class="classifier">2-tuple of floats, optional</span></dt><dd><p>The range of sigmas used.</p>
</dd>
<dt><strong>scale_step</strong><span class="classifier">float, optional</span></dt><dd><p>Step size between sigmas.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to deviation from a blob-like structure.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to areas of high variance/texture/structure.</p>
</dd>
<dt><strong>black_ridges</strong><span class="classifier">boolean, optional</span></dt><dd><p>When True (the default), the filter detects black ridges; when
False, it detects white ridges.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Filtered image (maximum of pixels across all scales).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.meijering" title="cucim.skimage.filters.meijering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meijering</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.sato" title="cucim.skimage.filters.sato"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sato</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.frangi" title="cucim.skimage.filters.frangi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frangi</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Written by Marc Schrijver (November 2001)
Re-Written by D. J. Kroon University of Twente (May 2009) <a class="reference internal" href="#r664d4133c7b0-2" id="id138">[2]</a></p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r664d4133c7b0-1"><span class="brackets"><a class="fn-backref" href="#id137">1</a></span></dt>
<dd><p>Ng, C. C., Yap, M. H., Costen, N., &amp; Li, B. (2014,). Automatic
wrinkle detection using hybrid Hessian filter. In Asian Conference on
Computer Vision (pp. 609-622). Springer International Publishing.
<a class="reference external" href="https://doi.org/10.1007/978-3-319-16811-1_40">DOI:10.1007/978-3-319-16811-1_40</a></p>
</dd>
<dt class="label" id="r664d4133c7b0-2"><span class="brackets"><a class="fn-backref" href="#id138">2</a></span></dt>
<dd><p>Kroon, D. J.: Hessian based Frangi vesselness filter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.laplace">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">laplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ksize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.laplace" title="Permalink to this definition">#</a></dt>
<dd><p>Find the edges of an image using the Laplace operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>ksize</strong><span class="classifier">int, optional</span></dt><dd><p>Define the size of the discrete Laplacian operator such that it
will have a size of (ksize,) * image.ndim.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>The Laplace edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Laplacian operator is generated using the function
skimage.restoration.uft.laplacian().</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.median">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">behavior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ndimage'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.median" title="Permalink to this definition">#</a></dt>
<dd><p>Return local median of an image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array-like</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, tuple of int, or None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">footprint</span></code> will be a N-D array with 3 elements for each
dimension (e.g., vector, square, cube, etc.). If <cite>footprint</cite> is a
tuple of integers, it will be an array of ones with the given shape.
Otherwise, if <code class="docutils literal notranslate"><span class="pre">behavior=='rank'</span></code>, <code class="docutils literal notranslate"><span class="pre">footprint</span></code> is a 2-D array of 1&rsquo;s
and 0&rsquo;s. If <code class="docutils literal notranslate"><span class="pre">behavior=='ndimage'</span></code>, <code class="docutils literal notranslate"><span class="pre">footprint</span></code> is a N-D array of
1&rsquo;s and 0&rsquo;s with the same number of dimension as <code class="docutils literal notranslate"><span class="pre">image</span></code>.
Note that upstream scikit-image currently does not support supplying
a tuple for <cite>footprint</cite>. It is added here to avoid overhead of
generating a small weights array in cases where it is not needed.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, (same dtype as image), optional</span></dt><dd><p>If None, a new array is allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;,&rsquo;&lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
<code class="docutils literal notranslate"><span class="pre">cval</span></code> is the value when mode is equal to &lsquo;constant&rsquo;.
Default is &lsquo;nearest&rsquo;.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.15: </span><code class="docutils literal notranslate"><span class="pre">mode</span></code> is used when <code class="docutils literal notranslate"><span class="pre">behavior='ndimage'</span></code>.</p>
</div>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;. Default is 0.0</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.15: </span><code class="docutils literal notranslate"><span class="pre">cval</span></code> was added in 0.15 is used when <code class="docutils literal notranslate"><span class="pre">behavior='ndimage'</span></code>.</p>
</div>
</dd>
<dt><strong>behavior</strong><span class="classifier">{&lsquo;ndimage&rsquo;, &lsquo;rank&rsquo;}, optional</span></dt><dd><p>Either to use the old behavior (i.e., &lt; 0.15) or the new behavior.
The old behavior will call the <a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.filters.rank.html#skimage.filters.rank.median" title="(in skimage v0.19.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.filters.rank.median()</span></code></a>.
The new behavior will call the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter" title="(in SciPy v1.10.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.ndimage.median_filter()</span></code></a>.
Default is &lsquo;ndimage&rsquo;.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.15: </span><code class="docutils literal notranslate"><span class="pre">behavior</span></code> is introduced in 0.15</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>Default <code class="docutils literal notranslate"><span class="pre">behavior</span></code> has been changed from &lsquo;rank&rsquo; to &lsquo;ndimage&rsquo;</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">2-D array (same dtype as input image)</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>algorithm</strong><span class="classifier">{&lsquo;auto&rsquo;, &lsquo;histogram&rsquo;, &lsquo;sorting&rsquo;}</span></dt><dd><p>Determines which algorithm is used to compute the median. The default
of &lsquo;auto&rsquo; will attempt to use a histogram-based algorithm for 2D
images with 8 or 16-bit integer data types. Otherwise a sorting-based
algorithm will be used. Note: this paramter is cuCIM-specific and does
not exist in upstream scikit-image.</p>
</dd>
<dt><strong>algorithm_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Any additional algorithm-specific keywords. Currently can only be used
to set the number of parallel partitions for the &lsquo;histogram&rsquo; algorithm.
(e.g. <code class="docutils literal notranslate"><span class="pre">algorithm_kwargs={'partitions':</span> <span class="pre">256}</span></code>). Note: this paramter is
cuCIM-specific and does not exist in upstream scikit-image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.filters.rank.html#skimage.filters.rank.median" title="(in skimage v0.19.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.filters.rank.median()</span></code></a></dt><dd><p>Rank-based implementation of the median filtering offering more flexibility with additional parameters but dedicated for unsigned integer images.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>An efficient, histogram-based median filter as described in <a class="reference internal" href="#rbe7f7d88d1ca-1" id="id141">[1]</a> is faster
than the sorting based approach for larger kernel sizes (e.g. greater than
13x13 or so in 2D). It has near-constant run time regardless of the kernel
size. The algorithm presented in <a class="reference internal" href="#rbe7f7d88d1ca-1" id="id142">[1]</a> has been adapted to additional bit
depths here. When algorithm=&rsquo;auto&rsquo;, the histogram-based algorithm will be
chosen for integer-valued images with sufficiently large footprint size.
Otherwise, the sorting-based approach is used.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbe7f7d88d1ca-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id141">1</a>,<a href="#id142">2</a>)</span></dt>
<dd><p>O. Green, &ldquo;Efficient Scalable Median Filtering Using Histogram-Based
Operations,&rdquo; in IEEE Transactions on Image Processing, vol. 27, no. 5,
pp. 2217-2228, May 2018, <a class="reference external" href="https://doi.org/10.1109/TIP.2017.2781375">https://doi.org/10.1109/TIP.2017.2781375</a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">median</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">med</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">disk</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.meijering">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">meijering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_ridges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.meijering" title="Permalink to this definition">#</a></dt>
<dd><p>Filter an image with the Meijering neuriteness filter.</p>
<p>This filter can be used to detect continuous ridges, e.g. neurites,
wrinkles, rivers. It can be used to calculate the fraction of the
whole image containing such objects.</p>
<p>Calculates the eigenvectors of the Hessian to compute the similarity of
an image region to neurites, according to the method described in <a class="reference internal" href="#r5ebf02c24e78-1" id="id144">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Array with input image data.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Sigmas used as scales of filter</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Shaping filter constant, that selects maximally flat elongated
features.  The default, None, selects the optimal value -1/(ndim+1).</p>
</dd>
<dt><strong>black_ridges</strong><span class="classifier">boolean, optional</span></dt><dd><p>When True (the default), the filter detects black ridges; when
False, it detects white ridges.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Filtered image (maximum of pixels across all scales).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.sato" title="cucim.skimage.filters.sato"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sato</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.frangi" title="cucim.skimage.filters.frangi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frangi</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.hessian" title="cucim.skimage.filters.hessian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5ebf02c24e78-1"><span class="brackets"><a class="fn-backref" href="#id144">1</a></span></dt>
<dd><p>Meijering, E., Jacob, M., Sarria, J. C., Steiner, P., Hirling, H.,
Unser, M. (2004). Design and validation of a tool for neurite tracing
and analysis in fluorescence microscopy images. Cytometry Part A,
58(2), 167-176.
<a class="reference external" href="https://doi.org/10.1002/cyto.a.20022">DOI:10.1002/cyto.a.20022</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.prewitt">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">prewitt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.prewitt" title="Permalink to this definition">#</a></dt>
<dd><p>Find the edge magnitude using the Prewitt transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array of bool, optional</span></dt><dd><p>Clip the output image to this mask. (Values where mask=0 will be set
to 0.)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>Compute the edge filter along this axis. If not provided, the edge
magnitude is computed. This is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prw_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">prewitt</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
<p>The magnitude is also computed if axis is a sequence.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or sequence of str, optional</span></dt><dd><p>The boundary mode for the convolution. See <cite>scipy.ndimage.convolve</cite>
for a description of the modes. This can be either a single boundary
mode or one boundary mode per axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>When <cite>mode</cite> is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>, this is the constant used in values
outside the boundary of the image data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array of float</span></dt><dd><p>The Prewitt edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.prewitt_h" title="cucim.skimage.filters.prewitt_h"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt_h</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.prewitt_v" title="cucim.skimage.filters.prewitt_v"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt_v</span></code></a></dt><dd><p>horizontal and vertical edge detection.</p>
</dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.sobel" title="cucim.skimage.filters.sobel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.scharr" title="cucim.skimage.filters.scharr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.farid" title="cucim.skimage.filters.farid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">farid</span></code></a>, <a class="reference internal" href="#cucim.skimage.feature.canny" title="cucim.skimage.feature.canny"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cucim.skimage.feature.canny</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The edge magnitude depends slightly on edge directions, since the
approximation of the gradient operator by the Prewitt operator is not
completely rotation invariant. For a better rotation invariance, the Scharr
operator should be used. The Sobel operator has a better rotation
invariance than the Prewitt operator, but a worse rotation invariance than
the Scharr operator.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">prewitt</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.prewitt_h">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">prewitt_h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.prewitt_h" title="Permalink to this definition">#</a></dt>
<dd><p>Find the horizontal edges of an image using the Prewitt transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Prewitt edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
  <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
<span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.prewitt_v">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">prewitt_v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.prewitt_v" title="Permalink to this definition">#</a></dt>
<dd><p>Find the vertical edges of an image using the Prewitt transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Prewitt edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.rank_order">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">rank_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.rank_order" title="Permalink to this definition">#</a></dt>
<dd><p>Return an image of the same shape where each pixel is the
index of the pixel value in the ascending order of the unique
values of <code class="docutils literal notranslate"><span class="pre">image</span></code>, aka the rank-order value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cp.ndarray</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">cp.ndarray of unsigned integers, of shape image.shape</span></dt><dd><p>New array where each pixel has the rank-order value of the
corresponding pixel in <code class="docutils literal notranslate"><span class="pre">image</span></code>. Pixel values are between 0 and
n - 1, where n is the number of distinct unique values in
<code class="docutils literal notranslate"><span class="pre">image</span></code>. The dtype of this array will be determined by
<code class="docutils literal notranslate"><span class="pre">cp.min_scalar_type(image.size)</span></code>.</p>
</dd>
<dt><strong>original_values</strong><span class="classifier">1-D cp.ndarray</span></dt><dd><p>Unique original values of <code class="docutils literal notranslate"><span class="pre">image</span></code>. This will have the same dtype as
<code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 4, 5],</span>
<span class="go">       [4, 4, 1],</span>
<span class="go">       [5, 1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank_order</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(array([[0, 1, 2],</span>
<span class="go">       [1, 1, 0],</span>
<span class="go">       [2, 0, 0]], dtype=uint8), array([1, 4, 5]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank_order</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(array([0, 1, 2, 1], dtype=uint8), array([-1. ,  2.5,  3.1]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.roberts">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">roberts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.roberts" title="Permalink to this definition">#</a></dt>
<dd><p>Find the edge magnitude using Roberts&rsquo; cross operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Roberts&rsquo; Cross edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.roberts_pos_diag" title="cucim.skimage.filters.roberts_pos_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roberts_pos_diag</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.roberts_neg_diag" title="cucim.skimage.filters.roberts_neg_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roberts_neg_diag</span></code></a></dt><dd><p>diagonal edge detection.</p>
</dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.sobel" title="cucim.skimage.filters.sobel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.scharr" title="cucim.skimage.filters.scharr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.prewitt" title="cucim.skimage.filters.prewitt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt</span></code></a>, <a class="reference internal" href="#cucim.skimage.feature.canny" title="cucim.skimage.feature.canny"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cucim.skimage.feature.canny</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">roberts</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.roberts_neg_diag">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">roberts_neg_diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.roberts_neg_diag" title="Permalink to this definition">#</a></dt>
<dd><p>Find the cross edges of an image using the Roberts&rsquo; Cross operator.</p>
<p>The kernel is applied to the input image to produce separate measurements
of the gradient component one orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Robert&rsquo;s edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">0</span>   <span class="mi">1</span>
<span class="o">-</span><span class="mi">1</span>   <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.roberts_pos_diag">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">roberts_pos_diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.roberts_pos_diag" title="Permalink to this definition">#</a></dt>
<dd><p>Find the cross edges of an image using Roberts&rsquo; cross operator.</p>
<p>The kernel is applied to the input image to produce separate measurements
of the gradient component one orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Robert&rsquo;s edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>   <span class="mi">0</span>
<span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.sato">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">sato</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_ridges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.sato" title="Permalink to this definition">#</a></dt>
<dd><p>Filter an image with the Sato tubeness filter.</p>
<p>This filter can be used to detect continuous ridges, e.g. tubes,
wrinkles, rivers. It can be used to calculate the fraction of the
whole image containing such objects.</p>
<p>Defined only for 2-D and 3-D images. Calculates the eigenvectors of the
Hessian to compute the similarity of an image region to tubes, according to
the method described in <a class="reference internal" href="#r8b615273143c-1" id="id146">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Array with input image data.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Sigmas used as scales of filter.</p>
</dd>
<dt><strong>black_ridges</strong><span class="classifier">boolean, optional</span></dt><dd><p>When True (the default), the filter detects black ridges; when
False, it detects white ridges.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Filtered image (maximum of pixels across all scales).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.meijering" title="cucim.skimage.filters.meijering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meijering</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.frangi" title="cucim.skimage.filters.frangi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frangi</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.hessian" title="cucim.skimage.filters.hessian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8b615273143c-1"><span class="brackets"><a class="fn-backref" href="#id146">1</a></span></dt>
<dd><p>Sato, Y., Nakajima, S., Shiraga, N., Atsumi, H., Yoshida, S.,
Koller, T., &hellip;, Kikinis, R. (1998). Three-dimensional multi-scale line
filter for segmentation and visualization of curvilinear structures in
medical images. Medical image analysis, 2(2), 143-168.
<a class="reference external" href="https://doi.org/10.1016/S1361-8415(98)80009-1">DOI:10.1016/S1361-8415(98)80009-1</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.scharr">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">scharr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.scharr" title="Permalink to this definition">#</a></dt>
<dd><p>Find the edge magnitude using the Scharr transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array of bool, optional</span></dt><dd><p>Clip the output image to this mask. (Values where mask=0 will be set
to 0.)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>Compute the edge filter along this axis. If not provided, the edge
magnitude is computed. This is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sch_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">scharr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
<p>The magnitude is also computed if axis is a sequence.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or sequence of str, optional</span></dt><dd><p>The boundary mode for the convolution. See <cite>scipy.ndimage.convolve</cite>
for a description of the modes. This can be either a single boundary
mode or one boundary mode per axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>When <cite>mode</cite> is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>, this is the constant used in values
outside the boundary of the image data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array of float</span></dt><dd><p>The Scharr edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.scharr_h" title="cucim.skimage.filters.scharr_h"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr_h</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.scharr_v" title="cucim.skimage.filters.scharr_v"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr_v</span></code></a></dt><dd><p>horizontal and vertical edge detection.</p>
</dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.sobel" title="cucim.skimage.filters.sobel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.prewitt" title="cucim.skimage.filters.prewitt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.farid" title="cucim.skimage.filters.farid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">farid</span></code></a>, <a class="reference internal" href="#cucim.skimage.feature.canny" title="cucim.skimage.feature.canny"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cucim.skimage.feature.canny</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The Scharr operator has a better rotation invariance than
other edge filters such as the Sobel or the Prewitt operators.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9c83a420f26b-1"><span class="brackets">1</span></dt>
<dd><p>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</p>
</dd>
<dt class="label" id="r9c83a420f26b-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators">https://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">scharr</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.scharr_h">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">scharr_h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.scharr_h" title="Permalink to this definition">#</a></dt>
<dd><p>Find the horizontal edges of an image using the Scharr transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Scharr edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">3</span>   <span class="mi">10</span>   <span class="mi">3</span>
 <span class="mi">0</span>    <span class="mi">0</span>   <span class="mi">0</span>
<span class="o">-</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">10</span>  <span class="o">-</span><span class="mi">3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbb5b441dedec-1"><span class="brackets">1</span></dt>
<dd><p>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.scharr_v">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">scharr_v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.scharr_v" title="Permalink to this definition">#</a></dt>
<dd><p>Find the vertical edges of an image using the Scharr transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Scharr edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">3</span>   <span class="mi">0</span>   <span class="o">-</span><span class="mi">3</span>
<span class="mi">10</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">10</span>
 <span class="mi">3</span>   <span class="mi">0</span>   <span class="o">-</span><span class="mi">3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9dd5dffe382e-1"><span class="brackets">1</span></dt>
<dd><p>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.sobel">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">sobel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.sobel" title="Permalink to this definition">#</a></dt>
<dd><p>Find edges in an image using the Sobel filter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array of bool, optional</span></dt><dd><p>Clip the output image to this mask. (Values where mask=0 will be set
to 0.)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>Compute the edge filter along this axis. If not provided, the edge
magnitude is computed. This is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sobel_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">sobel</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
<p>The magnitude is also computed if axis is a sequence.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or sequence of str, optional</span></dt><dd><p>The boundary mode for the convolution. See <cite>scipy.ndimage.convolve</cite>
for a description of the modes. This can be either a single boundary
mode or one boundary mode per axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>When <cite>mode</cite> is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>, this is the constant used in values
outside the boundary of the image data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array of float</span></dt><dd><p>The Sobel edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.sobel_h" title="cucim.skimage.filters.sobel_h"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel_h</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.sobel_v" title="cucim.skimage.filters.sobel_v"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel_v</span></code></a></dt><dd><p>horizontal and vertical edge detection.</p>
</dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.scharr" title="cucim.skimage.filters.scharr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.prewitt" title="cucim.skimage.filters.prewitt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.farid" title="cucim.skimage.filters.farid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">farid</span></code></a>, <a class="reference internal" href="#cucim.skimage.feature.canny" title="cucim.skimage.feature.canny"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cucim.skimage.feature.canny</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1f13622bd12e-1"><span class="brackets">1</span></dt>
<dd><p>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</p>
</dd>
<dt class="label" id="r1f13622bd12e-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Sobel_operator">https://en.wikipedia.org/wiki/Sobel_operator</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">sobel</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.sobel_h">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">sobel_h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.sobel_h" title="Permalink to this definition">#</a></dt>
<dd><p>Find the horizontal edges of an image using the Sobel transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Sobel edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">1</span>
 <span class="mi">0</span>   <span class="mi">0</span>   <span class="mi">0</span>
<span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.sobel_v">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">sobel_v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.sobel_v" title="Permalink to this definition">#</a></dt>
<dd><p>Find the vertical edges of an image using the Sobel transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Sobel edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span>
<span class="mi">2</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">2</span>
<span class="mi">1</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_isodata">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_isodata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_isodata" title="Permalink to this definition">#</a></dt>
<dd><p>Return threshold value(s) based on ISODATA method.</p>
<p>Histogram-based threshold, known as Ridler-Calvard method or inter-means.
Threshold values returned satisfy the following equality:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">image</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span>
             <span class="n">image</span><span class="p">[</span><span class="n">image</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="mf">2.0</span>
</pre></div>
</div>
<p>That is, returned thresholds are intensities that separate the image into
two groups of pixels, where the threshold intensity is midway between the
mean intensities of these groups.</p>
<p>For integer images, the above equality holds to within one; for floating-
point images, the equality holds to within the histogram bin-width.</p>
<p>Either image or hist must be provided. In case hist is given, the actual
histogram of the image is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>return_all</strong><span class="classifier">bool, optional</span></dt><dd><p>If False (default), return only the lowest threshold that satisfies
the above equality. If True, return all valid thresholds.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram to determine the threshold from and a corresponding array
of bin center intensities. Alternatively, only the histogram can be
passed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float or int or array</span></dt><dd><p>Threshold value(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r763768fdb3d6-1"><span class="brackets">1</span></dt>
<dd><p>Ridler, TW &amp; Calvard, S (1978), &ldquo;Picture thresholding using an
iterative selection method&rdquo;
IEEE Transactions on Systems, Man and Cybernetics 8: 630-632,
<a class="reference external" href="https://doi.org/10.1109/TSMC.1978.4310039">DOI:10.1109/TSMC.1978.4310039</a></p>
</dd>
<dt class="label" id="r763768fdb3d6-2"><span class="brackets">2</span></dt>
<dd><p>Sezgin M. and Sankur B. (2004) &ldquo;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&rdquo; Journal of
Electronic Imaging, 13(1): 146-165,
<a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a>
<a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a></p>
</dd>
<dt class="label" id="r763768fdb3d6-3"><span class="brackets">3</span></dt>
<dd><p>ImageJ AutoThresholder code,
<a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">coins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coins</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_isodata</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_li">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_li</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_li" title="Permalink to this definition">#</a></dt>
<dd><p>Compute threshold value by Li&rsquo;s iterative Minimum Cross Entropy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>Finish the computation when the change in the threshold in an iteration
is less than this value. By default, this is half the smallest
difference between intensity values in <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
<dt><strong>initial_guess</strong><span class="classifier">float or Callable[[array[float]], float], optional</span></dt><dd><p>Li&rsquo;s iterative method uses gradient descent to find the optimal
threshold. If the image intensity histogram contains more than two
modes (peaks), the gradient descent could get stuck in a local optimum.
An initial guess for the iteration can help the algorithm find the
globally-optimal threshold. A float value defines a specific start
point, while a callable should take in an array of image intensities
and return a float value. Example valid callables include
<code class="docutils literal notranslate"><span class="pre">numpy.mean</span></code> (default), <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">arr:</span> <span class="pre">numpy.quantile(arr,</span> <span class="pre">0.95)</span></code>,
or even <a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.filters.html#skimage.filters.threshold_otsu" title="(in skimage v0.19.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.filters.threshold_otsu()</span></code></a>.</p>
</dd>
<dt><strong>iter_callback</strong><span class="classifier">Callable[[float], Any], optional</span></dt><dd><p>A function that will be called on the threshold at every iteration of
the algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r6bdb6acf01e9-1"><span class="brackets">1</span></dt>
<dd><p>Li C.H. and Lee C.K. (1993) &ldquo;Minimum Cross Entropy Thresholding&rdquo;
Pattern Recognition, 26(4): 617-625
<a class="reference external" href="https://doi.org/10.1016/0031-3203(93)90115-D">DOI:10.1016/0031-3203(93)90115-D</a></p>
</dd>
<dt class="label" id="r6bdb6acf01e9-2"><span class="brackets">2</span></dt>
<dd><p>Li C.H. and Tam P.K.S. (1998) &ldquo;An Iterative Algorithm for Minimum
Cross Entropy Thresholding&rdquo; Pattern Recognition Letters, 18(8): 771-776
<a class="reference external" href="https://doi.org/10.1016/S0167-8655(98)00057-9">DOI:10.1016/S0167-8655(98)00057-9</a></p>
</dd>
<dt class="label" id="r6bdb6acf01e9-3"><span class="brackets">3</span></dt>
<dd><p>Sezgin M. and Sankur B. (2004) &ldquo;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&rdquo; Journal of
Electronic Imaging, 13(1): 146-165
<a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a></p>
</dd>
<dt class="label" id="r6bdb6acf01e9-4"><span class="brackets">4</span></dt>
<dd><p>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_li</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_local">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_local</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_local" title="Permalink to this definition">#</a></dt>
<dd><p>Compute a threshold mask image based on local pixel neighborhood.</p>
<p>Also known as adaptive or dynamic thresholding. The threshold value is
the weighted mean for the local neighborhood of a pixel subtracted by a
constant. Alternatively the threshold can be determined dynamically by a
given function, using the &lsquo;generic&rsquo; method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">int or sequence of int</span></dt><dd><p>Odd size of pixel neighborhood which is used to calculate the
threshold value (e.g. 3, 5, 7, &hellip;, 21, &hellip;).</p>
</dd>
<dt><strong>method</strong><span class="classifier">{&lsquo;generic&rsquo;, &lsquo;gaussian&rsquo;, &lsquo;mean&rsquo;, &lsquo;median&rsquo;}, optional</span></dt><dd><p>Method used to determine adaptive threshold for local neighborhood in
weighted mean image.</p>
<ul class="simple">
<li><p>&lsquo;generic&rsquo;: use custom function (see <code class="docutils literal notranslate"><span class="pre">param</span></code> parameter)</p></li>
<li><p>&lsquo;gaussian&rsquo;: apply gaussian filter (see <code class="docutils literal notranslate"><span class="pre">param</span></code> parameter for custom                      sigma value)</p></li>
<li><p>&lsquo;mean&rsquo;: apply arithmetic mean filter</p></li>
<li><p>&lsquo;median&rsquo;: apply median rank filter</p></li>
</ul>
<p>By default the &lsquo;gaussian&rsquo; method is used.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">float, optional</span></dt><dd><p>Constant subtracted from weighted mean of neighborhood to calculate
the local threshold value. Default offset is 0.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.
Default is &lsquo;reflect&rsquo;.</p>
</dd>
<dt><strong>param</strong><span class="classifier">{int, function}, optional</span></dt><dd><p>Either specify sigma for &lsquo;gaussian&rsquo; method or function object for
&lsquo;generic&rsquo; method. This functions takes the flat array of local
neighborhood as a single argument and returns the calculated
threshold for the centre pixel.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Threshold image. All pixels in the input image higher than the
corresponding pixel in the threshold image are considered foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r657fbacd2bc3-1"><span class="brackets">1</span></dt>
<dd><p>Gonzalez, R. C. and Wood, R. E. &ldquo;Digital Image Processing
(2nd Edition).&rdquo; Prentice-Hall Inc., 2002: 600&ndash;612.
ISBN: 0-201-18075-8</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">()[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_image1</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">threshold_local</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">'mean'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_mean">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_mean" title="Permalink to this definition">#</a></dt>
<dd><p>Return threshold value based on the mean of grayscale values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbb85261d77e3-1"><span class="brackets">1</span></dt>
<dd><p>C. A. Glasbey, &ldquo;An analysis of histogram-based thresholding
algorithms,&rdquo; CVGIP: Graphical Models and Image Processing,
vol. 55, pp. 532-537, 1993.
<a class="reference external" href="https://doi.org/10.1006/cgip.1993.1040">DOI:10.1006/cgip.1993.1040</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_mean</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_minimum">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_minimum" title="Permalink to this definition">#</a></dt>
<dd><p>Return threshold value based on minimum method.</p>
<p>The histogram of the input <code class="docutils literal notranslate"><span class="pre">image</span></code> is computed if not provided and
smoothed until there are only two maxima. Then the minimum in between is
the threshold value.</p>
<p>Either image or hist must be provided. In case hist is given, the actual
histogram of the image is ignored.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray, optional</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations to smooth the histogram.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram to determine the threshold from and a corresponding array
of bin center intensities. Alternatively, only the histogram can be
passed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>max_iter</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>max_num_iter</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If unable to find two local maxima in the histogram or if the
smoothing takes more than 1e4 iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r24ed7d67d119-1"><span class="brackets">1</span></dt>
<dd><p>C. A. Glasbey, &ldquo;An analysis of histogram-based thresholding
algorithms,&rdquo; CVGIP: Graphical Models and Image Processing,
vol. 55, pp. 532-537, 1993.</p>
</dd>
<dt class="label" id="r24ed7d67d119-2"><span class="brackets">2</span></dt>
<dd><p>Prewitt, JMS &amp; Mendelsohn, ML (1966), &ldquo;The analysis of cell
images&rdquo;, Annals of the New York Academy of Sciences 128: 1035-1053
<a class="reference external" href="https://doi.org/10.1111/j.1749-6632.1965.tb11715.x">DOI:10.1111/j.1749-6632.1965.tb11715.x</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_minimum</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_multiotsu">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_multiotsu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_multiotsu" title="Permalink to this definition">#</a></dt>
<dd><p>Generate <cite>classes</cite>-1 threshold values to divide gray levels in <cite>image</cite>,
following Otsu&rsquo;s method for multiple classes.</p>
<p>The threshold values are chosen to maximize the total sum of pairwise
variances between the thresholded graylevel classes. See Notes and <a class="reference internal" href="#r67a1a24cb955-1" id="id165">[1]</a>
for more details.</p>
<p>Either image or hist must be provided. If hist is provided, the actual
histogram of the image is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray, optional</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">int, optional</span></dt><dd><p>Number of classes to be thresholded, i.e. the number of resulting
regions.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate the histogram. This value is ignored
for integer arrays.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram from which to determine the threshold, and optionally a
corresponding array of bin center intensities. If no hist provided,
this function will compute it from the image (see notes).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>thresh</strong><span class="classifier">array</span></dt><dd><p>Array containing the threshold values for the desired classes.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">image</span></code> contains less grayscale value then the desired
number of classes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This implementation relies on a Cython function whose complexity
is <span class="math notranslate nohighlight">\(O\left(\frac{Ch^{C-1}}{(C-1)!}\right)\)</span>, where <span class="math notranslate nohighlight">\(h\)</span>
is the number of histogram bins and <span class="math notranslate nohighlight">\(C\)</span> is the number of
classes desired.</p>
<p>If no hist is given, this function will make use of
<cite>skimage.exposure.histogram</cite>, which behaves differently than
<cite>np.histogram</cite>. While both allowed, use the former for consistent
behaviour.</p>
<p>The input image must be grayscale.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r67a1a24cb955-1"><span class="brackets"><a class="fn-backref" href="#id165">1</a></span></dt>
<dd><p>Liao, P-S., Chen, T-S. and Chung, P-C., &ldquo;A fast algorithm for
multilevel thresholding&rdquo;, Journal of Information Science and
Engineering 17 (5): 713-727, 2001. Available at:
&lt;<a class="reference external" href="https://ftp.iis.sinica.edu.tw/JISE/2001/200109_01.pdf">https://ftp.iis.sinica.edu.tw/JISE/2001/200109_01.pdf</a>&gt;
<a class="reference external" href="https://doi.org/10.6688/JISE.2001.17.5.1">DOI:10.6688/JISE.2001.17.5.1</a></p>
</dd>
<dt class="label" id="r67a1a24cb955-2"><span class="brackets">2</span></dt>
<dd><p>Tosa, Y., &ldquo;Multi-Otsu Threshold&rdquo;, a java plugin for ImageJ.
Available at:
&lt;<a class="reference external" href="http://imagej.net/plugins/download/Multi_OtsuThreshold.java">http://imagej.net/plugins/download/Multi_OtsuThreshold.java</a>&gt;</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">label2rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span> <span class="o">=</span> <span class="n">threshold_multiotsu</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">thresholds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions_colorized</span> <span class="o">=</span> <span class="n">label2rgb</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_niblack">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_niblack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_niblack" title="Permalink to this definition">#</a></dt>
<dd><p>Applies Niblack local threshold to an array.</p>
<p>A threshold T is calculated for every pixel in the image using the
following formula:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>where m(x,y) and s(x,y) are the mean and standard deviation of
pixel (x,y) neighborhood defined by a rectangular window with size w
times w centered around the pixel. k is a configurable parameter
that weights the effect of standard deviation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>window_size</strong><span class="classifier">int, or iterable of int, optional</span></dt><dd><p>Window size specified as a single odd integer (3, 5, 7, &hellip;),
or an iterable of length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code> containing only odd
integers (e.g. <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">5,</span> <span class="pre">5)</span></code>).</p>
</dd>
<dt><strong>k</strong><span class="classifier">float, optional</span></dt><dd><p>Value of parameter k in threshold formula.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Threshold mask. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This algorithm is originally designed for text recognition.</p>
<p>The Bradley threshold is a particular case of the Niblack
one, being equivalent to</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">page</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">threshold_image</span> <span class="o">=</span> <span class="n">threshold_niblack</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span>
</pre></div>
</div>
<p>for some value <code class="docutils literal notranslate"><span class="pre">q</span></code>. By default, Bradley and Roth use <code class="docutils literal notranslate"><span class="pre">q=1</span></code>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7717d478b316-1"><span class="brackets">1</span></dt>
<dd><p>W. Niblack, An introduction to Digital Image Processing,
Prentice-Hall, 1986.</p>
</dd>
<dt class="label" id="r7717d478b316-2"><span class="brackets">2</span></dt>
<dd><p>D. Bradley and G. Roth, &ldquo;Adaptive thresholding using Integral
Image&rdquo;, Journal of Graphics Tools 12(2), pp. 13-21, 2007.
<a class="reference external" href="https://doi.org/10.1080/2151237X.2007.10129236">DOI:10.1080/2151237X.2007.10129236</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">page</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">threshold_image</span> <span class="o">=</span> <span class="n">threshold_niblack</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_otsu">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_otsu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_otsu" title="Permalink to this definition">#</a></dt>
<dd><p>Return threshold value based on Otsu&rsquo;s method.</p>
<p>Either image or hist must be provided. If hist is provided, the actual
histogram of the image is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray, optional</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram from which to determine the threshold, and optionally a
corresponding array of bin center intensities. If no hist provided,
this function will compute it from the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The input image must be grayscale.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9495d1f0443c-1"><span class="brackets">1</span></dt>
<dd><p>Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/Otsu's_Method">https://en.wikipedia.org/wiki/Otsu&rsquo;s_Method</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_otsu</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_sauvola">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_sauvola</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_sauvola" title="Permalink to this definition">#</a></dt>
<dd><p>Applies Sauvola local threshold to an array. Sauvola is a
modification of Niblack technique.</p>
<p>In the original method a threshold T is calculated for every pixel
in the image using the following formula:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="p">((</span><span class="n">s</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>where m(x,y) and s(x,y) are the mean and standard deviation of
pixel (x,y) neighborhood defined by a rectangular window with size w
times w centered around the pixel. k is a configurable parameter
that weights the effect of standard deviation.
R is the maximum standard deviation of a grayscale image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>window_size</strong><span class="classifier">int, or iterable of int, optional</span></dt><dd><p>Window size specified as a single odd integer (3, 5, 7, &hellip;),
or an iterable of length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code> containing only odd
integers (e.g. <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">5,</span> <span class="pre">5)</span></code>).</p>
</dd>
<dt><strong>k</strong><span class="classifier">float, optional</span></dt><dd><p>Value of the positive parameter k.</p>
</dd>
<dt><strong>r</strong><span class="classifier">float, optional</span></dt><dd><p>Value of R, the dynamic range of standard deviation.
If None, set to the half of the image dtype range.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Threshold mask. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This algorithm is originally designed for text recognition.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r44c24a249523-1"><span class="brackets">1</span></dt>
<dd><p>J. Sauvola and M. Pietikainen, &ldquo;Adaptive document image
binarization,&rdquo; Pattern Recognition 33(2),
pp. 225-236, 2000.
<a class="reference external" href="https://doi.org/10.1016/S0031-3203(99)00055-2">DOI:10.1016/S0031-3203(99)00055-2</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">page</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_sauvola</span> <span class="o">=</span> <span class="n">threshold_sauvola</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">t_sauvola</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_triangle">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_triangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_triangle" title="Permalink to this definition">#</a></dt>
<dd><p>Return threshold value based on the triangle algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r22136cd60ce5-1"><span class="brackets">1</span></dt>
<dd><p>Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,
Automatic Measurement of Sister Chromatid Exchange Frequency,
Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753
<a class="reference external" href="https://doi.org/10.1177/25.7.70454">DOI:10.1177/25.7.70454</a></p>
</dd>
<dt class="label" id="r22136cd60ce5-2"><span class="brackets">2</span></dt>
<dd><p>ImageJ AutoThresholder code,
<a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_triangle</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_yen">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_yen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_yen" title="Permalink to this definition">#</a></dt>
<dd><p>Return threshold value based on Yen&rsquo;s method.
Either image or hist must be provided. In case hist is given, the actual
histogram of the image is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram from which to determine the threshold, and optionally a
corresponding array of bin center intensities.
An alternative use of this function is to pass it only hist.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r32f25fa7ee23-1"><span class="brackets">1</span></dt>
<dd><p>Yen J.C., Chang F.J., and Chang S. (1995) &ldquo;A New Criterion
for Automatic Multilevel Thresholding&rdquo; IEEE Trans. on Image
Processing, 4(3): 370-378. <a class="reference external" href="https://doi.org/10.1109/83.366472">DOI:10.1109/83.366472</a></p>
</dd>
<dt class="label" id="r32f25fa7ee23-2"><span class="brackets">2</span></dt>
<dd><p>Sezgin M. and Sankur B. (2004) &ldquo;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&rdquo; Journal of
Electronic Imaging, 13(1): 146-165, <a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a>
<a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a></p>
</dd>
<dt class="label" id="r32f25fa7ee23-3"><span class="brackets">3</span></dt>
<dd><p>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_yen</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.try_all_threshold">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">try_all_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">5)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.try_all_threshold" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a figure comparing the outputs of different thresholding methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">tuple, optional</span></dt><dd><p>Figure size (in inches).</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>Print function name for each method.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>Matplotlib figure and axes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The following algorithms are used:</p>
<ul class="simple">
<li><p>isodata</p></li>
<li><p>li</p></li>
<li><p>mean</p></li>
<li><p>minimum</p></li>
<li><p>otsu</p></li>
<li><p>triangle</p></li>
<li><p>yen</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text_img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">text</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">try_all_threshold</span><span class="p">(</span><span class="n">text_img</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.unsharp_mask">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">unsharp_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amount</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.unsharp_mask" title="Permalink to this definition">#</a></dt>
<dd><p>Unsharp masking filter.</p>
<p>The sharp details are identified as the difference between the original
image and its blurred version. These details are then scaled, and added
back to the original image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">[P, &hellip;, ]M[, N][, C] ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">scalar or sequence of scalars, optional</span></dt><dd><p>If a scalar is given, then its value is used for all dimensions.
If sequence is given, then there must be exactly one radius
for each dimension except the last dimension for multichannel images.
Note that 0 radius means no blurring, and negative values are
not allowed.</p>
</dd>
<dt><strong>amount</strong><span class="classifier">scalar, optional</span></dt><dd><p>The details will be amplified with this factor. The factor could be 0
or negative. Typically, it is a small positive number, e.g. 1.0.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <code class="docutils literal notranslate"><span class="pre">img_as_float</span></code>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">[P, &hellip;, ]M[, N][, C] ndarray of float</span></dt><dd><p>Image with unsharp mask applied.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Unsharp masking is an image sharpening technique. It is a linear image
operation, and numerically stable, unlike deconvolution which is an
ill-posed problem. Because of this stability, it is often
preferred over deconvolution.</p>
<p>The main idea is as follows: sharp details are identified as the
difference between the original image and its blurred version.
These details are added back to the original image after a scaling step:</p>
<blockquote>
<div><p>enhanced image = original + amount * (original - blurred)</p>
</div></blockquote>
<p>When applying this filter to several color layers independently,
color bleeding may occur. More visually pleasing result can be
achieved by processing only the brightness/lightness/intensity
channel in a suitable color space such as HSV, HSL, YUV, or YCbCr.</p>
<p>Unsharp masking is described in most introductory digital image
processing books. This implementation is based on <a class="reference internal" href="#r82e4adc9e646-1" id="id177">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r82e4adc9e646-1"><span class="brackets"><a class="fn-backref" href="#id177">1</a></span></dt>
<dd><p>Maria Petrou, Costas Petrou
&ldquo;Image Processing: The Fundamentals&rdquo;, (2010), ed ii., page 357,
ISBN 13: 9781119994398  <a class="reference external" href="https://doi.org/10.1002/9781119994398">DOI:10.1002/9781119994398</a></p>
</dd>
<dt class="label" id="r82e4adc9e646-2"><span class="brackets">2</span></dt>
<dd><p>Wikipedia. Unsharp masking
<a class="reference external" href="https://en.wikipedia.org/wiki/Unsharp_masking">https://en.wikipedia.org/wiki/Unsharp_masking</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span>
<span class="go">array([[100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 120, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">unsharp_mask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0.39, 0.39, 0.39, 0.39, 0.39],</span>
<span class="go">       [0.39, 0.39, 0.38, 0.39, 0.39],</span>
<span class="go">       [0.39, 0.38, 0.53, 0.38, 0.39],</span>
<span class="go">       [0.39, 0.39, 0.38, 0.39, 0.39],</span>
<span class="go">       [0.39, 0.39, 0.39, 0.39, 0.39]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">127</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">unsharp_mask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0.79, 0.79, 0.79, 0.79, 0.79],</span>
<span class="go">       [0.79, 0.78, 0.75, 0.78, 0.79],</span>
<span class="go">       [0.79, 0.75, 1.  , 0.75, 0.79],</span>
<span class="go">       [0.79, 0.78, 0.75, 0.78, 0.79],</span>
<span class="go">       [0.79, 0.79, 0.79, 0.79, 0.79]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">unsharp_mask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="gp">... </span>          <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[100.  , 100.  ,  99.99, 100.  , 100.  ],</span>
<span class="go">       [100.  ,  99.39,  95.48,  99.39, 100.  ],</span>
<span class="go">       [ 99.99,  95.48, 147.59,  95.48,  99.99],</span>
<span class="go">       [100.  ,  99.39,  95.48,  99.39, 100.  ],</span>
<span class="go">       [100.  , 100.  ,  99.99, 100.  , 100.  ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.wiener">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impulse_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predefined_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.wiener" title="Permalink to this definition">#</a></dt>
<dd><p>Minimum Mean Square Error (Wiener) inverse filter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">(M,N) ndarray</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>K</strong><span class="classifier">float or (M,N) ndarray</span></dt><dd><p>Ratio between power spectrum of noise and undegraded
image.</p>
</dd>
<dt><strong>impulse_response</strong><span class="classifier">callable <cite>f(r, c, **filter_params)</cite></span></dt><dd><p>Impulse response of the filter.  See LPIFilter2D.__init__.</p>
</dd>
<dt><strong>filter_params</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword parameters to the impulse_response function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>predefined_filter</strong><span class="classifier">LPIFilter2D</span></dt><dd><p>If you need to apply the same filter multiple times over different
images, construct the LPIFilter2D and specify it here.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.window">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warp_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.window" title="Permalink to this definition">#</a></dt>
<dd><p>Return an n-dimensional window of a given size and dimensionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window_type</strong><span class="classifier">string, float, or tuple</span></dt><dd><p>The type of window to be created. Any window type supported by
<code class="docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code> is allowed here. See notes below for a
current list, or the SciPy documentation for the version of SciPy
on your machine.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple of int or int</span></dt><dd><p>The shape of the window along each axis. If an integer is provided,
a 1D window is generated.</p>
</dd>
<dt><strong>warp_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed to <cite>skimage.transform.warp</cite> (e.g.,
<code class="docutils literal notranslate"><span class="pre">warp_kwargs={'order':3}</span></code> to change interpolation method).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nd_window</strong><span class="classifier">ndarray</span></dt><dd><p>A window of the specified <code class="docutils literal notranslate"><span class="pre">shape</span></code>. <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is <code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is based on <code class="docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code> and thus can access
all of the window types available to that function
(e.g., <code class="docutils literal notranslate"><span class="pre">"hann"</span></code>, <code class="docutils literal notranslate"><span class="pre">"boxcar"</span></code>). Note that certain window types require
parameters that have to be supplied with the window name as a tuple
(e.g., <code class="docutils literal notranslate"><span class="pre">("tukey",</span> <span class="pre">0.8)</span></code>). If only a float is supplied, it is interpreted
as the beta parameter of the Kaiser window.</p>
<p>See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.get_window.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.get_window.html</a>
for more details.</p>
<p>Note that this function generates a double precision array of the specified
<code class="docutils literal notranslate"><span class="pre">shape</span></code> and can thus generate very large arrays that consume a large
amount of available memory.</p>
<p>The approach taken here to create nD windows is to first calculate the
Euclidean distance from the center of the intended nD window to each
position in the array. That distance is used to sample, with
interpolation, from a 1D window returned from <code class="docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code>.
The method of interpolation can be changed with the <code class="docutils literal notranslate"><span class="pre">order</span></code> keyword
argument passed to <cite>skimage.transform.warp</cite>.</p>
<p>Some coordinates in the output window will be outside of the original
signal; these will be filled in with zeros.</p>
<p>Window types:
- boxcar
- triang
- blackman
- hamming
- hann
- bartlett
- flattop
- parzen
- bohman
- blackmanharris
- nuttall
- barthann
- kaiser (needs beta)
- gaussian (needs standard deviation)
- general_gaussian (needs power, width)
- slepian (needs width)
- dpss (needs normalized half-bandwidth)
- chebwin (needs attenuation)
- exponential (needs decay scale)
- tukey (needs taper fraction)</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r616b68e37c96-1"><span class="brackets">1</span></dt>
<dd><p>Two-dimensional window design, Wikipedia,
<a class="reference external" href="https://en.wikipedia.org/wiki/Two_dimensional_window_design">https://en.wikipedia.org/wiki/Two_dimensional_window_design</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Return a Hann window with shape (512, 512):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">window</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="s1">'hann'</span><span class="p">,</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
</pre></div>
</div>
<p>Return a Kaiser window with beta parameter of 16 and shape (256, 256, 35):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">35</span><span class="p">))</span>
</pre></div>
</div>
<p>Return a Tukey window with an alpha parameter of 0.8 and shape (100, 300):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">window</span><span class="p">((</span><span class="s1">'tukey'</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.measure">
<span id="measure"></span><h3>measure<a class="headerlink" href="#module-cucim.skimage.measure" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.approximate_polygon">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">approximate_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.approximate_polygon" title="Permalink to this definition">#</a></dt>
<dd><p>Approximate a polygonal chain with the specified tolerance.</p>
<p>It is based on the Douglas-Peucker algorithm.</p>
<p>Note that the approximated polygon is always within the convex hull of the
original polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Coordinate array.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Maximum distance from original points of polygon to approximated
polygonal chain. If tolerance is 0, the original coordinate array
is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Approximated polygonal chain where M &lt;= N.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r10376cd04fb0-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.block_reduce">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">block_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func=&lt;function</span> <span class="pre">sum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_kwargs=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.block_reduce" title="Permalink to this definition">#</a></dt>
<dd><p>Downsample image by applying function <cite>func</cite> to local blocks.</p>
<p>This function is useful for max and mean pooling, for example.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>N-dimensional input image.</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">array_like or int</span></dt><dd><p>Array containing down-sampling integer factor along each axis.
Default block_size is 2.</p>
</dd>
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function object which is used to calculate the return value for each
local block. This function must implement an <code class="docutils literal notranslate"><span class="pre">axis</span></code> parameter.
Primary functions are <code class="docutils literal notranslate"><span class="pre">numpy.sum</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.min</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.max</span></code>,
<code class="docutils literal notranslate"><span class="pre">numpy.mean</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy.median</span></code>.  See also <cite>func_kwargs</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
block size.</p>
</dd>
<dt><strong>func_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed to <cite>func</cite>. Notably useful for passing dtype
argument to <code class="docutils literal notranslate"><span class="pre">np.mean</span></code>. Takes dictionary of inputs, e.g.:
<code class="docutils literal notranslate"><span class="pre">func_kwargs={'dtype':</span> <span class="pre">np.float16})</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">block_reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> 
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]],</span>
<span class="go">       [[24, 25, 26, 27],</span>
<span class="go">        [28, 29, 30, 31],</span>
<span class="go">        [32, 33, 34, 35]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">array([[[16., 17., 18., 19.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max1</span> <span class="o">=</span> <span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max1</span> 
<span class="go">array([[[11]],</span>
<span class="go">       [[23]],</span>
<span class="go">       [[35]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max2</span> <span class="o">=</span> <span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max2</span> 
<span class="go">array([[[27],</span>
<span class="go">        [31],</span>
<span class="go">        [35]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.blur_effect">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">blur_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h_size=11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_func=&lt;built-in</span> <span class="pre">function</span> <span class="pre">max&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.blur_effect" title="Permalink to this definition">#</a></dt>
<dd><p>Compute a metric that indicates the strength of blur in an image
(0 for no blur, 1 for maximal blur).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>RGB or grayscale nD image. The input image is converted to grayscale
before computing the blur metric.</p>
</dd>
<dt><strong>h_size</strong><span class="classifier">int, optional</span></dt><dd><p>Size of the re-blurring filter.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be grayscale (single-channel).
Otherwise, this parameter indicates which axis of the array
corresponds to color channels.</p>
</dd>
<dt><strong>reduce_func</strong><span class="classifier">callable, optional</span></dt><dd><p>Function used to calculate the aggregation of blur metrics along all
axes. If set to None, the entire list is returned, where the i-th
element is the blur metric along the i-th axis. This function should be
a host function that operates on standard python floats.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>blur</strong><span class="classifier">float (0 to 1) or list of floats</span></dt><dd><p>Blur metric: by default, the maximum of blur metrics along all axes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>h_size</cite> must keep the same value in order to compare results between
images. Most of the time, the default size (11) is enough. This means that
the metric can clearly discriminate blur up to an average 11x11 filter; if
blur is higher, the metric still gives good results but its values tend
towards an asymptote.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb72696b5f778-1"><span class="brackets">1</span></dt>
<dd><p>Frederique Crete, Thierry Dolmiere, Patricia Ladret, and Marina
Nicolas &ldquo;The blur effect: perception and estimation with a new
no-reference perceptual blur metric&rdquo; Proc. SPIE 6492, Human Vision and
Electronic Imaging XII, 64920I (2007)
<a class="reference external" href="https://hal.archives-ouvertes.fr/hal-00232709">https://hal.archives-ouvertes.fr/hal-00232709</a>
<a class="reference external" href="https://doi.org/10.1117/12.702790">DOI:10.1117/12.702790</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.centroid">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">centroid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.centroid" title="Permalink to this definition">#</a></dt>
<dd><p>Return the (weighted) centroid of an image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>center</strong><span class="classifier">tuple of float, length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code></span></dt><dd><p>The centroid of the (nonzero) pixels in <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">centroid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([13.16666667, 13.16666667])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.inertia_tensor">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">inertia_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.inertia_tensor" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the inertia tensor of the input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, optional</span></dt><dd><p>The pre-computed central moments of <code class="docutils literal notranslate"><span class="pre">image</span></code>. The inertia tensor
computation requires the central moments of the image. If an
application requires both the central moments and the inertia tensor
(for example, <cite>skimage.measure.regionprops</cite>), then it is more
efficient to pre-compute them and pass them to the inertia tensor
call.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>T</strong><span class="classifier">array, shape <code class="docutils literal notranslate"><span class="pre">(image.ndim,</span> <span class="pre">image.ndim)</span></code></span></dt><dd><p>The inertia tensor of the input image. <span class="math notranslate nohighlight">\(T_{i, j}\)</span> contains
the covariance of image intensity along axes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4e965d45b9bb-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor">https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor</a></p>
</dd>
<dt class="label" id="r4e965d45b9bb-2"><span class="brackets">2</span></dt>
<dd><p>Bernd J&auml;hne. Spatio-Temporal Image Processing: Theory and
Scientific Applications. (Chapter 8: Tensor Methods) Springer, 1993.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.inertia_tensor_eigvals">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">inertia_tensor_eigvals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.inertia_tensor_eigvals" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the eigenvalues of the inertia tensor of the image.</p>
<p>The inertia tensor measures covariance of the image intensity along
the image axes. (See <cite>inertia_tensor</cite>.) The relative magnitude of the
eigenvalues of the tensor is thus a measure of the elongation of a
(bright) object in the image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, optional</span></dt><dd><p>The pre-computed central moments of <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">array, shape <code class="docutils literal notranslate"><span class="pre">(image.ndim,</span> <span class="pre">image.ndim)</span></code></span></dt><dd><p>The pre-computed inertia tensor. If <code class="docutils literal notranslate"><span class="pre">T</span></code> is given, <code class="docutils literal notranslate"><span class="pre">mu</span></code> and
<code class="docutils literal notranslate"><span class="pre">image</span></code> are ignored.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eigvals</strong><span class="classifier">list of float, length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code></span></dt><dd><p>The eigenvalues of the inertia tensor of <code class="docutils literal notranslate"><span class="pre">image</span></code>, in descending
order.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computing the eigenvalues requires the inertia tensor of the input image.
This is much faster if the central moments (<code class="docutils literal notranslate"><span class="pre">mu</span></code>) are provided, or,
alternatively, one can provide the inertia tensor (<code class="docutils literal notranslate"><span class="pre">T</span></code>) directly.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.intersection_coeff">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">intersection_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.intersection_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>Fraction of a channel&rsquo;s segmented binary mask that overlaps with a
second channel&rsquo;s segmented binary mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0_mask</strong><span class="classifier">(M, N) ndarray of dtype bool</span></dt><dd><p>Image mask of channel A.</p>
</dd>
<dt><strong>image1_mask</strong><span class="classifier">(M, N) ndarray of dtype bool</span></dt><dd><p>Image mask of channel B.
Must have same dimensions as <cite>image0_mask</cite>.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of dtype bool, optional</span></dt><dd><p>Only <cite>image0_mask</cite> and <cite>image1_mask</cite> pixels within this region of
interest
mask are included in the calculation.
Must have same dimensions as <cite>image0_mask</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Intersection coefficient, float</dt><dd><p>Fraction of <cite>image0_mask</cite> that overlaps with <cite>image1_mask</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.label">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.label" title="Permalink to this definition">#</a></dt>
<dd><p>Label connected regions of an integer array.</p>
<p>Two pixels are connected when they are neighbors and have the same value.
In 2D, they can be neighbors either in a 1- or 2-connected sense.
The value refers to the maximum number of orthogonal hops to consider a
pixel/voxel a neighbor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>     <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>     <span class="n">diagonal</span> <span class="n">connection</span> <span class="n">close</span><span class="o">-</span><span class="n">up</span>

     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>             <span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>                 <span class="o">|</span>  <span class="o">&lt;-</span> <span class="n">hop</span> <span class="mi">2</span>
<span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>        <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \             <span class="n">hop</span> <span class="mi">1</span>
     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label_image</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Image to label.</p>
</dd>
<dt><strong>background</strong><span class="classifier">int, optional</span></dt><dd><p>Consider all pixels with this value as background pixels, and label
them as 0. By default, 0-valued pixels are considered as background
pixels.</p>
</dd>
<dt><strong>return_num</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return the number of assigned labels.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal notranslate"><span class="pre">input.ndim</span></code> is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Labeled array, where all connected regions are assigned the
same integer value.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of labels, which equals the maximum label index and is only
returned if return_num is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.measure.regionprops" title="cucim.skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.measure.regionprops_table" title="cucim.skimage.measure.regionprops_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops_table</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Currently the cucim implementation of this function always uses 32-bit
integers for the label array. This is done for performance. In the future
64-bit integer support may also be added for better skimage compatibility.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra24cf73accd3-1"><span class="brackets">1</span></dt>
<dd><p>Christophe Fiorio and Jens Gustedt, &ldquo;Two linear time Union-Find
strategies for image processing&rdquo;, Theoretical Computer Science
154 (1996), pp. 165-181.</p>
</dd>
<dt class="label" id="ra24cf73accd3-2"><span class="brackets">2</span></dt>
<dd><p>Kensheng Wu, Ekow Otoo and Arie Shoshani, &ldquo;Optimizing connected
component labeling algorithms&rdquo;, Paper LBNL-56864, 2005,
Lawrence Berkeley National Laboratory (University of California),
<a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 2 0]</span>
<span class="go"> [0 0 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">background</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 2 2]</span>
<span class="go"> [2 1 2]</span>
<span class="go"> [2 2 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [1 1 2]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.manders_coloc_coeff">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">manders_coloc_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.manders_coloc_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>Manders&rsquo; colocalization coefficient between two channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel A. All pixel values should be non-negative.</p>
</dd>
<dt><strong>image1_mask</strong><span class="classifier">(M, N) ndarray of dtype bool</span></dt><dd><p>Binary mask with segmented regions of interest in channel B.
Must have same dimensions as <cite>image0</cite>.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of dtype bool, optional</span></dt><dd><p>Only <cite>image0</cite> pixel values within this region of interest mask are
included in the calculation.
Must have same dimensions as <cite>image0</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mcc</strong><span class="classifier">float</span></dt><dd><p>Manders&rsquo; colocalization coefficient.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Manders&rsquo; Colocalization Coefficient (MCC) is the fraction of total
intensity of a certain channel (channel A) that is within the segmented
region of a second channel (channel B) <a class="reference internal" href="#r68fa832cfb27-1" id="id187">[1]</a>. It ranges from 0 for no
colocalisation to 1 for complete colocalization. It is also referred to
as M1 and M2.</p>
<p>MCC is commonly used to measure the colocalization of a particular protein
in a subceullar compartment. Typically a segmentation mask for channel B
is generated by setting a threshold that the pixel values must be above
to be included in the MCC calculation. In this implementation,
the channel B mask is provided as the argument <cite>image1_mask</cite>, allowing
the exact segmentation method to be decided by the user beforehand.</p>
<p>The implemented equation is:</p>
<div class="math notranslate nohighlight">
\[r = \frac{\sum A_{i,coloc}}{\sum A_i}\]</div>
<dl class="simple">
<dt>where</dt><dd><p><span class="math notranslate nohighlight">\(A_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <cite>image0</cite>
<span class="math notranslate nohighlight">\(A_{i,coloc} = A_i\)</span> if <span class="math notranslate nohighlight">\(Bmask_i &gt; 0\)</span>
<span class="math notranslate nohighlight">\(Bmask_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in
<cite>mask</cite></p>
</dd>
</dl>
<p>MCC is sensitive to noise, with diffuse signal in the first channel
inflating its value. Images should be processed to remove out of focus and
background light before the MCC is calculated <a class="reference internal" href="#r68fa832cfb27-2" id="id188">[2]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r68fa832cfb27-1"><span class="brackets"><a class="fn-backref" href="#id187">1</a></span></dt>
<dd><p>Manders, E.M.M., Verbeek, F.J. and Aten, J.A. (1993), Measurement of
co-localization of objects in dual-colour confocal images. Journal
of Microscopy, 169: 375-382.
<a class="reference external" href="https://doi.org/10.1111/j.1365-2818.1993.tb03313.x">https://doi.org/10.1111/j.1365-2818.1993.tb03313.x</a>
<a class="reference external" href="https://imagej.net/media/manders.pdf">https://imagej.net/media/manders.pdf</a></p>
</dd>
<dt class="label" id="r68fa832cfb27-2"><span class="brackets"><a class="fn-backref" href="#id188">2</a></span></dt>
<dd><p>Dunn, K. W., Kamocka, M. M., &amp; McDonald, J. H. (2011). A practical
guide to evaluating colocalization in biological microscopy.
American journal of physiology. Cell physiology, 300(4), C723&ndash;C742.
<a class="reference external" href="https://doi.org/10.1152/ajpcell.00462.2010">https://doi.org/10.1152/ajpcell.00462.2010</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.manders_overlap_coeff">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">manders_overlap_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.manders_overlap_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>Manders&rsquo; overlap coefficient</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel A. All pixel values should be non-negative.</p>
</dd>
<dt><strong>image1</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel B. All pixel values should be non-negative.
Must have same dimensions as <cite>image0</cite></p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of dtype bool, optional</span></dt><dd><p>Only <cite>image0</cite> and <cite>image1</cite> pixel values within this region of interest
mask are included in the calculation.
Must have same dimensions as <cite>image0</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>moc: float</dt><dd><p>Manders&rsquo; Overlap Coefficient of pixel intensities between the two
images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Manders&rsquo; Overlap Coefficient (MOC) is given by the equation <a class="reference internal" href="#rb497c6126263-1" id="id191">[1]</a>:</p>
<div class="math notranslate nohighlight">
\[r = \frac{\sum A_i B_i}{\sqrt{\sum A_i^2 \sum B_i^2}}\]</div>
<dl class="simple">
<dt>where</dt><dd><p><span class="math notranslate nohighlight">\(A_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <cite>image0</cite>
<span class="math notranslate nohighlight">\(B_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <cite>image1</cite></p>
</dd>
</dl>
<p>It ranges between 0 for no colocalization and 1 for complete colocalization
of all pixels.</p>
<p>MOC does not take into account pixel intensities, just the fraction of
pixels that have positive values for both channels[Rb497c6126263-2]_ <a class="reference internal" href="#rb497c6126263-3" id="id192">[3]</a>. Its usefulness
has been criticized as it changes in response to differences in both
co-occurence and correlation and so a particular MOC value could indicate
a wide range of colocalization patterns <a class="reference internal" href="#rb497c6126263-4" id="id193">[4]</a> <a class="reference internal" href="#rb497c6126263-5" id="id194">[5]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb497c6126263-1"><span class="brackets"><a class="fn-backref" href="#id191">1</a></span></dt>
<dd><p>Manders, E.M.M., Verbeek, F.J. and Aten, J.A. (1993), Measurement of
co-localization of objects in dual-colour confocal images. Journal
of Microscopy, 169: 375-382.
<a class="reference external" href="https://doi.org/10.1111/j.1365-2818.1993.tb03313.x">https://doi.org/10.1111/j.1365-2818.1993.tb03313.x</a>
<a class="reference external" href="https://imagej.net/media/manders.pdf">https://imagej.net/media/manders.pdf</a></p>
</dd>
<dt class="label" id="rb497c6126263-2"><span class="brackets">2</span></dt>
<dd><p>Dunn, K. W., Kamocka, M. M., &amp; McDonald, J. H. (2011). A practical
guide to evaluating colocalization in biological microscopy.
American journal of physiology. Cell physiology, 300(4), C723&ndash;C742.
<a class="reference external" href="https://doi.org/10.1152/ajpcell.00462.2010">https://doi.org/10.1152/ajpcell.00462.2010</a></p>
</dd>
<dt class="label" id="rb497c6126263-3"><span class="brackets"><a class="fn-backref" href="#id192">3</a></span></dt>
<dd><p>Bolte, S. and Cordeli&egrave;res, F.P. (2006), A guided tour into
subcellular colocalization analysis in light microscopy. Journal of
Microscopy, 224: 213-232.
<a class="reference external" href="https://doi.org/10.1111/j.1365-2818.2006.01">https://doi.org/10.1111/j.1365-2818.2006.01</a></p>
</dd>
<dt class="label" id="rb497c6126263-4"><span class="brackets"><a class="fn-backref" href="#id193">4</a></span></dt>
<dd><p>Adler J, Parmryd I. (2010), Quantifying colocalization by
correlation: the Pearson correlation coefficient is
superior to the Mander&rsquo;s overlap coefficient. Cytometry A.
Aug;77(8):733-42.https://doi.org/10.1002/cyto.a.20896</p>
</dd>
<dt class="label" id="rb497c6126263-5"><span class="brackets"><a class="fn-backref" href="#id194">5</a></span></dt>
<dd><p>Adler, J, Parmryd, I. Quantifying colocalization: The case for
discarding the Manders overlap coefficient. Cytometry. 2021; 99:
910&ndash; 920. <a class="reference external" href="https://doi.org/10.1002/cyto.a.24336">https://doi.org/10.1002/cyto.a.24336</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate all raw image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">nD double or uint8 array</span></dt><dd><p>Rasterized shape as image.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>m</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Raw image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r962b59a8bdb8-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r962b59a8bdb8-2"><span class="brackets">2</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r962b59a8bdb8-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r962b59a8bdb8-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">moments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span>
<span class="go">(array(14.5), array(14.5))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_central">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_central</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_central" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate all central image moments up to a certain order.</p>
<p>The center coordinates (cr, cc) can be calculated from the raw moments as:
{<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p>
<p>Note that central moments are translation invariant but not scale and
rotation invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">nD double or uint8 array</span></dt><dd><p>Rasterized shape as image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>Coordinates of the image centroid. This will be computed if it
is not provided.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The maximum order of moments computed.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>mu</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Central image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb0a3ccb395bd-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="rb0a3ccb395bd-2"><span class="brackets">2</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="rb0a3ccb395bd-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="rb0a3ccb395bd-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">moments</span><span class="p">,</span> <span class="n">moments_central</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
<span class="go">array([[16.,  0., 20.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [20.,  0., 25.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_coords">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_coords" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate all raw image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) double or uint8 array</span></dt><dd><p>Array of N points that describe an image of D dimensionality in
Cartesian space.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>M</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, &hellip;) array</span></dt><dd><p>Raw image moments. (D dimensions)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb6e66d7e5174-1"><span class="brackets">1</span></dt>
<dd><p>Johannes Kilian. Simple Image Analysis By Moments. Durham
University, version 0.2, Durham, 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">moments_coords</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span>
<span class="go">(array(14.5), array(15.5))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_coords_central">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_coords_central</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_coords_central" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate all central image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) double or uint8 array</span></dt><dd><p>Array of N points that describe an image of D dimensionality in
Cartesian space. A tuple of coordinates as returned by
<code class="docutils literal notranslate"><span class="pre">cp.nonzero</span></code> is also accepted as input.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>Coordinates of the image centroid. This will be computed if it
is not provided.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>Mc</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, &hellip;) array</span></dt><dd><p>Central image moments. (D dimensions)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r70c1250f8c31-1"><span class="brackets">1</span></dt>
<dd><p>Johannes Kilian. Simple Image Analysis By Moments. Durham
University, version 0.2, Durham, 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">moments_coords_central</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="go">array([[16.,  0., 20.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [20.,  0., 25.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>As seen above, for symmetric objects, odd-order moments (columns 1 and 3,
rows 1 and 3) are zero when centered on the centroid, or center of mass,
of the object (the default). If we break the symmetry by adding a new
point, this no longer holds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">coords</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">17</span><span class="p">]])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords2</span><span class="p">),</span>
<span class="gp">... </span>          <span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">array([[17.  ,  0.  , 22.12, -2.49],</span>
<span class="go">       [ 0.  ,  3.53,  1.73,  7.4 ],</span>
<span class="go">       [25.88,  6.02, 36.63,  8.83],</span>
<span class="go">       [ 4.15, 19.17, 14.8 , 39.6 ]])</span>
</pre></div>
</div>
<p>Image moments and central image moments are equivalent (by definition)
when the center is (0, 0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">moments_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">array(True)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_hu">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_hu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_hu" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate Hu&rsquo;s set of image moments (2D-only).</p>
<p>Note that this set of moments is proved to be translation, scale and
rotation invariant.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nu</strong><span class="classifier">(M, M) array</span></dt><dd><p>Normalized central image moments, where M must be &gt;= 4.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nu</strong><span class="classifier">(7,) array</span></dt><dd><p>Hu&rsquo;s set of image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Due to the small array sizes, this function will be faster on the CPU.
Consider transfering <code class="docutils literal notranslate"><span class="pre">nu</span></code> to the host and running
<code class="docutils literal notranslate"><span class="pre">skimage.measure.moments_hu</span></code> if the moments are not needed on the
device.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r13b44116663b-1"><span class="brackets">1</span></dt>
<dd><p>M. K. Hu, &ldquo;Visual Pattern Recognition by Moment Invariants&rdquo;,
IRE Trans. Info. Theory, vol. IT-8, pp. 179-187, 1962</p>
</dd>
<dt class="label" id="r13b44116663b-2"><span class="brackets">2</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r13b44116663b-3"><span class="brackets">3</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r13b44116663b-4"><span class="brackets">4</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r13b44116663b-5"><span class="brackets">5</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="p">(</span><span class="n">moments_central</span><span class="p">,</span> <span class="n">moments_hu</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">moments_normalized</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nu</span> <span class="o">=</span> <span class="n">moments_normalized</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_hu</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
<span class="go">array([7.45370370e-01, 3.51165981e-01, 1.04049179e-01, 4.06442107e-02,</span>
<span class="go">       2.64312299e-03, 2.40854582e-02, 6.50521303e-19])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_normalized">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_normalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_normalized" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate all normalized central image moments up to a certain order.</p>
<p>Note that normalized central moments are translation and scale invariant
but not rotation invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">(M,[ &hellip;,] M) array</span></dt><dd><p>Central image moments, where M must be greater than or equal
to <code class="docutils literal notranslate"><span class="pre">order</span></code>.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>nu</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>,[ &hellip;,] <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Normalized central image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Differs from the scikit-image implementation in that any moments greater
than the requested <cite>order</cite> will be set to <code class="docutils literal notranslate"><span class="pre">nan</span></code>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r653fe38b1244-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r653fe38b1244-2"><span class="brackets">2</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r653fe38b1244-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r653fe38b1244-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="n">moments_central</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">moments_normalized</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_normalized</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="go">array([[       nan,        nan, 0.078125  , 0.        ],</span>
<span class="go">       [       nan, 0.        , 0.        , 0.        ],</span>
<span class="go">       [0.078125  , 0.        , 0.00610352, 0.        ],</span>
<span class="go">       [0.        , 0.        , 0.        , 0.        ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.pearson_corr_coeff">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">pearson_corr_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.pearson_corr_coeff" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate Pearson&rsquo;s Correlation Coefficient between pixel intensities
in channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel A.</p>
</dd>
<dt><strong>image1</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel 2 to be correlated with channel B.
Must have same dimensions as <cite>image0</cite>.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of dtype bool, optional</span></dt><dd><p>Only <cite>image0</cite> and <cite>image1</cite> pixels within this region of interest mask
are included in the calculation. Must have same dimensions as <cite>image0</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pcc</strong><span class="classifier">float</span></dt><dd><p>Pearson&rsquo;s correlation coefficient of the pixel intensities between
the two images, within the mask if provided.</p>
</dd>
<dt><strong>p-value</strong><span class="classifier">float</span></dt><dd><p>Two-tailed p-value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Pearson&rsquo;s Correlation Coefficient (PCC) measures the linear correlation
between the pixel intensities of the two images. Its value ranges from -1
for perfect linear anti-correlation to +1 for perfect linear correlation.
The calculation of the p-value assumes that the intensities of pixels in
each input image are normally distributed.</p>
<p>Scipy&rsquo;s implementation of Pearson&rsquo;s correlation coefficient is used. Please
refer to it for further information and caveats <a class="reference internal" href="#rbf59d2a1d417-1" id="id219">[1]</a>.</p>
<div class="math notranslate nohighlight">
\[r = \frac{\sum (A_i - m_A_i) (B_i - m_B_i)}
{\sqrt{\sum (A_i - m_A_i)^2 \sum (B_i - m_B_i)^2}}\]</div>
<dl class="simple">
<dt>where</dt><dd><p><span class="math notranslate nohighlight">\(A_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <cite>image0</cite>
<span class="math notranslate nohighlight">\(B_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <cite>image1</cite>,
<span class="math notranslate nohighlight">\(m_A_i\)</span> is the mean of the pixel values in <cite>image0</cite>
<span class="math notranslate nohighlight">\(m_B_i\)</span> is the mean of the pixel values in <cite>image1</cite></p>
</dd>
</dl>
<p>A low PCC value does not necessarily mean that there is no correlation
between the two channel intensities, just that there is no linear
correlation. You may wish to plot the pixel intensities of each of the two
channels in a 2D scatterplot and use Spearman&rsquo;s rank correlation if a
non-linear correlation is visually identified <a class="reference internal" href="#rbf59d2a1d417-2" id="id220">[2]</a>. Also consider if you
are interested in correlation or co-occurence, in which case a method
involving segmentation masks (e.g. MCC or intersection coefficient) may be
more suitable <a class="reference internal" href="#rbf59d2a1d417-3" id="id221">[3]</a> <a class="reference internal" href="#rbf59d2a1d417-4" id="id222">[4]</a>.</p>
<p>Providing the mask of only relevant sections of the image (e.g., cells, or
particular cellular compartments) and removing noise is important as the
PCC is sensitive to these measures <a class="reference internal" href="#rbf59d2a1d417-3" id="id223">[3]</a> <a class="reference internal" href="#rbf59d2a1d417-4" id="id224">[4]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbf59d2a1d417-1"><span class="brackets"><a class="fn-backref" href="#id219">1</a></span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html</a>  # noqa</p>
</dd>
<dt class="label" id="rbf59d2a1d417-2"><span class="brackets"><a class="fn-backref" href="#id220">2</a></span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.spearmanr.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.spearmanr.html</a>  # noqa</p>
</dd>
<dt class="label" id="rbf59d2a1d417-3"><span class="brackets">3</span><span class="fn-backref">(<a href="#id221">1</a>,<a href="#id223">2</a>)</span></dt>
<dd><p>Dunn, K. W., Kamocka, M. M., &amp; McDonald, J. H. (2011). A practical
guide to evaluating colocalization in biological microscopy.
American journal of physiology. Cell physiology, 300(4), C723&ndash;C742.
<a class="reference external" href="https://doi.org/10.1152/ajpcell.00462.2010">https://doi.org/10.1152/ajpcell.00462.2010</a></p>
</dd>
<dt class="label" id="rbf59d2a1d417-4"><span class="brackets">4</span><span class="fn-backref">(<a href="#id222">1</a>,<a href="#id224">2</a>)</span></dt>
<dd><p>Bolte, S. and Cordeli&egrave;res, F.P. (2006), A guided tour into
subcellular colocalization analysis in light microscopy. Journal of
Microscopy, 224: 213-232.
<a class="reference external" href="https://doi.org/10.1111/j.1365-2818.2006.01706.x">https://doi.org/10.1111/j.1365-2818.2006.01706.x</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.perimeter">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">perimeter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighborhood</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.perimeter" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate total perimeter of all objects in binary image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>2D binary image.</p>
</dd>
<dt><strong>neighborhood</strong><span class="classifier">4 or 8, optional</span></dt><dd><p>Neighborhood connectivity for border pixel determination. It is used to
compute the contour. A higher neighborhood widens the border on which
the perimeter is computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Total perimeter of all objects in binary image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>neighbourhood</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>neighborhood</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 2022.12.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf0def8f1c63b-1"><span class="brackets">1</span></dt>
<dd><p>K. Benkrid, D. Crookes. Design and FPGA Implementation of
a Perimeter Estimator. The Queen&rsquo;s University of Belfast.
<a class="reference external" href="http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc">http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># coins image (binary)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_coins</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># total perimeter of all objects in the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">neighbourhood</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  
<span class="go">array(7796.86799644)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">neighbourhood</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  
<span class="go">array(8806.26807333)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.profile_line">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">profile_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linewidth=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode='reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval=0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_func=&lt;function</span> <span class="pre">mean&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.profile_line" title="Permalink to this definition">#</a></dt>
<dd><p>Return the intensity profile of an image measured along a scan line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, shape (M, N[, C])</span></dt><dd><p>The image, either grayscale (2D array) or multichannel
(3D array, where the final axis contains the channel
information).</p>
</dd>
<dt><strong>src</strong><span class="classifier">array_like, shape (2, )</span></dt><dd><p>The coordinates of the start point of the scan line.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">array_like, shape (2, )</span></dt><dd><p>The coordinates of the end point of the scan
line. The destination point is <em>included</em> in the profile, in
contrast to standard numpy indexing.</p>
</dd>
<dt><strong>linewidth</strong><span class="classifier">int, optional</span></dt><dd><p>Width of the scan, perpendicular to the line</p>
</dd>
<dt><strong>order</strong><span class="classifier">int in {0, 1, 2, 3, 4, 5}, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;reflect&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>How to compute any values falling outside of the image.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>If <cite>mode</cite> is &lsquo;constant&rsquo;, what constant value to use outside the image.</p>
</dd>
<dt><strong>reduce_func</strong><span class="classifier">callable, optional</span></dt><dd><p>Function used to calculate the aggregation of pixel values
perpendicular to the profile_line direction when <cite>linewidth</cite> &gt; 1.
If set to None the unreduced array will be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>return_value</strong><span class="classifier">array</span></dt><dd><p>The intensity profile along the scan line. The length of the profile
is the ceil of the computed length of the scan line.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span>
<span class="go">array([[0, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">array([1., 1., 2., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">cval</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([1., 1., 1., 2., 2., 2., 2.])</span>
</pre></div>
</div>
<p>The destination point is included in the profile, in contrast to
standard numpy indexing.
For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>  <span class="c1"># The final point is out of bounds</span>
<span class="go">array([1., 1., 1., 2., 2., 2., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># This accesses the full first row</span>
<span class="go">array([1., 1., 1., 2., 2., 2.])</span>
</pre></div>
</div>
<p>For different reduce_func inputs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">array([0.66666667, 0.66666667, 0.66666667, 1.33333333])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 4])</span>
</pre></div>
</div>
<p>The unreduced array will be returned when <cite>reduce_func</cite> is None or when
<cite>reduce_func</cite> acts on each pixel value individually.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">reduce_func</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([[1, 1, 2],</span>
<span class="go">       [1, 1, 2],</span>
<span class="go">       [1, 1, 2],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">)</span>
<span class="go">array([[1.        , 1.        , 0.        ],</span>
<span class="go">       [1.        , 1.        , 0.        ],</span>
<span class="go">       [1.        , 1.        , 0.        ],</span>
<span class="go">       [1.41421356, 1.41421356, 0.        ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.regionprops">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">regionprops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.regionprops" title="Permalink to this definition">#</a></dt>
<dd><p>Measure properties of labeled image regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>label_image</strong><span class="classifier">(M, N[, P]) ndarray</span></dt><dd><p>Labeled input image. Labels with value 0 are ignored.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.14.1: </span>Previously, <code class="docutils literal notranslate"><span class="pre">label_image</span></code> was processed by <code class="docutils literal notranslate"><span class="pre">numpy.squeeze</span></code> and
so any number of singleton dimensions was allowed. This resulted in
inconsistent handling of images with singleton dimensions. To
recover the old behaviour, use
<code class="docutils literal notranslate"><span class="pre">regionprops(np.squeeze(label_image),</span> <span class="pre">...)</span></code>.</p>
</div>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">(M, N[, P][, C]) ndarray, optional</span></dt><dd><p>Intensity (i.e., input) image with same size as labeled image, plus
optionally an extra dimension for multichannel data. Currently,
this extra channel dimension, if present, must be the last axis.
Default is None.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p>
</div>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
</dd>
<dt><strong>extra_properties</strong><span class="classifier">Iterable of callables</span></dt><dd><p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property will not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>properties</strong><span class="classifier">list of RegionProperties</span></dt><dd><p>Each item describes one labeled region, and can be accessed using the
attributes listed below.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.measure.label" title="cucim.skimage.measure.label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The following properties can be accessed as attributes or keys:</p>
<dl>
<dt><strong>num_pixels</strong><span class="classifier">int</span></dt><dd><p>Number of foreground pixels.</p>
</dd>
<dt><strong>area</strong><span class="classifier">float</span></dt><dd><p>Area of the region i.e. number of pixels of the region scaled by pixel-area.</p>
</dd>
<dt><strong>area_bbox</strong><span class="classifier">float</span></dt><dd><p>Area of the bounding box i.e. number of pixels of bounding box scaled by pixel-area.</p>
</dd>
<dt><strong>area_convex</strong><span class="classifier">float</span></dt><dd><p>Are of the convex hull image, which is the smallest convex
polygon that encloses the region.</p>
</dd>
<dt><strong>area_filled</strong><span class="classifier">float</span></dt><dd><p>Area of the region with all the holes filled in.</p>
</dd>
<dt><strong>axis_major_length</strong><span class="classifier">float</span></dt><dd><p>The length of the major axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
<dt><strong>axis_minor_length</strong><span class="classifier">float</span></dt><dd><p>The length of the minor axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
<dt><strong>bbox</strong><span class="classifier">tuple</span></dt><dd><p>Bounding box <code class="docutils literal notranslate"><span class="pre">(min_row,</span> <span class="pre">min_col,</span> <span class="pre">max_row,</span> <span class="pre">max_col)</span></code>.
Pixels belonging to the bounding box are in the half-open interval
<code class="docutils literal notranslate"><span class="pre">[min_row;</span> <span class="pre">max_row)</span></code> and <code class="docutils literal notranslate"><span class="pre">[min_col;</span> <span class="pre">max_col)</span></code>.</p>
</dd>
<dt><strong>centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>.</p>
</dd>
<dt><strong>centroid_local</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>, relative to region bounding
box.</p>
</dd>
<dt><strong>centroid_weighted</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> weighted with intensity
image.</p>
</dd>
<dt><strong>centroid_weighted_local</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>, relative to region bounding
box, weighted with intensity image.</p>
</dd>
<dt><strong>coords_scaled</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Coordinate list <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)``of</span> <span class="pre">the</span> <span class="pre">region</span> <span class="pre">scaled</span> <span class="pre">by</span> <span class="pre">``spacing</span></code>.</p>
</dd>
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Coordinate list <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> of the region.</p>
</dd>
<dt><strong>eccentricity</strong><span class="classifier">float</span></dt><dd><p>Eccentricity of the ellipse that has the same second-moments as the
region. The eccentricity is the ratio of the focal distance
(distance between focal points) over the major axis length.
The value is in the interval [0, 1).
When it is 0, the ellipse becomes a circle.</p>
</dd>
<dt><strong>equivalent_diameter_area</strong><span class="classifier">float</span></dt><dd><p>The diameter of a circle with the same area as the region.</p>
</dd>
<dt><strong>euler_number</strong><span class="classifier">int</span></dt><dd><p>Euler characteristic of the set of non-zero pixels.
Computed as number of connected components subtracted by number of
holes (input.ndim connectivity). In 3D, number of connected
components plus number of holes subtracted by number of tunnels.</p>
</dd>
<dt><strong>extent</strong><span class="classifier">float</span></dt><dd><p>Ratio of pixels in the region to pixels in the total bounding box.
Computed as <code class="docutils literal notranslate"><span class="pre">area</span> <span class="pre">/</span> <span class="pre">(rows</span> <span class="pre">*</span> <span class="pre">cols)</span></code></p>
</dd>
<dt><strong>feret_diameter_max</strong><span class="classifier">float</span></dt><dd><p>Maximum Feret&rsquo;s diameter computed as the longest distance between
points around a region&rsquo;s convex hull contour as determined by
<code class="docutils literal notranslate"><span class="pre">find_contours</span></code>. <a class="reference internal" href="#r357b1e388f3a-5" id="id230">[5]</a></p>
</dd>
<dt><strong>image</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Sliced binary region image which has the same size as bounding box.</p>
</dd>
<dt><strong>image_convex</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Binary convex hull image which has the same size as bounding box.</p>
</dd>
<dt><strong>image_filled</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Binary region image with filled holes which has the same size as
bounding box.</p>
</dd>
<dt><strong>image_intensity</strong><span class="classifier">ndarray</span></dt><dd><p>Image inside region bounding box.</p>
</dd>
<dt><strong>inertia_tensor</strong><span class="classifier">ndarray</span></dt><dd><p>Inertia tensor of the region for the rotation around its mass.</p>
</dd>
<dt><strong>inertia_tensor_eigvals</strong><span class="classifier">tuple</span></dt><dd><p>The eigenvalues of the inertia tensor in decreasing order.</p>
</dd>
<dt><strong>intensity_max</strong><span class="classifier">float</span></dt><dd><p>Value with the greatest intensity in the region.</p>
</dd>
<dt><strong>intensity_mean</strong><span class="classifier">float</span></dt><dd><p>Value with the mean intensity in the region.</p>
</dd>
<dt><strong>intensity_min</strong><span class="classifier">float</span></dt><dd><p>Value with the least intensity in the region.</p>
</dd>
<dt><strong>label</strong><span class="classifier">int</span></dt><dd><p>The label in the labeled input image.</p>
</dd>
<dt><strong>moments</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Spatial moments up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="n">col</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <cite>row</cite>, <cite>col</cite> coordinates of the region.</p>
</dd>
<dt><strong>moments_central</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Central moments (translation invariant) up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mu_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row_c</span><span class="p">)</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">col_c</span><span class="p">)</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <cite>row</cite>, <cite>col</cite> coordinates of the region,
and <cite>row_c</cite> and <cite>col_c</cite> are the coordinates of the region&rsquo;s centroid.</p>
</dd>
<dt><strong>moments_hu</strong><span class="classifier">tuple</span></dt><dd><p>Hu moments (translation, scale and rotation invariant).</p>
</dd>
<dt><strong>moments_normalized</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Normalized moments (translation and scale invariant) up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nu_ij</span> <span class="o">=</span> <span class="n">mu_ij</span> <span class="o">/</span> <span class="n">m_00</span><span class="o">^</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <cite>m_00</cite> is the zeroth spatial moment.</p>
</dd>
<dt><strong>moments_weighted</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Spatial moments of intensity image up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wm_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="n">col</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <cite>row</cite>, <cite>col</cite> coordinates of the region.</p>
</dd>
<dt><strong>moments_weighted_central</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Central moments (translation invariant) of intensity image up to
3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wmu_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row_c</span><span class="p">)</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">col_c</span><span class="p">)</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <cite>row</cite>, <cite>col</cite> coordinates of the region,
and <cite>row_c</cite> and <cite>col_c</cite> are the coordinates of the region&rsquo;s weighted
centroid.</p>
</dd>
<dt><strong>moments_weighted_hu</strong><span class="classifier">tuple</span></dt><dd><p>Hu moments (translation, scale and rotation invariant) of intensity
image.</p>
</dd>
<dt><strong>moments_weighted_normalized</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Normalized moments (translation and scale invariant) of intensity
image up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wnu_ij</span> <span class="o">=</span> <span class="n">wmu_ij</span> <span class="o">/</span> <span class="n">wm_00</span><span class="o">^</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">wm_00</span></code> is the zeroth spatial moment (intensity-weighted area).</p>
</dd>
<dt><strong>orientation</strong><span class="classifier">float</span></dt><dd><p>Angle between the 0th axis (rows) and the major
axis of the ellipse that has the same second moments as the region,
ranging from <cite>-pi/2</cite> to <cite>pi/2</cite> counter-clockwise.</p>
</dd>
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Perimeter of object which approximates the contour as a line
through the centers of border pixels using a 4-connectivity.</p>
</dd>
<dt><strong>perimeter_crofton</strong><span class="classifier">float</span></dt><dd><p>Perimeter of object approximated by the Crofton formula in 4
directions.</p>
</dd>
<dt><strong>slice</strong><span class="classifier">tuple of slices</span></dt><dd><p>A slice to extract the object from the source image.</p>
</dd>
<dt><strong>solidity</strong><span class="classifier">float</span></dt><dd><p>Ratio of pixels in the region to pixels of the convex hull image.</p>
</dd>
</dl>
<p>Each region also supports iteration, so that you can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">region</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r357b1e388f3a-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r357b1e388f3a-2"><span class="brackets">2</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r357b1e388f3a-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r357b1e388f3a-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
<dt class="label" id="r357b1e388f3a-5"><span class="brackets"><a class="fn-backref" href="#id230">5</a></span></dt>
<dd><p>W. Pabst, E. Gregorov&aacute;. Characterization of particles and particle
systems, pp. 27-28. ICT Prague, 2007.
<a class="reference external" href="https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf">https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">'centroid'</span><span class="p">]</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
</pre></div>
</div>
<p>Add custom measurements by passing functions as <code class="docutils literal notranslate"><span class="pre">extra_properties</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pixelcount</span><span class="p">(</span><span class="n">regionmask</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regionmask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">,</span> <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">pixelcount</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelcount</span>
<span class="go">array(7741)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">'pixelcount'</span><span class="p">]</span>
<span class="go">array(42)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.regionprops_table">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">regionprops_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('label',</span> <span class="pre">'bbox')</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.regionprops_table" title="Permalink to this definition">#</a></dt>
<dd><p>Compute image properties and return them as a pandas-compatible table.</p>
<p>The table is a dictionary mapping column names to value arrays. See Notes
section below for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.16.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>label_image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Labeled input image. Labels with value 0 are ignored.</p>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">(M, N[, P][, C]) ndarray, optional</span></dt><dd><p>Intensity (i.e., input) image with same size as labeled image, plus
optionally an extra dimension for multichannel data. Currently,
this extra channel dimension, if present, must be the last axis.
Default is None.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p>
</div>
</dd>
<dt><strong>properties</strong><span class="classifier">tuple or list of str, optional</span></dt><dd><p>Properties that will be included in the resulting dictionary
For a list of available properties, please see <a class="reference internal" href="#cucim.skimage.measure.regionprops" title="cucim.skimage.measure.regionprops"><code class="xref py py-func docutils literal notranslate"><span class="pre">regionprops()</span></code></a>.
Users should remember to add &ldquo;label&rdquo; to keep track of region
identities.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
</dd>
<dt><strong>separator</strong><span class="classifier">str, optional</span></dt><dd><p>For non-scalar properties not listed in OBJECT_COLUMNS, each element
will appear in its own column, with the index of that element separated
from the property name by this separator. For example, the inertia
tensor of a 2D region will appear in four columns:
<code class="docutils literal notranslate"><span class="pre">inertia_tensor-0-0</span></code>, <code class="docutils literal notranslate"><span class="pre">inertia_tensor-0-1</span></code>, <code class="docutils literal notranslate"><span class="pre">inertia_tensor-1-0</span></code>,
and <code class="docutils literal notranslate"><span class="pre">inertia_tensor-1-1</span></code> (where the separator is <code class="docutils literal notranslate"><span class="pre">-</span></code>).</p>
<p>Object columns are those that cannot be split in this way because the
number of columns would change depending on the object. For example,
<code class="docutils literal notranslate"><span class="pre">image</span></code> and <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p>
</dd>
<dt><strong>extra_properties</strong><span class="classifier">Iterable of callables</span></dt><dd><p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property will not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out_dict</strong><span class="classifier">dict</span></dt><dd><p>Dictionary mapping property names to an array of values of that
property, one value per region. This dictionary can be used as input to
pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to map property names to columns in the frame and
regions to rows. If the image has no regions,
the arrays will have length 0, but the correct type.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Each column contains either a scalar property, an object property, or an
element in a multidimensional array.</p>
<p>Properties with scalar values for each region, such as &ldquo;eccentricity&rdquo;, will
appear as a float or int array with that property name as key.</p>
<p>Multidimensional properties <em>of fixed size</em> for a given image dimension,
such as &ldquo;centroid&rdquo; (every centroid will have three elements in a 3D image,
no matter the region size), will be split into that many columns, with the
name {property_name}{separator}{element_num} (for 1D properties),
{property_name}{separator}{elem_num0}{separator}{elem_num1} (for 2D
properties), and so on.</p>
<p>For multidimensional properties that don&rsquo;t have a fixed size, such as
&ldquo;image&rdquo; (the image of a region varies in size depending on the region
size), an object array will be used, with the corresponding property name
as the key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">'label'</span><span class="p">,</span> <span class="s1">'inertia_tensor'</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="s1">'inertia_tensor_eigvals'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span>  
<span class="go">{'label': array([ 1,  2, ...]), ...</span>
<span class="go"> 'inertia_tensor-0-0': array([  4.012...e+03,   8.51..., ...]), ...</span>
<span class="go"> ...,</span>
<span class="go"> 'inertia_tensor_eigvals-1': array([  2.67...e+02,   2.83..., ...])}</span>
</pre></div>
</div>
<p>The resulting dictionary can be directly passed to pandas, if installed, to
obtain a clean DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">props</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>  
<span class="go">   label  inertia_tensor-0-0  ...  inertia_tensor_eigvals-1</span>
<span class="go">0      1         4012.909888  ...                267.065503</span>
<span class="go">1      2            8.514739  ...                  2.834806</span>
<span class="go">2      3            0.666667  ...                  0.000000</span>
<span class="go">3      4            0.000000  ...                  0.000000</span>
<span class="go">4      5            0.222222  ...                  0.111111</span>
</pre></div>
</div>
<p>[5 rows x 7 columns]</p>
<p>If we want to measure a feature that does not come as a built-in
property, we can define custom functions and pass them as
<code class="docutils literal notranslate"><span class="pre">extra_properties</span></code>. For example, we can create a custom function
that measures the intensity quartiles in a region:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">quartiles</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">intensity</span><span class="p">[</span><span class="n">regionmask</span><span class="p">],</span> <span class="n">q</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">properties</span><span class="o">=</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,),</span>
<span class="gp">... </span>                                  <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">quartiles</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">props</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span> 
<span class="go">       label  quartiles-0  quartiles-1  quartiles-2</span>
<span class="go">0      1       117.00        123.0        130.0</span>
<span class="go">1      2       111.25        112.0        114.0</span>
<span class="go">2      3       111.00        111.0        111.0</span>
<span class="go">3      4       111.00        111.5        112.5</span>
<span class="go">4      5       112.50        113.0        114.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.shannon_entropy">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">shannon_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.shannon_entropy" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the Shannon entropy of an image.</p>
<p>The Shannon entropy is defined as S = -sum(pk * log(pk)),
where pk are frequency/probability of pixels of value k.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>base</strong><span class="classifier">float, optional</span></dt><dd><p>The logarithmic base to use.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">0-dimensional float cupy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The returned value is measured in bits or shannon (Sh) for base=2, natural
unit (nat) for base=np.e and hartley (Hart) for base=10.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r12a42ec6364e-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory">https://en.wikipedia.org/wiki/Entropy_(information_theory</a>) &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">https://en.wikipedia.org/wiki/Entropy_(information_theory)</a>&gt;`_  # noqa</p>
</dd>
<dt class="label" id="r12a42ec6364e-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wiktionary.org/wiki/Shannon_entropy">https://en.wiktionary.org/wiki/Shannon_entropy</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">shannon_entropy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shannon_entropy</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()))</span>
<span class="go">array(7.23169501)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.subdivide_polygon">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">subdivide_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_ends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.subdivide_polygon" title="Permalink to this definition">#</a></dt>
<dd><p>Subdivision of polygonal curves using B-Splines.</p>
<p>Note that the resulting curve is always within the convex hull of the
original polygon. Circular polygons stay closed after subdivision.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Coordinate array.</p>
</dd>
<dt><strong>degree</strong><span class="classifier">{1, 2, 3, 4, 5, 6, 7}, optional</span></dt><dd><p>Degree of B-Spline. Default is 2.</p>
</dd>
<dt><strong>preserve_ends</strong><span class="classifier">bool, optional</span></dt><dd><p>Preserve first and last coordinate of non-circular polygon. Default is
False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Subdivided coordinate array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8ce9c450b75c-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf">http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.skimage.metrics">
<span id="metrics"></span><h3>metrics<a class="headerlink" href="#module-cucim.skimage.metrics" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.adapted_rand_error">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">adapted_rand_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_true</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">table</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.adapted_rand_error" title="Permalink to this definition">#</a></dt>
<dd><p>Compute Adapted Rand error as defined by the SNEMI3D contest. <a class="reference internal" href="#rcdd78a98f6a6-1" id="id239">[1]</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_true</strong><span class="classifier">cp.ndarray of int</span></dt><dd><p>Ground-truth label image, same shape as im_test.</p>
</dd>
<dt><strong>image_test</strong><span class="classifier">cp.ndarray of int</span></dt><dd><p>Test image.</p>
</dd>
<dt><strong>table</strong><span class="classifier">cupyx.scipy.sparse array in csr format, optional</span></dt><dd><p>A contingency table built with skimage.evaluate.contingency_table.
If None, it will be computed on the fly.</p>
</dd>
<dt><strong>ignore_labels</strong><span class="classifier">sequence of int, optional</span></dt><dd><p>Labels to ignore. Any part of the true image labeled with any of these
values will not be counted in the score.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Relative weight given to precision and recall in the adapted Rand error
calculation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>are</strong><span class="classifier">float</span></dt><dd><p>The adapted Rand error.</p>
</dd>
<dt><strong>prec</strong><span class="classifier">float</span></dt><dd><p>The adapted Rand precision: this is the number of pairs of pixels that
have the same label in the test label image <em>and</em> in the true image,
divided by the number in the test image.</p>
</dd>
<dt><strong>rec</strong><span class="classifier">float</span></dt><dd><p>The adapted Rand recall: this is the number of pairs of pixels that
have the same label in the test label image <em>and</em> in the true image,
divided by the number in the true image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Pixels with label 0 in the true segmentation are ignored in the score.</p>
<p>The adapted Rand error is calculated as follows:</p>
<p><span class="math notranslate nohighlight">\(1 - \frac{\sum_{ij} p_{ij}^{2}}{\alpha \sum_{k} s_{k}^{2} +
(1-\alpha)\sum_{k} t_{k}^{2}}\)</span>,
where <span class="math notranslate nohighlight">\(p_{ij}\)</span> is the probability that a pixel has the same label
in the test image <em>and</em> in the true image, <span class="math notranslate nohighlight">\(t_{k}\)</span> is the
probability that a pixel has label <span class="math notranslate nohighlight">\(k\)</span> in the true image,
and <span class="math notranslate nohighlight">\(s_{k}\)</span> is the probability that a pixel has label <span class="math notranslate nohighlight">\(k\)</span>
in the test image.</p>
<p>Default behavior is to weight precision and recall equally in the
adapted Rand error calculation.
When alpha = 0, adapted Rand error = recall.
When alpha = 1, adapted Rand error = precision.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rcdd78a98f6a6-1"><span class="brackets"><a class="fn-backref" href="#id239">1</a></span></dt>
<dd><p>Arganda-Carreras I, Turaga SC, Berger DR, et al. (2015)
Crowdsourcing the creation of image segmentation algorithms
for connectomics. Front. Neuroanat. 9:142.
<a class="reference external" href="https://doi.org/10.3389/fnana.2015.00142">DOI:10.3389/fnana.2015.00142</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.contingency_table">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">contingency_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im_test</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.contingency_table" title="Permalink to this definition">#</a></dt>
<dd><p>Return the contingency table for all regions in matched segmentations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>im_true</strong><span class="classifier">ndarray of int</span></dt><dd><p>Ground-truth label image, same shape as im_test.</p>
</dd>
<dt><strong>im_test</strong><span class="classifier">ndarray of int</span></dt><dd><p>Test image.</p>
</dd>
<dt><strong>ignore_labels</strong><span class="classifier">sequence of int, optional</span></dt><dd><p>Labels to ignore. Any part of the true image labeled with any of these
values will not be counted in the score.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>Determines if the contingency table is normalized by pixel count.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cont</strong><span class="classifier">scipy.sparse.csr_matrix</span></dt><dd><p>A contingency table. <cite>cont[i, j]</cite> will equal the number of voxels
labeled <cite>i</cite> in <cite>im_true</cite> and <cite>j</cite> in <cite>im_test</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.mean_squared_error">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">mean_squared_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.mean_squared_error" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the mean-squared error between two images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0, image1</strong><span class="classifier">ndarray</span></dt><dd><p>Images.  Any dimensionality, must have same shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mse</strong><span class="classifier">float</span></dt><dd><p>The mean-squared error (MSE) metric.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code class="docutils literal notranslate"><span class="pre">skimage.measure.compare_mse</span></code> to
<code class="docutils literal notranslate"><span class="pre">skimage.metrics.mean_squared_error</span></code>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.normalized_mutual_information">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">normalized_mutual_information</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.normalized_mutual_information" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the normalized mutual information (NMI).</p>
<p>The normalized mutual information of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span> <span class="n">math</span><span class="p">::</span>
</pre></div>
</div>
<blockquote>
<div><p>Y(A, B) = frac{H(A) + H(B)}{H(A, B)}</p>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(H(X) := - \sum_{x \in X}{x \log x}\)</span> is the entropy.</p>
<p>It was proposed to be useful in registering images by Colin Studholme and
colleagues <a class="reference internal" href="#r988d52405a80-1" id="id241">[1]</a>. It ranges from 1 (perfectly uncorrelated image values)
to 2 (perfectly correlated image values, whether positively or negatively).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0, image1</strong><span class="classifier">ndarray</span></dt><dd><p>Images to be compared. The two input images must have the same number
of dimensions.</p>
</dd>
<dt><strong>bins</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>The number of bins along each axis of the joint histogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nmi</strong><span class="classifier">float</span></dt><dd><p>The normalized mutual information between the two arrays, computed at
the granularity given by <code class="docutils literal notranslate"><span class="pre">bins</span></code>. Higher NMI implies more similar
input images.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the images don&rsquo;t have the same number of dimensions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the two input images are not the same shape, the smaller image is padded
with zeros.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r988d52405a80-1"><span class="brackets"><a class="fn-backref" href="#id241">1</a></span></dt>
<dd><p>C. Studholme, D.L.G. Hill, &amp; D.J. Hawkes (1999). An overlap
invariant entropy measure of 3D medical image alignment.
Pattern Recognition 32(1):71-86
<a class="reference external" href="https://doi.org/10.1016/S0031-3203(98)00091-0">DOI:10.1016/S0031-3203(98)00091-0</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.normalized_root_mse">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">normalized_root_mse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_test</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.normalized_root_mse" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the normalized root mean-squared error (NRMSE) between two
images.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image_true</strong><span class="classifier">ndarray</span></dt><dd><p>Ground-truth image, same shape as im_test.</p>
</dd>
<dt><strong>image_test</strong><span class="classifier">ndarray</span></dt><dd><p>Test image.</p>
</dd>
<dt><strong>normalization</strong><span class="classifier">{&lsquo;euclidean&rsquo;, &lsquo;min-max&rsquo;, &lsquo;mean&rsquo;}, optional</span></dt><dd><p>Controls the normalization method to use in the denominator of the
NRMSE.  There is no standard method of normalization across the
literature <a class="reference internal" href="#r9462348ca58d-1" id="id243">[1]</a>.  The methods available here are as follows:</p>
<ul>
<li><p>&lsquo;euclidean&rsquo; : normalize by the averaged Euclidean norm of
<code class="docutils literal notranslate"><span class="pre">im_true</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NRMSE</span> <span class="o">=</span> <span class="n">RMSE</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="o">||</span> <span class="n">im_true</span> <span class="o">||</span>
</pre></div>
</div>
<p>where || . || denotes the Frobenius norm and <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">im_true.size</span></code>.
This result is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NRMSE</span> <span class="o">=</span> <span class="o">||</span> <span class="n">im_true</span> <span class="o">-</span> <span class="n">im_test</span> <span class="o">||</span> <span class="o">/</span> <span class="o">||</span> <span class="n">im_true</span> <span class="o">||.</span>
</pre></div>
</div>
</li>
<li><p>&lsquo;min-max&rsquo;   : normalize by the intensity range of <code class="docutils literal notranslate"><span class="pre">im_true</span></code>.</p></li>
<li><p>&lsquo;mean&rsquo;      : normalize by the mean of <code class="docutils literal notranslate"><span class="pre">im_true</span></code></p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nrmse</strong><span class="classifier">float</span></dt><dd><p>The NRMSE metric.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code class="docutils literal notranslate"><span class="pre">skimage.measure.compare_nrmse</span></code> to
<code class="docutils literal notranslate"><span class="pre">skimage.metrics.normalized_root_mse</span></code>.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9462348ca58d-1"><span class="brackets"><a class="fn-backref" href="#id243">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">https://en.wikipedia.org/wiki/Root-mean-square_deviation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.peak_signal_noise_ratio">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">peak_signal_noise_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_test</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.peak_signal_noise_ratio" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the peak signal to noise ratio (PSNR) for an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_true</strong><span class="classifier">ndarray</span></dt><dd><p>Ground-truth image, same shape as im_test.</p>
</dd>
<dt><strong>image_test</strong><span class="classifier">ndarray</span></dt><dd><p>Test image.</p>
</dd>
<dt><strong>data_range</strong><span class="classifier">int, optional</span></dt><dd><p>The data range of the input image (distance between minimum and
maximum possible values).  By default, this is estimated from the image
data-type.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>psnr</strong><span class="classifier">float</span></dt><dd><p>The PSNR metric.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code class="docutils literal notranslate"><span class="pre">skimage.measure.compare_psnr</span></code> to
<code class="docutils literal notranslate"><span class="pre">skimage.metrics.peak_signal_noise_ratio</span></code>.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1f1d01c3ecbf-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio">https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.structural_similarity">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">structural_similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaussian_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.structural_similarity" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the mean structural similarity index between two images.
Please pay attention to the <cite>data_range</cite> parameter with floating-point
images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>im1, im2</strong><span class="classifier">ndarray</span></dt><dd><p>Images. Any dimensionality with same shape.</p>
</dd>
<dt><strong>win_size</strong><span class="classifier">int or None, optional</span></dt><dd><p>The side-length of the sliding window used in comparison. Must be an
odd value. If <cite>gaussian_weights</cite> is True, this is ignored and the
window size will depend on <cite>sigma</cite>.</p>
</dd>
<dt><strong>gradient</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, also return the gradient with respect to im2.</p>
</dd>
<dt><strong>data_range</strong><span class="classifier">float, optional</span></dt><dd><p>The data range of the input image (distance between minimum and
maximum possible values). By default, this is estimated from the image
data type. This estimate may be wrong for floating-point image data.
Therefore it is recommended to always pass this value explicitly
(see note below).</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
<dt><strong>gaussian_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, each patch has its mean and variance spatially weighted by a
normalized Gaussian kernel of width sigma=1.5.</p>
</dd>
<dt><strong>full</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, also return the full structural similarity image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mssim</strong><span class="classifier">float</span></dt><dd><p>The mean structural similarity index over the image.</p>
</dd>
<dt><strong>grad</strong><span class="classifier">ndarray</span></dt><dd><p>The gradient of the structural similarity between im1 and im2 <a class="reference internal" href="#rb94e0698d256-2" id="id246">[2]</a>.
This is only returned if <cite>gradient</cite> is set to True.</p>
</dd>
<dt><strong>S</strong><span class="classifier">ndarray</span></dt><dd><p>The full SSIM image.  This is only returned if <cite>full</cite> is set to True.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>use_sample_covariance</strong><span class="classifier">bool</span></dt><dd><p>If True, normalize covariances by N-1 rather than, N where N is the
number of pixels within the sliding window.</p>
</dd>
<dt><strong>K1</strong><span class="classifier">float</span></dt><dd><p>Algorithm parameter, K1 (small constant, see <a class="reference internal" href="#rb94e0698d256-1" id="id247">[1]</a>).</p>
</dd>
<dt><strong>K2</strong><span class="classifier">float</span></dt><dd><p>Algorithm parameter, K2 (small constant, see <a class="reference internal" href="#rb94e0698d256-1" id="id248">[1]</a>).</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float</span></dt><dd><p>Standard deviation for the Gaussian when <cite>gaussian_weights</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>data_range</cite> is not specified, the range is automatically guessed
based on the image data type. However for floating-point image data, this
estimate yields a result double the value of the desired range, as the
<cite>dtype_range</cite> in <cite>skimage.util.dtype.py</cite> has defined intervals from -1 to
+1. This yields an estimate of 2, instead of 1, which is most often
required when working with image data (as negative light intentsities are
nonsensical). In case of working with YCbCr-like color data, note that
these ranges are different per channel (Cb and Cr have double the range
of Y), so one cannot calculate a channel-averaged SSIM with a single call
to this function, as identical ranges are assumed for each channel.</p>
<p>To match the implementation of Wang et al. <a class="reference internal" href="#rb94e0698d256-1" id="id249">[1]</a>, set <cite>gaussian_weights</cite>
to True, <cite>sigma</cite> to 1.5, <cite>use_sample_covariance</cite> to False, and
specify the <cite>data_range</cite> argument.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code class="docutils literal notranslate"><span class="pre">skimage.measure.compare_ssim</span></code> to
<code class="docutils literal notranslate"><span class="pre">skimage.metrics.structural_similarity</span></code>.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb94e0698d256-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id247">1</a>,<a href="#id248">2</a>,<a href="#id249">3</a>)</span></dt>
<dd><p>Wang, Z., Bovik, A. C., Sheikh, H. R., &amp; Simoncelli, E. P.
(2004). Image quality assessment: From error visibility to
structural similarity. IEEE Transactions on Image Processing,
13, 600-612.
<a class="reference external" href="https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf">https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf</a>,
<a class="reference external" href="https://doi.org/10.1109/TIP.2003.819861">DOI:10.1109/TIP.2003.819861</a></p>
</dd>
<dt class="label" id="rb94e0698d256-2"><span class="brackets"><a class="fn-backref" href="#id246">2</a></span></dt>
<dd><p>Avanaki, A. N. (2009). Exact global histogram specification
optimized for structural similarity. Optical Review, 16, 613-621.
<a class="reference external" href="https://arxiv.org/abs/0901.0065">arXiv:0901.0065</a>
<a class="reference external" href="https://doi.org/10.1007/s10043-009-0119-z">DOI:10.1007/s10043-009-0119-z</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.variation_of_information">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">variation_of_information</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">table</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.variation_of_information" title="Permalink to this definition">#</a></dt>
<dd><p>Return symmetric conditional entropies associated with the VI. <a class="reference internal" href="#r1dff00e1e61d-1" id="id252">[1]</a></p>
<p>The variation of information is defined as VI(X,Y) = H(X|Y) + H(Y|X).
If X is the ground-truth segmentation, then H(X|Y) can be interpreted
as the amount of under-segmentation and H(X|Y) as the amount
of over-segmentation. In other words, a perfect over-segmentation
will have H(X|Y)=0 and a perfect under-segmentation will have H(Y|X)=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0, image1</strong><span class="classifier">cp.ndarray of int</span></dt><dd><p>Label images / segmentations, must have same shape.</p>
</dd>
<dt><strong>table</strong><span class="classifier">cupyx.scipy.sparse array in csr format, optional</span></dt><dd><p>A contingency table built with skimage.evaluate.contingency_table.
If None, it will be computed with skimage.evaluate.contingency_table.
If given, the entropies will be computed from this table and any images
will be ignored.</p>
</dd>
<dt><strong>ignore_labels</strong><span class="classifier">sequence of int, optional</span></dt><dd><p>Labels to ignore. Any part of the true image labeled with any of these
values will not be counted in the score.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vi</strong><span class="classifier">cp.ndarray of float, shape (2,)</span></dt><dd><p>The conditional entropies of image1|image0 and image0|image1.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1dff00e1e61d-1"><span class="brackets"><a class="fn-backref" href="#id252">1</a></span></dt>
<dd><p>Marina Meil&abreve; (2007), Comparing clusterings&mdash;an information based
distance, Journal of Multivariate Analysis, Volume 98, Issue 5,
Pages 873-895, ISSN 0047-259X, <a class="reference external" href="https://doi.org/10.1016/j.jmva.2006.11.013">DOI:10.1016/j.jmva.2006.11.013</a>.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="id254">
<h3>morphology<a class="headerlink" href="#id254" title="Permalink to this heading">#</a></h3>
<span class="target" id="module-cucim.skimage.morphology"></span><dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.ball">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">ball</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_radius=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.ball" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a ball-shaped footprint.</p>
<p>This is the 3D equivalent of a disk.
A pixel is within the neighborhood if the Euclidean distance between
it and the origin is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the ball-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>strict_radius</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, extend the radius by 0.5. This allows the circle to expand
further within a cube that remains of size <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">radius</span> <span class="pre">+</span> <span class="pre">1</span></code> along
each axis. This parameter is ignored if decomposition is not None.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, &lsquo;sequence&rsquo;}, optional</span></dt><dd><p>If None, a single array is returned. For &lsquo;sequence&rsquo;, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given a result equivalent to a single, larger footprint, but with
better computational performance. For ball footprints, the sequence
decomposition is not exactly equivalent to decomposition=None.
See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The disk produced by the decomposition=&rsquo;sequence&rsquo; mode is not identical
to that with decomposition=None. Here we extend the approach taken in <a class="reference internal" href="#rd994c2171c55-1" id="id255">[1]</a>
for disks to the 3D case, using 3-dimensional extensions of the &ldquo;square&rdquo;,
&ldquo;diamond&rdquo; and &ldquo;t-shaped&rdquo; elements from that publication. All of these
elementary elements have size <code class="docutils literal notranslate"><span class="pre">(3,)</span> <span class="pre">*</span> <span class="pre">ndim</span></code>. We numerically computed the
number of repetitions of each element that gives the closest match to the
ball computed with kwargs <code class="docutils literal notranslate"><span class="pre">strict_radius=False,</span> <span class="pre">decomposition=None</span></code>.</p>
<p>Empirically, the equivalent composite footprint to the sequence
decomposition approaches a rhombicuboctahedron (26-faces <a class="reference internal" href="#rd994c2171c55-2" id="id256">[2]</a>).</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd994c2171c55-1"><span class="brackets"><a class="fn-backref" href="#id255">1</a></span></dt>
<dd><p>Park, H and Chin R.T. Decomposition of structuring elements for
optimal implementation of morphological operations. In Proceedings:
1997 IEEE Workshop on Nonlinear Signal and Image Processing, London,
UK.
<a class="reference external" href="https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf">https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf</a></p>
</dd>
<dt class="label" id="rd994c2171c55-2"><span class="brackets"><a class="fn-backref" href="#id256">2</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Rhombicuboctahedron">https://en.wikipedia.org/wiki/Rhombicuboctahedron</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.binary_closing">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.binary_closing" title="Permalink to this definition">#</a></dt>
<dd><p>Return fast binary morphological closing of an image.</p>
<p>This function returns the same result as grayscale closing but performs
faster for binary images.</p>
<p>The morphological closing on an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. &ldquo;pepper&rdquo;) and connect
small bright cracks. This tends to &ldquo;close&rdquo; up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closing</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.binary_dilation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_dilation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.binary_dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Return fast binary morphological dilation of an image.</p>
<p>This function returns the same result as grayscale dilation but performs
faster for binary images.</p>
<p>Morphological dilation sets a pixel at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> to the maximum over all
pixels in the neighborhood centered at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>. Dilation enlarges bright
regions and shrinks dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dilated</strong><span class="classifier">ndarray of bool or uint</span></dt><dd><p>The result of the morphological dilation with values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.binary_erosion">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_erosion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.binary_erosion" title="Permalink to this definition">#</a></dt>
<dd><p>Return fast binary morphological erosion of an image.</p>
<p>This function returns the same result as grayscale erosion but performs
faster for binary images.</p>
<p>Morphological erosion sets a pixel at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> to the minimum over all
pixels in the neighborhood centered at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>. Erosion shrinks bright
regions and enlarges dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eroded</strong><span class="classifier">ndarray of bool or uint</span></dt><dd><p>The result of the morphological erosion taking values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.binary_opening">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.binary_opening" title="Permalink to this definition">#</a></dt>
<dd><p>Return fast binary morphological opening of an image.</p>
<p>This function returns the same result as grayscale opening but performs
faster for binary images.</p>
<p>The morphological opening on an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. &ldquo;salt&rdquo;) and connect
small dark cracks. This tends to &ldquo;open&rdquo; up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opening</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.black_tophat">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">black_tophat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.black_tophat" title="Permalink to this definition">#</a></dt>
<dd><p>Return black top hat of an image.</p>
<p>The black top hat of an image is defined as its morphological closing minus
the original image. This operation returns the dark spots of the image that
are smaller than the footprint. Note that dark spots in the
original image are bright spots after the black top hat.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">cupy.ndarray, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological black top hat.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.morphology.white_tophat" title="cucim.skimage.morphology.white_tophat"><code class="xref py py-func docutils literal notranslate"><span class="pre">white_tophat()</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb3bcd3b396ca-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Change dark peak to bright peak and subtract background</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dark_on_grey</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">black_tophat</span><span class="p">(</span><span class="n">dark_on_grey</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.closing">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.closing" title="Permalink to this definition">#</a></dt>
<dd><p>Return grayscale morphological closing of an image.</p>
<p>The morphological closing of an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. &ldquo;pepper&rdquo;) and connect
small bright cracks. This tends to &ldquo;close&rdquo; up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>closing</strong><span class="classifier">cupy.ndarray, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Close a gap between two bright lines</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">broken_line</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">closing</span><span class="p">(</span><span class="n">broken_line</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.cube">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">cube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.cube" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a cube-shaped footprint.</p>
<p>This is the 3D equivalent of a square.
Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width, height and depth of the cube.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <cite>decomposition</cite> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, &lsquo;separable&rsquo;, &lsquo;sequence&rsquo;}, optional</span></dt><dd><p>If None, a single array is returned. For &lsquo;sequence&rsquo;, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but often with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <cite>decomposition</cite> is not None, each element of the <cite>footprint</cite>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For binary morphology, using <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code>
was observed to give better performance, with the magnitude of the
performance increase rapidly increasing with footprint size. For grayscale
morphology with square footprints, it is recommended to use
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> since the internal SciPy functions that are called
already have a fast implementation based on separable 1D sliding windows.</p>
<p>The &lsquo;sequence&rsquo; decomposition mode only supports odd valued <cite>width</cite>. If
<cite>width</cite> is even, the sequence used will be identical to the &lsquo;separable&rsquo;
mode.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.diamond">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">diamond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.diamond" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a flat, diamond-shaped footprint.</p>
<p>A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the diamond-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <cite>decomposition</cite> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, &lsquo;sequence&rsquo;}, optional</span></dt><dd><p>If None, a single array is returned. For &lsquo;sequence&rsquo;, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <cite>decomposition</cite> is not None, each element of the <cite>footprint</cite>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For either binary or grayscale morphology, using
<code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> was observed to have a performance benefit,
with the magnitude of the benefit increasing with increasing footprint
size.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.dilation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">dilation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Return grayscale morphological dilation of an image.</p>
<p>Morphological dilation sets the value of a pixel to the maximum over all
pixel values within a local neighborhood centered about it. The values
where the footprint is 1 define this neighborhood.
Dilation enlarges bright regions and shrinks dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>shift_x, shift_y</strong><span class="classifier">bool, optional</span></dt><dd><p>Shift footprint about center point. This only affects 2D
eccentric footprints (i.e., footprints with even-numbered
sides).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>dilated</strong><span class="classifier">cupy.ndarray, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological dilation.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For <cite>uint8</cite> (and <cite>uint16</cite> up to a certain bit-depth) data, the lower
algorithm complexity makes the <cite>skimage.filters.rank.maximum</cite> function more
efficient for larger images and footprints.</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Dilation enlarges bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_pixel</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dilation</span><span class="p">(</span><span class="n">bright_pixel</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.disk">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">disk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_radius=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.disk" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a flat, disk-shaped footprint.</p>
<p>A pixel is within the neighborhood if the Euclidean distance between
it and the origin is no greater than radius (This is only approximately
True, when <cite>decomposition == &lsquo;sequence&rsquo;</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the disk-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>strict_radius</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, extend the radius by 0.5. This allows the circle to expand
further within a cube that remains of size <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">radius</span> <span class="pre">+</span> <span class="pre">1</span></code> along
each axis. This parameter is ignored if decomposition is not None.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, &lsquo;sequence&rsquo;, &lsquo;crosses&rsquo;}, optional</span></dt><dd><p>If None, a single array is returned. For &lsquo;sequence&rsquo;, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given a result equivalent to a single, larger footprint, but with
better computational performance. For disk footprints, the &lsquo;sequence&rsquo;
or &lsquo;crosses&rsquo; decompositions are not always exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <cite>decomposition</cite> is not None, each element of the <cite>footprint</cite>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>The disk produced by the <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> mode may not be
identical to that with <code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>. A disk footprint can be
approximated by applying a series of smaller footprints of extent 3 along
each axis. Specific solutions for this are given in <a class="reference internal" href="#r24440ba9a49a-1" id="id260">[1]</a> for the case of
2D disks with radius 2 through 10. Here, we numerically computed the number
of repetitions of each element that gives the closest match to the disk
computed with kwargs <code class="docutils literal notranslate"><span class="pre">strict_radius=False,</span> <span class="pre">decomposition=None</span></code>.</p>
<p>Empirically, the series decomposition at large radius approaches a
hexadecagon (a 16-sided polygon <a class="reference internal" href="#r24440ba9a49a-2" id="id261">[2]</a>). In <a class="reference internal" href="#r24440ba9a49a-3" id="id262">[3]</a>, the authors demonstrate
that a hexadecagon is the closest approximation to a disk that can be
achieved for decomposition with footprints of shape (3, 3).</p>
<p>The disk produced by the <code class="docutils literal notranslate"><span class="pre">decomposition='crosses'</span></code> is often but not
always  identical to that with <code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>. It tends to give a
closer approximation than <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code>, at a performance
that is fairly comparable. The individual cross-shaped elements are not
limited to extent (3, 3) in size. Unlike the &lsquo;seqeuence&rsquo; decomposition, the
&lsquo;crosses&rsquo; decomposition can also accurately approximate the shape of disks
with <code class="docutils literal notranslate"><span class="pre">strict_radius=True</span></code>. The method is based on an adaption of
algorithm 1 given in <a class="reference internal" href="#r24440ba9a49a-4" id="id263">[4]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r24440ba9a49a-1"><span class="brackets"><a class="fn-backref" href="#id260">1</a></span></dt>
<dd><p>Park, H and Chin R.T. Decomposition of structuring elements for
optimal implementation of morphological operations. In Proceedings:
1997 IEEE Workshop on Nonlinear Signal and Image Processing, London,
UK.
<a class="reference external" href="https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf">https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf</a></p>
</dd>
<dt class="label" id="r24440ba9a49a-2"><span class="brackets"><a class="fn-backref" href="#id261">2</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Hexadecagon">https://en.wikipedia.org/wiki/Hexadecagon</a></p>
</dd>
<dt class="label" id="r24440ba9a49a-3"><span class="brackets"><a class="fn-backref" href="#id262">3</a></span></dt>
<dd><p>Vanrell, M and Vitri&agrave;, J. Optimal 3 &times; 3 decomposable disks for
morphological transformations. Image and Vision Computing, Vol. 15,
Issue 11, 1997.
<a class="reference external" href="https://doi.org/10.1016/S0262-8856(97)00026-7">DOI:10.1016/S0262-8856(97)00026-7</a></p>
</dd>
<dt class="label" id="r24440ba9a49a-4"><span class="brackets"><a class="fn-backref" href="#id263">4</a></span></dt>
<dd><p>Li, D. and Ritter, G.X. Decomposition of Separable and Symmetric
Convex Templates. Proc. SPIE 1350, Image Algebra and Morphological
Image Processing, (1 November 1990).
<a class="reference external" href="https://doi.org/10.1117/12.23608">DOI:10.1117/12.23608</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.erosion">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">erosion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.erosion" title="Permalink to this definition">#</a></dt>
<dd><p>Return grayscale morphological erosion of an image.</p>
<p>Morphological erosion sets a pixel at (i,j) to the minimum over all pixels
in the neighborhood centered at (i,j). Erosion shrinks bright regions and
enlarges dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>shift_x, shift_y</strong><span class="classifier">bool, optional</span></dt><dd><p>shift footprint about center point. This only affects
eccentric footprints (i.e. footprint with even numbered
sides).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eroded</strong><span class="classifier">cupy.ndarray, same shape as <cite>image</cite></span></dt><dd><p>The result of the morphological erosion.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For <code class="docutils literal notranslate"><span class="pre">uint8</span></code> (and <code class="docutils literal notranslate"><span class="pre">uint16</span></code> up to a certain bit-depth) data, the
lower algorithm complexity makes the <cite>skimage.filters.rank.minimum</cite>
function more efficient for larger images and footprints.</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Erosion shrinks bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erosion</span><span class="p">(</span><span class="n">bright_square</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.isotropic_closing">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">isotropic_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.isotropic_closing" title="Permalink to this definition">#</a></dt>
<dd><p>Return binary morphological closing of an image.</p>
<p>This function returns the same result as binary
<a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.morphology.html#skimage.morphology.binary_closing" title="(in skimage v0.19.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_closing()</span></code></a> but performs faster for large
circular structuring elements. This works by thresholding the exact
Euclidean distance map <a class="reference internal" href="#rf7a1262585f2-1" id="id268">[1]</a>, <a class="reference internal" href="#rf7a1262585f2-2" id="id269">[2]</a>. The implementation is based on:
func:<cite>cucim.core.operations.morphology.distance_transform_edt</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius with which the regions should be closed.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension.
If a sequence, must be of length equal to the input&rsquo;s dimension
(number of axes).
If a single number, this value is used for all axes.
If not specified, a grid spacing of unity is implied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closed</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Empirically, on an RTX A6000 GPU, it was observed that
<code class="docutils literal notranslate"><span class="pre">isotropic_closing</span></code> is faster than <code class="docutils literal notranslate"><span class="pre">binary_closing</span></code> with
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> at radius 12 in 2D and radius 3 in 3D. It becomes
faster than <code class="docutils literal notranslate"><span class="pre">binary_erosion</span></code> with <code class="docutils literal notranslate"><span class="pre">decomposition="sequence"</span></code> at radius
14 in 2D and radius 5 in 3D. In practice, the exact point at which these
isotropic functions become faster than their binary counterparts will also
be dependent on image shape and content.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf7a1262585f2-1"><span class="brackets"><a class="fn-backref" href="#id268">1</a></span></dt>
<dd><p>Cuisenaire, O. and Macq, B., &ldquo;Fast Euclidean morphological operators
using local distance transformation by propagation, and applications,&rdquo;
Image Processing And Its Applications, 1999. Seventh International
Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.
<a class="reference external" href="https://doi.org/10.1049/cp:19990446">DOI:10.1049/cp:19990446</a></p>
</dd>
<dt class="label" id="rf7a1262585f2-2"><span class="brackets"><a class="fn-backref" href="#id269">2</a></span></dt>
<dd><p>Ingemar Ragnemalm, Fast erosion and dilation by contour processing
and thresholding of distance maps, Pattern Recognition Letters,
Volume 13, Issue 3, 1992, Pages 161-166.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(92)90055-5">DOI:10.1016/0167-8655(92)90055-5</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.isotropic_dilation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">isotropic_dilation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.isotropic_dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Return binary morphological dilation of an image.</p>
<p>This function returns the same result as
<a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.morphology.html#skimage.morphology.binary_dilation" title="(in skimage v0.19.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_dilation()</span></code></a> but performs faster for large
circular structuring elements. This works by applying a threshold to the
exact Euclidean distance map of the inverted image <a class="reference internal" href="#re99c914bb6cb-1" id="id272">[1]</a>, <a class="reference internal" href="#re99c914bb6cb-2" id="id273">[2]</a>. The
implementation is based on:
func:<cite>cucim.core.operations.morphology.distance_transform_edt</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius by which regions should be dilated.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension.
If a sequence, must be of length equal to the input&rsquo;s dimension
(number of axes).
If a single number, this value is used for all axes.
If not specified, a grid spacing of unity is implied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dilated</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological dilation with values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Empirically, on an RTX A6000 GPU, it was observed that
<code class="docutils literal notranslate"><span class="pre">isotropic_dilation</span></code> is faster than <code class="docutils literal notranslate"><span class="pre">binary_dilation</span></code> with
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> at radius 12 in 2D and radius 3 in 3D. It becomes
faster than <code class="docutils literal notranslate"><span class="pre">binary_dilation</span></code> with <code class="docutils literal notranslate"><span class="pre">decomposition="sequence"</span></code> at radius
14 in 2D and radius 5 in 3D. In practice, the exact point at which these
isotropic functions become faster than their binary counterparts will also
be dependent on image shape and content.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re99c914bb6cb-1"><span class="brackets"><a class="fn-backref" href="#id272">1</a></span></dt>
<dd><p>Cuisenaire, O. and Macq, B., &ldquo;Fast Euclidean morphological operators
using local distance transformation by propagation, and applications,&rdquo;
Image Processing And Its Applications, 1999. Seventh International
Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.
<a class="reference external" href="https://doi.org/10.1049/cp:19990446">DOI:10.1049/cp:19990446</a></p>
</dd>
<dt class="label" id="re99c914bb6cb-2"><span class="brackets"><a class="fn-backref" href="#id273">2</a></span></dt>
<dd><p>Ingemar Ragnemalm, Fast erosion and dilation by contour processing
and thresholding of distance maps, Pattern Recognition Letters,
Volume 13, Issue 3, 1992, Pages 161-166.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(92)90055-5">DOI:10.1016/0167-8655(92)90055-5</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.isotropic_erosion">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">isotropic_erosion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.isotropic_erosion" title="Permalink to this definition">#</a></dt>
<dd><p>Return binary morphological erosion of an image.</p>
<p>This function returns the same result as
<a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.morphology.html#skimage.morphology.binary_erosion" title="(in skimage v0.19.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_erosion()</span></code></a> but performs faster for large
circular structuring elements. This works by applying a threshold to the
exact Euclidean distance map of the image <a class="reference internal" href="#rfafca02defc4-1" id="id276">[1]</a>, <a class="reference internal" href="#rfafca02defc4-2" id="id277">[2]</a>. The implementation is
based on:
func:<cite>cucim.core.operations.morphology.distance_transform_edt</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius by which regions should be eroded.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
a new array will be allocated.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension.
If a sequence, must be of length equal to the input&rsquo;s dimension
(number of axes). If a single number, this value is used for all axes.
If not specified, a grid spacing of unity is implied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eroded</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological erosion taking values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Empirically, on an RTX A6000 GPU, it was observed that
<code class="docutils literal notranslate"><span class="pre">isotropic_erosion</span></code> is faster than <code class="docutils literal notranslate"><span class="pre">binary_erosion</span></code> with
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> at radius 12 in 2D and radius 3 in 3D. It becomes
faster than <code class="docutils literal notranslate"><span class="pre">binary_erosion</span></code> with <code class="docutils literal notranslate"><span class="pre">decomposition="sequence"</span></code> at radius
14 in 2D and radius 5 in 3D. In practice, the exact point at which these
isotropic functions become faster than their binary counterparts will also
be dependent on image shape and content.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rfafca02defc4-1"><span class="brackets"><a class="fn-backref" href="#id276">1</a></span></dt>
<dd><p>Cuisenaire, O. and Macq, B., &ldquo;Fast Euclidean morphological operators
using local distance transformation by propagation, and applications,&rdquo;
Image Processing And Its Applications, 1999. Seventh International
Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.
<a class="reference external" href="https://doi.org/10.1049/cp:19990446">DOI:10.1049/cp:19990446</a></p>
</dd>
<dt class="label" id="rfafca02defc4-2"><span class="brackets"><a class="fn-backref" href="#id277">2</a></span></dt>
<dd><p>Ingemar Ragnemalm, Fast erosion and dilation by contour processing
and thresholding of distance maps, Pattern Recognition Letters,
Volume 13, Issue 3, 1992, Pages 161-166.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(92)90055-5">DOI:10.1016/0167-8655(92)90055-5</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.isotropic_opening">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">isotropic_opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.isotropic_opening" title="Permalink to this definition">#</a></dt>
<dd><p>Return binary morphological opening of an image.</p>
<p>This function returns the same result as
<a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.morphology.html#skimage.morphology.binary_opening" title="(in skimage v0.19.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_opening()</span></code></a> but performs faster for large
circular structuring elements. This works by thresholding the exact
Euclidean distance map <a class="reference internal" href="#ra33c1fbc8804-1" id="id280">[1]</a>, <a class="reference internal" href="#ra33c1fbc8804-2" id="id281">[2]</a>. The implementation is based on:
func:<cite>cucim.core.operations.morphology.distance_transform_edt</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius with which the regions should be opened.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension.
If a sequence, must be of length equal to the input&rsquo;s dimension
(number of axes).
If a single number, this value is used for all axes.
If not specified, a grid spacing of unity is implied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opened</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Empirically, on an RTX A6000 GPU, it was observed that
<code class="docutils literal notranslate"><span class="pre">isotropic_opening</span></code> is faster than <code class="docutils literal notranslate"><span class="pre">binary_opening</span></code> with
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> at radius 12 in 2D and radius 3 in 3D. It becomes
faster than <code class="docutils literal notranslate"><span class="pre">binary_erosion</span></code> with <code class="docutils literal notranslate"><span class="pre">decomposition="sequence"</span></code> at radius
14 in 2D and radius 5 in 3D. In practice, the exact point at which these
isotropic functions become faster than their binary counterparts will also
be dependent on image shape and content.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra33c1fbc8804-1"><span class="brackets"><a class="fn-backref" href="#id280">1</a></span></dt>
<dd><p>Cuisenaire, O. and Macq, B., &ldquo;Fast Euclidean morphological operators
using local distance transformation by propagation, and applications,&rdquo;
Image Processing And Its Applications, 1999. Seventh International
Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.
<a class="reference external" href="https://doi.org/10.1049/cp:19990446">DOI:10.1049/cp:19990446</a></p>
</dd>
<dt class="label" id="ra33c1fbc8804-2"><span class="brackets"><a class="fn-backref" href="#id281">2</a></span></dt>
<dd><p>Ingemar Ragnemalm, Fast erosion and dilation by contour processing
and thresholding of distance maps, Pattern Recognition Letters,
Volume 13, Issue 3, 1992, Pages 161-166.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(92)90055-5">DOI:10.1016/0167-8655(92)90055-5</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.medial_axis">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">medial_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.medial_axis" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the medial axis transform of a binary image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">binary ndarray, shape (M, N)</span></dt><dd><p>The image of the shape to be skeletonized.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">binary ndarray, shape (M, N), optional</span></dt><dd><p>If a mask is given, only those elements in <cite>image</cite> with a true
value in <cite>mask</cite> are used for computing the medial axis.</p>
</dd>
<dt><strong>return_distance</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, the distance transform is returned as well as the skeleton.</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">{None, int, <cite>numpy.random.Generator</cite>}, optional</span></dt><dd><p>If <cite>random_state</cite> is None the <cite>numpy.random.Generator</cite> singleton is
used.
If <cite>random_state</cite> is an int, a new <code class="docutils literal notranslate"><span class="pre">Generator</span></code> instance is used,
seeded with <cite>random_state</cite>.
If <cite>random_state</cite> is already a <code class="docutils literal notranslate"><span class="pre">Generator</span></code> instance then that
instance is used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of bools</span></dt><dd><p>Medial axis transform of the image</p>
</dd>
<dt><strong>dist</strong><span class="classifier">ndarray of ints, optional</span></dt><dd><p>Distance transform of the image (only returned if <cite>return_distance</cite>
is True)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skeletonize</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This algorithm computes the medial axis transform of an image
as the ridges of its distance transform.</p>
<dl class="simple">
<dt>The different steps of the algorithm are as follows</dt><dd><ul class="simple">
<li><p>A lookup table is used, that assigns 0 or 1 to each configuration of
the 3x3 binary square, whether the central pixel should be removed
or kept. We want a point to be removed if it has more than one neighbor
and if removing it does not change the number of connected components.</p></li>
<li><p>The distance transform to the background is computed, as well as
the cornerness of the pixel.</p></li>
<li><p>The foreground (value of 1) points are ordered by
the distance transform, then the cornerness.</p></li>
<li><p>A cython function is called to reduce the image to its skeleton. It
processes pixels in the order determined at the previous step, and
removes or maintains a pixel according to the lookup table. Because
of the ordering, it is possible to process all pixels in only one
pass.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">medial_axis</span><span class="p">(</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.octagon">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">octagon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.octagon" title="Permalink to this definition">#</a></dt>
<dd><p>Generates an octagon shaped footprint.</p>
<p>For a given size of (m) horizontal and vertical sides
and a given (n) height or width of slanted sides octagon is generated.
The slanted sides are 45 or 135 degrees to the horizontal axis
and hence the widths and heights are equal. The overall size of the
footprint along a single axis will be <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">n</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>The size of the horizontal and vertical sides.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The height or width of the slanted sides.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <cite>decomposition</cite> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, &lsquo;sequence&rsquo;}, optional</span></dt><dd><p>If None, a single array is returned. For &lsquo;sequence&rsquo;, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <cite>decomposition</cite> is not None, each element of the <cite>footprint</cite>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For either binary or grayscale morphology, using
<code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> was observed to have a performance benefit,
with the magnitude of the benefit increasing with increasing footprint
size.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.octahedron">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">octahedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.octahedron" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a octahedron-shaped footprint.</p>
<p>This is the 3D equivalent of a diamond.
A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the octahedron-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <cite>decomposition</cite> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, &lsquo;sequence&rsquo;}, optional</span></dt><dd><p>If None, a single array is returned. For &lsquo;sequence&rsquo;, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <cite>decomposition</cite> is not None, each element of the <cite>footprint</cite>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For either binary or grayscale morphology, using
<code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> was observed to have a performance benefit,
with the magnitude of the benefit increasing with increasing footprint
size.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.opening">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.opening" title="Permalink to this definition">#</a></dt>
<dd><p>Return grayscale morphological opening of an image.</p>
<p>The morphological opening of an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. &ldquo;salt&rdquo;) and connect
small dark cracks. This tends to &ldquo;open&rdquo; up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>opening</strong><span class="classifier">cupy.ndarray, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Open up gap between two bright regions (but also shrink regions)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bad_connection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opening</span><span class="p">(</span><span class="n">bad_connection</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.reconstruction">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dilation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.reconstruction" title="Permalink to this definition">#</a></dt>
<dd><p>Perform a morphological reconstruction of an image.</p>
<p>Morphological reconstruction by dilation is similar to basic morphological
dilation: high-intensity values will replace nearby low-intensity values.
The basic dilation operator, however, uses a footprint to
determine how far a value in the input image can spread. In contrast,
reconstruction uses two images: a &ldquo;seed&rdquo; image, which specifies the values
that spread, and a &ldquo;mask&rdquo; image, which gives the maximum allowed value at
each pixel. The mask image, like the footprint, limits the spread
of high-intensity values. Reconstruction by erosion is simply the inverse:
low-intensity values spread from the seed image and are limited by the mask
image, which represents the minimum allowed value.</p>
<p>Alternatively, you can think of reconstruction as a way to isolate the
connected regions of an image. For dilation, reconstruction connects
regions marked by local maxima in the seed image: neighboring pixels
less-than-or-equal-to those seeds are connected to the seeded region.
Local maxima with values larger than the seed image will get truncated to
the seed value.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">ndarray</span></dt><dd><p>The seed image (a.k.a. marker image), which specifies the values that
are dilated or eroded.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>The maximum (dilation) / minimum (erosion) allowed value at each pixel.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{&lsquo;dilation&rsquo;|&rsquo;erosion&rsquo;}, optional</span></dt><dd><p>Perform reconstruction by dilation or erosion. In dilation (or
erosion), the seed image is dilated (or eroded) until limited by the
mask image. For dilation, each seed value must be less than or equal
to the corresponding mask value; for erosion, the reverse is true.
Default is &lsquo;dilation&rsquo;.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an n-D array of 1&rsquo;s and 0&rsquo;s.
Default is the n-D square of radius equal to 1 (i.e. a 3x3 square
for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</dd>
<dt><strong>offset</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The coordinates of the center of the footprint.
Default is located on the geometrical center of the footprint, in that
case footprint dimensions must be odd.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>The result of morphological reconstruction.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The algorithm is taken from <a class="reference internal" href="#r790032433545-1" id="id284">[1]</a>. Applications for grayscale reconstruction
are discussed in <a class="reference internal" href="#r790032433545-2" id="id285">[2]</a> and <a class="reference internal" href="#r790032433545-3" id="id286">[3]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r790032433545-1"><span class="brackets"><a class="fn-backref" href="#id284">1</a></span></dt>
<dd><p>Robinson, &ldquo;Efficient morphological reconstruction: a downhill
filter&rdquo;, Pattern Recognition Letters 25 (2004) 1759-1767.</p>
</dd>
<dt class="label" id="r790032433545-2"><span class="brackets"><a class="fn-backref" href="#id285">2</a></span></dt>
<dd><p>Vincent, L., &ldquo;Morphological Grayscale Reconstruction in Image
Analysis: Applications and Efficient Algorithms&rdquo;, IEEE Transactions
on Image Processing (1993)</p>
</dd>
<dt class="label" id="r790032433545-3"><span class="brackets"><a class="fn-backref" href="#id286">3</a></span></dt>
<dd><p>Soille, P., &ldquo;Morphological Image Analysis: Principles and
Applications&rdquo;, Chapter 6, 2nd edition (2003), ISBN 3540429883.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">reconstruction</span>
</pre></div>
</div>
<p>First, we create a sinusoidal mask image with peaks at middle and ends.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_mask</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we create a seed image initialized to the minimum mask value (for
reconstruction by dilation, min-intensity values don&rsquo;t spread) and add
&ldquo;seeds&rdquo; to the left and right peak, but at a fraction of peak value (1).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span> <span class="o">=</span> <span class="n">y_mask</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_rec</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">y_seed</span><span class="p">,</span> <span class="n">y_mask</span><span class="p">)</span>
</pre></div>
</div>
<p>The reconstructed image (or curve, in this case) is exactly the same as the
mask image, except that the peaks are truncated to 0.5 and 0. The middle
peak disappears completely: Since there were no seed values in this peak
region, its reconstructed value is truncated to the surrounding value (-1).</p>
<p>As a more practical example, we try to extract the bright features of an
image by subtracting a background image created by reconstruction.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bumps</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">cp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>To create the background image, set the mask image to the original image,
and the seed image to the original image with an intensity offset, <cite>h</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">bumps</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting reconstructed image looks exactly like the original image,
but with the peaks of the bumps cut off. Subtracting this reconstructed
image from the original image leaves just the peaks of the bumps</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdome</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">background</span>
</pre></div>
</div>
<p>This operation is known as the h-dome of the image and leaves features
of height <cite>h</cite> in the subtracted image.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.rectangle">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">rectangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.rectangle" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a flat, rectangular-shaped footprint.</p>
<p>Every pixel in the rectangle generated for a given width and given height
belongs to the neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nrows</strong><span class="classifier">int</span></dt><dd><p>The number of rows of the rectangle.</p>
</dd>
<dt><strong>ncols</strong><span class="classifier">int</span></dt><dd><p>The number of columns of the rectangle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>A footprint consisting only of ones, i.e. every pixel belongs to the
neighborhood. When <cite>decomposition</cite> is None, this is just a
numpy.ndarray. Otherwise, this will be a tuple whose length is equal to
the number of unique structuring elements to apply (see Notes for more
detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, &lsquo;separable&rsquo;, &lsquo;sequence&rsquo;}, optional</span></dt><dd><p>If None, a single array is returned. For &lsquo;sequence&rsquo;, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but often with
better computational performance. See Notes for more details.
With &lsquo;separable&rsquo;, this function uses separable 1D footprints for each
axis. Whether &lsquo;seqeunce&rsquo; or &lsquo;separable&rsquo; is computationally faster may
be architecture-dependent.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <cite>decomposition</cite> is not None, each element of the <cite>footprint</cite>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For binary morphology, using <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code>
was observed to give better performance, with the magnitude of the
performance increase rapidly increasing with footprint size. For grayscale
morphology with rectangular footprints, it is recommended to use
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> since the internal SciPy functions that are called
already have a fast implementation based on separable 1D sliding windows.</p>
<p>The <cite>sequence</cite> decomposition mode only supports odd valued <cite>nrows</cite> and
<cite>ncols</cite>. If either <cite>nrows</cite> or <cite>ncols</cite> is even, the sequence used will be
identical to <code class="docutils literal notranslate"><span class="pre">decomposition='separable'</span></code>.</p>
<ul class="simple">
<li><p>The use of <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> has been deprecated in
version 0.18.0. Use <code class="docutils literal notranslate"><span class="pre">nrows</span></code> and <code class="docutils literal notranslate"><span class="pre">ncols</span></code> instead.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.remove_small_holes">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">remove_small_holes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.remove_small_holes" title="Permalink to this definition">#</a></dt>
<dd><p>Remove contiguous holes smaller than the specified size.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">ndarray (arbitrary shape, int or bool type)</span></dt><dd><p>The array containing the connected components of interest.</p>
</dd>
<dt><strong>area_threshold</strong><span class="classifier">int, optional (default: 64)</span></dt><dd><p>The maximum area, in pixels, of a contiguous hole that will be filled.
Replaces <cite>min_size</cite>.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, {1, 2, &hellip;, ar.ndim}, optional (default: 1)</span></dt><dd><p>The connectivity defining the neighborhood of a pixel.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of the same shape as <cite>ar</cite> and bool dtype, into which the
output is placed. By default, a new array is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray, same shape and type as input <cite>ar</cite></span></dt><dd><p>The input array with small holes within connected components removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the input array is of an invalid type, such as float or string.</p>
</dd>
<dt>ValueError</dt><dd><p>If the input array contains negative values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the array type is int, it is assumed that it contains already-labeled
objects. The labels are not kept in the output image (this function always
outputs a bool image). It is suggested that labeling is completed after
using this function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True, False,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.remove_small_objects">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">remove_small_objects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.remove_small_objects" title="Permalink to this definition">#</a></dt>
<dd><p>Remove objects smaller than the specified size.</p>
<p>Expects ar to be an array with labeled objects, and removes objects
smaller than min_size. If <cite>ar</cite> is bool, the image is first labeled.
This leads to potentially different behavior for bool and 0-and-1
arrays.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">ndarray (arbitrary shape, int or bool type)</span></dt><dd><p>The array containing the objects of interest. If the array type is
int, the ints must be non-negative.</p>
</dd>
<dt><strong>min_size</strong><span class="classifier">int, optional (default: 64)</span></dt><dd><p>The smallest allowable object size.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, {1, 2, &hellip;, ar.ndim}, optional (default: 1)</span></dt><dd><p>The connectivity defining the neighborhood of a pixel. Used during
labelling if <cite>ar</cite> is bool.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of the same shape as <cite>ar</cite>, into which the output is
placed. By default, a new array is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray, same shape and type as input <cite>ar</cite></span></dt><dd><p>The input array with small connected components removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the input array is of an invalid type, such as float or string.</p>
</dd>
<dt>ValueError</dt><dd><p>If the input array contains negative values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[False, False, False, False, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[False, False, False,  True, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.square">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.square" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a flat, square-shaped footprint.</p>
<p>Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width and height of the square.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <cite>decomposition</cite> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, &lsquo;separable&rsquo;, &lsquo;sequence&rsquo;}, optional</span></dt><dd><p>If None, a single array is returned. For &lsquo;sequence&rsquo;, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but often with
better computational performance. See Notes for more details.
With &lsquo;separable&rsquo;, this function uses separable 1D footprints for each
axis. Whether &lsquo;seqeunce&rsquo; or &lsquo;separable&rsquo; is computationally faster may
be architecture-dependent.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <cite>decomposition</cite> is not None, each element of the <cite>footprint</cite>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For binary morphology, using <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> or
<code class="docutils literal notranslate"><span class="pre">decomposition='separable'</span></code> were observed to give better performance than
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>, with the magnitude of the performance increase
rapidly increasing with footprint size. For grayscale morphology with
square footprints, it is recommended to use <code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> since
the internal SciPy functions that are called already have a fast
implementation based on separable 1D sliding windows.</p>
<p>The &lsquo;sequence&rsquo; decomposition mode only supports odd valued <cite>width</cite>. If
<cite>width</cite> is even, the sequence used will be identical to the &lsquo;separable&rsquo;
mode.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.star">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">star</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.star" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a star shaped footprint.</p>
<p>Start has 8 vertices and is an overlap of square of size <cite>2*a + 1</cite>
with its 45 degree rotated version.
The slanted sides are 45 or 135 degrees to the horizontal axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">int</span></dt><dd><p>Parameter deciding the size of the star structural element. The side
of the square array returned is <cite>2*a + 1 + 2*floor(a / 2)</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.thin">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">thin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.thin" title="Permalink to this definition">#</a></dt>
<dd><p>Perform morphological thinning of a binary image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">binary (M, N) ndarray</span></dt><dd><p>The image to be thinned.</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">int, number of iterations, optional</span></dt><dd><p>Regardless of the value of this parameter, the thinned image
is returned immediately if an iteration produces no change.
If this parameter is specified it thus sets an upper bound on
the number of iterations performed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of bool</span></dt><dd><p>Thinned image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>max_iter</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>max_num_iter</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.morphology.medial_axis" title="cucim.skimage.morphology.medial_axis"><code class="xref py py-func docutils literal notranslate"><span class="pre">medial_axis()</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This algorithm <a class="reference internal" href="#r455cf7e5f861-1" id="id290">[1]</a> works by making multiple passes over the image,
removing pixels matching a set of criteria designed to thin
connected regions while preserving eight-connected components and
2 x 2 squares <a class="reference internal" href="#r455cf7e5f861-2" id="id291">[2]</a>. In each of the two sub-iterations the algorithm
correlates the intermediate skeleton image with a neighborhood mask,
then looks up each neighborhood in a lookup table indicating whether
the central pixel should be deleted in that sub-iteration.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r455cf7e5f861-1"><span class="brackets"><a class="fn-backref" href="#id290">1</a></span></dt>
<dd><p>Z. Guo and R. W. Hall, &ldquo;Parallel thinning with
two-subiteration algorithms,&rdquo; Comm. ACM, vol. 32, no. 3,
pp. 359-373, 1989. <a class="reference external" href="https://doi.org/10.1145/62065.62074">DOI:10.1145/62065.62074</a></p>
</dd>
<dt class="label" id="r455cf7e5f861-2"><span class="brackets"><a class="fn-backref" href="#id291">2</a></span></dt>
<dd><p>Lam, L., Seong-Whan Lee, and Ching Y. Suen, &ldquo;Thinning
Methodologies-A Comprehensive Survey,&rdquo; IEEE Transactions on
Pattern Analysis and Machine Intelligence, Vol 14, No. 9,
p. 879, 1992. <a class="reference external" href="https://doi.org/10.1109/34.161346">DOI:10.1109/34.161346</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">thin</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.white_tophat">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">white_tophat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.white_tophat" title="Permalink to this definition">#</a></dt>
<dd><p>Return white top hat of an image.</p>
<p>The white top hat of an image is defined as the image minus its
morphological opening. This operation returns the bright spots of the image
that are smaller than the footprint.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">cupy.ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">cupy.ndarray, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological white top hat.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>selem</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>footprint</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.morphology.black_tophat" title="cucim.skimage.morphology.black_tophat"><code class="xref py py-func docutils literal notranslate"><span class="pre">black_tophat()</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(cp.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(cp.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=cp.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code> provide an option to automically generate a
footprint sequence of this type.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r03d2b2716769-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Subtract grey background from bright peak</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_on_grey</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">white_tophat</span><span class="p">(</span><span class="n">bright_on_grey</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.registration">
<span id="registration"></span><h3>registration<a class="headerlink" href="#module-cucim.skimage.registration" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.registration.optical_flow_ilk">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.registration.</span></span><span class="sig-name descname"><span class="pre">optical_flow_ilk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius=7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_warp=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaussian=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefilter=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.registration.optical_flow_ilk" title="Permalink to this definition">#</a></dt>
<dd><p>Coarse to fine optical flow estimator.</p>
<p>The iterative Lucas-Kanade (iLK) solver is applied at each level
of the image pyramid. iLK <a class="reference internal" href="#r8a901ce569ca-1" id="id295">[1]</a> is a fast and robust alternative to
TVL1 algorithm although less accurate for rendering flat surfaces
and object boundaries (see <a class="reference internal" href="#r8a901ce569ca-2" id="id296">[2]</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_image</strong><span class="classifier">ndarray, shape (M, N[, P[, &hellip;]])</span></dt><dd><p>The first gray scale image of the sequence.</p>
</dd>
<dt><strong>moving_image</strong><span class="classifier">ndarray, shape (M, N[, P[, &hellip;]])</span></dt><dd><p>The second gray scale image of the sequence.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int, optional</span></dt><dd><p>Radius of the window considered around each pixel.</p>
</dd>
<dt><strong>num_warp</strong><span class="classifier">int, optional</span></dt><dd><p>Number of times moving_image is warped.</p>
</dd>
<dt><strong>gaussian</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, a Gaussian kernel is used for the local
integration. Otherwise, a uniform kernel is used.</p>
</dd>
<dt><strong>prefilter</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to prefilter the estimated optical flow before each
image warp. When True, a median filter with window size 3
along each axis is applied. This helps to remove potential
outliers.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Output data type: must be floating point. Single precision
provides good results and saves memory usage and computation
time compared to double precision.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>flow</strong><span class="classifier">ndarray, shape ((reference_image.ndim, M, N[, P[, &hellip;]])</span></dt><dd><p>The estimated optical flow components for each axis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The implemented algorithm is described in <strong>Table2</strong> of <a class="reference internal" href="#r8a901ce569ca-1" id="id297">[1]</a>.</p></li>
<li><p>Color images are not supported.</p></li>
</ul>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8a901ce569ca-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id295">1</a>,<a href="#id297">2</a>)</span></dt>
<dd><p>Le Besnerais, G., &amp; Champagnat, F. (2005, September). Dense
optical flow by iterative local window registration. In IEEE
International Conference on Image Processing 2005 (Vol. 1,
pp. I-137). IEEE. <a class="reference external" href="https://doi.org/10.1109/ICIP.2005.1529706">DOI:10.1109/ICIP.2005.1529706</a></p>
</dd>
<dt class="label" id="r8a901ce569ca-2"><span class="brackets"><a class="fn-backref" href="#id296">2</a></span></dt>
<dd><p>Plyer, A., Le Besnerais, G., &amp; Champagnat,
F. (2016). Massively parallel Lucas Kanade optical flow for
real-time video processing applications. Journal of Real-Time
Image Processing, 11(4), 713-730. <a class="reference external" href="https://doi.org/10.1007/s11554-014-0423-0">DOI:10.1007/s11554-014-0423-0</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">stereo_motorcycle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2gray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.registration</span> <span class="kn">import</span> <span class="n">optical_flow_ilk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_image</span><span class="p">,</span> <span class="n">moving_image</span><span class="p">,</span> <span class="n">disp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">stereo_motorcycle</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># --- Convert the images to gray level: color is not supported.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_image</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">reference_image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moving_image</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">moving_image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span> <span class="o">=</span> <span class="n">optical_flow_ilk</span><span class="p">(</span><span class="n">moving_image</span><span class="p">,</span> <span class="n">reference_image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.registration.optical_flow_tvl1">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.registration.</span></span><span class="sig-name descname"><span class="pre">optical_flow_tvl1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attachment=15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tightness=0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_warp=5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefilter=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.registration.optical_flow_tvl1" title="Permalink to this definition">#</a></dt>
<dd><p>Coarse to fine optical flow estimator.</p>
<p>The TV-L1 solver is applied at each level of the image
pyramid. TV-L1 is a popular algorithm for optical flow estimation
introduced by Zack et al. <a class="reference internal" href="#rfeed16b8dc8b-1" id="id300">[1]</a>, improved in <a class="reference internal" href="#rfeed16b8dc8b-2" id="id301">[2]</a> and detailed in <a class="reference internal" href="#rfeed16b8dc8b-3" id="id302">[3]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_image</strong><span class="classifier">ndarray, shape (M, N[, P[, &hellip;]])</span></dt><dd><p>The first gray scale image of the sequence.</p>
</dd>
<dt><strong>moving_image</strong><span class="classifier">ndarray, shape (M, N[, P[, &hellip;]])</span></dt><dd><p>The second gray scale image of the sequence.</p>
</dd>
<dt><strong>attachment</strong><span class="classifier">float, optional</span></dt><dd><p>Attachment parameter (<span class="math notranslate nohighlight">\(\lambda\)</span> in <a class="reference internal" href="#rfeed16b8dc8b-1" id="id303">[1]</a>). The smaller
this parameter is, the smoother the returned result will be.</p>
</dd>
<dt><strong>tightness</strong><span class="classifier">float, optional</span></dt><dd><p>Tightness parameter (<span class="math notranslate nohighlight">\(\tau\)</span> in <a class="reference internal" href="#rfeed16b8dc8b-1" id="id304">[1]</a>). It should have
a small value in order to maintain attachment and
regularization parts in correspondence.</p>
</dd>
<dt><strong>num_warp</strong><span class="classifier">int, optional</span></dt><dd><p>Number of times moving_image is warped.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of fixed point iteration.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance used as stopping criterion based on the L&sup2; distance
between two consecutive values of (u, v).</p>
</dd>
<dt><strong>prefilter</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to prefilter the estimated optical flow before each
image warp. When True, a median filter with window size 3
along each axis is applied. This helps to remove potential
outliers.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Output data type: must be floating point. Single precision
provides good results and saves memory usage and computation
time compared to double precision.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>flow</strong><span class="classifier">ndarray, shape ((image0.ndim, M, N[, P[, &hellip;]])</span></dt><dd><p>The estimated optical flow components for each axis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Color images are not supported.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rfeed16b8dc8b-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id300">1</a>,<a href="#id303">2</a>,<a href="#id304">3</a>)</span></dt>
<dd><p>Zach, C., Pock, T., &amp; Bischof, H. (2007, September). A
duality based approach for realtime TV-L 1 optical flow. In Joint
pattern recognition symposium (pp. 214-223). Springer, Berlin,
Heidelberg. <a class="reference external" href="https://doi.org/10.1007/978-3-540-74936-3_22">DOI:10.1007/978-3-540-74936-3_22</a></p>
</dd>
<dt class="label" id="rfeed16b8dc8b-2"><span class="brackets"><a class="fn-backref" href="#id301">2</a></span></dt>
<dd><p>Wedel, A., Pock, T., Zach, C., Bischof, H., &amp; Cremers,
D. (2009). An improved algorithm for TV-L 1 optical flow. In
Statistical and geometrical approaches to visual motion analysis
(pp. 23-45). Springer, Berlin, Heidelberg.
<a class="reference external" href="https://doi.org/10.1007/978-3-642-03061-1_2">DOI:10.1007/978-3-642-03061-1_2</a></p>
</dd>
<dt class="label" id="rfeed16b8dc8b-3"><span class="brackets"><a class="fn-backref" href="#id302">3</a></span></dt>
<dd><p>P&eacute;rez, J. S., Meinhardt-Llopis, E., &amp; Facciolo,
G. (2013). TV-L1 optical flow estimation. Image Processing On
Line, 2013, 137-150. <a class="reference external" href="https://doi.org/10.5201/ipol.2013.26">DOI:10.5201/ipol.2013.26</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2gray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">stereo_motorcycle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.registration</span> <span class="kn">import</span> <span class="n">optical_flow_tvl1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image0</span><span class="p">,</span> <span class="n">image1</span><span class="p">,</span> <span class="n">disp</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">stereo_motorcycle</span><span class="p">()]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># --- Convert the images to gray level: color is not supported.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image0</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">image0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image1</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">image1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span> <span class="o">=</span> <span class="n">optical_flow_tvl1</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.registration.phase_cross_correlation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.registration.</span></span><span class="sig-name descname"><span class="pre">phase_cross_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upsample_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disambiguate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'phase'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.registration.phase_cross_correlation" title="Permalink to this definition">#</a></dt>
<dd><p>Efficient subpixel image translation registration by cross-correlation.</p>
<p>This code gives the same precision as the FFT upsampled cross-correlation
in a fraction of the computation time and with reduced memory requirements.
It obtains an initial estimate of the cross-correlation peak by an FFT and
then refines the shift estimation by upsampling the DFT only in a small
neighborhood of that estimate by means of a matrix-multiply DFT <a class="reference internal" href="#r2c60f15ff436-1" id="id308">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_image</strong><span class="classifier">array</span></dt><dd><p>Reference image.</p>
</dd>
<dt><strong>moving_image</strong><span class="classifier">array</span></dt><dd><p>Image to register. Must be same dimensionality as
<code class="docutils literal notranslate"><span class="pre">reference_image</span></code>.</p>
</dd>
<dt><strong>upsample_factor</strong><span class="classifier">int, optional</span></dt><dd><p>Upsampling factor. Images will be registered to within
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">upsample_factor</span></code> of a pixel. For example
<code class="docutils literal notranslate"><span class="pre">upsample_factor</span> <span class="pre">==</span> <span class="pre">20</span></code> means the images will be registered
within 1/20th of a pixel. Default is 1 (no upsampling).
Not used if any of <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> or <code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> is not None.</p>
</dd>
<dt><strong>space</strong><span class="classifier">string, one of &ldquo;real&rdquo; or &ldquo;fourier&rdquo;, optional</span></dt><dd><p>Defines how the algorithm interprets input data. &ldquo;real&rdquo; means
data will be FFT&rsquo;d to compute the correlation, while &ldquo;fourier&rdquo;
data will bypass FFT of input data. Case insensitive. Not
used if any of <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> or <code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> is not
None.</p>
</dd>
<dt><strong>disambiguate</strong><span class="classifier">bool</span></dt><dd><p>The shift returned by this function is only accurate <em>modulo</em> the
image shape, due to the periodic nature of the Fourier transform. If
this parameter is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the <em>real</em> space cross-correlation
is computed for each possible shift, and the shift with the highest
cross-correlation within the overlapping area is returned.</p>
</dd>
<dt><strong>return_error</strong><span class="classifier">bool, optional</span></dt><dd><p>Returns error and phase difference if &ldquo;always&rdquo; is given. If False, or
either <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> or <code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> are given, only the shift
is returned.</p>
</dd>
<dt><strong>reference_mask</strong><span class="classifier">ndarray</span></dt><dd><p>Boolean mask for <code class="docutils literal notranslate"><span class="pre">reference_image</span></code>. The mask should evaluate
to <code class="docutils literal notranslate"><span class="pre">True</span></code> (or 1) on valid pixels. <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> should
have the same shape as <code class="docutils literal notranslate"><span class="pre">reference_image</span></code>.</p>
</dd>
<dt><strong>moving_mask</strong><span class="classifier">ndarray or None, optional</span></dt><dd><p>Boolean mask for <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>. The mask should evaluate to <code class="docutils literal notranslate"><span class="pre">True</span></code>
(or 1) on valid pixels. <code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> should have the same shape
as <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> will be used.</p>
</dd>
<dt><strong>overlap_ratio</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum allowed overlap ratio between images. The correlation for
translations corresponding with an overlap ratio lower than this
threshold will be ignored. A lower <cite>overlap_ratio</cite> leads to smaller
maximum translation, while a higher <cite>overlap_ratio</cite> leads to greater
robustness against spurious matches due to small overlap between
masked images. Used only if one of <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> or
<code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> is None.</p>
</dd>
<dt><strong>normalization</strong><span class="classifier">{&ldquo;phase&rdquo;, None}</span></dt><dd><p>The type of normalization to apply to the cross-correlation. This
parameter is unused when masks (<cite>reference_mask</cite> and <cite>moving_mask</cite>) are
supplied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>shift</strong><span class="classifier">tuple</span></dt><dd><p>Shift vector (in pixels) required to register <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>
with <code class="docutils literal notranslate"><span class="pre">reference_image</span></code>. Axis ordering is consistent with
the axis order of the input array.</p>
</dd>
<dt><strong>error</strong><span class="classifier">float</span></dt><dd><p>Translation invariant normalized RMS error between
<code class="docutils literal notranslate"><span class="pre">reference_image</span></code> and <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>.</p>
</dd>
<dt><strong>phasediff</strong><span class="classifier">float</span></dt><dd><p>Global phase difference between the two images (should be
zero if images are non-negative).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The use of cross-correlation to estimate image translation has a long
history dating back to at least <a class="reference internal" href="#r2c60f15ff436-2" id="id309">[2]</a>. The &ldquo;phase correlation&rdquo;
method (selected by <code class="docutils literal notranslate"><span class="pre">normalization="phase"</span></code>) was first proposed in <a class="reference internal" href="#r2c60f15ff436-3" id="id310">[3]</a>.
Publications <a class="reference internal" href="#r2c60f15ff436-1" id="id311">[1]</a> and <a class="reference internal" href="#r2c60f15ff436-2" id="id312">[2]</a> use an unnormalized cross-correlation
(<code class="docutils literal notranslate"><span class="pre">normalization=None</span></code>). Which form of normalization is better is
application-dependent. For example, the phase correlation method works
well in registering images under different illumination, but is not very
robust to noise. In a high noise scenario, the unnormalized method may be
preferable.</p>
<p>When masks are provided, a masked normalized cross-correlation algorithm is
used <a class="reference internal" href="#r2c60f15ff436-5" id="id313">[5]</a>, <a class="reference internal" href="#r2c60f15ff436-6" id="id314">[6]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2c60f15ff436-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id308">1</a>,<a href="#id311">2</a>)</span></dt>
<dd><p>Manuel Guizar-Sicairos, Samuel T. Thurman, and James R. Fienup,
&ldquo;Efficient subpixel image registration algorithms,&rdquo;
Optics Letters 33, 156-158 (2008). <a class="reference external" href="https://doi.org/10.1364/OL.33.000156">DOI:10.1364/OL.33.000156</a></p>
</dd>
<dt class="label" id="r2c60f15ff436-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id309">1</a>,<a href="#id312">2</a>)</span></dt>
<dd><p>P. Anuta, Spatial registration of multispectral and multitemporal
digital imagery using fast Fourier transform techniques, IEEE Trans.
Geosci. Electron., vol. 8, no. 4, pp. 353&ndash;368, Oct. 1970.
<a class="reference external" href="https://doi.org/10.1109/TGE.1970.271435">DOI:10.1109/TGE.1970.271435</a>.</p>
</dd>
<dt class="label" id="r2c60f15ff436-3"><span class="brackets"><a class="fn-backref" href="#id310">3</a></span></dt>
<dd><p>C. D. Kuglin D. C. Hines. The phase correlation image alignment
method, Proceeding of IEEE International Conference on Cybernetics
and Society, pp. 163-165, New York, NY, USA, 1975, pp. 163&ndash;165.</p>
</dd>
<dt class="label" id="r2c60f15ff436-4"><span class="brackets">4</span></dt>
<dd><p>James R. Fienup, &ldquo;Invariant error metrics for image reconstruction&rdquo;
Optics Letters 36, 8352-8357 (1997). <a class="reference external" href="https://doi.org/10.1364/AO.36.008352">DOI:10.1364/AO.36.008352</a></p>
</dd>
<dt class="label" id="r2c60f15ff436-5"><span class="brackets"><a class="fn-backref" href="#id313">5</a></span></dt>
<dd><p>Dirk Padfield. Masked Object Registration in the Fourier Domain.
IEEE Transactions on Image Processing, vol. 21(5),
pp. 2706-2718 (2012). <a class="reference external" href="https://doi.org/10.1109/TIP.2011.2181402">DOI:10.1109/TIP.2011.2181402</a></p>
</dd>
<dt class="label" id="r2c60f15ff436-6"><span class="brackets"><a class="fn-backref" href="#id314">6</a></span></dt>
<dd><p>D. Padfield. &ldquo;Masked FFT registration&rdquo;. In Proc. Computer Vision and
Pattern Recognition, pp. 2918-2925 (2010).
<a class="reference external" href="https://doi.org/10.1109/CVPR.2010.5540032">DOI:10.1109/CVPR.2010.5540032</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.skimage.restoration">
<span id="restoration"></span><h3>restoration<a class="headerlink" href="#module-cucim.skimage.restoration" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.calibrate_denoiser">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">calibrate_denoiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoise_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoise_parameters</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximate_loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.calibrate_denoiser" title="Permalink to this definition">#</a></dt>
<dd><p>Calibrate a denoising function and return optimal J-invariant version.</p>
<p>The returned function is partially evaluated with optimal parameter values
set for denoising the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input data to be denoised (converted using <cite>img_as_float</cite>).</p>
</dd>
<dt><strong>denoise_function</strong><span class="classifier">function</span></dt><dd><p>Denoising function to be calibrated.</p>
</dd>
<dt><strong>denoise_parameters</strong><span class="classifier">dict of list</span></dt><dd><p>Ranges of parameters for <cite>denoise_function</cite> to be calibrated over.</p>
</dd>
<dt><strong>stride</strong><span class="classifier">int, optional</span></dt><dd><p>Stride used in masking procedure that converts <cite>denoise_function</cite>
to J-invariance.</p>
</dd>
<dt><strong>approximate_loss</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to approximate the self-supervised loss used to evaluate the
denoiser by only computing it on one masked version of the image.
If False, the runtime will be a factor of <cite>stride**image.ndim</cite> longer.</p>
</dd>
<dt><strong>extra_output</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return parameters and losses in addition to the calibrated
denoising function</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>best_denoise_function</strong><span class="classifier">function</span></dt><dd><p>The optimal J-invariant version of <cite>denoise_function</cite>.</p>
</dd>
<dt>If <cite>extra_output</cite> is True, the following tuple is also returned:</dt><dd></dd>
<dt><strong>(parameters_tested, losses)</strong><span class="classifier">tuple (list of dict, list of int)</span></dt><dd><p>List of parameters tested for <cite>denoise_function</cite>, as a dictionary of
kwargs
Self-supervised loss for each set of parameters in <cite>parameters_tested</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The calibration procedure uses a self-supervised mean-square-error loss
to evaluate the performance of J-invariant versions of <cite>denoise_function</cite>.
The minimizer of the self-supervised loss is also the minimizer of the
ground-truth loss (i.e., the true MSE error) [1]. The returned function
can be used on the original noisy image, or other images with similar
characteristics.</p>
<dl class="simple">
<dt>Increasing the stride increases the performance of <cite>best_denoise_function</cite></dt><dd><p>at the expense of increasing its runtime. It has no effect on the runtime
of the calibration.</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb96c97e71b15-1"><span class="brackets">1</span></dt>
<dd><p>J. Batson &amp; L. Royer. Noise2Self: Blind Denoising by Self-Supervision,
International Conference on Machine Learning, p. 524-533 (2019).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.restoration</span> <span class="kn">import</span> <span class="p">(</span><span class="n">denoise_tv_chambolle</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">calibrate_denoiser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noisy</span> <span class="o">=</span> <span class="n">img</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'weight'</span><span class="p">:</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoising_function</span> <span class="o">=</span> <span class="n">calibrate_denoiser</span><span class="p">(</span><span class="n">noisy</span><span class="p">,</span> <span class="n">denoise_tv_chambolle</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">denoise_parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_img</span> <span class="o">=</span> <span class="n">denoising_function</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.denoise_tv_chambolle">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">denoise_tv_chambolle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0002</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.denoise_tv_chambolle" title="Permalink to this definition">#</a></dt>
<dd><p>Perform total variation denoising in nD.</p>
<p>Given <span class="math notranslate nohighlight">\(f\)</span>, a noisy image (input data),
total variation denoising (also known as total variation regularization)
aims to find an image <span class="math notranslate nohighlight">\(u\)</span> with less total variation than <span class="math notranslate nohighlight">\(f\)</span>,
under the constraint that <span class="math notranslate nohighlight">\(u\)</span> remain similar to <span class="math notranslate nohighlight">\(f\)</span>.
This can be expressed by the Rudin&ndash;Osher&ndash;Fatemi (ROF) minimization
problem:</p>
<div class="math notranslate nohighlight">
\[\min_{u} \sum_{i=0}^{N-1} \left( \left| \nabla{u_i} \right| + \frac{\lambda}{2}(f_i - u_i)^2 \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is a positive parameter.
The first term of this cost function is the total variation;
the second term represents data fidelity. As <span class="math notranslate nohighlight">\(\lambda \to 0\)</span>,
the total variation term dominates, forcing the solution to have smaller
total variation, at the expense of looking less like the input data.</p>
<p>This code is an implementation of the algorithm proposed by Chambolle
in <a class="reference internal" href="#rd494debfd106-1" id="id322">[1]</a> to solve the ROF problem.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image to be denoised. If its dtype is not float, it gets
converted with <a class="reference internal" href="#cucim.skimage.util.img_as_float" title="cucim.skimage.util.img_as_float"><code class="xref py py-func docutils literal notranslate"><span class="pre">img_as_float()</span></code></a>.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Denoising weight. It is equal to <span class="math notranslate nohighlight">\(\frac{1}{\lambda}\)</span>. Therefore,
the greater the <cite>weight</cite>, the more denoising (at the expense of
fidelity to <cite>image</cite>).</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance <span class="math notranslate nohighlight">\(\varepsilon &gt; 0\)</span> for the stop criterion (compares to
absolute value of relative difference of the cost function <span class="math notranslate nohighlight">\(E\)</span>):
The algorithm stops when <span class="math notranslate nohighlight">\(|E_{n-1} - E_n| &lt; \varepsilon * E_0\)</span>.</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximal number of iterations used for the optimization.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the image is assumed to be grayscale (single-channel).
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">ndarray</span></dt><dd><p>Denoised image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n_iter_max</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>max_num_iter</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.06.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">denoise_tv_bregman()</span></code></dt><dd><p>Perform total variation denoising using split-Bregman optimization.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Make sure to set the <cite>channel_axis</cite> parameter appropriately for color
images.</p>
<p>The principle of total variation denoising is explained in <a class="reference internal" href="#rd494debfd106-2" id="id323">[2]</a>.
It is about minimizing the total variation of an image,
which can be roughly described as
the integral of the norm of the image gradient. Total variation
denoising tends to produce cartoon-like images, that is,
piecewise-constant images.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd494debfd106-1"><span class="brackets"><a class="fn-backref" href="#id322">1</a></span></dt>
<dd><p>A. Chambolle, An algorithm for total variation minimization and
applications, Journal of Mathematical Imaging and Vision,
Springer, 2004, 20, 89-97.</p>
</dd>
<dt class="label" id="rd494debfd106-2"><span class="brackets"><a class="fn-backref" href="#id323">2</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Total_variation_denoising">https://en.wikipedia.org/wiki/Total_variation_denoising</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>2D example on astronaut image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_img</span> <span class="o">=</span> <span class="n">denoise_tv_chambolle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p>3D example on synthetic data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">22</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="mi">17</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">+=</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">denoise_tv_chambolle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.richardson_lucy">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">richardson_lucy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.richardson_lucy" title="Permalink to this definition">#</a></dt>
<dd><p>Richardson-Lucy deconvolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input degraded image (can be n-dimensional).</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>The point spread function.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of iterations. This parameter plays the role of
regularisation.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If true, pixel value of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
<dt><strong>filter_epsilon: float, optional</strong></dt><dd><p>Value below which intermediate results become 0 to avoid division
by small numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>im_deconv</strong><span class="classifier">ndarray</span></dt><dd><p>The deconvolved image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>iterations</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>num_iter</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra93a945e32d4-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution">https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">img_as_float</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img_as_float</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupyx.scipy.signal</span> <span class="kn">import</span> <span class="n">convolve2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="s1">'same'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">camera</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">richardson_lucy</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.unsupervised_wiener">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">unsupervised_wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.unsupervised_wiener" title="Permalink to this definition">#</a></dt>
<dd><p>Unsupervised Wiener-Hunt deconvolution.</p>
<p>Return the deconvolution with a Wiener-Hunt approach, where the
hyperparameters are automatically estimated. The algorithm is a
stochastic iterative process (Gibbs sampler) described in the
reference below. See also <code class="docutils literal notranslate"><span class="pre">wiener</span></code> function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The input degraded image.</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>The impulse response (input image&rsquo;s space) or the transfer
function (Fourier space). Both are accepted. The transfer
function is automatically recognized as being complex
(<code class="docutils literal notranslate"><span class="pre">cupy.iscomplexobj(psf)</span></code>).</p>
</dd>
<dt><strong>reg</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The regularisation operator. The Laplacian by default. It can
be an impulse response or a transfer function, as for the psf.</p>
</dd>
<dt><strong>user_params</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary of parameters for the Gibbs sampler. See below.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If true, pixel values of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">{None, int, <cite>cupy.random.Generator</cite>}, optional</span></dt><dd><p>If <cite>random_state</cite> is None the <cite>cupy.random.Generator</cite> singleton is
used.
If <cite>random_state</cite> is an int, a new <code class="docutils literal notranslate"><span class="pre">Generator</span></code> instance is used,
seeded with <cite>random_state</cite>.
If <cite>random_state</cite> is already a <code class="docutils literal notranslate"><span class="pre">Generator</span></code> instance then that
instance is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x_postmean</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The deconvolved image (the posterior mean).</p>
</dd>
<dt><strong>chains</strong><span class="classifier">dict</span></dt><dd><p>The keys <code class="docutils literal notranslate"><span class="pre">noise</span></code> and <code class="docutils literal notranslate"><span class="pre">prior</span></code> contain the chain list of
noise and prior precision respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>The keys of ``user_params`` are:</strong></dt><dd></dd>
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>The stopping criterion: the norm of the difference between to
successive approximated solution (empirical mean of object
samples, see Notes section). 1e-4 by default.</p>
</dd>
<dt><strong>burnin</strong><span class="classifier">int</span></dt><dd><p>The number of sample to ignore to start computation of the
mean. 15 by default.</p>
</dd>
<dt><strong>min_num_iter</strong><span class="classifier">int</span></dt><dd><p>The minimum number of iterations. 30 by default.</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations if <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is not
satisfied. 200 by default.</p>
</dd>
<dt><strong>callback</strong><span class="classifier">callable (None by default)</span></dt><dd><p>A user provided callable to which is passed, if the function
exists, the current image sample for whatever purpose. The user
can store the sample, or compute other moments than the
mean. It has no influence on the algorithm execution and is
only for inspection.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The estimated image is design as the posterior mean of a
probability law (from a Bayesian analysis). The mean is defined as
a sum over all the possible images weighted by their respective
probability. Given the size of the problem, the exact sum is not
tractable. This algorithm use of MCMC to draw image under the
posterior law. The practical idea is to only draw highly probable
images since they have the biggest contribution to the mean. At the
opposite, the less probable images are drawn less often since
their contribution is low. Finally, the empirical mean of these
samples give us an estimation of the mean, and an exact
computation with an infinite sample set.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbda4effdf2e5-1"><span class="brackets">1</span></dt>
<dd><p>Fran&ccedil;ois Orieux, Jean-Fran&ccedil;ois Giovannelli, and Thomas
Rodet, &ldquo;Bayesian estimation of regularization and point
spread function parameters for Wiener-Hunt deconvolution&rdquo;,
J. Opt. Soc. Am. A 27, 1593-1607 (2010)</p>
<p><a class="reference external" href="https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593">https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593</a></p>
<p><a class="reference external" href="https://hal.archives-ouvertes.fr/hal-00674508">https://hal.archives-ouvertes.fr/hal-00674508</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupyx.scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">uniform_filter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">psf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved_img</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">unsupervised_wiener</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.wiener">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.wiener" title="Permalink to this definition">#</a></dt>
<dd><p>Wiener-Hunt deconvolution</p>
<p>Return the deconvolution with a Wiener-Hunt approach (i.e. with
Fourier diagonalisation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">cp.ndarray</span></dt><dd><p>Input degraded image (can be n-dimensional).</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>Point Spread Function. This is assumed to be the impulse
response (input image space) if the data-type is real, or the
transfer function (Fourier space) if the data-type is
complex. There is no constraints on the shape of the impulse
response. The transfer function must be of shape
<cite>(N1, N2, &hellip;, ND)</cite> if <cite>is_real is True</cite>,
<cite>(N1, N2, &hellip;, ND // 2 + 1)</cite> otherwise (see <cite>cp.fft.rfftn</cite>).</p>
</dd>
<dt><strong>balance</strong><span class="classifier">float</span></dt><dd><p>The regularisation parameter value that tunes the balance
between the data adequacy that improve frequency restoration
and the prior adequacy that reduce frequency restoration (to
avoid noise artifacts).</p>
</dd>
<dt><strong>reg</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The regularisation operator. The Laplacian by default. It can
be an impulse response or a transfer function, as for the
psf. Shape constraint is the same as for the <cite>psf</cite> parameter.</p>
</dd>
<dt><strong>is_real</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. Specify if <code class="docutils literal notranslate"><span class="pre">psf</span></code> and <code class="docutils literal notranslate"><span class="pre">reg</span></code> are provided
with hermitian hypothesis, that is only half of the frequency
plane is provided (due to the redundancy of Fourier transform
of real signal). It&rsquo;s apply only if <code class="docutils literal notranslate"><span class="pre">psf</span></code> and/or <code class="docutils literal notranslate"><span class="pre">reg</span></code> are
provided as transfer function.  For the hermitian property see
<code class="docutils literal notranslate"><span class="pre">uft</span></code> module or <code class="docutils literal notranslate"><span class="pre">cupy.fft.rfftn</span></code>.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If True, pixel values of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>im_deconv</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The deconvolved image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function applies the Wiener filter to a noisy and degraded
image by an impulse response (or PSF). If the data model is</p>
<div class="math notranslate nohighlight">
\[y = Hx + n\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is noise, <span class="math notranslate nohighlight">\(H\)</span> the PSF and <span class="math notranslate nohighlight">\(x\)</span> the
unknown original image, the Wiener filter is</p>
<div class="math notranslate nohighlight">
\[\hat x = F^\dagger (|\Lambda_H|^2 + \lambda |\Lambda_D|^2)
\Lambda_H^\dagger F y\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(F^\dagger\)</span> are the Fourier and inverse
Fourier transforms respectively, <span class="math notranslate nohighlight">\(\Lambda_H\)</span> the transfer
function (or the Fourier transform of the PSF, see [Hunt] below)
and <span class="math notranslate nohighlight">\(\Lambda_D\)</span> the filter to penalize the restored image
frequencies (Laplacian by default, that is penalization of high
frequency). The parameter <span class="math notranslate nohighlight">\(\lambda\)</span> tunes the balance
between the data (that tends to increase high frequency, even
those coming from noise), and the regularization.</p>
<p>These methods are then specific to a prior model. Consequently,
the application or the true image nature must correspond to the
prior model. By default, the prior model (Laplacian) introduce
image smoothness or pixel correlation. It can also be interpreted
as high-frequency penalization to compensate the instability of
the solution with respect to the data (sometimes called noise
amplification or &ldquo;explosive&rdquo; solution).</p>
<p>Finally, the use of Fourier space implies a circulant property of
<span class="math notranslate nohighlight">\(H\)</span>, see <a class="reference internal" href="#r33534ae55690-2" id="id328">[2]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r33534ae55690-1"><span class="brackets">1</span></dt>
<dd><p>Fran&ccedil;ois Orieux, Jean-Fran&ccedil;ois Giovannelli, and Thomas
Rodet, &ldquo;Bayesian estimation of regularization and point
spread function parameters for Wiener-Hunt deconvolution&rdquo;,
J. Opt. Soc. Am. A 27, 1593-1607 (2010)</p>
<p><a class="reference external" href="https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593">https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593</a></p>
<p><a class="reference external" href="https://hal.archives-ouvertes.fr/hal-00674508">https://hal.archives-ouvertes.fr/hal-00674508</a></p>
</dd>
<dt class="label" id="r33534ae55690-2"><span class="brackets"><a class="fn-backref" href="#id328">2</a></span></dt>
<dd><p>B. R. Hunt &ldquo;A matrix theory proof of the discrete
convolution theorem&rdquo;, IEEE Trans. on Audio and
Electroacoustics, vol. au-19, no. 4, pp. 285-288, dec. 1971</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupyx.scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">uniform_filter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">psf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved_img</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">wiener</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.segmentation">
<span id="segmentation"></span><h3>segmentation<a class="headerlink" href="#module-cucim.skimage.segmentation" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.chan_vese">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">chan_vese</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_level_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'checkerboard'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extended_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.chan_vese" title="Permalink to this definition">#</a></dt>
<dd><p>Chan-Vese segmentation algorithm.</p>
<p>Active contour model by evolving a level set. Can be used to
segment objects without clearly defined boundaries.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Grayscale image to be segmented.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float, optional</span></dt><dd><p>&lsquo;edge length&rsquo; weight parameter. Higher <cite>mu</cite> values will
produce a &lsquo;round&rsquo; edge, while values closer to zero will
detect smaller objects.</p>
</dd>
<dt><strong>lambda1</strong><span class="classifier">float, optional</span></dt><dd><p>&lsquo;difference from average&rsquo; weight parameter for the output
region with value &lsquo;True&rsquo;. If it is lower than <cite>lambda2</cite>, this
region will have a larger range of values than the other.</p>
</dd>
<dt><strong>lambda2</strong><span class="classifier">float, optional</span></dt><dd><p>&lsquo;difference from average&rsquo; weight parameter for the output
region with value &lsquo;False&rsquo;. If it is lower than <cite>lambda1</cite>, this
region will have a larger range of values than the other.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, positive, optional</span></dt><dd><p>Level set variation tolerance between iterations. If the
L2 norm difference between the level sets of successive
iterations normalized by the area of the image is below this
value, the algorithm will assume that the solution was
reached.</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">uint, optional</span></dt><dd><p>Maximum number of iterations allowed before the algorithm
interrupts itself.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>A multiplication factor applied at calculations for each step,
serves to accelerate the algorithm. While higher values may
speed up the algorithm, they may also lead to convergence
problems.</p>
</dd>
<dt><strong>init_level_set</strong><span class="classifier">str or (M, N) ndarray, optional</span></dt><dd><p>Defines the starting level set used by the algorithm.
If a string is inputted, a level set that matches the image
size will automatically be generated. Alternatively, it is
possible to define a custom level set, which should be an
array of float values, with the same shape as &lsquo;image&rsquo;.
Accepted string values are as follows.</p>
<dl class="simple">
<dt>&lsquo;checkerboard&rsquo;</dt><dd><p>the starting level set is defined as
sin(x/5*pi)*sin(y/5*pi), where x and y are pixel
coordinates. This level set has fast convergence, but may
fail to detect implicit edges.</p>
</dd>
<dt>&lsquo;disk&rsquo;</dt><dd><p>the starting level set is defined as the opposite
of the distance from the center of the image minus half of
the minimum value between image width and image height.
This is somewhat slower, but is more likely to properly
detect implicit edges.</p>
</dd>
<dt>&lsquo;small disk&rsquo;</dt><dd><p>the starting level set is defined as the
opposite of the distance from the center of the image
minus a quarter of the minimum value between image width
and image height.</p>
</dd>
</dl>
</dd>
<dt><strong>extended_output</strong><span class="classifier">bool, optional</span></dt><dd><p>If set to True, the return value will be a tuple containing
the three return values (see below). If set to False which
is the default value, only the &lsquo;segmentation&rsquo; array will be
returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segmentation</strong><span class="classifier">(M, N) ndarray, bool</span></dt><dd><p>Segmentation produced by the algorithm.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">(M, N) ndarray of floats</span></dt><dd><p>Final level set computed by the algorithm.</p>
</dd>
<dt><strong>energies</strong><span class="classifier">list of floats</span></dt><dd><p>Shows the evolution of the &lsquo;energy&rsquo; for each step of the
algorithm. This should allow to check whether the algorithm
converged.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>max_iter</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>max_num_iter</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Chan-Vese Algorithm is designed to segment objects without
clearly defined boundaries. This algorithm is based on level sets
that are evolved iteratively to minimize an energy, which is
defined by weighted values corresponding to the sum of differences
intensity from the average value outside the segmented region, the
sum of differences from the average value inside the segmented
region, and a term which is dependent on the length of the
boundary of the segmented region.</p>
<p>This algorithm was first proposed by Tony Chan and Luminita Vese,
in a publication entitled &ldquo;An Active Contour Model Without Edges&rdquo;
<a class="reference internal" href="#rbdce7887ce89-1" id="id331">[1]</a>.</p>
<p>This implementation of the algorithm is somewhat simplified in the
sense that the area factor &lsquo;nu&rsquo; described in the original paper is
not implemented, and is only suitable for grayscale images.</p>
<p>Typical values for <cite>lambda1</cite> and <cite>lambda2</cite> are 1. If the
&lsquo;background&rsquo; is very different from the segmented object in terms
of distribution (for example, a uniform black image with figures
of varying intensity), then these values should be different from
each other.</p>
<p>Typical values for mu are between 0 and 1, though higher values
can be used when dealing with shapes with very ill-defined
contours.</p>
<p>The &lsquo;energy&rsquo; which this algorithm tries to minimize is defined
as the sum of the differences from the average within the region
squared and weighed by the &lsquo;lambda&rsquo; factors to which is added the
length of the contour multiplied by the &lsquo;mu&rsquo; factor.</p>
<p>Supports 2D grayscale images only, and does not implement the area
term described in the original article.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbdce7887ce89-1"><span class="brackets"><a class="fn-backref" href="#id331">1</a></span></dt>
<dd><p>An Active Contour Model without Edges, Tony Chan and
Luminita Vese, Scale-Space Theories in Computer Vision,
1999, <a class="reference external" href="https://doi.org/10.1007/3-540-48236-9_13">DOI:10.1007/3-540-48236-9_13</a></p>
</dd>
<dt class="label" id="rbdce7887ce89-2"><span class="brackets">2</span></dt>
<dd><p>Chan-Vese Segmentation, Pascal Getreuer Image Processing On
Line, 2 (2012), pp. 214-224,
<a class="reference external" href="https://doi.org/10.5201/ipol.2012.g-cv">DOI:10.5201/ipol.2012.g-cv</a></p>
</dd>
<dt class="label" id="rbdce7887ce89-3"><span class="brackets">3</span></dt>
<dd><p>The Chan-Vese Algorithm - Project Report, Rami Cohen, 2011
<a class="reference external" href="https://arxiv.org/abs/1107.2782">arXiv:1107.2782</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.checkerboard_level_set">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">checkerboard_level_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">square_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.checkerboard_level_set" title="Permalink to this definition">#</a></dt>
<dd><p>Create a checkerboard level set with binary values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_shape</strong><span class="classifier">tuple of positive integers</span></dt><dd><p>Shape of the image.</p>
</dd>
<dt><strong>square_size</strong><span class="classifier">int, optional</span></dt><dd><p>Size of the squares of the checkerboard. It defaults to 5.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array with shape <cite>image_shape</cite></span></dt><dd><p>Binary level set of the checkerboard.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.disk_level_set" title="cucim.skimage.segmentation.disk_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disk_level_set</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.clear_border">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">clear_border</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.clear_border" title="Permalink to this definition">#</a></dt>
<dd><p>Clear objects connected to the label image border.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">(M[, N[, &hellip;, P]]) array of int or bool</span></dt><dd><p>Imaging data labels.</p>
</dd>
<dt><strong>buffer_size</strong><span class="classifier">int, optional</span></dt><dd><p>The width of the border examined. By default, only objects
that touch the outside of the image are removed.</p>
</dd>
<dt><strong>bgval</strong><span class="classifier">float or int, optional</span></dt><dd><p>Cleared objects are set to this value.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray of bool, same shape as <cite>image</cite>, optional.</span></dt><dd><p>Image data mask. Objects in labels image overlapping with
False pixels of mask will be removed. If defined, the
argument buffer_size will be ignored.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of the same shape as <cite>labels</cite>, into which the
output is placed. By default, a new array is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(M[, N[, &hellip;, P]]) array</span></dt><dd><p>Imaging data labels with cleared borders</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.segmentation</span> <span class="kn">import</span> <span class="n">clear_border</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clear_border</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clear_border</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.disk_level_set">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">disk_level_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.disk_level_set" title="Permalink to this definition">#</a></dt>
<dd><p>Create a disk level set with binary values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_shape</strong><span class="classifier">tuple of positive integers</span></dt><dd><p>Shape of the image</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of positive integers, optional</span></dt><dd><p>Coordinates of the center of the disk given in (row, column). If not
given, it defaults to the center of the image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius of the disk. If not given, it is set to the 75% of the
smallest image dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array with shape <cite>image_shape</cite></span></dt><dd><p>Binary level set of the disk with the given <cite>radius</cite> and <cite>center</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.checkerboard_level_set" title="cucim.skimage.segmentation.checkerboard_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">checkerboard_level_set</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.find_boundaries">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">find_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'thick'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.find_boundaries" title="Permalink to this definition">#</a></dt>
<dd><p>Return bool array where boundaries between labeled regions are True.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>label_img</strong><span class="classifier">array of int or bool</span></dt><dd><p>An array in which different regions are labeled with either different
integers or boolean values.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int in {1, &hellip;, <cite>label_img.ndim</cite>}, optional</span></dt><dd><p>A pixel is considered a boundary pixel if any of its neighbors
has a different label. <cite>connectivity</cite> controls which pixels are
considered neighbors. A connectivity of 1 (default) means
pixels sharing an edge (in 2D) or a face (in 3D) will be
considered neighbors. A connectivity of <cite>label_img.ndim</cite> means
pixels sharing a corner will be considered neighbors.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string in {&lsquo;thick&rsquo;, &lsquo;inner&rsquo;, &lsquo;outer&rsquo;, &lsquo;subpixel&rsquo;}</span></dt><dd><p>How to mark the boundaries:</p>
<ul class="simple">
<li><p>thick: any pixel not completely surrounded by pixels of the
same label (defined by <cite>connectivity</cite>) is marked as a boundary.
This results in boundaries that are 2 pixels thick.</p></li>
<li><p>inner: outline the pixels <em>just inside</em> of objects, leaving
background pixels untouched.</p></li>
<li><p>outer: outline pixels in the background around object
boundaries. When two objects touch, their boundary is also
marked.</p></li>
<li><p>subpixel: return a doubled image, with pixels <em>between</em> the
original pixels marked as boundary where appropriate.</p></li>
</ul>
</dd>
<dt><strong>background</strong><span class="classifier">int, optional</span></dt><dd><p>For modes &lsquo;inner&rsquo; and &lsquo;outer&rsquo;, a definition of a background
label is required. See <cite>mode</cite> for descriptions of these two.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>boundaries</strong><span class="classifier">array of bool, same shape as <cite>label_img</cite></span></dt><dd><p>A bool image where <code class="docutils literal notranslate"><span class="pre">True</span></code> represents a boundary pixel. For
<cite>mode</cite> equal to &lsquo;subpixel&rsquo;, <code class="docutils literal notranslate"><span class="pre">boundaries.shape[i]</span></code> is equal
to <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">label_img.shape[i]</span> <span class="pre">-</span> <span class="pre">1</span></code> for all <code class="docutils literal notranslate"><span class="pre">i</span></code> (a pixel is
inserted in between all other pairs of pixels).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'thick'</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 1, 1, 0, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 1, 1, 0, 1, 1, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'inner'</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'outer'</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_small</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_small</span>
<span class="go">array([[0, 0, 0, 0],</span>
<span class="go">       [0, 0, 5, 0],</span>
<span class="go">       [0, 1, 5, 0],</span>
<span class="go">       [0, 0, 5, 0],</span>
<span class="go">       [0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">labels_small</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'subpixel'</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 1, 0, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">]],</span>
<span class="gp">... </span>                      <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">bool_image</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False],</span>
<span class="go">       [False, False,  True,  True,  True],</span>
<span class="go">       [False,  True,  True,  True,  True],</span>
<span class="go">       [False,  True,  True, False, False],</span>
<span class="go">       [False,  True,  True, False, False]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.inverse_gaussian_gradient">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">inverse_gaussian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.inverse_gaussian_gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Inverse of gradient magnitude.</p>
<p>Compute the magnitude of the gradients in the image and then inverts the
result in the range [0, 1]. Flat areas are assigned values close to 1,
while areas close to borders are assigned values close to 0.</p>
<p>This function or a similar one defined by the user should be applied over
the image as a preprocessing step before calling
<cite>morphological_geodesic_active_contour</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Grayscale image or volume.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Controls the steepness of the inversion. A larger value will make the
transition between the flat areas and border areas steeper in the
resulting array.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation of the Gaussian filter applied over the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gimage</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Preprocessed image (or volume) suitable for
<cite>morphological_geodesic_active_contour</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.join_segmentations">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">join_segmentations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.join_segmentations" title="Permalink to this definition">#</a></dt>
<dd><p>Return the join of the two input segmentations.</p>
<p>The join J of S1 and S2 is defined as the segmentation in which two
voxels are in the same segment if and only if they are in the same
segment in <em>both</em> S1 and S2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s1, s2</strong><span class="classifier">numpy arrays</span></dt><dd><p>s1 and s2 are label fields of the same shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>j</strong><span class="classifier">numpy array</span></dt><dd><p>The join segmentation of s1 and s2.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.segmentation</span> <span class="kn">import</span> <span class="n">join_segmentations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join_segmentations</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="go">array([[0, 1, 3, 2],</span>
<span class="go">       [0, 5, 3, 2],</span>
<span class="go">       [4, 5, 5, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.mark_boundaries">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">mark_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outline_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'outer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.mark_boundaries" title="Permalink to this definition">#</a></dt>
<dd><p>Return image with boundaries between labeled regions highlighted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N[, 3]) array</span></dt><dd><p>Grayscale or RGB image.</p>
</dd>
<dt><strong>label_img</strong><span class="classifier">(M, N) array of int</span></dt><dd><p>Label array where regions are marked by different integer values.</p>
</dd>
<dt><strong>color</strong><span class="classifier">length-3 sequence, optional</span></dt><dd><p>RGB color of boundaries in the output image.</p>
</dd>
<dt><strong>outline_color</strong><span class="classifier">length-3 sequence, optional</span></dt><dd><p>RGB color surrounding boundaries in the output image. If None, no
outline is drawn.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string in {&lsquo;thick&rsquo;, &lsquo;inner&rsquo;, &lsquo;outer&rsquo;, &lsquo;subpixel&rsquo;}, optional</span></dt><dd><p>The mode for finding boundaries.</p>
</dd>
<dt><strong>background_label</strong><span class="classifier">int, optional</span></dt><dd><p>Which label to consider background (this is only useful for
modes <code class="docutils literal notranslate"><span class="pre">inner</span></code> and <code class="docutils literal notranslate"><span class="pre">outer</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>marked</strong><span class="classifier">(M, N, 3) array of float</span></dt><dd><p>An image in which the boundaries between labels are
superimposed on the original image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.find_boundaries" title="cucim.skimage.segmentation.find_boundaries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_boundaries</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.morphological_chan_vese">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">morphological_chan_vese</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_level_set='checkerboard'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda1=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda2=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_callback=&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.morphological_chan_vese" title="Permalink to this definition">#</a></dt>
<dd><p>Morphological Active Contours without Edges (MorphACWE)</p>
<p>Active contours without edges implemented with morphological operators. It
can be used to segment objects in images and volumes without well defined
borders. It is required that the inside of the object looks different on
average than the outside (i.e., the inner area of the object should be
darker or lighter than the outer area on average).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Grayscale image or volume to be segmented.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">uint</span></dt><dd><p>Number of num_iter to run</p>
</dd>
<dt><strong>init_level_set</strong><span class="classifier">str, (M, N) array, or (L, M, N) array</span></dt><dd><p>Initial level set. If an array is given, it will be binarized and used
as the initial level set. If a string is given, it defines the method
to generate a reasonable initial level set with the shape of the
<cite>image</cite>. Accepted values are &lsquo;checkerboard&rsquo; and &lsquo;disk&rsquo;. See the
documentation of <cite>checkerboard_level_set</cite> and <cite>disk_level_set</cite>
respectively for details about how these level sets are created.</p>
</dd>
<dt><strong>smoothing</strong><span class="classifier">uint, optional</span></dt><dd><p>Number of times the smoothing operator is applied per iteration.
Reasonable values are around 1-4. Larger values lead to smoother
segmentations.</p>
</dd>
<dt><strong>lambda1</strong><span class="classifier">float, optional</span></dt><dd><p>Weight parameter for the outer region. If <cite>lambda1</cite> is larger than
<cite>lambda2</cite>, the outer region will contain a larger range of values than
the inner region.</p>
</dd>
<dt><strong>lambda2</strong><span class="classifier">float, optional</span></dt><dd><p>Weight parameter for the inner region. If <cite>lambda2</cite> is larger than
<cite>lambda1</cite>, the inner region will contain a larger range of values than
the outer region.</p>
</dd>
<dt><strong>iter_callback</strong><span class="classifier">function, optional</span></dt><dd><p>If given, this function is called once per iteration with the current
level set as the only argument. This is useful for debugging or for
plotting intermediate results during the evolution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Final segmentation (i.e., the final level set)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>iterations</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>num_iter</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.disk_level_set" title="cucim.skimage.segmentation.disk_level_set"><code class="xref py py-func docutils literal notranslate"><span class="pre">disk_level_set()</span></code></a>, <a class="reference internal" href="#cucim.skimage.segmentation.checkerboard_level_set" title="cucim.skimage.segmentation.checkerboard_level_set"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkerboard_level_set()</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This is a version of the Chan-Vese algorithm that uses morphological
operators instead of solving a partial differential equation (PDE) for the
evolution of the contour. The set of morphological operators used in this
algorithm are proved to be infinitesimally equivalent to the Chan-Vese PDE
(see <a class="reference internal" href="#r2416b93d33b0-1" id="id335">[1]</a>). However, morphological operators are do not suffer from the
numerical stability issues typically found in PDEs (it is not necessary to
find the right time step for the evolution), and are computationally
faster.</p>
<p>The algorithm and its theoretical derivation are described in <a class="reference internal" href="#r2416b93d33b0-1" id="id336">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2416b93d33b0-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id335">1</a>,<a href="#id336">2</a>)</span></dt>
<dd><p>A Morphological Approach to Curvature-based Evolution of Curves and
Surfaces, Pablo M&aacute;rquez-Neila, Luis Baumela, Luis &Aacute;lvarez. In IEEE
Transactions on Pattern Analysis and Machine Intelligence (PAMI),
2014, <a class="reference external" href="https://doi.org/10.1109/TPAMI.2013.106">DOI:10.1109/TPAMI.2013.106</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.morphological_geodesic_active_contour">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">morphological_geodesic_active_contour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gimage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_level_set='disk'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold='auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balloon=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_callback=&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.morphological_geodesic_active_contour" title="Permalink to this definition">#</a></dt>
<dd><p>Morphological Geodesic Active Contours (MorphGAC).</p>
<p>Geodesic active contours implemented with morphological operators. It can
be used to segment objects with visible but noisy, cluttered, broken
borders.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gimage</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Preprocessed image or volume to be segmented. This is very rarely the
original image. Instead, this is usually a preprocessed version of the
original image that enhances and highlights the borders (or other
structures) of the object to segment.
<cite>morphological_geodesic_active_contour</cite> will try to stop the contour
evolution in areas where <cite>gimage</cite> is small. See
<cite>morphsnakes.inverse_gaussian_gradient</cite> as an example function to
perform this preprocessing. Note that the quality of
<cite>morphological_geodesic_active_contour</cite> might greatly depend on this
preprocessing.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">uint</span></dt><dd><p>Number of num_iter to run.</p>
</dd>
<dt><strong>init_level_set</strong><span class="classifier">str, (M, N) array, or (L, M, N) array</span></dt><dd><p>Initial level set. If an array is given, it will be binarized and used
as the initial level set. If a string is given, it defines the method
to generate a reasonable initial level set with the shape of the
<cite>image</cite>. Accepted values are &lsquo;checkerboard&rsquo; and &lsquo;disk&rsquo;. See the
documentation of <cite>checkerboard_level_set</cite> and <cite>disk_level_set</cite>
respectively for details about how these level sets are created.</p>
</dd>
<dt><strong>smoothing</strong><span class="classifier">uint, optional</span></dt><dd><p>Number of times the smoothing operator is applied per iteration.
Reasonable values are around 1-4. Larger values lead to smoother
segmentations.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Areas of the image with a value smaller than this threshold will be
considered borders. The evolution of the contour will stop in this
areas.</p>
</dd>
<dt><strong>balloon</strong><span class="classifier">float, optional</span></dt><dd><p>Balloon force to guide the contour in non-informative areas of the
image, i.e., areas where the gradient of the image is too small to push
the contour towards a border. A negative value will shrink the contour,
while a positive value will expand the contour in these areas. Setting
this to zero will disable the balloon force.</p>
</dd>
<dt><strong>iter_callback</strong><span class="classifier">function, optional</span></dt><dd><p>If given, this function is called once per iteration with the current
level set as the only argument. This is useful for debugging or for
plotting intermediate results during the evolution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Final segmentation (i.e., the final level set)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>iterations</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <cite>num_iter</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 22.02.00.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.inverse_gaussian_gradient" title="cucim.skimage.segmentation.inverse_gaussian_gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">inverse_gaussian_gradient()</span></code></a>, <a class="reference internal" href="#cucim.skimage.segmentation.disk_level_set" title="cucim.skimage.segmentation.disk_level_set"><code class="xref py py-func docutils literal notranslate"><span class="pre">disk_level_set()</span></code></a>, <a class="reference internal" href="#cucim.skimage.segmentation.checkerboard_level_set" title="cucim.skimage.segmentation.checkerboard_level_set"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkerboard_level_set()</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This is a version of the Geodesic Active Contours (GAC) algorithm that uses
morphological operators instead of solving partial differential equations
(PDEs) for the evolution of the contour. The set of morphological operators
used in this algorithm are proved to be infinitesimally equivalent to the
GAC PDEs (see <a class="reference internal" href="#ra07eed798308-1" id="id338">[1]</a>). However, morphological operators are do not suffer
from the numerical stability issues typically found in PDEs (e.g., it is
not necessary to find the right time step for the evolution), and are
computationally faster.</p>
<p>The algorithm and its theoretical derivation are described in <a class="reference internal" href="#ra07eed798308-1" id="id339">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra07eed798308-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id338">1</a>,<a href="#id339">2</a>)</span></dt>
<dd><p>A Morphological Approach to Curvature-based Evolution of Curves and
Surfaces, Pablo M&aacute;rquez-Neila, Luis Baumela, Luis &Aacute;lvarez. In IEEE
Transactions on Pattern Analysis and Machine Intelligence (PAMI),
2014, <a class="reference external" href="https://doi.org/10.1109/TPAMI.2013.106">DOI:10.1109/TPAMI.2013.106</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.random_walker">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">random_walker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">130</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cg_j'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_full_prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.random_walker" title="Permalink to this definition">#</a></dt>
<dd><p>Random walker algorithm for segmentation from markers.</p>
<p>Random walker algorithm is implemented for gray-level or multichannel
images.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Image to be segmented in phases. Gray-level <cite>data</cite> can be two- or
three-dimensional; multichannel data can be three- or four-
dimensional with <cite>channel_axis</cite> specifying the dimension containing
channels. Data spacing is assumed isotropic unless the <cite>spacing</cite>
keyword argument is used.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">array of ints, of same shape as <cite>data</cite> without channels dimension</span></dt><dd><p>Array of seed markers labeled with different positive integers
for different phases. Zero-labeled pixels are unlabeled pixels.
Negative labels correspond to inactive pixels that are not taken
into account (they are removed from the graph). If labels are not
consecutive integers, the labels array will be transformed so that
labels are consecutive. In the multichannel case, <cite>labels</cite> should have
the same shape as a single channel of <cite>data</cite>, i.e. without the final
dimension denoting channels.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>Penalization coefficient for the random walker motion
(the greater <cite>beta</cite>, the more difficult the diffusion).</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string, available options {&lsquo;cg&rsquo;, &lsquo;cg_j&rsquo;, &lsquo;cg_mg&rsquo;, &lsquo;bf&rsquo;}</span></dt><dd><p>Mode for solving the linear system in the random walker algorithm.</p>
<ul class="simple">
<li><p>&lsquo;bf&rsquo; (brute force): an LU factorization of the Laplacian is
computed. This is fast for small images (&lt;1024x1024), but very slow
and memory-intensive for large images (e.g., 3-D volumes).</p></li>
<li><p>&lsquo;cg&rsquo; (conjugate gradient): the linear system is solved iteratively
using the Conjugate Gradient method from scipy.sparse.linalg. This is
less memory-consuming than the brute force method for large images,
but it is quite slow.</p></li>
<li><p>&lsquo;cg_j&rsquo; (conjugate gradient with Jacobi preconditionner): the
Jacobi preconditionner is applied during the Conjugate
gradient method iterations. This may accelerate the
convergence of the &lsquo;cg&rsquo; method.</p></li>
<li><p>&lsquo;cg_mg&rsquo; (conjugate gradient with multigrid preconditioner): a
preconditioner is computed using a multigrid solver, then the
solution is computed with the Conjugate Gradient method. This mode
requires that the pyamg module is installed.</p></li>
</ul>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance to achieve when solving the linear system using
the conjugate gradient based modes (&lsquo;cg&rsquo;, &lsquo;cg_j&rsquo; and &lsquo;cg_mg&rsquo;).</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>If copy is False, the <cite>labels</cite> array will be overwritten with
the result of the segmentation. Use copy=False if you want to
save on memory.</p>
</dd>
<dt><strong>return_full_prob</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the probability that a pixel belongs to each of the
labels will be returned, instead of only the most likely
label.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Spacing between voxels in each spatial dimension. If <cite>None</cite>, then
the spacing between pixels/voxels in each dimension is assumed 1.</p>
</dd>
<dt><strong>prob_tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance on the resulting probability to be in the interval [0, 1].
If the tolerance is not satisfied, a warning is displayed.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><ul class="simple">
<li><p>If <cite>return_full_prob</cite> is False, array of ints of same shape
and data type as <cite>labels</cite>, in which each pixel has been
labeled according to the marker that reached the pixel first
by anisotropic diffusion.</p></li>
<li><p>If <cite>return_full_prob</cite> is True, array of floats of shape
<cite>(nlabels, labels.shape)</cite>. <cite>output[label_nb, i, j]</cite> is the
probability that label <cite>label_nb</cite> reaches the pixel <cite>(i, j)</cite>
first.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Multichannel inputs are scaled with all channel data combined. Ensure all
channels are separately normalized prior to running this algorithm.</p>
<p>The <cite>spacing</cite> argument is specifically for anisotropic datasets, where
data points are spaced differently in one or more spatial dimensions.
Anisotropic data is commonly encountered in medical imaging.</p>
<p>The algorithm was first proposed in <a class="reference internal" href="#rbeca6ade2f68-1" id="id341">[1]</a>.</p>
<p>The algorithm solves the diffusion equation at infinite times for
sources placed on markers of each phase in turn. A pixel is labeled with
the phase that has the greatest probability to diffuse first to the pixel.</p>
<p>The diffusion equation is solved by minimizing x.T L x for each phase,
where L is the Laplacian of the weighted graph of the image, and x is
the probability that a marker of the given phase arrives first at a pixel
by diffusion (x=1 on markers of the phase, x=0 on the other markers, and
the other coefficients are looked for). Each pixel is attributed the label
for which it has a maximal value of x. The Laplacian L of the image
is defined as:</p>
<blockquote>
<div><ul class="simple">
<li><p>L_ii = d_i, the number of neighbors of pixel i (the degree of i)</p></li>
<li><p>L_ij = -w_ij if i and j are adjacent pixels</p></li>
</ul>
</div></blockquote>
<p>The weight w_ij is a decreasing function of the norm of the local gradient.
This ensures that diffusion is easier between pixels of similar values.</p>
<p>When the Laplacian is decomposed into blocks of marked and unmarked
pixels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="n">M</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span>
    <span class="n">B</span> <span class="n">A</span>
</pre></div>
</div>
<p>with first indices corresponding to marked pixels, and then to unmarked
pixels, minimizing x.T L x for one phase amount to solving:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span> <span class="n">B</span> <span class="n">x_m</span>
</pre></div>
</div>
<p>where x_m = 1 on markers of the given phase, and 0 on other markers.
This linear system is solved in the algorithm using a direct method for
small images, and an iterative method for larger images.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbeca6ade2f68-1"><span class="brackets"><a class="fn-backref" href="#id341">1</a></span></dt>
<dd><p>Leo Grady, Random walks for image segmentation, IEEE Trans Pattern
Anal Mach Intell. 2006 Nov;28(11):1768-83.
<a class="reference external" href="https://doi.org/10.1109/TPAMI.2006.233">DOI:10.1109/TPAMI.2006.233</a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Marker for first phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Marker for second phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_walker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.relabel_sequential">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">relabel_sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.relabel_sequential" title="Permalink to this definition">#</a></dt>
<dd><p>Relabel arbitrary labels to {<cite>offset</cite>, &hellip; <cite>offset</cite> + number_of_labels}.</p>
<p>This function also returns the forward map (mapping the original labels to
the reduced labels) and the inverse map (mapping the reduced labels back
to the original ones).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label_field</strong><span class="classifier">numpy array of int, arbitrary shape</span></dt><dd><p>An array of labels, which must be non-negative integers.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int, optional</span></dt><dd><p>The return labels will start at <cite>offset</cite>, which should be
strictly positive.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>relabeled</strong><span class="classifier">numpy array of int, same shape as <cite>label_field</cite></span></dt><dd><p>The input label field with labels mapped to
{offset, &hellip;, number_of_labels + offset - 1}.
The data type will be the same as <cite>label_field</cite>, except when
offset + number_of_labels causes overflow of the current data type.</p>
</dd>
<dt><strong>forward_map</strong><span class="classifier">ArrayMap</span></dt><dd><p>The map from the original label space to the returned label
space. Can be used to re-apply the same mapping. See examples
for usage. The output data type will be the same as <cite>relabeled</cite>.</p>
</dd>
<dt><strong>inverse_map</strong><span class="classifier">ArrayMap</span></dt><dd><p>The map from the new label space to the original space. This
can be used to reconstruct the original label field from the
relabeled one. The output data type will be the same as <cite>label_field</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The label 0 is assumed to denote the background and is never remapped.</p>
<p>The forward map can be extremely big for some inputs, since its
length is given by the maximum of the label field. However, in most
situations, <code class="docutils literal notranslate"><span class="pre">label_field.max()</span></code> is much smaller than
<code class="docutils literal notranslate"><span class="pre">label_field.size</span></code>, and in these cases the forward map is
guaranteed to be smaller than either the input or output images.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.segmentation</span> <span class="kn">import</span> <span class="n">relabel_sequential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_field</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">42</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">relabel_sequential</span><span class="p">(</span><span class="n">label_field</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span>
<span class="go">array([1, 1, 2, 2, 3, 5, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fw</span><span class="p">)</span>
<span class="go">ArrayMap:</span>
<span class="go">  1 &rarr; 1</span>
<span class="go">  5 &rarr; 2</span>
<span class="go">  8 &rarr; 3</span>
<span class="go">  42 &rarr; 4</span>
<span class="go">  99 &rarr; 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fw</span><span class="p">)</span>
<span class="go">array([0, 1, 0, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inv</span><span class="p">)</span>
<span class="go">array([ 0,  1,  5,  8, 42, 99])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">fw</span><span class="p">[</span><span class="n">label_field</span><span class="p">]</span> <span class="o">==</span> <span class="n">relab</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">array(True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">inv</span><span class="p">[</span><span class="n">relab</span><span class="p">]</span> <span class="o">==</span> <span class="n">label_field</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">array(True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">relabel_sequential</span><span class="p">(</span><span class="n">label_field</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span>
<span class="go">array([5, 5, 6, 6, 7, 9, 8])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.transform">
<span id="transform"></span><h3>transform<a class="headerlink" href="#module-cucim.skimage.transform" title="Permalink to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">AffineTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.10/site-packages/cupy/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform" title="Permalink to this definition">#</a></dt>
<dd><p>Affine transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">sx</span></code> and <code class="docutils literal notranslate"><span class="pre">sy</span></code> are scale factors in the x and y directions,
and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">a1</span>  <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">b1</span>  <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>In 2D, the transformation parameters can be given as the homogeneous
transformation matrix, above, or as the implicit parameters, scale,
rotation, shear, and translation in x (a2) and y (b2). For 3D and higher,
only the matrix form is allowed.</p>
<p>In narrower transforms, such as the Euclidean (only rotation and
translation) or Similarity (rotation, translation, and a global scale
factor) transforms, it is possible to specify 3D transforms using implicit
parameters also.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) ndarray, optional</span></dt><dd><p>Homogeneous transformation matrix. If this matrix is provided, it is an
error to provide any of scale, rotation, shear, or translation.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{s as float or (sx, sy) as ndarray, list or tuple}, optional</span></dt><dd><p>Scale factor(s). If a single value, it will be assigned to both
sx and sy. Only available for 2D.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span>Added support for supplying a single scalar value.</p>
</div>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians. Only
available for 2D.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">float, optional</span></dt><dd><p>Shear angle in counter-clockwise direction as radians. Only available
for 2D.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(tx, ty) as ndarray, list or tuple, optional</span></dt><dd><p>Translation parameters. Only available for 2D.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The dimensionality of the transform. This is not used if any other
parameters are provided.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>If both <code class="docutils literal notranslate"><span class="pre">matrix</span></code> and any of the other parameters are provided.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) ndarray</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform.rotation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform.rotation" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform.scale">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale</span></span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform.scale" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform.shear">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shear</span></span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform.shear" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform.translation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform.translation" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.EssentialMatrixTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">EssentialMatrixTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.10/site-packages/cupy/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.EssentialMatrixTransform" title="Permalink to this definition">#</a></dt>
<dd><p>Essential matrix transformation.</p>
<p>The essential matrix relates corresponding points between a pair of
calibrated images. The matrix transforms normalized, homogeneous image
points in one image to epipolar lines in the other image.</p>
<p>The essential matrix is only defined for a pair of moving images capturing a
non-planar scene. In the case of pure rotation or planar scenes, the
homography describes the geometric relation between two images
(<cite>ProjectiveTransform</cite>). If the intrinsic calibration of the images is
unknown, the fundamental matrix describes the projective relation between
the two images (<cite>FundamentalMatrixTransform</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rotation</strong><span class="classifier">(3, 3) ndarray, optional</span></dt><dd><p>Rotation matrix of the relative camera motion.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(3, 1) ndarray, optional</span></dt><dd><p>Translation vector of the relative camera motion. The vector must
have unit length.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) ndarray, optional</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r42dd810e13a3-1"><span class="brackets">1</span></dt>
<dd><p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.EssentialMatrixTransform.estimate" title="cucim.skimage.transform.EssentialMatrixTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate essential matrix using 8-point algorithm.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.EssentialMatrixTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.EssentialMatrixTransform.estimate" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate essential matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.EuclideanTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">EuclideanTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.10/site-packages/cupy/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.EuclideanTransform" title="Permalink to this definition">#</a></dt>
<dd><p>Euclidean transformation, also known as a rigid transform.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The Euclidean transformation is a rigid transformation with rotation and
translation parameters. The similarity transformation extends the Euclidean
transformation with a single scaling factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) ndarray, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float or sequence of float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians. If given as
a vector, it is interpreted as Euler rotation angles <a class="reference internal" href="#ra85de9f51a41-1" id="id344">[1]</a>. Only 2D
(single rotation) and 3D (Euler rotations) values are supported. For
higher dimensions, you must provide or estimate the transformation
matrix.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">sequence of float, length D, optional</span></dt><dd><p>Translation parameters for each axis.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The dimensionality of the transform.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra85de9f51a41-1"><span class="brackets"><a class="fn-backref" href="#id344">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions">https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) ndarray</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.EuclideanTransform.estimate" title="cucim.skimage.transform.EuclideanTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.EuclideanTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.EuclideanTransform.estimate" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, D) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, D) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.EuclideanTransform.rotation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#cucim.skimage.transform.EuclideanTransform.rotation" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.EuclideanTransform.translation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#cucim.skimage.transform.EuclideanTransform.translation" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.FundamentalMatrixTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">FundamentalMatrixTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.10/site-packages/cupy/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.FundamentalMatrixTransform" title="Permalink to this definition">#</a></dt>
<dd><p>Fundamental matrix transformation.</p>
<p>The fundamental matrix relates corresponding points between a pair of
uncalibrated images. The matrix transforms homogeneous image points in one
image to epipolar lines in the other image.</p>
<p>The fundamental matrix is only defined for a pair of moving images. In the
case of pure rotation or planar scenes, the homography describes the
geometric relation between two images (<cite>ProjectiveTransform</cite>). If the
intrinsic calibration of the images is known, the essential matrix describes
the metric relation between the two images (<cite>EssentialMatrixTransform</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(3, 3) ndarray, optional</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ree05424bfe6b-1"><span class="brackets">1</span></dt>
<dd><p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(coords)</p></td>
<td><p>Apply forward transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.FundamentalMatrixTransform.estimate" title="cucim.skimage.transform.FundamentalMatrixTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate fundamental matrix using 8-point algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.FundamentalMatrixTransform.inverse" title="cucim.skimage.transform.FundamentalMatrixTransform.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>(coords)</p></td>
<td><p>Apply inverse transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.FundamentalMatrixTransform.residuals" title="cucim.skimage.transform.FundamentalMatrixTransform.residuals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">residuals</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Compute the Sampson distance.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.FundamentalMatrixTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.FundamentalMatrixTransform.estimate" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate fundamental matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.FundamentalMatrixTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.FundamentalMatrixTransform.inverse" title="Permalink to this definition">#</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 3) ndarray</span></dt><dd><p>Epipolar lines in the source image.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.FundamentalMatrixTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.FundamentalMatrixTransform.residuals" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Sampson distance.</p>
<p>The Sampson distance is the first approximation to the geometric error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) ndarray</span></dt><dd><p>Sampson distance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.PiecewiseAffineTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">PiecewiseAffineTransform</span></span><a class="headerlink" href="#cucim.skimage.transform.PiecewiseAffineTransform" title="Permalink to this definition">#</a></dt>
<dd><p>Piecewise affine transformation.</p>
<p>Control points are used to define the mapping. The transform is based on
a Delaunay triangulation of the points to form a mesh. Each triangle is
used to find a local affine transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Affine transformations for each triangle in the mesh.</p>
</dd>
<dt><strong>inverse_affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Inverse affine transformations for each triangle in the mesh.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(coords)</p></td>
<td><p>Apply forward transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.PiecewiseAffineTransform.estimate" title="cucim.skimage.transform.PiecewiseAffineTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.PiecewiseAffineTransform.inverse" title="cucim.skimage.transform.PiecewiseAffineTransform.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>(coords)</p></td>
<td><p>Apply inverse transformation.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.PiecewiseAffineTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PiecewiseAffineTransform.estimate" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, D) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, D) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if all pieces of the model are successfully estimated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.PiecewiseAffineTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PiecewiseAffineTransform.inverse" title="Permalink to this definition">#</a></dt>
<dd><p>Apply inverse transformation.</p>
<p>Coordinates outside of the mesh will be set to <cite>- 1</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) ndarray</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.PolynomialTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">PolynomialTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.10/site-packages/cupy/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PolynomialTransform" title="Permalink to this definition">#</a></dt>
<dd><p>2D polynomial transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) ndarray, optional</span></dt><dd><p>Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) ndarray</span></dt><dd><p>Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(coords)</p></td>
<td><p>Apply forward transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.PolynomialTransform.estimate" title="cucim.skimage.transform.PolynomialTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst[,&nbsp;order,&nbsp;weights])</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.PolynomialTransform.inverse" title="cucim.skimage.transform.PolynomialTransform.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>(coords)</p></td>
<td><p>Apply inverse transformation.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.PolynomialTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PolynomialTransform.estimate" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">...</span> <span class="mi">0</span> <span class="o">...</span>             <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="o">...</span>                 <span class="mi">0</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a00</span> <span class="n">a10</span> <span class="n">a11</span> <span class="n">a20</span> <span class="n">a21</span> <span class="n">a22</span> <span class="o">...</span> <span class="n">ann</span>
       <span class="n">b00</span> <span class="n">b10</span> <span class="n">b11</span> <span class="n">b20</span> <span class="n">b21</span> <span class="n">b22</span> <span class="o">...</span> <span class="n">bnn</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>Weights can be applied to each pair of corresponding points to
indicate, particularly in an overdetermined system, if point pairs have
higher or lower confidence or uncertainties associated with them. From
the matrix treatment of least squares problems, these weight values are
normalised, square-rooted, then built into a diagonal matrix, by which
A is multiplied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Polynomial order (number of coefficients is order + 1).</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) ndarray, optional</span></dt><dd><p>Relative weight values for each pair of points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.PolynomialTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PolynomialTransform.inverse" title="Permalink to this definition">#</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.ProjectiveTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">ProjectiveTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.10/site-packages/cupy/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.ProjectiveTransform" title="Permalink to this definition">#</a></dt>
<dd><p>Projective transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <span class="math notranslate nohighlight">\(\mathbf{x} = [x, y, 1]^T\)</span>, its
target position is calculated by multiplying with the given matrix,
<span class="math notranslate nohighlight">\(H\)</span>, to give <span class="math notranslate nohighlight">\(H \mathbf{x}\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">c0</span> <span class="n">c1</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>  <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>            <span class="mi">0</span>         <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">20</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) ndarray, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The number of dimensions of the transform. This is ignored if
<code class="docutils literal notranslate"><span class="pre">matrix</span></code> is not None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) ndarray</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(coords)</p></td>
<td><p>Apply forward transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.ProjectiveTransform.estimate" title="cucim.skimage.transform.ProjectiveTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst[,&nbsp;weights])</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.ProjectiveTransform.inverse" title="cucim.skimage.transform.ProjectiveTransform.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>(coords)</p></td>
<td><p>Apply inverse transformation.</p></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.ProjectiveTransform.dimensionality">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dimensionality</span></span><a class="headerlink" href="#cucim.skimage.transform.ProjectiveTransform.dimensionality" title="Permalink to this definition">#</a></dt>
<dd><p>The dimensionality of the transformation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.ProjectiveTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.ProjectiveTransform.estimate" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c0</span> <span class="n">c1</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>Weights can be applied to each pair of corresponding points to
indicate, particularly in an overdetermined system, if point pairs have
higher or lower confidence or uncertainties associated with them. From
the matrix treatment of least squares problems, these weight values are
normalised, square-rooted, then built into a diagonal matrix, by which
A is multiplied.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) ndarray, optional</span></dt><dd><p>Relative weight values for each pair of points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.ProjectiveTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.ProjectiveTransform.inverse" title="Permalink to this definition">#</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords_out</strong><span class="classifier">(N, D) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.SimilarityTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">SimilarityTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.10/site-packages/cupy/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.SimilarityTransform" title="Permalink to this definition">#</a></dt>
<dd><p>Similarity transformation.</p>
<p>Has the following form in 2D:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">s</span></code> is a scale factor and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The similarity transformation extends the Euclidean transformation with a
single scaling factor in addition to the rotation and translation
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(dim+1, dim+1) ndarray, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float, optional</span></dt><dd><p>Scale factor. Implemented only for 2D and 3D.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians.
Implemented only for 2D and 3D. For 3D, this is given in XZX Euler
angles.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(dim,) ndarray-like, optional</span></dt><dd><p>x, y[, z] translation parameters. Implemented only for 2D and 3D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(dim+1, dim+1) ndarray</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.SimilarityTransform.estimate" title="cucim.skimage.transform.SimilarityTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.SimilarityTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.SimilarityTransform.estimate" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.SimilarityTransform.scale">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale</span></span><a class="headerlink" href="#cucim.skimage.transform.SimilarityTransform.scale" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.downscale_local_mean">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">downscale_local_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.downscale_local_mean" title="Permalink to this definition">#</a></dt>
<dd><p>Down-sample N-dimensional image by local averaging.</p>
<p>The image is padded with <cite>cval</cite> if it is not perfectly divisible by the
integer factors.</p>
<p>In contrast to interpolation in <cite>skimage.transform.resize</cite> and
<cite>skimage.transform.rescale</cite> this function calculates the local mean of
elements in each block of size <cite>factors</cite> in the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>N-dimensional input image.</p>
</dd>
<dt><strong>factors</strong><span class="classifier">array_like</span></dt><dd><p>Array containing down-sampling integer factor along each axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
integer factors.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Unused, but kept here for API consistency with the other transforms
in this module. (The local mean will never fall outside the range
of values in the input image, assuming the provided <cite>cval</cite> also
falls within that range.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.
For integer inputs, the output dtype will be <code class="docutils literal notranslate"><span class="pre">float64</span></code>.
See <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean" title="(in NumPy v1.24)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.mean()</span></code></a> for details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [10, 11, 12, 13, 14]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downscale_local_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[3.5, 4. ],</span>
<span class="go">       [5.5, 4.5]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.estimate_transform">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">estimate_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ttype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.estimate_transform" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ttype</strong><span class="classifier">{&lsquo;euclidean&rsquo;, similarity&rsquo;, &lsquo;affine&rsquo;, &lsquo;piecewise-affine&rsquo;,              &lsquo;projective&rsquo;, &lsquo;polynomial&rsquo;}</span></dt><dd><p>Type of transform.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">ndarray or int</span></dt><dd><p>Function parameters (src, dst, n, angle):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>NAME / TTYPE        FUNCTION PARAMETERS
'euclidean'         `src, `dst`
'similarity'        `src, `dst`
'affine'            `src, `dst`
'piecewise-affine'  `src, `dst`
'projective'        `src, `dst`
'polynomial'        `src, `dst`, `order` (polynomial order,
                                          default order is 2)
</pre></div>
</div>
<p>Also see examples below.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tform</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></span></dt><dd><p>Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">transform</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s1">'similarity'</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)),</span> <span class="n">src</span><span class="p">)</span>
<span class="go">array(True)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span> 
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">tform2</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)))</span>
<span class="go">array(True)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.integral_image">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">integral_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.integral_image" title="Permalink to this definition">#</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math notranslate nohighlight">
\[S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image/summed area table of same shape as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For better accuracy and to avoid potential overflow, the data type of the
output may differ from the input&rsquo;s when the default dtype of None is used.
For inputs with integer dtype, the behavior matches that for
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.cumsum.html#numpy.cumsum" title="(in NumPy v1.24)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.cumsum()</span></code></a>. Floating point inputs will be promoted to at least
double precision. The user can set <cite>dtype</cite> to override this behavior.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf29e65fd98a8-1"><span class="brackets">1</span></dt>
<dd><p>F.C. Crow, &ldquo;Summed-area tables for texture mapping,&rdquo;
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.integrate">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ii</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.integrate" title="Permalink to this definition">#</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ii</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image.</p>
</dd>
<dt><strong>start</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <cite>ii</cite></span></dt><dd><p>Coordinates of top left corner of window(s).
Each tuple in the list contains the starting row, col, &hellip; index
i.e <cite>[(row_win1, col_win1, &hellip;), (row_win2, col_win2,&hellip;), &hellip;]</cite>.</p>
</dd>
<dt><strong>end</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <cite>ii</cite></span></dt><dd><p>Coordinates of bottom right corner of window(s).
Each tuple in the list containing the end row, col, &hellip; index i.e
<cite>[(row_win1, col_win1, &hellip;), (row_win2, col_win2, &hellip;), &hellip;]</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">scalar or ndarray</span></dt><dd><p>Integral (sum) over the given window(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">integral_image</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># sum from (1, 0) to (1, 2)</span>
<span class="go">array([3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>  <span class="c1"># sum from (3, 3) to (4, 5)</span>
<span class="go">array([6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="go">array([3., 6.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.matrix_transform">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">matrix_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.matrix_transform" title="Permalink to this definition">#</a></dt>
<dd><p>Apply 2D matrix transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>x, y coordinates to transform</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.pyramid_expand">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.pyramid_expand" title="Permalink to this definition">#</a></dt>
<dd><p>Upsample and then smooth image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>upscale</strong><span class="classifier">float, optional</span></dt><dd><p>Upscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <cite>2 * upscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of upsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Upsampled and smoothed float image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r50c57162be63-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.pyramid_gaussian">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.pyramid_gaussian" title="Permalink to this definition">#</a></dt>
<dd><p>Yield images of the Gaussian pyramid formed by the input image.</p>
<p>Recursively applies the <cite>pyramid_reduce</cite> function to the image, and yields
the downscaled images.</p>
<p>Note that the first image of the pyramid will be the original, unscaled
image. The total number of images is <cite>max_layer + 1</cite>. In case all layers
are computed, the last image is either a one-pixel image or the image where
the reduction does not change its shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r937127d69afe-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.pyramid_laplacian">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_laplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.pyramid_laplacian" title="Permalink to this definition">#</a></dt>
<dd><p>Yield images of the laplacian pyramid formed by the input image.</p>
<p>Each layer contains the difference between the downsampled and the
downsampled, smoothed image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">layer</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">)</span> <span class="o">-</span> <span class="n">smooth</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of
images is <cite>max_layer + 1</cite>. In case all layers are computed, the last image
is either a one-pixel image or the image where the reduction does not
change its shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b6b3170da35-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
<dt class="label" id="r0b6b3170da35-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.pyramid_reduce">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.pyramid_reduce" title="Permalink to this definition">#</a></dt>
<dd><p>Smooth and then downsample image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Smoothed and downsampled float image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb5aed66567c5-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.rescale">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">rescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.rescale" title="Permalink to this definition">#</a></dt>
<dd><p>Scale image by a certain factor.</p>
<p>Performs interpolation to up-scale or down-scale N-dimensional images.
Note that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For down-sampling with an integer factor also see
<cite>skimage.transform.downscale_local_mean</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{float, tuple of floats}</span></dt><dd><p>Scale factors. Separate scale factors can be defined as
<cite>(rows, cols[, &hellip;][, dim])</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scaled</strong><span class="classifier">ndarray</span></dt><dd><p>Scaled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to down-scaling. It is crucial to filter when down-sampling
the image to avoid aliasing artifacts. If input image data
type is bool, no anti-aliasing is applied.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (s - 1) / 2 where s is the
down-scaling factor.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22.02.00: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 22.02.00.</p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes &lsquo;reflect&rsquo; and &lsquo;symmetric&rsquo; are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">rescale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(51, 51)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(256, 256)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.resize">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">resize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.resize" title="Permalink to this definition">#</a></dt>
<dd><p>Resize image to match a certain size.</p>
<p>Performs interpolation to up-size or down-size N-dimensional images. Note
that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For downsampling with an integer factor also see
<cite>skimage.transform.downscale_local_mean</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple or ndarray</span></dt><dd><p>Size of the generated output image <cite>(rows, cols[, &hellip;][, dim])</cite>. If
<cite>dim</cite> is not provided, the number of channels is preserved. In case the
number of input channels does not equal the number of output channels a
n-dimensional interpolation is applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resized</strong><span class="classifier">ndarray</span></dt><dd><p>Resized version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to downsampling. It is crucial to filter when downsampling
the image to avoid aliasing artifacts. If not specified, it is set to
True when downsampling an image whose data type is not bool.
It is also set to False when using nearest neighbor interpolation
(<code class="docutils literal notranslate"><span class="pre">order</span></code> == 0) with integer input data type.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering used when anti-aliasing.
By default, this value is chosen as (s - 1) / 2 where s is the
downsampling factor, where s &gt; 1. For the up-size case, s &lt; 1, no
anti-aliasing is performed prior to rescaling.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes &lsquo;reflect&rsquo; and &lsquo;symmetric&rsquo; are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.resize_local_mean">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">resize_local_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.resize_local_mean" title="Permalink to this definition">#</a></dt>
<dd><p>Resize an array with the local mean / bilinear scaling.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. If this is a multichannel image, the axis corresponding
to channels should be specified using <cite>channel_axis</cite></p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple or ndarray</span></dt><dd><p>Size of the generated output image. When <cite>channel_axis</cite> is not None,
the <cite>channel_axis</cite> should either be omitted from <cite>output_shape</cite> or the
<code class="docutils literal notranslate"><span class="pre">output_shape[channel_axis]</span></code> must match
<code class="docutils literal notranslate"><span class="pre">image.shape[channel_axis]</span></code>. If the length of <cite>output_shape</cite> exceeds
image.ndim, additional singleton dimensions will be appended to the
input <code class="docutils literal notranslate"><span class="pre">image</span></code> as needed.</p>
</dd>
<dt><strong>grid_mode</strong><span class="classifier">bool, optional</span></dt><dd><p>Defines <code class="docutils literal notranslate"><span class="pre">image</span></code> pixels position: if True, pixels are assumed to be at
grid intersections, otherwise at cell centers. As a consequence,
for example, a 1d signal of length 5 is considered to have length 4
when <cite>grid_mode</cite> is False, but length 5 when <cite>grid_mode</cite> is True. See
the following visual illustration:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| pixel 1 | pixel 2 | pixel 3 | pixel 4 | pixel 5 |
     |&lt;--------------------------------------&gt;|
                        vs.
|&lt;-----------------------------------------------&gt;|
</pre></div>
</div>
<p>The starting point of the arrow in the diagram above corresponds to
coordinate location 0 in each mode.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resized</strong><span class="classifier">ndarray</span></dt><dd><p>Resized version of the input.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.transform.resize" title="cucim.skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code></a>, <a class="reference internal" href="#cucim.skimage.transform.downscale_local_mean" title="cucim.skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downscale_local_mean</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This method is sometimes referred to as &ldquo;area-based&rdquo; interpolation or
&ldquo;pixel mixing&rdquo; interpolation <a class="reference internal" href="#ra76f015d1e1d-1" id="id353">[1]</a>. When <cite>grid_mode</cite> is True, it is
equivalent to using OpenCV&rsquo;s resize with <cite>INTER_AREA</cite> interpolation mode.
It is commonly used for image downsizing. If the downsizing factors are
integers, then <cite>downscale_local_mean</cite> should be preferred instead.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra76f015d1e1d-1"><span class="brackets"><a class="fn-backref" href="#id353">1</a></span></dt>
<dd><p><a class="reference external" href="http://entropymine.com/imageworsener/pixelmixing/">http://entropymine.com/imageworsener/pixelmixing/</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">resize_local_mean</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize_local_mean</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.rotate">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.rotate" title="Permalink to this definition">#</a></dt>
<dd><p>Rotate image by a certain angle around its center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Rotation angle in degrees in counter-clockwise direction.</p>
</dd>
<dt><strong>resize</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is
False.</p>
</dd>
<dt><strong>center</strong><span class="classifier">iterable of length 2</span></dt><dd><p>The rotation center. If <code class="docutils literal notranslate"><span class="pre">center=None</span></code>, the image is rotated around
its center, i.e. <code class="docutils literal notranslate"><span class="pre">center=(cols</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5,</span> <span class="pre">rows</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5)</span></code>.  Please
note that this parameter is (cols, rows), contrary to normal skimage
ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rotated</strong><span class="classifier">ndarray</span></dt><dd><p>Rotated version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes &lsquo;reflect&rsquo; and &lsquo;symmetric&rsquo; are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p>If <code class="docutils literal notranslate"><span class="pre">image.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code>, the rotation occurs for the first two dimensions of
the array. Unlike the scikit-image implementation, more than one additional
axis may be present on the array.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">rotate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(530, 530)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.swirl">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">swirl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.swirl" title="Permalink to this definition">#</a></dt>
<dd><p>Perform a swirl transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">(column, row) tuple or (2,) ndarray, optional</span></dt><dd><p>Center coordinate of transformation.</p>
</dd>
<dt><strong>strength</strong><span class="classifier">float, optional</span></dt><dd><p>The amount of swirling applied.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>The extent of the swirl in pixels.  The effect dies out
rapidly beyond <cite>radius</cite>.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Additional rotation applied to the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>swirled</strong><span class="classifier">ndarray</span></dt><dd><p>Swirled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode, with &lsquo;constant&rsquo; used as the default. Modes match
the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.warp">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.warp" title="Permalink to this definition">#</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>inverse_map</strong><span class="classifier">transformation object, callable <code class="docutils literal notranslate"><span class="pre">cr</span> <span class="pre">=</span> <span class="pre">f(cr,</span> <span class="pre">**kwargs)</span></code>, or ndarray</span></dt><dd><p>Inverse coordinate map, which transforms coordinates in the output
images into their corresponding coordinates in the input image.</p>
<p>There are a number of different options to define this map, depending
on the dimensionality of the input image. A 2-D image can have 2
dimensions for gray-scale images, or 3 dimensions with color
information.</p>
<blockquote>
<div><ul class="simple">
<li><p>For 2-D images, you can directly pass a transformation object,
e.g. <cite>skimage.transform.SimilarityTransform</cite>, or its inverse.</p></li>
<li><p>For 2-D images, you can pass a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> homogeneous
transformation matrix, e.g.
<cite>skimage.transform.SimilarityTransform.params</cite>.</p></li>
<li><p>For 2-D images, a function that transforms a <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">2)</span></code> array of
<code class="docutils literal notranslate"><span class="pre">(col,</span> <span class="pre">row)</span></code> coordinates in the output image to their
corresponding coordinates in the input image. Extra parameters to
the function can be specified through <cite>map_args</cite>.</p></li>
<li><p>For N-D images, you can directly pass an array of coordinates.
The first dimension specifies the coordinates in the input image,
while the subsequent dimensions determine the position in the
output image. E.g. in case of 2-D images, you need to pass an array
of shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">rows,</span> <span class="pre">cols)</span></code>, where <cite>rows</cite> and <cite>cols</cite> determine the
shape of the output image, and the first dimension contains the
<code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> coordinate in the input image.
See <cite>scipy.ndimage.map_coordinates</cite> for further documentation.</p></li>
</ul>
</div></blockquote>
<p>Note, that a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> matrix is interpreted as a homogeneous
transformation matrix, so you cannot interpolate values from a 3-D
input, if the output is of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>.</p>
<p>See example section for usage.</p>
</dd>
<dt><strong>map_args</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments passed to <cite>inverse_map</cite>.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.  Note that, even for multi-band images, only rows
and columns need to be specified.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><dl>
<dt>The order of interpolation. The order has to be in the range 0-5:</dt><dd><ul class="simple">
<li><p>0: Nearest-neighbor</p></li>
<li><p>1: Bi-linear (default)</p></li>
<li><p>2: Bi-quadratic</p></li>
<li><p>3: Bi-cubic</p></li>
<li><p>4: Bi-quartic</p></li>
<li><p>5: Bi-quintic</p></li>
</ul>
<p>Default is 0 if image.dtype is bool and 1 otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">double ndarray</span></dt><dd><p>The warped input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input image is converted to a <cite>double</cite> image.</p></li>
<li><p>In case of a <cite>SimilarityTransform</cite>, <cite>AffineTransform</cite> and
<cite>ProjectiveTransform</cite> and <cite>order</cite> in [0, 3] this function uses the
underlying transformation matrix to warp the image with a much faster
routine.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
</pre></div>
</div>
<p>The following image warps are all equal but differ substantially in
execution time. The image is shifted to the bottom.</p>
<p>Use a geometric transform to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a callable (slow):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_down</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_down</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a transformation matrix to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">ProjectiveTransform</span><span class="p">,</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ProjectiveTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also use the inverse of a geometric transformation (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<p>For N-D images you can pass a coordinate array, that specifies the
coordinates in the input image for every element in the output image. E.g.
if you want to rescale a 3-D cube, you can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cube_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">cube_shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Setup the coordinate array, that defines the scaling:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">cube_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">])</span>
</pre></div>
</div>
<p>Assume that the cube contains spatial data, where the first array element
center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to
account for this extra offset when scaling the image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.warp_coords">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.warp_coords" title="Permalink to this definition">#</a></dt>
<dd><p>Build the source coordinates for the output of a 2-D image warp.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coord_map</strong><span class="classifier">callable like GeometricTransform.inverse</span></dt><dd><p>Return input coordinates for given output coordinates.
Coordinates are in the shape (P, 2), where P is the number
of coordinates and each element is a <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> pair.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple</span></dt><dd><p>Shape of output image <code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols[,</span> <span class="pre">bands])</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype or string</span></dt><dd><p>dtype for return value (sane choices: float32 or float64).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>coords</strong><span class="classifier">(ndim, rows, cols[, bands]) array of dtype <cite>dtype</cite></span></dt><dd><p>Coordinates for <cite>scipy.ndimage.map_coordinates</cite>, that will yield
an image of shape (orows, ocols, bands) by drawing from source
points according to the <cite>coord_transform_fn</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a lower-level routine that produces the source coordinates for 2-D
images used by <cite>warp()</cite>.</p>
<p>It is provided separately from <cite>warp</cite> to give additional flexibility to
users who would like, for example, to re-use a particular coordinate
mapping, to use specific dtypes at various points along the the
image-warping process, or to implement different post-processing logic
than <cite>warp</cite> performs after the call to <cite>ndi.map_coordinates</cite>.</p>
<p class="rubric">Examples</p>
<p>Produce a coordinate map that shifts an image up and to the right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">warp_coords</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupyx.scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_up10_left20</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">warp_coords</span><span class="p">(</span><span class="n">shift_up10_left20</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.warp_polar">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp_polar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.warp_polar" title="Permalink to this definition">#</a></dt>
<dd><p>Remap image to polar or log-polar coordinates space.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. Only 2-D arrays are accepted by default. 3-D arrays are
accepted if a <cite>channel_axis</cite> is specified.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple (row, col), optional</span></dt><dd><p>Point in image that represents the center of the transformation (i.e.,
the origin in cartesian space). Values can be of type <cite>float</cite>.
If no value is given, the center is assumed to be the center point
of the image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius of the circle that bounds the area to be transformed.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (row, col), optional</span></dt><dd></dd>
<dt><strong>scaling</strong><span class="classifier">{&lsquo;linear&rsquo;, &lsquo;log&rsquo;}, optional</span></dt><dd><p>Specify whether the image warp is polar or log-polar. Defaults to
&lsquo;linear&rsquo;.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22.02.00: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 22.02.00.</p>
</div>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>Passed to <cite>transform.warp</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">ndarray</span></dt><dd><p>The polar or log-polar warped image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Perform a basic polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">warp_polar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">checkerboard</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">'log'</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image while specifying center,
radius, and output shape:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">output_shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">'log'</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a color image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">'log'</span><span class="p">,</span> <span class="n">channel_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.util">
<span id="util"></span><h3>util<a class="headerlink" href="#module-cucim.skimage.util" title="Permalink to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.crop">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">crop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crop_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.crop" title="Permalink to this definition">#</a></dt>
<dd><p>Crop array <cite>ar</cite> by <cite>crop_width</cite> along each dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">array-like of rank N</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>crop_width</strong><span class="classifier">{sequence, int}</span></dt><dd><p>Number of values to remove from the edges of each axis.
<code class="docutils literal notranslate"><span class="pre">((before_1,</span> <span class="pre">after_1),</span></code> &hellip; <code class="docutils literal notranslate"><span class="pre">(before_N,</span> <span class="pre">after_N))</span></code> specifies
unique crop widths at the start and end of each axis.
<code class="docutils literal notranslate"><span class="pre">((before,</span> <span class="pre">after),)</span> <span class="pre">or</span> <span class="pre">(before,</span> <span class="pre">after)</span></code> specifies
a fixed start and end crop for every axis.
<code class="docutils literal notranslate"><span class="pre">(n,)</span></code> or <code class="docutils literal notranslate"><span class="pre">n</span></code> for integer <code class="docutils literal notranslate"><span class="pre">n</span></code> is a shortcut for
before = after = <code class="docutils literal notranslate"><span class="pre">n</span></code> for all axes.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, ensure the returned array is a contiguous copy. Normally,
a crop operation will return a discontiguous view of the underlying
input array.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{&lsquo;C&rsquo;, &lsquo;F&rsquo;, &lsquo;A&rsquo;, &lsquo;K&rsquo;}, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">copy==True</span></code>, control the memory layout of the copy. See
<code class="docutils literal notranslate"><span class="pre">np.copy</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cropped</strong><span class="classifier">array</span></dt><dd><p>The cropped array. If <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> (default), this is a sliced
view of the input array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.dtype_limits">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">dtype_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.dtype_limits" title="Permalink to this definition">#</a></dt>
<dd><p>Return intensity limits, i.e. (min, max) tuple, of the image&rsquo;s dtype.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>clip_negative</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, clip the negative range (i.e. return 0 for min intensity)
even if the image dtype allows negative values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>imin, imax</strong><span class="classifier">tuple</span></dt><dd><p>Lower and upper intensity limits.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_bool">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_bool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_bool" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image to boolean format.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray of bool (<cite>bool_</cite>)</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The upper half of the input dtype&rsquo;s positive range is True, and the lower
half is False. All negative values (if present) are False.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_float">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_float" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image to floating point format.</p>
<p>This function is similar to <cite>img_as_float64</cite>, but will not convert
lower-precision floating point arrays to <cite>float64</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of float</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively.
If the input image has a float type, intensity values are not modified
and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_float32">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_float32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_float32" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image to single-precision (32-bit) floating point format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of float32</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively.
If the input image has a float type, intensity values are not modified
and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_float64">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_float64</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_float64" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image to double-precision (64-bit) floating point format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of float64</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively.
If the input image has a float type, intensity values are not modified
and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_int">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_int" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image to 16-bit signed integer format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of int16</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The values are scaled between -32768 and 32767.
If the input data-type is positive-only (e.g., uint8), then
the output image will still only have positive values.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_ubyte">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_ubyte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_ubyte" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image to 8-bit unsigned integer format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of ubyte (uint8)</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Negative input values will be clipped.
Positive values are scaled between 0 and 255.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_uint">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_uint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_uint" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an image to 16-bit unsigned integer format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of uint16</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Negative input values will be clipped.
Positive values are scaled between 0 and 65535.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.invert">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed_float</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.invert" title="Permalink to this definition">#</a></dt>
<dd><p>Invert an image.</p>
<p>Invert the intensity range of the input image, so that the dtype maximum
is now the dtype minimum, and vice-versa. This operation is
slightly different depending on the input dtype:</p>
<ul class="simple">
<li><p>unsigned integers: subtract the image from the dtype maximum</p></li>
<li><p>signed integers: subtract the image from -1 (see Notes)</p></li>
<li><p>floats: subtract the image from 1 (if signed_float is False, so we
assume the image is unsigned), or from 0 (if signed_float is True).</p></li>
</ul>
<p>See the examples for clarification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>signed_float</strong><span class="classifier">bool, optional</span></dt><dd><p>If True and the image is of type float, the range is assumed to
be [-1, 1]. If False and the image is of type float, the range is
assumed to be [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inverted</strong><span class="classifier">ndarray</span></dt><dd><p>Inverted image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Ideally, for signed integers we would simply multiply by -1. However,
signed integer ranges are asymmetric. For example, for np.int8, the range
of possible values is [-128, 127], so that -128 * -1 equals -128! By
subtracting from -1, we correctly map the maximum dtype value to the
minimum.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">100</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mi">30</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="go">array([[155, 255,  55],</span>
<span class="go">       [255, 205, 255],</span>
<span class="go">       [225, 255,   0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="p">[</span><span class="mi">127</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">5</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert</span><span class="p">(</span><span class="n">img2</span><span class="p">)</span>
<span class="go">array([[   1,   -1,  127],</span>
<span class="go">       [-128,   -1,   -6]], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img3</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert</span><span class="p">(</span><span class="n">img3</span><span class="p">)</span>
<span class="go">array([[1.  , 0.  , 0.5 , 0.25]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img4</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert</span><span class="p">(</span><span class="n">img4</span><span class="p">,</span> <span class="n">signed_float</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[-0.  , -1.  ,  1.  ,  0.25]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.map_array">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">map_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.map_array" title="Permalink to this definition">#</a></dt>
<dd><p>Map values from input array from input_vals to output_vals.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_arr</strong><span class="classifier">array of int, shape (M[, N][, P][, &hellip;])</span></dt><dd><p>The input label image.</p>
</dd>
<dt><strong>input_vals</strong><span class="classifier">array of int, shape (N,)</span></dt><dd><p>The values to map from.</p>
</dd>
<dt><strong>output_vals</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>The values to map to.</p>
</dd>
<dt><strong>out: array, same shape as `input_arr`</strong></dt><dd><p>The output array. Will be created if not provided. It should
have the same dtype as <cite>output_vals</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array, same shape as <cite>input_arr</cite></span></dt><dd><p>The array of mapped values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.random_noise">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">random_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.random_noise" title="Permalink to this definition">#</a></dt>
<dd><p>Function to add random noise of various types to a floating-point image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image data. Will be converted to float.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>One of the following strings, selecting the type of noise to add:</p>
<dl class="simple">
<dt>&lsquo;gaussian&rsquo; (default)</dt><dd><p>Gaussian-distributed additive noise.</p>
</dd>
<dt>&lsquo;localvar&rsquo;</dt><dd><p>Gaussian-distributed additive noise, with specified local variance
at each point of <cite>image</cite>.</p>
</dd>
<dt>&lsquo;poisson&rsquo;</dt><dd><p>Poisson-distributed noise generated from the data.</p>
</dd>
<dt>&lsquo;salt&rsquo;</dt><dd><p>Replaces random pixels with 1.</p>
</dd>
<dt>&lsquo;pepper&rsquo;</dt><dd><p>Replaces random pixels with 0 (for unsigned images) or -1 (for
signed images).</p>
</dd>
<dt>&lsquo;s&amp;p&rsquo;</dt><dd><p>Replaces random pixels with either 1 or <cite>low_val</cite>, where <cite>low_val</cite>
is 0 for unsigned images or -1 for signed images.</p>
</dd>
<dt>&lsquo;speckle&rsquo;</dt><dd><p>Multiplicative noise using <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">image</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">image</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code>
is Gaussian noise with specified mean &amp; variance.</p>
</dd>
</dl>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>If provided, this will set the random seed before generating noise,
for valid pseudo-random comparisons.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), the output will be clipped after noise applied
for modes <cite>&lsquo;speckle&rsquo;</cite>, <cite>&lsquo;poisson&rsquo;</cite>, and <cite>&lsquo;gaussian&rsquo;</cite>. This is
needed to maintain the proper image data range. If False, clipping
is not applied, and the output may extend beyond the range [-1, 1].</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float, optional</span></dt><dd><p>Mean of random distribution. Used in &lsquo;gaussian&rsquo; and &lsquo;speckle&rsquo;.
Default : 0.</p>
</dd>
<dt><strong>var</strong><span class="classifier">float, optional</span></dt><dd><p>Variance of random distribution. Used in &lsquo;gaussian&rsquo; and &lsquo;speckle&rsquo;.
Note: variance = (standard deviation) ** 2. Default : 0.01</p>
</dd>
<dt><strong>local_vars</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Array of positive floats, same shape as <cite>image</cite>, defining the local
variance at every image point. Used in &lsquo;localvar&rsquo;.</p>
</dd>
<dt><strong>amount</strong><span class="classifier">float, optional</span></dt><dd><p>Proportion of image pixels to replace with noise on range [0, 1].
Used in &lsquo;salt&rsquo;, &lsquo;pepper&rsquo;, and &lsquo;salt &amp; pepper&rsquo;. Default : 0.05</p>
</dd>
<dt><strong>salt_vs_pepper</strong><span class="classifier">float, optional</span></dt><dd><p>Proportion of salt vs. pepper noise for &lsquo;s&amp;p&rsquo; on range [0, 1].
Higher values represent more salt. Default : 0.5 (equal amounts)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Output floating-point image data on range [0, 1] or [-1, 1] if the
input <cite>image</cite> was unsigned or signed, respectively.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Speckle, Poisson, Localvar, and Gaussian noise may generate noise outside
the valid image range. The default is to clip (not alias) these values,
but they may be preserved by setting <cite>clip=False</cite>. Note that in this case
the output may contain values outside the ranges [0, 1] or [-1, 1].
Use this option with care.</p>
<p>Because of the prevalence of exclusively positive floating-point images in
intermediate calculations, it is not possible to intuit if an input is
signed based on dtype alone. Instead, negative values are explicitly
searched for. Only if found does this function assume signed input.
Unexpected results only occur in rare, poorly exposes cases (e.g. if all
values are above 50 percent gray in a signed <cite>image</cite>). In this event,
manually scaling the input to the positive domain will solve the problem.</p>
<p>The Poisson distribution is only defined for positive integers. To apply
this noise type, the number of unique values in the image is found and
the next round power of two is used to scale up the floating-point result,
after which it is scaled back down to the floating-point image range.</p>
<p>To generate Poisson noise against a signed image, the signed image is
temporarily converted to an unsigned image in the floating point domain,
Poisson noise is generated, then it is returned to the original range.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.view_as_blocks">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">view_as_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.view_as_blocks" title="Permalink to this definition">#</a></dt>
<dd><p>Block view of the input n-dimensional array (using re-striding).</p>
<p>Blocks are non-overlapping views of the input array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr_in</strong><span class="classifier">ndarray</span></dt><dd><p>N-d input array.</p>
</dd>
<dt><strong>block_shape</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the block. Each dimension must divide evenly into the
corresponding dimensions of <cite>arr_in</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr_out</strong><span class="classifier">ndarray</span></dt><dd><p>Block view of the input array.  If <cite>arr_in</cite> is non-contiguous, a
copy is made.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.util.shape</span> <span class="kn">import</span> <span class="n">view_as_blocks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_blocks</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">block_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[2, 3],</span>
<span class="go">       [6, 7]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array(13)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>  
<span class="go">array([[[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">        [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">        [12, 13, 14, 15, 16, 17],</span>
<span class="go">        [18, 19, 20, 21, 22, 23]],</span>
<span class="go">       [[24, 25, 26, 27, 28, 29],</span>
<span class="go">        [30, 31, 32, 33, 34, 35],</span>
<span class="go">        [36, 37, 38, 39, 40, 41],</span>
<span class="go">        [42, 43, 44, 45, 46, 47]],</span>
<span class="go">       [[48, 49, 50, 51, 52, 53],</span>
<span class="go">        [54, 55, 56, 57, 58, 59],</span>
<span class="go">        [60, 61, 62, 63, 64, 65],</span>
<span class="go">        [66, 67, 68, 69, 70, 71]],</span>
<span class="go">       [[72, 73, 74, 75, 76, 77],</span>
<span class="go">        [78, 79, 80, 81, 82, 83],</span>
<span class="go">        [84, 85, 86, 87, 88, 89],</span>
<span class="go">        [90, 91, 92, 93, 94, 95]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_blocks</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">block_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 2, 3, 1, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">array([[[[52, 53],</span>
<span class="go">         [58, 59]]],</span>
<span class="go">       [[[76, 77],</span>
<span class="go">         [82, 83]]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.view_as_windows">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">view_as_windows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.view_as_windows" title="Permalink to this definition">#</a></dt>
<dd><p>Rolling window view of the input n-dimensional array.</p>
<p>Windows are overlapping views of the input array, with adjacent windows
shifted by a single row or column (or an index of a higher dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr_in</strong><span class="classifier">ndarray</span></dt><dd><p>N-d input array.</p>
</dd>
<dt><strong>window_shape</strong><span class="classifier">integer or tuple of length arr_in.ndim</span></dt><dd><p>Defines the shape of the elementary n-dimensional orthotope
(better know as hyperrectangle <a class="reference internal" href="#rba40a1c6483a-1" id="id355">[1]</a>) of the rolling window view.
If an integer is given, the shape will be a hypercube of
sidelength given by its value.</p>
</dd>
<dt><strong>step</strong><span class="classifier">integer or tuple of length arr_in.ndim</span></dt><dd><p>Indicates step size at which extraction shall be performed.
If integer is given, then the step is uniform in all dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr_out</strong><span class="classifier">ndarray</span></dt><dd><p>(rolling) window view of the input array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>One should be very careful with rolling views when it comes to
memory usage.  Indeed, although a &lsquo;view&rsquo; has the same memory
footprint as its base array, the actual array that emerges when this
&lsquo;view&rsquo; is used in a computation is generally a (much) larger array
than the original, especially for 2-dimensional arrays and above.</p>
<p>For example, let us consider a 3 dimensional array of size (100,
100, 100) of <code class="docutils literal notranslate"><span class="pre">float64</span></code>. This array takes about 8*100**3 Bytes for
storage which is just 8 MB. If one decides to build a rolling view
on this array with a window of (3, 3, 3) the hypothetical size of
the rolling view (if one was to reshape the view for example) would
be 8*(100-3+1)**3*3**3 which is about 203 MB! The scaling becomes
even worse as the dimension of the input array becomes larger.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rba40a1c6483a-1"><span class="brackets"><a class="fn-backref" href="#id355">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Hyperrectangle">https://en.wikipedia.org/wiki/Hyperrectangle</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.util.shape</span> <span class="kn">import</span> <span class="n">view_as_windows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [5, 6]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(8, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [2, 3, 4],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [4, 5, 6],</span>
<span class="go">       [5, 6, 7],</span>
<span class="go">       [6, 7, 8],</span>
<span class="go">       [7, 8, 9]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15],</span>
<span class="go">       [16, 17, 18, 19]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>  
<span class="go">array([[[[ 0,  1,  2],</span>
<span class="go">         [ 4,  5,  6],</span>
<span class="go">         [ 8,  9, 10],</span>
<span class="go">         [12, 13, 14]],</span>
<span class="go">        [[ 1,  2,  3],</span>
<span class="go">         [ 5,  6,  7],</span>
<span class="go">         [ 9, 10, 11],</span>
<span class="go">         [13, 14, 15]]],</span>
<span class="go">       [[[ 4,  5,  6],</span>
<span class="go">         [ 8,  9, 10],</span>
<span class="go">         [12, 13, 14],</span>
<span class="go">         [16, 17, 18]],</span>
<span class="go">        [[ 5,  6,  7],</span>
<span class="go">         [ 9, 10, 11],</span>
<span class="go">         [13, 14, 15],</span>
<span class="go">         [17, 18, 19]]]])</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="submodule-contents">
<h2>Submodule Contents<a class="headerlink" href="#submodule-contents" title="Permalink to this heading">#</a></h2>
<section id="module-cucim.skimage">
<span id="skimage"></span><h3>skimage<a class="headerlink" href="#module-cucim.skimage" title="Permalink to this heading">#</a></h3>
<p>GPU Image Processing for Python</p>
<p>This module is a CuPy based implementation of a subset of scikit-image.</p>
<p>It is a collection of algorithms for image processing and computer vision.</p>
<p>The main package only provides a few utilities for converting between image
data types; for most features, you need to import one of the following
subpackages:</p>
<section id="subpackages">
<h4>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>color</dt><dd><p>Color space conversion.</p>
</dd>
<dt>data</dt><dd><p>Test images and example data.</p>
</dd>
<dt>exposure</dt><dd><p>Image intensity adjustment, e.g., histogram equalization, etc.</p>
</dd>
<dt>feature</dt><dd><p>Feature detection and extraction, e.g., texture analysis corners, etc.</p>
</dd>
<dt>filters</dt><dd><p>Sharpening, edge finding, rank filters, thresholding, etc.</p>
</dd>
<dt>measure</dt><dd><p>Measurement of image properties, e.g., region properties and contours.</p>
</dd>
<dt>metrics</dt><dd><p>Metrics corresponding to images, e.g. distance metrics, similarity, etc.</p>
</dd>
<dt>morphology</dt><dd><p>Morphological operations, e.g., opening or skeletonization.</p>
</dd>
<dt>restoration</dt><dd><p>Restoration algorithms, e.g., deconvolution algorithms, denoising, etc.</p>
</dd>
<dt>segmentation</dt><dd><p>Partitioning an image into multiple regions.</p>
</dd>
<dt>transform</dt><dd><p>Geometric and other transforms, e.g., rotation or the Radon transform.</p>
</dd>
<dt>util</dt><dd><p>Generic utilities.</p>
</dd>
</dl>
</section>
<section id="utility-functions">
<h4>Utility Functions<a class="headerlink" href="#utility-functions" title="Permalink to this heading">#</a></h4>
<dl class="simple">
<dt>img_as_float</dt><dd><p>Convert an image to floating point format, with values in [0, 1].
Is similar to <cite>img_as_float64</cite>, but will not convert lower-precision
floating point arrays to <cite>float64</cite>.</p>
</dd>
<dt>img_as_float32</dt><dd><p>Convert an image to single-precision (32-bit) floating point format,
with values in [0, 1].</p>
</dd>
<dt>img_as_float64</dt><dd><p>Convert an image to double-precision (64-bit) floating point format,
with values in [0, 1].</p>
</dd>
<dt>img_as_uint</dt><dd><p>Convert an image to unsigned integer format, with values in [0, 65535].</p>
</dd>
<dt>img_as_int</dt><dd><p>Convert an image to signed integer format, with values in [-32768, 32767].</p>
</dd>
<dt>img_as_ubyte</dt><dd><p>Convert an image to unsigned byte format, with values in [0, 255].</p>
</dd>
<dt>img_as_bool</dt><dd><p>Convert an image to boolean format, with values either True or False.</p>
</dd>
<dt>dtype_limits</dt><dd><p>Return intensity limits, i.e. (min, max) tuple, of the image&rsquo;s dtype.</p>
</dd>
</dl>
</section>
</section>
</section>
</section>


            </article>
            
            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class="prev-next-area">
  <a class="left-prev" href="index.html" id="prev-link" title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Welcome to cuCIM&rsquo;s documentation!</p>
      </div>
  </a>
</div>
            </footer>
            
          </div>
          
          
          
            <div class="bd-sidebar-secondary bd-toc">
              
<div class="toc-item">
  
<div class="tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
</div>
<nav class="page-toc" id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cucim.clara">
   Clara Submodules
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cucim.clara.CuImage">
     <code class="docutils literal notranslate">
      <span class="pre">
       CuImage
      </span>
     </code>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.associated_image">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.associated_image()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.associated_images">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.associated_images
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.cache">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.cache()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.channel_names">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.channel_names
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.close">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.close()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.coord_sys">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.coord_sys
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.device">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.device
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.dims">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.dims
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.direction">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.direction
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.dtype">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.dtype
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.is_loaded">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.is_loaded
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.is_trace_enabled">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.is_trace_enabled
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.metadata">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.metadata
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.ndim">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.ndim
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.origin">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.origin
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.path">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.path
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.profiler">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.profiler()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.raw_metadata">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.raw_metadata
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.read_region">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.read_region()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.resolutions">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.resolutions
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.save">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.save()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.shape">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.shape
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.size">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.size()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.spacing">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.spacing()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.spacing_units">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.spacing_units()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.CuImage.typestr">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuImage.typestr
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cucim.clara.DLDataType">
     <code class="docutils literal notranslate">
      <span class="pre">
       DLDataType
      </span>
     </code>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataType.bits">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataType.bits
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataType.code">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataType.code
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataType.lanes">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataType.lanes
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cucim.clara.DLDataTypeCode">
     <code class="docutils literal notranslate">
      <span class="pre">
       DLDataTypeCode
      </span>
     </code>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataTypeCode.DLBfloat">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataTypeCode.DLBfloat
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataTypeCode.DLFloat">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataTypeCode.DLFloat
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataTypeCode.DLInt">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataTypeCode.DLInt
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataTypeCode.DLUInt">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataTypeCode.DLUInt
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataTypeCode.name">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataTypeCode.name
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.DLDataTypeCode.value">
       <code class="docutils literal notranslate">
        <span class="pre">
         DLDataTypeCode.value
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.clara.cache">
     cache
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.cache.CacheType">
       <code class="docutils literal notranslate">
        <span class="pre">
         CacheType
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.CacheType.NoCache">
         <code class="docutils literal notranslate">
          <span class="pre">
           CacheType.NoCache
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.CacheType.PerProcess">
         <code class="docutils literal notranslate">
          <span class="pre">
           CacheType.PerProcess
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.CacheType.SharedMemory">
         <code class="docutils literal notranslate">
          <span class="pre">
           CacheType.SharedMemory
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.CacheType.name">
         <code class="docutils literal notranslate">
          <span class="pre">
           CacheType.name
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.CacheType.value">
         <code class="docutils literal notranslate">
          <span class="pre">
           CacheType.value
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache">
       <code class="docutils literal notranslate">
        <span class="pre">
         ImageCache
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.capacity">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.capacity
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.config">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.config
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.free_memory">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.free_memory
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.hit_count">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.hit_count
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.memory_capacity">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.memory_capacity
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.memory_size">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.memory_size
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.miss_count">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.miss_count
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.record">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.record()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.reserve">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.reserve()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.size">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.size
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.cache.ImageCache.type">
         <code class="docutils literal notranslate">
          <span class="pre">
           ImageCache.type
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.cache.preferred_memory_capacity">
       <code class="docutils literal notranslate">
        <span class="pre">
         preferred_memory_capacity()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.clara.filesystem">
     filesystem
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.filesystem.CuFileDriver">
       <code class="docutils literal notranslate">
        <span class="pre">
         CuFileDriver
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.filesystem.CuFileDriver.close">
         <code class="docutils literal notranslate">
          <span class="pre">
           CuFileDriver.close()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.filesystem.CuFileDriver.pread">
         <code class="docutils literal notranslate">
          <span class="pre">
           CuFileDriver.pread()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.filesystem.CuFileDriver.pwrite">
         <code class="docutils literal notranslate">
          <span class="pre">
           CuFileDriver.pwrite()
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.filesystem.close">
       <code class="docutils literal notranslate">
        <span class="pre">
         close()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.filesystem.discard_page_cache">
       <code class="docutils literal notranslate">
        <span class="pre">
         discard_page_cache()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.filesystem.open">
       <code class="docutils literal notranslate">
        <span class="pre">
         open()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.filesystem.pread">
       <code class="docutils literal notranslate">
        <span class="pre">
         pread()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.filesystem.pwrite">
       <code class="docutils literal notranslate">
        <span class="pre">
         pwrite()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.clara.io">
     io
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.io.Device">
       <code class="docutils literal notranslate">
        <span class="pre">
         Device
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.Device.index">
         <code class="docutils literal notranslate">
          <span class="pre">
           Device.index
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.Device.parse_type">
         <code class="docutils literal notranslate">
          <span class="pre">
           Device.parse_type()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.Device.type">
         <code class="docutils literal notranslate">
          <span class="pre">
           Device.type
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType">
       <code class="docutils literal notranslate">
        <span class="pre">
         DeviceType
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType.CPU">
         <code class="docutils literal notranslate">
          <span class="pre">
           DeviceType.CPU
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType.CPUShared">
         <code class="docutils literal notranslate">
          <span class="pre">
           DeviceType.CPUShared
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType.CUDA">
         <code class="docutils literal notranslate">
          <span class="pre">
           DeviceType.CUDA
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType.CUDAHost">
         <code class="docutils literal notranslate">
          <span class="pre">
           DeviceType.CUDAHost
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType.CUDAManaged">
         <code class="docutils literal notranslate">
          <span class="pre">
           DeviceType.CUDAManaged
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType.CUDAShared">
         <code class="docutils literal notranslate">
          <span class="pre">
           DeviceType.CUDAShared
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType.name">
         <code class="docutils literal notranslate">
          <span class="pre">
           DeviceType.name
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.clara.io.DeviceType.value">
         <code class="docutils literal notranslate">
          <span class="pre">
           DeviceType.value
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#core-submodules">
   core Submodules
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.core.operations.color">
     color
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.color.color_jitter">
       <code class="docutils literal notranslate">
        <span class="pre">
         color_jitter()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.color.image_to_absorbance">
       <code class="docutils literal notranslate">
        <span class="pre">
         image_to_absorbance()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.color.normalize_colors_pca">
       <code class="docutils literal notranslate">
        <span class="pre">
         normalize_colors_pca()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.color.stain_extraction_pca">
       <code class="docutils literal notranslate">
        <span class="pre">
         stain_extraction_pca()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.core.operations.expose">
     expose
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.core.operations.intensity">
     intensity
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.intensity.normalize_data">
       <code class="docutils literal notranslate">
        <span class="pre">
         normalize_data()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.intensity.rand_zoom">
       <code class="docutils literal notranslate">
        <span class="pre">
         rand_zoom()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.intensity.scale_intensity_range">
       <code class="docutils literal notranslate">
        <span class="pre">
         scale_intensity_range()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.intensity.zoom">
       <code class="docutils literal notranslate">
        <span class="pre">
         zoom()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.core.operations.morphology">
     morphology
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.morphology.distance_transform_edt">
       <code class="docutils literal notranslate">
        <span class="pre">
         distance_transform_edt()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.core.operations.spatial">
     spatial
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.spatial.image_flip">
       <code class="docutils literal notranslate">
        <span class="pre">
         image_flip()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.spatial.image_rotate_90">
       <code class="docutils literal notranslate">
        <span class="pre">
         image_rotate_90()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.spatial.rand_image_flip">
       <code class="docutils literal notranslate">
        <span class="pre">
         rand_image_flip()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.core.operations.spatial.rand_image_rotate_90">
       <code class="docutils literal notranslate">
        <span class="pre">
         rand_image_rotate_90()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#skimage-submodules">
   skimage Submodules
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id13">
     color
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.combine_stains">
       <code class="docutils literal notranslate">
        <span class="pre">
         combine_stains()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.convert_colorspace">
       <code class="docutils literal notranslate">
        <span class="pre">
         convert_colorspace()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.deltaE_cie76">
       <code class="docutils literal notranslate">
        <span class="pre">
         deltaE_cie76()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.deltaE_ciede2000">
       <code class="docutils literal notranslate">
        <span class="pre">
         deltaE_ciede2000()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.deltaE_ciede94">
       <code class="docutils literal notranslate">
        <span class="pre">
         deltaE_ciede94()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.deltaE_cmc">
       <code class="docutils literal notranslate">
        <span class="pre">
         deltaE_cmc()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.gray2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         gray2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.gray2rgba">
       <code class="docutils literal notranslate">
        <span class="pre">
         gray2rgba()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.hed2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         hed2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.hsv2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         hsv2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.lab2lch">
       <code class="docutils literal notranslate">
        <span class="pre">
         lab2lch()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.lab2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         lab2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.lab2xyz">
       <code class="docutils literal notranslate">
        <span class="pre">
         lab2xyz()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.label2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         label2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.lch2lab">
       <code class="docutils literal notranslate">
        <span class="pre">
         lch2lab()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.luv2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         luv2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.luv2xyz">
       <code class="docutils literal notranslate">
        <span class="pre">
         luv2xyz()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2gray">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2gray()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2hed">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2hed()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2hsv">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2hsv()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2lab">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2lab()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2luv">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2luv()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2rgbcie">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2rgbcie()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2xyz">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2xyz()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2ycbcr">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2ycbcr()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2ydbdr">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2ydbdr()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2yiq">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2yiq()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2ypbpr">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2ypbpr()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgb2yuv">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgb2yuv()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgba2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgba2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.rgbcie2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         rgbcie2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.separate_stains">
       <code class="docutils literal notranslate">
        <span class="pre">
         separate_stains()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.xyz2lab">
       <code class="docutils literal notranslate">
        <span class="pre">
         xyz2lab()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.xyz2luv">
       <code class="docutils literal notranslate">
        <span class="pre">
         xyz2luv()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.xyz2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         xyz2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.ycbcr2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         ycbcr2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.ydbdr2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         ydbdr2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.yiq2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         yiq2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.ypbpr2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         ypbpr2rgb()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.color.yuv2rgb">
       <code class="docutils literal notranslate">
        <span class="pre">
         yuv2rgb()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.data">
     data
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.data.binary_blobs">
       <code class="docutils literal notranslate">
        <span class="pre">
         binary_blobs()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.exposure">
     exposure
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.adjust_gamma">
       <code class="docutils literal notranslate">
        <span class="pre">
         adjust_gamma()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.adjust_log">
       <code class="docutils literal notranslate">
        <span class="pre">
         adjust_log()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.adjust_sigmoid">
       <code class="docutils literal notranslate">
        <span class="pre">
         adjust_sigmoid()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.cumulative_distribution">
       <code class="docutils literal notranslate">
        <span class="pre">
         cumulative_distribution()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.equalize_adapthist">
       <code class="docutils literal notranslate">
        <span class="pre">
         equalize_adapthist()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.equalize_hist">
       <code class="docutils literal notranslate">
        <span class="pre">
         equalize_hist()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.histogram">
       <code class="docutils literal notranslate">
        <span class="pre">
         histogram()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.is_low_contrast">
       <code class="docutils literal notranslate">
        <span class="pre">
         is_low_contrast()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.match_histograms">
       <code class="docutils literal notranslate">
        <span class="pre">
         match_histograms()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.exposure.rescale_intensity">
       <code class="docutils literal notranslate">
        <span class="pre">
         rescale_intensity()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.feature">
     feature
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.blob_dog">
       <code class="docutils literal notranslate">
        <span class="pre">
         blob_dog()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.blob_doh">
       <code class="docutils literal notranslate">
        <span class="pre">
         blob_doh()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.blob_log">
       <code class="docutils literal notranslate">
        <span class="pre">
         blob_log()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.canny">
       <code class="docutils literal notranslate">
        <span class="pre">
         canny()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.corner_foerstner">
       <code class="docutils literal notranslate">
        <span class="pre">
         corner_foerstner()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.corner_harris">
       <code class="docutils literal notranslate">
        <span class="pre">
         corner_harris()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.corner_kitchen_rosenfeld">
       <code class="docutils literal notranslate">
        <span class="pre">
         corner_kitchen_rosenfeld()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.corner_peaks">
       <code class="docutils literal notranslate">
        <span class="pre">
         corner_peaks()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.corner_shi_tomasi">
       <code class="docutils literal notranslate">
        <span class="pre">
         corner_shi_tomasi()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.daisy">
       <code class="docutils literal notranslate">
        <span class="pre">
         daisy()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.hessian_matrix">
       <code class="docutils literal notranslate">
        <span class="pre">
         hessian_matrix()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.hessian_matrix_det">
       <code class="docutils literal notranslate">
        <span class="pre">
         hessian_matrix_det()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.hessian_matrix_eigvals">
       <code class="docutils literal notranslate">
        <span class="pre">
         hessian_matrix_eigvals()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.match_descriptors">
       <code class="docutils literal notranslate">
        <span class="pre">
         match_descriptors()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.match_template">
       <code class="docutils literal notranslate">
        <span class="pre">
         match_template()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.multiscale_basic_features">
       <code class="docutils literal notranslate">
        <span class="pre">
         multiscale_basic_features()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.peak_local_max">
       <code class="docutils literal notranslate">
        <span class="pre">
         peak_local_max()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.shape_index">
       <code class="docutils literal notranslate">
        <span class="pre">
         shape_index()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.structure_tensor">
       <code class="docutils literal notranslate">
        <span class="pre">
         structure_tensor()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.feature.structure_tensor_eigenvalues">
       <code class="docutils literal notranslate">
        <span class="pre">
         structure_tensor_eigenvalues()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.filters">
     filters
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.LPIFilter2D">
       <code class="docutils literal notranslate">
        <span class="pre">
         LPIFilter2D
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.apply_hysteresis_threshold">
       <code class="docutils literal notranslate">
        <span class="pre">
         apply_hysteresis_threshold()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.butterworth">
       <code class="docutils literal notranslate">
        <span class="pre">
         butterworth()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.correlate_sparse">
       <code class="docutils literal notranslate">
        <span class="pre">
         correlate_sparse()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.difference_of_gaussians">
       <code class="docutils literal notranslate">
        <span class="pre">
         difference_of_gaussians()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.farid">
       <code class="docutils literal notranslate">
        <span class="pre">
         farid()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.farid_h">
       <code class="docutils literal notranslate">
        <span class="pre">
         farid_h()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.farid_v">
       <code class="docutils literal notranslate">
        <span class="pre">
         farid_v()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.filter_inverse">
       <code class="docutils literal notranslate">
        <span class="pre">
         filter_inverse()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.frangi">
       <code class="docutils literal notranslate">
        <span class="pre">
         frangi()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.gabor">
       <code class="docutils literal notranslate">
        <span class="pre">
         gabor()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.gabor_kernel">
       <code class="docutils literal notranslate">
        <span class="pre">
         gabor_kernel()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.gaussian">
       <code class="docutils literal notranslate">
        <span class="pre">
         gaussian()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.hessian">
       <code class="docutils literal notranslate">
        <span class="pre">
         hessian()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.laplace">
       <code class="docutils literal notranslate">
        <span class="pre">
         laplace()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.median">
       <code class="docutils literal notranslate">
        <span class="pre">
         median()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.meijering">
       <code class="docutils literal notranslate">
        <span class="pre">
         meijering()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.prewitt">
       <code class="docutils literal notranslate">
        <span class="pre">
         prewitt()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.prewitt_h">
       <code class="docutils literal notranslate">
        <span class="pre">
         prewitt_h()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.prewitt_v">
       <code class="docutils literal notranslate">
        <span class="pre">
         prewitt_v()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.rank_order">
       <code class="docutils literal notranslate">
        <span class="pre">
         rank_order()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.roberts">
       <code class="docutils literal notranslate">
        <span class="pre">
         roberts()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.roberts_neg_diag">
       <code class="docutils literal notranslate">
        <span class="pre">
         roberts_neg_diag()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.roberts_pos_diag">
       <code class="docutils literal notranslate">
        <span class="pre">
         roberts_pos_diag()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.sato">
       <code class="docutils literal notranslate">
        <span class="pre">
         sato()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.scharr">
       <code class="docutils literal notranslate">
        <span class="pre">
         scharr()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.scharr_h">
       <code class="docutils literal notranslate">
        <span class="pre">
         scharr_h()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.scharr_v">
       <code class="docutils literal notranslate">
        <span class="pre">
         scharr_v()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.sobel">
       <code class="docutils literal notranslate">
        <span class="pre">
         sobel()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.sobel_h">
       <code class="docutils literal notranslate">
        <span class="pre">
         sobel_h()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.sobel_v">
       <code class="docutils literal notranslate">
        <span class="pre">
         sobel_v()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_isodata">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_isodata()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_li">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_li()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_local">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_local()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_mean">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_mean()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_minimum">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_minimum()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_multiotsu">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_multiotsu()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_niblack">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_niblack()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_otsu">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_otsu()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_sauvola">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_sauvola()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_triangle">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_triangle()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.threshold_yen">
       <code class="docutils literal notranslate">
        <span class="pre">
         threshold_yen()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.try_all_threshold">
       <code class="docutils literal notranslate">
        <span class="pre">
         try_all_threshold()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.unsharp_mask">
       <code class="docutils literal notranslate">
        <span class="pre">
         unsharp_mask()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.wiener">
       <code class="docutils literal notranslate">
        <span class="pre">
         wiener()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.filters.window">
       <code class="docutils literal notranslate">
        <span class="pre">
         window()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.measure">
     measure
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.approximate_polygon">
       <code class="docutils literal notranslate">
        <span class="pre">
         approximate_polygon()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.block_reduce">
       <code class="docutils literal notranslate">
        <span class="pre">
         block_reduce()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.blur_effect">
       <code class="docutils literal notranslate">
        <span class="pre">
         blur_effect()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.centroid">
       <code class="docutils literal notranslate">
        <span class="pre">
         centroid()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.inertia_tensor">
       <code class="docutils literal notranslate">
        <span class="pre">
         inertia_tensor()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.inertia_tensor_eigvals">
       <code class="docutils literal notranslate">
        <span class="pre">
         inertia_tensor_eigvals()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.intersection_coeff">
       <code class="docutils literal notranslate">
        <span class="pre">
         intersection_coeff()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.label">
       <code class="docutils literal notranslate">
        <span class="pre">
         label()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.manders_coloc_coeff">
       <code class="docutils literal notranslate">
        <span class="pre">
         manders_coloc_coeff()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.manders_overlap_coeff">
       <code class="docutils literal notranslate">
        <span class="pre">
         manders_overlap_coeff()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.moments">
       <code class="docutils literal notranslate">
        <span class="pre">
         moments()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.moments_central">
       <code class="docutils literal notranslate">
        <span class="pre">
         moments_central()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.moments_coords">
       <code class="docutils literal notranslate">
        <span class="pre">
         moments_coords()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.moments_coords_central">
       <code class="docutils literal notranslate">
        <span class="pre">
         moments_coords_central()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.moments_hu">
       <code class="docutils literal notranslate">
        <span class="pre">
         moments_hu()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.moments_normalized">
       <code class="docutils literal notranslate">
        <span class="pre">
         moments_normalized()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.pearson_corr_coeff">
       <code class="docutils literal notranslate">
        <span class="pre">
         pearson_corr_coeff()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.perimeter">
       <code class="docutils literal notranslate">
        <span class="pre">
         perimeter()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.profile_line">
       <code class="docutils literal notranslate">
        <span class="pre">
         profile_line()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.regionprops">
       <code class="docutils literal notranslate">
        <span class="pre">
         regionprops()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.regionprops_table">
       <code class="docutils literal notranslate">
        <span class="pre">
         regionprops_table()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.shannon_entropy">
       <code class="docutils literal notranslate">
        <span class="pre">
         shannon_entropy()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.measure.subdivide_polygon">
       <code class="docutils literal notranslate">
        <span class="pre">
         subdivide_polygon()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.metrics">
     metrics
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.metrics.adapted_rand_error">
       <code class="docutils literal notranslate">
        <span class="pre">
         adapted_rand_error()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.metrics.contingency_table">
       <code class="docutils literal notranslate">
        <span class="pre">
         contingency_table()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.metrics.mean_squared_error">
       <code class="docutils literal notranslate">
        <span class="pre">
         mean_squared_error()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.metrics.normalized_mutual_information">
       <code class="docutils literal notranslate">
        <span class="pre">
         normalized_mutual_information()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.metrics.normalized_root_mse">
       <code class="docutils literal notranslate">
        <span class="pre">
         normalized_root_mse()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.metrics.peak_signal_noise_ratio">
       <code class="docutils literal notranslate">
        <span class="pre">
         peak_signal_noise_ratio()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.metrics.structural_similarity">
       <code class="docutils literal notranslate">
        <span class="pre">
         structural_similarity()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.metrics.variation_of_information">
       <code class="docutils literal notranslate">
        <span class="pre">
         variation_of_information()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id254">
     morphology
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.ball">
       <code class="docutils literal notranslate">
        <span class="pre">
         ball()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.binary_closing">
       <code class="docutils literal notranslate">
        <span class="pre">
         binary_closing()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.binary_dilation">
       <code class="docutils literal notranslate">
        <span class="pre">
         binary_dilation()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.binary_erosion">
       <code class="docutils literal notranslate">
        <span class="pre">
         binary_erosion()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.binary_opening">
       <code class="docutils literal notranslate">
        <span class="pre">
         binary_opening()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.black_tophat">
       <code class="docutils literal notranslate">
        <span class="pre">
         black_tophat()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.closing">
       <code class="docutils literal notranslate">
        <span class="pre">
         closing()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.cube">
       <code class="docutils literal notranslate">
        <span class="pre">
         cube()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.diamond">
       <code class="docutils literal notranslate">
        <span class="pre">
         diamond()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.dilation">
       <code class="docutils literal notranslate">
        <span class="pre">
         dilation()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.disk">
       <code class="docutils literal notranslate">
        <span class="pre">
         disk()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.erosion">
       <code class="docutils literal notranslate">
        <span class="pre">
         erosion()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.isotropic_closing">
       <code class="docutils literal notranslate">
        <span class="pre">
         isotropic_closing()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.isotropic_dilation">
       <code class="docutils literal notranslate">
        <span class="pre">
         isotropic_dilation()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.isotropic_erosion">
       <code class="docutils literal notranslate">
        <span class="pre">
         isotropic_erosion()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.isotropic_opening">
       <code class="docutils literal notranslate">
        <span class="pre">
         isotropic_opening()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.medial_axis">
       <code class="docutils literal notranslate">
        <span class="pre">
         medial_axis()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.octagon">
       <code class="docutils literal notranslate">
        <span class="pre">
         octagon()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.octahedron">
       <code class="docutils literal notranslate">
        <span class="pre">
         octahedron()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.opening">
       <code class="docutils literal notranslate">
        <span class="pre">
         opening()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.reconstruction">
       <code class="docutils literal notranslate">
        <span class="pre">
         reconstruction()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.rectangle">
       <code class="docutils literal notranslate">
        <span class="pre">
         rectangle()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.remove_small_holes">
       <code class="docutils literal notranslate">
        <span class="pre">
         remove_small_holes()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.remove_small_objects">
       <code class="docutils literal notranslate">
        <span class="pre">
         remove_small_objects()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.square">
       <code class="docutils literal notranslate">
        <span class="pre">
         square()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.star">
       <code class="docutils literal notranslate">
        <span class="pre">
         star()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.thin">
       <code class="docutils literal notranslate">
        <span class="pre">
         thin()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.morphology.white_tophat">
       <code class="docutils literal notranslate">
        <span class="pre">
         white_tophat()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.registration">
     registration
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.registration.optical_flow_ilk">
       <code class="docutils literal notranslate">
        <span class="pre">
         optical_flow_ilk()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.registration.optical_flow_tvl1">
       <code class="docutils literal notranslate">
        <span class="pre">
         optical_flow_tvl1()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.registration.phase_cross_correlation">
       <code class="docutils literal notranslate">
        <span class="pre">
         phase_cross_correlation()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.restoration">
     restoration
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.restoration.calibrate_denoiser">
       <code class="docutils literal notranslate">
        <span class="pre">
         calibrate_denoiser()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.restoration.denoise_tv_chambolle">
       <code class="docutils literal notranslate">
        <span class="pre">
         denoise_tv_chambolle()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.restoration.richardson_lucy">
       <code class="docutils literal notranslate">
        <span class="pre">
         richardson_lucy()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.restoration.unsupervised_wiener">
       <code class="docutils literal notranslate">
        <span class="pre">
         unsupervised_wiener()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.restoration.wiener">
       <code class="docutils literal notranslate">
        <span class="pre">
         wiener()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.segmentation">
     segmentation
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.chan_vese">
       <code class="docutils literal notranslate">
        <span class="pre">
         chan_vese()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.checkerboard_level_set">
       <code class="docutils literal notranslate">
        <span class="pre">
         checkerboard_level_set()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.clear_border">
       <code class="docutils literal notranslate">
        <span class="pre">
         clear_border()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.disk_level_set">
       <code class="docutils literal notranslate">
        <span class="pre">
         disk_level_set()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.find_boundaries">
       <code class="docutils literal notranslate">
        <span class="pre">
         find_boundaries()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.inverse_gaussian_gradient">
       <code class="docutils literal notranslate">
        <span class="pre">
         inverse_gaussian_gradient()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.join_segmentations">
       <code class="docutils literal notranslate">
        <span class="pre">
         join_segmentations()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.mark_boundaries">
       <code class="docutils literal notranslate">
        <span class="pre">
         mark_boundaries()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.morphological_chan_vese">
       <code class="docutils literal notranslate">
        <span class="pre">
         morphological_chan_vese()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.morphological_geodesic_active_contour">
       <code class="docutils literal notranslate">
        <span class="pre">
         morphological_geodesic_active_contour()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.random_walker">
       <code class="docutils literal notranslate">
        <span class="pre">
         random_walker()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.segmentation.relabel_sequential">
       <code class="docutils literal notranslate">
        <span class="pre">
         relabel_sequential()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.transform">
     transform
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.AffineTransform">
       <code class="docutils literal notranslate">
        <span class="pre">
         AffineTransform
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.AffineTransform.rotation">
         <code class="docutils literal notranslate">
          <span class="pre">
           AffineTransform.rotation
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.AffineTransform.scale">
         <code class="docutils literal notranslate">
          <span class="pre">
           AffineTransform.scale
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.AffineTransform.shear">
         <code class="docutils literal notranslate">
          <span class="pre">
           AffineTransform.shear
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.AffineTransform.translation">
         <code class="docutils literal notranslate">
          <span class="pre">
           AffineTransform.translation
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.EssentialMatrixTransform">
       <code class="docutils literal notranslate">
        <span class="pre">
         EssentialMatrixTransform
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.EssentialMatrixTransform.estimate">
         <code class="docutils literal notranslate">
          <span class="pre">
           EssentialMatrixTransform.estimate()
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.EuclideanTransform">
       <code class="docutils literal notranslate">
        <span class="pre">
         EuclideanTransform
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.EuclideanTransform.estimate">
         <code class="docutils literal notranslate">
          <span class="pre">
           EuclideanTransform.estimate()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.EuclideanTransform.rotation">
         <code class="docutils literal notranslate">
          <span class="pre">
           EuclideanTransform.rotation
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.EuclideanTransform.translation">
         <code class="docutils literal notranslate">
          <span class="pre">
           EuclideanTransform.translation
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.FundamentalMatrixTransform">
       <code class="docutils literal notranslate">
        <span class="pre">
         FundamentalMatrixTransform
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.FundamentalMatrixTransform.estimate">
         <code class="docutils literal notranslate">
          <span class="pre">
           FundamentalMatrixTransform.estimate()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.FundamentalMatrixTransform.inverse">
         <code class="docutils literal notranslate">
          <span class="pre">
           FundamentalMatrixTransform.inverse()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.FundamentalMatrixTransform.residuals">
         <code class="docutils literal notranslate">
          <span class="pre">
           FundamentalMatrixTransform.residuals()
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.PiecewiseAffineTransform">
       <code class="docutils literal notranslate">
        <span class="pre">
         PiecewiseAffineTransform
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.PiecewiseAffineTransform.estimate">
         <code class="docutils literal notranslate">
          <span class="pre">
           PiecewiseAffineTransform.estimate()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.PiecewiseAffineTransform.inverse">
         <code class="docutils literal notranslate">
          <span class="pre">
           PiecewiseAffineTransform.inverse()
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.PolynomialTransform">
       <code class="docutils literal notranslate">
        <span class="pre">
         PolynomialTransform
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.PolynomialTransform.estimate">
         <code class="docutils literal notranslate">
          <span class="pre">
           PolynomialTransform.estimate()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.PolynomialTransform.inverse">
         <code class="docutils literal notranslate">
          <span class="pre">
           PolynomialTransform.inverse()
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.ProjectiveTransform">
       <code class="docutils literal notranslate">
        <span class="pre">
         ProjectiveTransform
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.ProjectiveTransform.dimensionality">
         <code class="docutils literal notranslate">
          <span class="pre">
           ProjectiveTransform.dimensionality
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.ProjectiveTransform.estimate">
         <code class="docutils literal notranslate">
          <span class="pre">
           ProjectiveTransform.estimate()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.ProjectiveTransform.inverse">
         <code class="docutils literal notranslate">
          <span class="pre">
           ProjectiveTransform.inverse()
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.SimilarityTransform">
       <code class="docutils literal notranslate">
        <span class="pre">
         SimilarityTransform
        </span>
       </code>
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.SimilarityTransform.estimate">
         <code class="docutils literal notranslate">
          <span class="pre">
           SimilarityTransform.estimate()
          </span>
         </code>
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#cucim.skimage.transform.SimilarityTransform.scale">
         <code class="docutils literal notranslate">
          <span class="pre">
           SimilarityTransform.scale
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.downscale_local_mean">
       <code class="docutils literal notranslate">
        <span class="pre">
         downscale_local_mean()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.estimate_transform">
       <code class="docutils literal notranslate">
        <span class="pre">
         estimate_transform()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.integral_image">
       <code class="docutils literal notranslate">
        <span class="pre">
         integral_image()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.integrate">
       <code class="docutils literal notranslate">
        <span class="pre">
         integrate()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.matrix_transform">
       <code class="docutils literal notranslate">
        <span class="pre">
         matrix_transform()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.pyramid_expand">
       <code class="docutils literal notranslate">
        <span class="pre">
         pyramid_expand()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.pyramid_gaussian">
       <code class="docutils literal notranslate">
        <span class="pre">
         pyramid_gaussian()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.pyramid_laplacian">
       <code class="docutils literal notranslate">
        <span class="pre">
         pyramid_laplacian()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.pyramid_reduce">
       <code class="docutils literal notranslate">
        <span class="pre">
         pyramid_reduce()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.rescale">
       <code class="docutils literal notranslate">
        <span class="pre">
         rescale()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.resize">
       <code class="docutils literal notranslate">
        <span class="pre">
         resize()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.resize_local_mean">
       <code class="docutils literal notranslate">
        <span class="pre">
         resize_local_mean()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.rotate">
       <code class="docutils literal notranslate">
        <span class="pre">
         rotate()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.swirl">
       <code class="docutils literal notranslate">
        <span class="pre">
         swirl()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.warp">
       <code class="docutils literal notranslate">
        <span class="pre">
         warp()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.warp_coords">
       <code class="docutils literal notranslate">
        <span class="pre">
         warp_coords()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.transform.warp_polar">
       <code class="docutils literal notranslate">
        <span class="pre">
         warp_polar()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage.util">
     util
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.crop">
       <code class="docutils literal notranslate">
        <span class="pre">
         crop()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.dtype_limits">
       <code class="docutils literal notranslate">
        <span class="pre">
         dtype_limits()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.img_as_bool">
       <code class="docutils literal notranslate">
        <span class="pre">
         img_as_bool()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.img_as_float">
       <code class="docutils literal notranslate">
        <span class="pre">
         img_as_float()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.img_as_float32">
       <code class="docutils literal notranslate">
        <span class="pre">
         img_as_float32()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.img_as_float64">
       <code class="docutils literal notranslate">
        <span class="pre">
         img_as_float64()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.img_as_int">
       <code class="docutils literal notranslate">
        <span class="pre">
         img_as_int()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.img_as_ubyte">
       <code class="docutils literal notranslate">
        <span class="pre">
         img_as_ubyte()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.img_as_uint">
       <code class="docutils literal notranslate">
        <span class="pre">
         img_as_uint()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.invert">
       <code class="docutils literal notranslate">
        <span class="pre">
         invert()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.map_array">
       <code class="docutils literal notranslate">
        <span class="pre">
         map_array()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.random_noise">
       <code class="docutils literal notranslate">
        <span class="pre">
         random_noise()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.view_as_blocks">
       <code class="docutils literal notranslate">
        <span class="pre">
         view_as_blocks()
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cucim.skimage.util.view_as_windows">
       <code class="docutils literal notranslate">
        <span class="pre">
         view_as_windows()
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#submodule-contents">
   Submodule Contents
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#module-cucim.skimage">
     skimage
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#subpackages">
       Subpackages
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#utility-functions">
       Utility Functions
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

</nav>
</div>

<div class="toc-item">
  
<div id="searchbox"></div>
</div>

<div class="toc-item">
  
</div>

<div class="toc-item">
  
<div class="tocsection sourcelink">
    <a href="_sources/api.rst.txt">
        <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
</div>

</div>

            </div>
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
          </div>
        </footer>
        
      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>

  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2020-2021, NVIDIA.<br>

</p>

  </div>
  
  <div class="footer-item">
    <p class="theme-version">
    Built with the
    <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">
        PyData Sphinx Theme
    </a>
    0.12.0.
</p>
  </div>
  
  <div class="footer-item">
    
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>

  </div>
  
</div>
  </footer>
  
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>