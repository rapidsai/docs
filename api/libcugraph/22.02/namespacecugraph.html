<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcugraph: cugraph Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcugraph</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">stable (22.02)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcugraph/nightly">nightly (22.04)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcugraph/stable">stable (22.02)</a><a class="rapids-selector__menu-item" href="/api/libcugraph/legacy">legacy (21.12)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cugraph Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Katz Centrality implementation.  
<a href="namespacecugraph.html#details">More...</a></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecugraph_1_1ext__raft"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugraph_1_1ext__raft.html">ext_raft</a></td></tr>
<tr class="memdesc:namespacecugraph_1_1ext__raft"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper function for Nvgraph balanced cut clustering. <br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1atomic__accumulate__thrust__tuple.html">atomic_accumulate_thrust_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1cast__edge__op__bool__to__integer.html">cast_edge_op_bool_to_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1col__properties__t.html">col_properties_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1compute__thrust__tuple__element__sizes.html">compute_thrust_tuple_element_sizes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1dataframe__element.html">dataframe_element</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1dataframe__element_3_01rmm_1_1device__uvector_3_01T_01_4_01_4.html">dataframe_element&lt; rmm::device_uvector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1dataframe__element_3_01std_1_1tuple_3_01rmm_1_1device__uvector_3_01T_01_4_8_8_8_01_4_01_4.html">dataframe_element&lt; std::tuple&lt; rmm::device_uvector&lt; T &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1dummy__properties__device__view__t.html">dummy_properties_device_view_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1dummy__properties__t.html">dummy_properties_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1edgelist__t.html">edgelist_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1evaluate__edge__op.html">evaluate_edge_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1graph__meta__t.html">graph_meta_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1graph__meta__t_3_01vertex__t_00_01edge__t_00_01multi__gpu_00_01std_1_1enable__if__t_3_01multi__gpu_01_4_01_4.html">graph_meta_t&lt; vertex_t, edge_t, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1graph__meta__t_3_01vertex__t_00_01edge__t_00_01multi__gpu_00_01std_1_1enable__if__t_3_9multi__gpu_01_4_01_4.html">graph_meta_t&lt; vertex_t, edge_t, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1graph__t.html">graph_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1graph__t_3_01vertex__t_00_01edge__t_00_01weight__t_00_01store__transposed_00_01m3f7c17fe4219df9b8f669eff3aef52e6.html">graph_t&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1graph__t_3_01vertex__t_00_01edge__t_00_01weight__t_00_01store__transposed_00_01m2fc6cedfe93871a8f0abf388ab08bcd3.html">graph_t&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1graph__view__meta__t.html">graph_view_meta_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1graph__view__meta__t_3_01vertex__t_00_01edge__t_00_01multi__gpu_00_01std_1_1ena7f39c62c6d367ee4fd0a3eb791d3227a.html">graph_view_meta_t&lt; vertex_t, edge_t, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1graph__view__meta__t_3_01vertex__t_00_01edge__t_00_01multi__gpu_00_01std_1_1enaa7227113adc41510420c5320dceb7f15.html">graph_view_meta_t&lt; vertex_t, edge_t, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1graph__view__t_3_01vertex__t_00_01edge__t_00_01weight__t_00_01store__transposed_50242af97bfb8ea0667346a3db6743be.html">graph_view_t&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1graph__view__t_3_01vertex__t_00_01edge__t_00_01weight__t_00_01store__transposed_78bf17bb0694a8676cff3c28df193524.html">graph_view_t&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__component__id.html">invalid_component_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__edge__id.html">invalid_edge_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__idx.html">invalid_idx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__idx_3_01T_00_01typename_01std_1_1enable__if__t_3_01std_1_1is__integrala86ae2d93d44d918b9efbc21d0fbe771.html">invalid_idx&lt; T, typename std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__idx_3_01T_00_01typename_01std_1_1enable__if__t_3_01std_1_1is__integral45babf51909e2de1c13670b29d67cf51.html">invalid_idx&lt; T, typename std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__vertex__id.html">invalid_vertex_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__arithmetic__or__thrust__tuple__of__arithmetic.html">is_arithmetic_or_thrust_tuple_of_arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__arithmetic__or__thrust__tuple__of__arithmetic_3_01thrust_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_arithmetic_or_thrust_tuple_of_arithmetic&lt; thrust::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__arithmetic__vector.html">is_arithmetic_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__arithmetic__vector_3_01Vector_3_01T_01_4_00_01Vector_01_4.html">is_arithmetic_vector&lt; Vector&lt; T &gt;, Vector &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__candidate.html">is_candidate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__one__of.html">is_one_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__one__of_3_01Src_01_4.html">is_one_of&lt; Src &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__one__of_3_01Src_00_01Head_00_01Tail_8_8_8_01_4.html">is_one_of&lt; Src, Head, Tail... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__std__tuple.html">is_std_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__std__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_std_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__std__tuple__of__arithmetic__vectors.html">is_std_tuple_of_arithmetic_vectors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__std__tuple__of__arithmetic__vectors_3_01std_1_1tuple_3_01rmm_1_1device__uve3b7f3b6fb038a250f9d6b54835b8882f.html">is_std_tuple_of_arithmetic_vectors&lt; std::tuple&lt; rmm::device_uvector&lt; Args &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__thrust__tuple_3_01thrust_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_thrust_tuple&lt; thrust::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic_3_01thrust_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">is_thrust_tuple_of_arithmetic&lt; thrust::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1is__vertex__edge__combo.html">is_vertex_edge_combo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when logical precondition is violated.  <a href="structcugraph_1_1logic__error.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1matrix__partition__device__view__t.html">matrix_partition_device_view_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1matrix__partition__device__view__t_3_01vertex__t_00_01edge__t_00_01weight__t_00_4003112d4f266ff3445cf43f5f886396.html">matrix_partition_device_view_t&lt; vertex_t, edge_t, weight_t, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1matrix__partition__device__view__t_3_01vertex__t_00_01edge__t_00_01weight__t_00_a80d84253e1c199368721fcdc1c5a6fa.html">matrix_partition_device_view_t&lt; vertex_t, edge_t, weight_t, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1matrix__partition__view__t.html">matrix_partition_view_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1matrix__partition__view__t_3_01vertex__t_00_01edge__t_00_01weight__t_00_01multi_4182aaaf6a1521178d6c6bcc7f40ae5d.html">matrix_partition_view_t&lt; vertex_t, edge_t, weight_t, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1matrix__partition__view__t_3_01vertex__t_00_01edge__t_00_01weight__t_00_01multi_b531d34b016bbce23074c5da0d021743.html">matrix_partition_view_t&lt; vertex_t, edge_t, weight_t, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1partition__t.html">partition_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">store vertex partitioning map  <a href="classcugraph_1_1partition__t.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1property__op.html">property_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1property__op_3_01thrust_1_1tuple_3_01Args_8_8_8_01_4_00_01Op_01_4.html">property_op&lt; thrust::tuple&lt; Args... &gt;, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1renumber__meta__t_3_01vertex__t_00_01edge__t_00_01multi__gpu_00_01std_1_1enable80e2fb438bdc1a365ff3181665439243.html">renumber_meta_t&lt; vertex_t, edge_t, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1renumber__meta__t_3_01vertex__t_00_01edge__t_00_01multi__gpu_00_01std_1_1enable__if__t_3_9multi__gpu_01_4_01_4.html">renumber_meta_t&lt; vertex_t, edge_t, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1row__properties__t.html">row_properties_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1SortedUniqueKeyBucket.html">SortedUniqueKeyBucket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1thrust__tuple__size__or__one.html">thrust_tuple_size_or_one</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1thrust__tuple__size__or__one_3_01thrust_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">thrust_tuple_size_or_one&lt; thrust::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1vertex__partition__device__view__t.html">vertex_partition_device_view_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1vertex__partition__device__view__t_3_01vertex__t_00_01multi__gpu_00_01std_1_1ena852dd6e9071ecf96345ff549a9b20238.html">vertex_partition_device_view_t&lt; vertex_t, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1vertex__partition__device__view__t_3_01vertex__t_00_01multi__gpu_00_01std_1_1enaafe258083c73f09613bba6173b275a13.html">vertex_partition_device_view_t&lt; vertex_t, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1vertex__partition__view__t.html">vertex_partition_view_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1vertex__partition__view__t_3_01vertex__t_00_01multi__gpu_00_01std_1_1enable__if__t_3_01multi__gpu_01_4_01_4.html">vertex_partition_view_t&lt; vertex_t, multi_gpu, std::enable_if_t&lt; multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1vertex__partition__view__t_3_01vertex__t_00_01multi__gpu_00_01std_1_1enable__if__t_3_9multi__gpu_01_4_01_4.html">vertex_partition_view_t&lt; vertex_t, multi_gpu, std::enable_if_t&lt;!multi_gpu &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1VertexFrontier.html">VertexFrontier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a597875429dde46aee1fe9856ab3d3220"><td class="memTemplParams" colspan="2"><a id="a597875429dde46aee1fe9856ab3d3220"></a>
template&lt;typename DataframeType &gt; </td></tr>
<tr class="memitem:a597875429dde46aee1fe9856ab3d3220"><td align="right" class="memTemplItemLeft" valign="top">using&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>dataframe_element_t</b> = typename <a class="el" href="structcugraph_1_1dataframe__element.html">dataframe_element</a>&lt; DataframeType &gt;::type</td></tr>
<tr class="separator:a597875429dde46aee1fe9856ab3d3220"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a365647c6c8b681e9af24661537ee6e27"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a> { <b>CUGRAPH_WEAK</b> = 0, 
<a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27a5882369885616cc6ba190202b140ee02">cugraph_cc_t::CUGRAPH_STRONG</a>, 
<a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27a436bdad1238dd6b8309bdbd0150c0e65">cugraph_cc_t::NUM_CONNECTIVITY_TYPES</a>
 }</td></tr>
<tr class="separator:a365647c6c8b681e9af24661537ee6e27"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a879a8e6f854a6879c9c5846517e78c1f"><td align="right" class="memItemLeft" valign="top"><a id="a879a8e6f854a6879c9c5846517e78c1f"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>k_core_degree_type_t</b> { <b>IN</b>, 
<b>OUT</b>, 
<b>INOUT</b>
 }</td></tr>
<tr class="separator:a879a8e6f854a6879c9c5846517e78c1f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab77986c1ff94f6dbdaa477da4a8151b0"><td align="right" class="memItemLeft" valign="top"><a id="ab77986c1ff94f6dbdaa477da4a8151b0"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>sampling_strategy_t</b> : int { <b>UNIFORM</b> = 0, 
<b>BIASED</b>, 
<b>NODE2VEC</b>
 }</td></tr>
<tr class="separator:ab77986c1ff94f6dbdaa477da4a8151b0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1ac5777ac96f1f7ecef0c3c2aee6d711"><td align="right" class="memItemLeft" valign="top"><a id="a1ac5777ac96f1f7ecef0c3c2aee6d711"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>generator_distribution_t</b> { <b>POWER_LAW</b> = 0, 
<b>UNIFORM</b>
 }</td></tr>
<tr class="separator:a1ac5777ac96f1f7ecef0c3c2aee6d711"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7e9a199ea9d7c11038c43641f88e8a58"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t &gt; </td></tr>
<tr class="memitem:a7e9a199ea9d7c11038c43641f88e8a58"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a7e9a199ea9d7c11038c43641f88e8a58">betweenness_centrality</a> (const raft::handle_t &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const  &amp;graph, result_t *result, bool normalized=true, bool endpoints=false, weight_t const  *weight=nullptr, vertex_t k=0, vertex_t const  *vertices=nullptr)</td></tr>
<tr class="memdesc:a7e9a199ea9d7c11038c43641f88e8a58"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute betweenness centrality for a graph.  <a href="namespacecugraph.html#a7e9a199ea9d7c11038c43641f88e8a58">More...</a><br></td></tr>
<tr class="separator:a7e9a199ea9d7c11038c43641f88e8a58"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af35a9f9ee12c320a55981337cd7a68b3"><td align="right" class="memItemLeft" valign="top"><a id="af35a9f9ee12c320a55981337cd7a68b3"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>betweenness_centrality&lt; int, int, float, float &gt;</b> (const raft::handle_t &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, float &gt; const &amp;, float *, bool, bool, float const *, int, int const *)</td></tr>
<tr class="separator:af35a9f9ee12c320a55981337cd7a68b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a195baa060706ee0569b529657e20a28e"><td align="right" class="memItemLeft" valign="top"><a id="a195baa060706ee0569b529657e20a28e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>betweenness_centrality&lt; int, int, double, double &gt;</b> (const raft::handle_t &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, double &gt; const &amp;, double *, bool, bool, double const *, int, int const *)</td></tr>
<tr class="separator:a195baa060706ee0569b529657e20a28e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0a1f1874fab344455c686bcb7c086fbb"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t &gt; </td></tr>
<tr class="memitem:a0a1f1874fab344455c686bcb7c086fbb"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a0a1f1874fab344455c686bcb7c086fbb">edge_betweenness_centrality</a> (const raft::handle_t &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const  &amp;graph, result_t *result, bool normalized=true, weight_t const  *weight=nullptr, vertex_t k=0, vertex_t const  *vertices=nullptr)</td></tr>
<tr class="memdesc:a0a1f1874fab344455c686bcb7c086fbb"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute edge betweenness centrality for a graph.  <a href="namespacecugraph.html#a0a1f1874fab344455c686bcb7c086fbb">More...</a><br></td></tr>
<tr class="separator:a0a1f1874fab344455c686bcb7c086fbb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab716d823e648a94bc5f6ac3063fb532f"><td align="right" class="memItemLeft" valign="top"><a id="ab716d823e648a94bc5f6ac3063fb532f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>edge_betweenness_centrality&lt; int, int, float, float &gt;</b> (const raft::handle_t &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, float &gt; const &amp;, float *, bool, float const *, int, int const *)</td></tr>
<tr class="separator:ab716d823e648a94bc5f6ac3063fb532f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acf7af648a4166eed152d1f1852193da5"><td align="right" class="memItemLeft" valign="top"><a id="acf7af648a4166eed152d1f1852193da5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>edge_betweenness_centrality&lt; int, int, double, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, double &gt; const &amp;, double *, bool, double const *, int, int const *)</td></tr>
<tr class="separator:acf7af648a4166eed152d1f1852193da5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9942a275444c2e0b96d90feec4ab6e90"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a9942a275444c2e0b96d90feec4ab6e90"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a9942a275444c2e0b96d90feec4ab6e90">katz_centrality</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, true, multi_gpu &gt; const  &amp;graph_view, result_t const  *betas, result_t *katz_centralities, result_t alpha, result_t beta, result_t epsilon, size_t max_iterations=500, bool has_initial_guess=false, bool normalize=false, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a9942a275444c2e0b96d90feec4ab6e90"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute Katz Centrality scores.  <a href="namespacecugraph.html#a9942a275444c2e0b96d90feec4ab6e90">More...</a><br></td></tr>
<tr class="separator:a9942a275444c2e0b96d90feec4ab6e90"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6bd0a7a981876d9432eb2cd2c31dd5ea"><td align="right" class="memItemLeft" valign="top"><a id="a6bd0a7a981876d9432eb2cd2c31dd5ea"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, true &gt; const &amp;graph_view, float const *betas, float *katz_centralities, float alpha, float beta, float epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a6bd0a7a981876d9432eb2cd2c31dd5ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a10dc48c5068f29d529f698390c1c2e10"><td align="right" class="memItemLeft" valign="top"><a id="a10dc48c5068f29d529f698390c1c2e10"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, true &gt; const &amp;graph_view, double const *betas, double *katz_centralities, double alpha, double beta, double epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a10dc48c5068f29d529f698390c1c2e10"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5de2cffb1a7106532854d2c4171f7bf1"><td align="right" class="memItemLeft" valign="top"><a id="a5de2cffb1a7106532854d2c4171f7bf1"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, true &gt; const &amp;graph_view, float const *betas, float *katz_centralities, float alpha, float beta, float epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a5de2cffb1a7106532854d2c4171f7bf1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8cb85eec0623b7daf1e7035574b13dec"><td align="right" class="memItemLeft" valign="top"><a id="a8cb85eec0623b7daf1e7035574b13dec"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, true &gt; const &amp;graph_view, double const *betas, double *katz_centralities, double alpha, double beta, double epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a8cb85eec0623b7daf1e7035574b13dec"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a73e00dcc24fc24368ae04369ddf9ec5b"><td align="right" class="memItemLeft" valign="top"><a id="a73e00dcc24fc24368ae04369ddf9ec5b"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, true &gt; const &amp;graph_view, float const *betas, float *katz_centralities, float alpha, float beta, float epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a73e00dcc24fc24368ae04369ddf9ec5b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7b984c5ef154d3dc64315682c2dc1f3f"><td align="right" class="memItemLeft" valign="top"><a id="a7b984c5ef154d3dc64315682c2dc1f3f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, true &gt; const &amp;graph_view, double const *betas, double *katz_centralities, double alpha, double beta, double epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a7b984c5ef154d3dc64315682c2dc1f3f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a973d1b37d40bd6634885dfda70240177"><td align="right" class="memItemLeft" valign="top"><a id="a973d1b37d40bd6634885dfda70240177"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, false &gt; const &amp;graph_view, float const *betas, float *katz_centralities, float alpha, float beta, float epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a973d1b37d40bd6634885dfda70240177"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afa36b0c242e097e88f4a899a9e2d2531"><td align="right" class="memItemLeft" valign="top"><a id="afa36b0c242e097e88f4a899a9e2d2531"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, false &gt; const &amp;graph_view, double const *betas, double *katz_centralities, double alpha, double beta, double epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:afa36b0c242e097e88f4a899a9e2d2531"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a306e953eac16a4661cf699659342d3cb"><td align="right" class="memItemLeft" valign="top"><a id="a306e953eac16a4661cf699659342d3cb"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, false &gt; const &amp;graph_view, float const *betas, float *katz_centralities, float alpha, float beta, float epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a306e953eac16a4661cf699659342d3cb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9e05e068855780922a4f295a96a1f6b3"><td align="right" class="memItemLeft" valign="top"><a id="a9e05e068855780922a4f295a96a1f6b3"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, false &gt; const &amp;graph_view, double const *betas, double *katz_centralities, double alpha, double beta, double epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a9e05e068855780922a4f295a96a1f6b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa1ea49649565fb7933c83159a56be354"><td align="right" class="memItemLeft" valign="top"><a id="aa1ea49649565fb7933c83159a56be354"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, false &gt; const &amp;graph_view, float const *betas, float *katz_centralities, float alpha, float beta, float epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:aa1ea49649565fb7933c83159a56be354"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5c71799c5bef242c3d2c45dcb9a309b4"><td align="right" class="memItemLeft" valign="top"><a id="a5c71799c5bef242c3d2c45dcb9a309b4"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, false &gt; const &amp;graph_view, double const *betas, double *katz_centralities, double alpha, double beta, double epsilon, size_t max_iterations, bool has_initial_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a5c71799c5bef242c3d2c45dcb9a309b4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a049ce498c5e78992d28049763f9c04f8"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT , typename result_t &gt; </td></tr>
<tr class="memitem:a049ce498c5e78992d28049763f9c04f8"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a049ce498c5e78992d28049763f9c04f8">katz_centrality</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const  &amp;graph, result_t *result, double alpha, int max_iter, double tol, bool has_guess, bool normalized)</td></tr>
<tr class="memdesc:a049ce498c5e78992d28049763f9c04f8"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the Katz centrality for the nodes of the graph G.  <a href="namespacecugraph.html#a049ce498c5e78992d28049763f9c04f8">More...</a><br></td></tr>
<tr class="separator:a049ce498c5e78992d28049763f9c04f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae6ee3ee0e398f61254c7fe6e8dc49d33"><td align="right" class="memItemLeft" valign="top"><a id="ae6ee3ee0e398f61254c7fe6e8dc49d33"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality&lt; int, int, float, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, float &gt; const &amp;, double *, double, int, double, bool, bool)</td></tr>
<tr class="separator:ae6ee3ee0e398f61254c7fe6e8dc49d33"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8055199c8d2f78e6c757e671a1b2f568"><td class="memTemplParams" colspan="2"><a id="a8055199c8d2f78e6c757e671a1b2f568"></a>
template&lt;typename vertex_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a8055199c8d2f78e6c757e671a1b2f568"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>partition_at_level</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; vertex_t &gt; const &amp;dendrogram, vertex_t const *d_vertex_ids, vertex_t *d_partition, size_t level)</td></tr>
<tr class="separator:a8055199c8d2f78e6c757e671a1b2f568"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa3062d0437821f23a9b1a5b37814bfb9"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:aa3062d0437821f23a9b1a5b37814bfb9"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aa3062d0437821f23a9b1a5b37814bfb9">ecg</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const  &amp;graph, weight_t min_weight, vertex_t ensemble_size, vertex_t *clustering)</td></tr>
<tr class="memdesc:aa3062d0437821f23a9b1a5b37814bfb9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the ecg clustering of the given graph.  <a href="namespacecugraph.html#aa3062d0437821f23a9b1a5b37814bfb9">More...</a><br></td></tr>
<tr class="separator:aa3062d0437821f23a9b1a5b37814bfb9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac47741a9abecb3af36478494699166d6"><td align="right" class="memItemLeft" valign="top"><a id="ac47741a9abecb3af36478494699166d6"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ecg&lt; int32_t, int32_t, float &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;graph, float min_weight, int32_t ensemble_size, int32_t *clustering)</td></tr>
<tr class="separator:ac47741a9abecb3af36478494699166d6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5863c0f16392d46971139c83924df668"><td align="right" class="memItemLeft" valign="top"><a id="a5863c0f16392d46971139c83924df668"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ecg&lt; int32_t, int32_t, double &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;graph, double min_weight, int32_t ensemble_size, int32_t *clustering)</td></tr>
<tr class="separator:a5863c0f16392d46971139c83924df668"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a73675c501c55f4633b34da4475c9c5ed"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a73675c501c55f4633b34da4475c9c5ed"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a73675c501c55f4633b34da4475c9c5ed">extract_ego</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const  &amp;graph_view, vertex_t *source_vertex, vertex_t n_subgraphs, vertex_t radius)</td></tr>
<tr class="memdesc:a73675c501c55f4633b34da4475c9c5ed"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns induced EgoNet subgraph(s) of neighbors centered at nodes in source_vertex within a given radius.  <a href="namespacecugraph.html#a73675c501c55f4633b34da4475c9c5ed">More...</a><br></td></tr>
<tr class="separator:a73675c501c55f4633b34da4475c9c5ed"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acc4987b31e32f5cfd7973cd46ecfd543"><td align="right" class="memItemLeft" valign="top"><a id="acc4987b31e32f5cfd7973cd46ecfd543"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_ego</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;, int32_t *, int32_t, int32_t)</td></tr>
<tr class="separator:acc4987b31e32f5cfd7973cd46ecfd543"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab4fac833be50a9d90f52088aa2a6d08d"><td align="right" class="memItemLeft" valign="top"><a id="ab4fac833be50a9d90f52088aa2a6d08d"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_ego</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;, int32_t *, int32_t, int32_t)</td></tr>
<tr class="separator:ab4fac833be50a9d90f52088aa2a6d08d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af1d0551078d81ba69460528be546872c"><td align="right" class="memItemLeft" valign="top"><a id="af1d0551078d81ba69460528be546872c"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_ego</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;, int64_t *, int64_t, int64_t)</td></tr>
<tr class="separator:af1d0551078d81ba69460528be546872c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afeb968ab3a8e5e250ec508dd8b4b8636"><td align="right" class="memItemLeft" valign="top"><a id="afeb968ab3a8e5e250ec508dd8b4b8636"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_ego</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;, int32_t *, int32_t, int32_t)</td></tr>
<tr class="separator:afeb968ab3a8e5e250ec508dd8b4b8636"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a01727dffd7eabf9c16426ce09152a8da"><td align="right" class="memItemLeft" valign="top"><a id="a01727dffd7eabf9c16426ce09152a8da"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_ego</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;, int32_t *, int32_t, int32_t)</td></tr>
<tr class="separator:a01727dffd7eabf9c16426ce09152a8da"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab161ecce877f9e913658fb782ef4b018"><td align="right" class="memItemLeft" valign="top"><a id="ab161ecce877f9e913658fb782ef4b018"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_ego</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;, int64_t *, int64_t, int64_t)</td></tr>
<tr class="separator:ab161ecce877f9e913658fb782ef4b018"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad7ff468bf1c4237f65af7a3a581c1db7"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ad7ff468bf1c4237f65af7a3a581c1db7"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; VT, ET, WT &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad7ff468bf1c4237f65af7a3a581c1db7">k_truss_subgraph</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; VT, ET, WT &gt; const  &amp;graph, int k, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ad7ff468bf1c4237f65af7a3a581c1db7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute k truss for a graph.  <a href="namespacecugraph.html#ad7ff468bf1c4237f65af7a3a581c1db7">More...</a><br></td></tr>
<tr class="separator:ad7ff468bf1c4237f65af7a3a581c1db7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af83d35520ac2529b18bb336ca30ddc66"><td align="right" class="memItemLeft" valign="top"><a id="af83d35520ac2529b18bb336ca30ddc66"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; int32_t, int32_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>k_truss_subgraph&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int, int, float &gt; const &amp;, int, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:af83d35520ac2529b18bb336ca30ddc66"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af0d4357c603aebcc69e56893b8d69f9c"><td align="right" class="memItemLeft" valign="top"><a id="af0d4357c603aebcc69e56893b8d69f9c"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; int32_t, int32_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>k_truss_subgraph&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int, int, double &gt; const &amp;, int, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:af0d4357c603aebcc69e56893b8d69f9c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a55cf4ef622742e6f1717a7995f1a82ee"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a55cf4ef622742e6f1717a7995f1a82ee"><td align="right" class="memTemplItemLeft" valign="top">std::pair&lt; size_t, weight_t &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a55cf4ef622742e6f1717a7995f1a82ee">leiden</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const  &amp;graph, vertex_t *clustering, size_t max_iter=100, weight_t resolution=weight_t{1})</td></tr>
<tr class="memdesc:a55cf4ef622742e6f1717a7995f1a82ee"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Leiden implementation.  <a href="namespacecugraph.html#a55cf4ef622742e6f1717a7995f1a82ee">More...</a><br></td></tr>
<tr class="separator:a55cf4ef622742e6f1717a7995f1a82ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab798e2db1ab8bcc996ad988e9ef8043d"><td align="right" class="memItemLeft" valign="top"><a id="ab798e2db1ab8bcc996ad988e9ef8043d"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>leiden</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:ab798e2db1ab8bcc996ad988e9ef8043d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac2dccfec6e61ef58c08ec73c57e43ee7"><td align="right" class="memItemLeft" valign="top"><a id="ac2dccfec6e61ef58c08ec73c57e43ee7"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>leiden</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:ac2dccfec6e61ef58c08ec73c57e43ee7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aba90b00d58c83e321421dab7a2ae3776"><td class="memTemplParams" colspan="2">template&lt;typename graph_view_t &gt; </td></tr>
<tr class="memitem:aba90b00d58c83e321421dab7a2ae3776"><td align="right" class="memTemplItemLeft" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; typename graph_view_t::vertex_type &gt; &gt;, typename graph_view_t::weight_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aba90b00d58c83e321421dab7a2ae3776">louvain</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a> const  &amp;graph_view, size_t max_level=100, typename graph_view_t::weight_type resolution=typename graph_view_t::weight_type{1})</td></tr>
<tr class="memdesc:aba90b00d58c83e321421dab7a2ae3776"><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> implementation, returning dendrogram.  <a href="namespacecugraph.html#aba90b00d58c83e321421dab7a2ae3776">More...</a><br></td></tr>
<tr class="separator:aba90b00d58c83e321421dab7a2ae3776"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a42db40269afe962c9edd2937ecae051d"><td class="memTemplParams" colspan="2">template&lt;typename graph_view_t &gt; </td></tr>
<tr class="memitem:a42db40269afe962c9edd2937ecae051d"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a42db40269afe962c9edd2937ecae051d">flatten_dendrogram</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a> const  &amp;graph_view, <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; typename graph_view_t::vertex_type &gt; const  &amp;dendrogram, typename graph_view_t::vertex_type *clustering)</td></tr>
<tr class="memdesc:a42db40269afe962c9edd2937ecae051d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flatten a <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a> at a particular level.  <a href="namespacecugraph.html#a42db40269afe962c9edd2937ecae051d">More...</a><br></td></tr>
<tr class="separator:a42db40269afe962c9edd2937ecae051d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a936a52eb10e269e918a2a8e9490080ca"><td class="memTemplParams" colspan="2">template&lt;typename graph_view_t &gt; </td></tr>
<tr class="memitem:a936a52eb10e269e918a2a8e9490080ca"><td align="right" class="memTemplItemLeft" valign="top">std::pair&lt; size_t, typename graph_view_t::weight_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a936a52eb10e269e918a2a8e9490080ca">louvain</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a> const  &amp;graph_view, typename graph_view_t::vertex_type *clustering, size_t max_level=100, typename graph_view_t::weight_type resolution=typename graph_view_t::weight_type{1})</td></tr>
<tr class="memdesc:a936a52eb10e269e918a2a8e9490080ca"><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> implementation.  <a href="namespacecugraph.html#a936a52eb10e269e918a2a8e9490080ca">More...</a><br></td></tr>
<tr class="separator:a936a52eb10e269e918a2a8e9490080ca"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac6ae8b2566e162d0891424ee7ffbeded"><td align="right" class="memItemLeft" valign="top"><a id="ac6ae8b2566e162d0891424ee7ffbeded"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:ac6ae8b2566e162d0891424ee7ffbeded"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8921327ac1fd6b8a9c87055dc29253d8"><td align="right" class="memItemLeft" valign="top"><a id="a8921327ac1fd6b8a9c87055dc29253d8"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:a8921327ac1fd6b8a9c87055dc29253d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac7564a891cd1f1a0ef821fd22f050414"><td align="right" class="memItemLeft" valign="top"><a id="ac7564a891cd1f1a0ef821fd22f050414"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:ac7564a891cd1f1a0ef821fd22f050414"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad5cef65e6a577e56e10d0d0ef672e81c"><td align="right" class="memItemLeft" valign="top"><a id="ad5cef65e6a577e56e10d0d0ef672e81c"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:ad5cef65e6a577e56e10d0d0ef672e81c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a510e03dada0768d2c907f4a27895823f"><td align="right" class="memItemLeft" valign="top"><a id="a510e03dada0768d2c907f4a27895823f"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int64_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:a510e03dada0768d2c907f4a27895823f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a561228a81a33c8f820fd13de2c86c750"><td align="right" class="memItemLeft" valign="top"><a id="a561228a81a33c8f820fd13de2c86c750"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:a561228a81a33c8f820fd13de2c86c750"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aec52ca3adc24810447a26729e1e6d0e9"><td align="right" class="memItemLeft" valign="top"><a id="aec52ca3adc24810447a26729e1e6d0e9"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:aec52ca3adc24810447a26729e1e6d0e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a54996ee338d06eaed17f1dbfd8ff67e1"><td align="right" class="memItemLeft" valign="top"><a id="a54996ee338d06eaed17f1dbfd8ff67e1"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int64_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:a54996ee338d06eaed17f1dbfd8ff67e1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acb427017034c3c63fde55f6824f35eec"><td align="right" class="memItemLeft" valign="top"><a id="acb427017034c3c63fde55f6824f35eec"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:acb427017034c3c63fde55f6824f35eec"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a04eb410c96663ea73a1b7df484c66909"><td align="right" class="memItemLeft" valign="top"><a id="a04eb410c96663ea73a1b7df484c66909"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:a04eb410c96663ea73a1b7df484c66909"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab0526af828dd837bd7314a3c4f4b32a7"><td align="right" class="memItemLeft" valign="top"><a id="ab0526af828dd837bd7314a3c4f4b32a7"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:ab0526af828dd837bd7314a3c4f4b32a7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acc54ce51bb0155bcfed28c04b15fa663"><td align="right" class="memItemLeft" valign="top"><a id="acc54ce51bb0155bcfed28c04b15fa663"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:acc54ce51bb0155bcfed28c04b15fa663"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5b4b327e73dfb0602d2c5921cc3611fd"><td align="right" class="memItemLeft" valign="top"><a id="a5b4b327e73dfb0602d2c5921cc3611fd"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;, int64_t *, size_t, float)</td></tr>
<tr class="separator:a5b4b327e73dfb0602d2c5921cc3611fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7dc8932aab7daf5f6299b76d89ddc30b"><td align="right" class="memItemLeft" valign="top"><a id="a7dc8932aab7daf5f6299b76d89ddc30b"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;, int64_t *, size_t, double)</td></tr>
<tr class="separator:a7dc8932aab7daf5f6299b76d89ddc30b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab089907a41083ffc9571a7f473aff1ad"><td align="right" class="memItemLeft" valign="top"><a id="ab089907a41083ffc9571a7f473aff1ad"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:ab089907a41083ffc9571a7f473aff1ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5b214ed8c87abe1199cf290e6c071f7d"><td align="right" class="memItemLeft" valign="top"><a id="a5b214ed8c87abe1199cf290e6c071f7d"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:a5b214ed8c87abe1199cf290e6c071f7d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae34cd293c350b47c0f569d6351eb8c14"><td align="right" class="memItemLeft" valign="top"><a id="ae34cd293c350b47c0f569d6351eb8c14"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int64_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:ae34cd293c350b47c0f569d6351eb8c14"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8b5ed079aef0391e55a60d2d521f639d"><td align="right" class="memItemLeft" valign="top"><a id="a8b5ed079aef0391e55a60d2d521f639d"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:a8b5ed079aef0391e55a60d2d521f639d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:affbb0e5864f69be1c768717fa8dcd574"><td align="right" class="memItemLeft" valign="top"><a id="affbb0e5864f69be1c768717fa8dcd574"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:affbb0e5864f69be1c768717fa8dcd574"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1badbe464ec91e8249f24e8e8081c125"><td align="right" class="memItemLeft" valign="top"><a id="a1badbe464ec91e8249f24e8e8081c125"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int64_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:a1badbe464ec91e8249f24e8e8081c125"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2fbe6e213c0e64a13f065cfa691dc0dd"><td align="right" class="memItemLeft" valign="top"><a id="a2fbe6e213c0e64a13f065cfa691dc0dd"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:a2fbe6e213c0e64a13f065cfa691dc0dd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae641b562cce0d602277f0a5db51cc898"><td align="right" class="memItemLeft" valign="top"><a id="ae641b562cce0d602277f0a5db51cc898"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:ae641b562cce0d602277f0a5db51cc898"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a73fed987a294f1d5f4e40bc68c89cfdc"><td align="right" class="memItemLeft" valign="top"><a id="a73fed987a294f1d5f4e40bc68c89cfdc"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:a73fed987a294f1d5f4e40bc68c89cfdc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abdbe193def0d4840ddf14d7c6be482e8"><td align="right" class="memItemLeft" valign="top"><a id="abdbe193def0d4840ddf14d7c6be482e8"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:abdbe193def0d4840ddf14d7c6be482e8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1dc2d61f8e377233b15bee70959ca4e3"><td align="right" class="memItemLeft" valign="top"><a id="a1dc2d61f8e377233b15bee70959ca4e3"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;, int64_t *, size_t, float)</td></tr>
<tr class="separator:a1dc2d61f8e377233b15bee70959ca4e3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5ea48ecd328d1c8c0e75b759210e31ac"><td align="right" class="memItemLeft" valign="top"><a id="a5ea48ecd328d1c8c0e75b759210e31ac"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;, int64_t *, size_t, double)</td></tr>
<tr class="separator:a5ea48ecd328d1c8c0e75b759210e31ac"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5d2693f86441fd77a28bacadc7687a91"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a5d2693f86441fd77a28bacadc7687a91"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a5d2693f86441fd77a28bacadc7687a91">connected_components</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const  &amp;graph, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a> connectivity_type, VT *labels)</td></tr>
<tr class="memdesc:a5d2693f86441fd77a28bacadc7687a91"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute connected components.  <a href="namespacecugraph.html#a5d2693f86441fd77a28bacadc7687a91">More...</a><br></td></tr>
<tr class="separator:a5d2693f86441fd77a28bacadc7687a91"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a08d9a948d2b63879bd9cc5f3cb6e8466"><td align="right" class="memItemLeft" valign="top"><a id="a08d9a948d2b63879bd9cc5f3cb6e8466"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>connected_components&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a>, int32_t *)</td></tr>
<tr class="separator:a08d9a948d2b63879bd9cc5f3cb6e8466"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2e81d6a36ddaa149b0b6bdc59e0414ce"><td align="right" class="memItemLeft" valign="top"><a id="a2e81d6a36ddaa149b0b6bdc59e0414ce"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>connected_components&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a>, int64_t *)</td></tr>
<tr class="separator:a2e81d6a36ddaa149b0b6bdc59e0414ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8a74317d58e73cb48b1240070e9a1c44"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a8a74317d58e73cb48b1240070e9a1c44"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a8a74317d58e73cb48b1240070e9a1c44">weakly_connected_components</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const  &amp;graph_view, vertex_t *components, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a8a74317d58e73cb48b1240070e9a1c44"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds (weakly-connected-)component IDs of each vertices in the input graph.  <a href="namespacecugraph.html#a8a74317d58e73cb48b1240070e9a1c44">More...</a><br></td></tr>
<tr class="separator:a8a74317d58e73cb48b1240070e9a1c44"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7eb7f190eb8b5c00deb3b0165ffde019"><td align="right" class="memItemLeft" valign="top"><a id="a7eb7f190eb8b5c00deb3b0165ffde019"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;graph_view, int32_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:a7eb7f190eb8b5c00deb3b0165ffde019"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab5dc16c3b867498627fc49b17b72216c"><td align="right" class="memItemLeft" valign="top"><a id="ab5dc16c3b867498627fc49b17b72216c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;graph_view, int32_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:ab5dc16c3b867498627fc49b17b72216c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a891032de366b80b5cc4b73182b9c431f"><td align="right" class="memItemLeft" valign="top"><a id="a891032de366b80b5cc4b73182b9c431f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;graph_view, int32_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:a891032de366b80b5cc4b73182b9c431f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adefda849f9a7536ba2601dad28199752"><td align="right" class="memItemLeft" valign="top"><a id="adefda849f9a7536ba2601dad28199752"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;graph_view, int32_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:adefda849f9a7536ba2601dad28199752"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8d37b52f880904955def28f50987c154"><td align="right" class="memItemLeft" valign="top"><a id="a8d37b52f880904955def28f50987c154"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;graph_view, int64_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:a8d37b52f880904955def28f50987c154"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7707c1587da16981654439c4c6c6a198"><td align="right" class="memItemLeft" valign="top"><a id="a7707c1587da16981654439c4c6c6a198"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;graph_view, int64_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:a7707c1587da16981654439c4c6c6a198"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9182cb13d59d931b5ffc4b659bacf29"><td align="right" class="memItemLeft" valign="top"><a id="ae9182cb13d59d931b5ffc4b659bacf29"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;graph_view, int32_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:ae9182cb13d59d931b5ffc4b659bacf29"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afaa1d2ddf7c48d07b6acb654aa24f81d"><td align="right" class="memItemLeft" valign="top"><a id="afaa1d2ddf7c48d07b6acb654aa24f81d"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;graph_view, int32_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:afaa1d2ddf7c48d07b6acb654aa24f81d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a52cee7d74d6941f36326a89dbdbb2553"><td align="right" class="memItemLeft" valign="top"><a id="a52cee7d74d6941f36326a89dbdbb2553"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;graph_view, int32_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:a52cee7d74d6941f36326a89dbdbb2553"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a127d47ae7513fe2e4f82bda33f750ae5"><td align="right" class="memItemLeft" valign="top"><a id="a127d47ae7513fe2e4f82bda33f750ae5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;graph_view, int32_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:a127d47ae7513fe2e4f82bda33f750ae5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a70fc289bfc1791640887415e4f34da19"><td align="right" class="memItemLeft" valign="top"><a id="a70fc289bfc1791640887415e4f34da19"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;graph_view, int64_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:a70fc289bfc1791640887415e4f34da19"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ace6526f23a6bdd94774267d72f2b74e9"><td align="right" class="memItemLeft" valign="top"><a id="ace6526f23a6bdd94774267d72f2b74e9"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>weakly_connected_components</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;graph_view, int64_t *components, bool do_expensive_check)</td></tr>
<tr class="separator:ace6526f23a6bdd94774267d72f2b74e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaaeb58bcffde6b1d1c89e52509e00083"><td align="right" class="memItemLeft" valign="top"><a id="aaaeb58bcffde6b1d1c89e52509e00083"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCSR.html">legacy::GraphCSR</a>&lt; uint32_t, uint32_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; uint32_t, uint32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; uint32_t, uint32_t, float &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:aaaeb58bcffde6b1d1c89e52509e00083"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aba1cd91a4c3930a74a6802600ff73ad8"><td align="right" class="memItemLeft" valign="top"><a id="aba1cd91a4c3930a74a6802600ff73ad8"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCSR.html">legacy::GraphCSR</a>&lt; uint32_t, uint32_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; uint32_t, uint32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; uint32_t, uint32_t, double &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:aba1cd91a4c3930a74a6802600ff73ad8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af314131471462deb73eae803ca5999f6"><td align="right" class="memItemLeft" valign="top"><a id="af314131471462deb73eae803ca5999f6"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCSR.html">legacy::GraphCSR</a>&lt; int32_t, int32_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:af314131471462deb73eae803ca5999f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab5c37dd03d71480c1f2d1f9779dab82c"><td align="right" class="memItemLeft" valign="top"><a id="ab5c37dd03d71480c1f2d1f9779dab82c"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCSR.html">legacy::GraphCSR</a>&lt; int32_t, int32_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:ab5c37dd03d71480c1f2d1f9779dab82c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5e211db378563db1c1adf8f71123d055"><td align="right" class="memItemLeft" valign="top"><a id="a5e211db378563db1c1adf8f71123d055"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCSR.html">legacy::GraphCSR</a>&lt; int64_t, int64_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int64_t, int64_t, float &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a5e211db378563db1c1adf8f71123d055"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af0674a2b5604b63518a94f0cc79a98a5"><td align="right" class="memItemLeft" valign="top"><a id="af0674a2b5604b63518a94f0cc79a98a5"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCSR.html">legacy::GraphCSR</a>&lt; int64_t, int64_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int64_t, int64_t, double &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:af0674a2b5604b63518a94f0cc79a98a5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abf0660786f942ccc258e726e0cf3ece5"><td align="right" class="memItemLeft" valign="top"><a id="abf0660786f942ccc258e726e0cf3ece5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; uint32_t, uint32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; uint32_t, uint32_t, float &gt; &amp;graph, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; uint32_t, uint32_t, float &gt; &amp;result)</td></tr>
<tr class="separator:abf0660786f942ccc258e726e0cf3ece5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9f780efc337b126a7f0a70d29150377"><td align="right" class="memItemLeft" valign="top"><a id="ae9f780efc337b126a7f0a70d29150377"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; uint32_t, uint32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; uint32_t, uint32_t, double &gt; &amp;graph, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; uint32_t, uint32_t, double &gt; &amp;result)</td></tr>
<tr class="separator:ae9f780efc337b126a7f0a70d29150377"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a54f5940777af071e9437e8ac4aa5294e"><td align="right" class="memItemLeft" valign="top"><a id="a54f5940777af071e9437e8ac4aa5294e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, float &gt; &amp;graph, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; &amp;result)</td></tr>
<tr class="separator:a54f5940777af071e9437e8ac4aa5294e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae167c2c9ac26ed4cb61897998db84f2e"><td align="right" class="memItemLeft" valign="top"><a id="ae167c2c9ac26ed4cb61897998db84f2e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, double &gt; &amp;graph, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; &amp;result)</td></tr>
<tr class="separator:ae167c2c9ac26ed4cb61897998db84f2e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1134fcb304c90e53307a9f26c6969195"><td align="right" class="memItemLeft" valign="top"><a id="a1134fcb304c90e53307a9f26c6969195"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int64_t, int64_t, float &gt; &amp;graph, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; &amp;result)</td></tr>
<tr class="separator:a1134fcb304c90e53307a9f26c6969195"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a382bb941dcf48ce3a57da403a2a03e79"><td align="right" class="memItemLeft" valign="top"><a id="a382bb941dcf48ce3a57da403a2a03e79"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int64_t, int64_t, double &gt; &amp;graph, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; &amp;result)</td></tr>
<tr class="separator:a382bb941dcf48ce3a57da403a2a03e79"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0e4e7507413b75cac2580707c1ad8e04"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a0e4e7507413b75cac2580707c1ad8e04"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCSR.html">legacy::GraphCSR</a>&lt; VT, ET, WT &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a0e4e7507413b75cac2580707c1ad8e04">coo_to_csr</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; VT, ET, WT &gt; const  &amp;graph, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a0e4e7507413b75cac2580707c1ad8e04"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert COO to CSR.  <a href="namespacecugraph.html#a0e4e7507413b75cac2580707c1ad8e04">More...</a><br></td></tr>
<tr class="separator:a0e4e7507413b75cac2580707c1ad8e04"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a82c4153cac71181f0b88bd87b287ab7a"><td class="memTemplParams" colspan="2"><a id="a82c4153cac71181f0b88bd87b287ab7a"></a>
template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a82c4153cac71181f0b88bd87b287ab7a"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>coo_to_csr_inplace</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; VT, ET, WT &gt; &amp;graph, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; &amp;result)</td></tr>
<tr class="separator:a82c4153cac71181f0b88bd87b287ab7a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4ebeef531f3dc12f614ce8990ec8ad83"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a4ebeef531f3dc12f614ce8990ec8ad83"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a4ebeef531f3dc12f614ce8990ec8ad83">core_number</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const  &amp;graph_view, edge_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first=0, size_t k_last=std::numeric_limits&lt; size_t &gt;::max(), bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a4ebeef531f3dc12f614ce8990ec8ad83"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute core numbers of individual vertices from K-core decomposition.  <a href="namespacecugraph.html#a4ebeef531f3dc12f614ce8990ec8ad83">More...</a><br></td></tr>
<tr class="separator:a4ebeef531f3dc12f614ce8990ec8ad83"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a56a7fc3b525e60c15992a71c990bc315"><td align="right" class="memItemLeft" valign="top"><a id="a56a7fc3b525e60c15992a71c990bc315"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;graph_view, int32_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:a56a7fc3b525e60c15992a71c990bc315"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa1dd1acce79c48d541bfde3ad413648d"><td align="right" class="memItemLeft" valign="top"><a id="aa1dd1acce79c48d541bfde3ad413648d"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;graph_view, int32_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:aa1dd1acce79c48d541bfde3ad413648d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a197d5195b4340f1bdfec8de58d448da3"><td align="right" class="memItemLeft" valign="top"><a id="a197d5195b4340f1bdfec8de58d448da3"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;graph_view, int64_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:a197d5195b4340f1bdfec8de58d448da3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a255a7f33663f81db04c24f940496b58d"><td align="right" class="memItemLeft" valign="top"><a id="a255a7f33663f81db04c24f940496b58d"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;graph_view, int64_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:a255a7f33663f81db04c24f940496b58d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aab91ab8171f3ea2153abe76a4d496399"><td align="right" class="memItemLeft" valign="top"><a id="aab91ab8171f3ea2153abe76a4d496399"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;graph_view, int64_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:aab91ab8171f3ea2153abe76a4d496399"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a25cfaae3609f3078ca084934b875d59e"><td align="right" class="memItemLeft" valign="top"><a id="a25cfaae3609f3078ca084934b875d59e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;graph_view, int64_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:a25cfaae3609f3078ca084934b875d59e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a211c924b2d1fd40f74c260b614949505"><td align="right" class="memItemLeft" valign="top"><a id="a211c924b2d1fd40f74c260b614949505"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;graph_view, int32_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:a211c924b2d1fd40f74c260b614949505"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae46ced4ee27419e777d0804ff3c39920"><td align="right" class="memItemLeft" valign="top"><a id="ae46ced4ee27419e777d0804ff3c39920"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;graph_view, int32_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:ae46ced4ee27419e777d0804ff3c39920"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaf1c09364b94022601feb045d79bc72b"><td align="right" class="memItemLeft" valign="top"><a id="aaf1c09364b94022601feb045d79bc72b"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;graph_view, int64_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:aaf1c09364b94022601feb045d79bc72b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae4b90337df686f9b9bf58d3466970e73"><td align="right" class="memItemLeft" valign="top"><a id="ae4b90337df686f9b9bf58d3466970e73"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;graph_view, int64_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:ae4b90337df686f9b9bf58d3466970e73"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a151e2417d6c36389b5c65f799546ba70"><td align="right" class="memItemLeft" valign="top"><a id="a151e2417d6c36389b5c65f799546ba70"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;graph_view, int64_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:a151e2417d6c36389b5c65f799546ba70"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a49a0ba445b38f9b0a16a2c566ceb34ad"><td align="right" class="memItemLeft" valign="top"><a id="a49a0ba445b38f9b0a16a2c566ceb34ad"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;graph_view, int64_t *core_numbers, k_core_degree_type_t degree_type, size_t k_first, size_t k_last, bool do_expensive_check)</td></tr>
<tr class="separator:a49a0ba445b38f9b0a16a2c566ceb34ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a01fa3a11aa66f35b9ae35a67e11bcd08"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a01fa3a11aa66f35b9ae35a67e11bcd08"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a01fa3a11aa66f35b9ae35a67e11bcd08">core_number</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const  &amp;graph, VT *core_number)</td></tr>
<tr class="memdesc:a01fa3a11aa66f35b9ae35a67e11bcd08"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the Core Number for the nodes of the graph G.  <a href="namespacecugraph.html#a01fa3a11aa66f35b9ae35a67e11bcd08">More...</a><br></td></tr>
<tr class="separator:a01fa3a11aa66f35b9ae35a67e11bcd08"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8c4ad5a6f48fbdf620c9007189af32ea"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a8c4ad5a6f48fbdf620c9007189af32ea"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; VT, ET, WT &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a8c4ad5a6f48fbdf620c9007189af32ea">k_core</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; VT, ET, WT &gt; const  &amp;graph, int k, VT const  *vertex_id, VT const  *<a class="el" href="namespacecugraph.html#a4ebeef531f3dc12f614ce8990ec8ad83">core_number</a>, VT num_vertex_ids, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a8c4ad5a6f48fbdf620c9007189af32ea"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute K Core of the graph G.  <a href="namespacecugraph.html#a8c4ad5a6f48fbdf620c9007189af32ea">More...</a><br></td></tr>
<tr class="separator:a8c4ad5a6f48fbdf620c9007189af32ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a29b66c0753548df3a81875fb67c57649"><td align="right" class="memItemLeft" valign="top"><a id="a29b66c0753548df3a81875fb67c57649"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t *<a class="el" href="namespacecugraph.html#a4ebeef531f3dc12f614ce8990ec8ad83">core_number</a>)</td></tr>
<tr class="separator:a29b66c0753548df3a81875fb67c57649"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a36ef4ff59b926215b8f1e9b1504be517"><td align="right" class="memItemLeft" valign="top"><a id="a36ef4ff59b926215b8f1e9b1504be517"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; int32_t, int32_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>k_core&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int, int32_t const *, int32_t const *, int32_t, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a36ef4ff59b926215b8f1e9b1504be517"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a43d9d487d7ea6a6a8862bdb8ad01b8c0"><td align="right" class="memItemLeft" valign="top"><a id="a43d9d487d7ea6a6a8862bdb8ad01b8c0"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; int32_t, int32_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>k_core&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int, int32_t const *, int32_t const *, int32_t, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a43d9d487d7ea6a6a8862bdb8ad01b8c0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af11f1d7615d6d81abe5e1904cd4772bf"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:af11f1d7615d6d81abe5e1904cd4772bf"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#af11f1d7615d6d81abe5e1904cd4772bf">generate_erdos_renyi_graph_edgelist_gnp</a> (raft::handle_t const  &amp;handle, vertex_t num_vertices, float p, vertex_t base_vertex_id, uint64_t seed=0)</td></tr>
<tr class="memdesc:af11f1d7615d6d81abe5e1904cd4772bf"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge lists for an Erdos-Renyi graph  <a href="namespacecugraph.html#af11f1d7615d6d81abe5e1904cd4772bf">More...</a><br></td></tr>
<tr class="separator:af11f1d7615d6d81abe5e1904cd4772bf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1e86bcbf7be7a1d9d7afd0c3bc326acd"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a1e86bcbf7be7a1d9d7afd0c3bc326acd"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a1e86bcbf7be7a1d9d7afd0c3bc326acd">generate_erdos_renyi_graph_edgelist_gnm</a> (raft::handle_t const  &amp;handle, vertex_t num_vertices, size_t m, vertex_t base_vertex_id, uint64_t seed=0)</td></tr>
<tr class="memdesc:a1e86bcbf7be7a1d9d7afd0c3bc326acd"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge lists for an Erdos-Renyi graph  <a href="namespacecugraph.html#a1e86bcbf7be7a1d9d7afd0c3bc326acd">More...</a><br></td></tr>
<tr class="separator:a1e86bcbf7be7a1d9d7afd0c3bc326acd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa996401923e74bb039bc422c4c26f686"><td align="right" class="memItemLeft" valign="top"><a id="aa996401923e74bb039bc422c4c26f686"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_erdos_renyi_graph_edgelist_gnp</b> (raft::handle_t const &amp;handle, int32_t num_vertices, float p, int32_t base_vertex_id, uint64_t seed)</td></tr>
<tr class="separator:aa996401923e74bb039bc422c4c26f686"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae3c7ee53bf5ce6d070aaa2828f23430d"><td align="right" class="memItemLeft" valign="top"><a id="ae3c7ee53bf5ce6d070aaa2828f23430d"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_erdos_renyi_graph_edgelist_gnp</b> (raft::handle_t const &amp;handle, int64_t num_vertices, float p, int64_t base_vertex_id, uint64_t seed)</td></tr>
<tr class="separator:ae3c7ee53bf5ce6d070aaa2828f23430d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8310f60a3ed7cfc94cdc0fa371b4ae0b"><td align="right" class="memItemLeft" valign="top"><a id="a8310f60a3ed7cfc94cdc0fa371b4ae0b"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_erdos_renyi_graph_edgelist_gnm</b> (raft::handle_t const &amp;handle, int32_t num_vertices, size_t m, int32_t base_vertex_id, uint64_t seed)</td></tr>
<tr class="separator:a8310f60a3ed7cfc94cdc0fa371b4ae0b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae85f9586885517386275a74aaee7849f"><td align="right" class="memItemLeft" valign="top"><a id="ae85f9586885517386275a74aaee7849f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_erdos_renyi_graph_edgelist_gnm</b> (raft::handle_t const &amp;handle, int64_t num_vertices, size_t m, int64_t base_vertex_id, uint64_t seed)</td></tr>
<tr class="separator:ae85f9586885517386275a74aaee7849f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad63e55a56aafcb092d524d0cbe9bfe2a"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:ad63e55a56aafcb092d524d0cbe9bfe2a"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad63e55a56aafcb092d524d0cbe9bfe2a">generate_rmat_edgelist</a> (raft::handle_t const  &amp;handle, size_t scale, size_t num_edges, double a=0.57, double b=0.19, double c=0.19, uint64_t seed=0, bool clip_and_flip=false)</td></tr>
<tr class="memdesc:ad63e55a56aafcb092d524d0cbe9bfe2a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge list for an R-mat graph.  <a href="namespacecugraph.html#ad63e55a56aafcb092d524d0cbe9bfe2a">More...</a><br></td></tr>
<tr class="separator:ad63e55a56aafcb092d524d0cbe9bfe2a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac04e233fc46602ad3e67478f4ed4076a"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:ac04e233fc46602ad3e67478f4ed4076a"><td align="right" class="memTemplItemLeft" valign="top">std::vector&lt; std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac04e233fc46602ad3e67478f4ed4076a">generate_rmat_edgelists</a> (raft::handle_t const  &amp;handle, size_t n_edgelists, size_t min_scale, size_t max_scale, size_t edge_factor=16, generator_distribution_t size_distribution=generator_distribution_t::POWER_LAW, generator_distribution_t edge_distribution=generator_distribution_t::POWER_LAW, uint64_t seed=0, bool clip_and_flip=false)</td></tr>
<tr class="memdesc:ac04e233fc46602ad3e67478f4ed4076a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate multiple edge lists using the R-mat graph generator.  <a href="namespacecugraph.html#ac04e233fc46602ad3e67478f4ed4076a">More...</a><br></td></tr>
<tr class="separator:ac04e233fc46602ad3e67478f4ed4076a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a84de876392aef937cf70fda769cd417f"><td align="right" class="memItemLeft" valign="top"><a id="a84de876392aef937cf70fda769cd417f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_rmat_edgelist&lt; int32_t &gt;</b> (raft::handle_t const &amp;handle, size_t scale, size_t num_edges, double a, double b, double c, uint64_t seed, bool clip_and_flip)</td></tr>
<tr class="separator:a84de876392aef937cf70fda769cd417f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a20fcf14b8ad581459cad3834c400af6c"><td align="right" class="memItemLeft" valign="top"><a id="a20fcf14b8ad581459cad3834c400af6c"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_rmat_edgelist&lt; int64_t &gt;</b> (raft::handle_t const &amp;handle, size_t scale, size_t num_edges, double a, double b, double c, uint64_t seed, bool clip_and_flip)</td></tr>
<tr class="separator:a20fcf14b8ad581459cad3834c400af6c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8078ea85bbed316071b1d029312c6c84"><td align="right" class="memItemLeft" valign="top"><a id="a8078ea85bbed316071b1d029312c6c84"></a>
template std::vector&lt; std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_rmat_edgelists&lt; int32_t &gt;</b> (raft::handle_t const &amp;handle, size_t n_edgelists, size_t min_scale, size_t max_scale, size_t edge_factor, generator_distribution_t component_distribution, generator_distribution_t edge_distribution, uint64_t seed, bool clip_and_flip)</td></tr>
<tr class="separator:a8078ea85bbed316071b1d029312c6c84"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5fa6f7683ff630c2673f986b35c6a0b5"><td align="right" class="memItemLeft" valign="top"><a id="a5fa6f7683ff630c2673f986b35c6a0b5"></a>
template std::vector&lt; std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_rmat_edgelists&lt; int64_t &gt;</b> (raft::handle_t const &amp;handle, size_t n_edgelists, size_t min_scale, size_t max_scale, size_t edge_factor, generator_distribution_t component_distribution, generator_distribution_t edge_distribution, uint64_t seed, bool clip_and_flip)</td></tr>
<tr class="separator:a5fa6f7683ff630c2673f986b35c6a0b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af138b768b2b98f7c72d74fca7135f6be"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:af138b768b2b98f7c72d74fca7135f6be"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#af138b768b2b98f7c72d74fca7135f6be">scramble_vertex_ids</a> (raft::handle_t const  &amp;handle, rmm::device_uvector&lt; vertex_t &gt; &amp;d_src_v, rmm::device_uvector&lt; vertex_t &gt; &amp;d_dst_v, vertex_t vertex_id_offset, uint64_t seed=0)</td></tr>
<tr class="memdesc:af138b768b2b98f7c72d74fca7135f6be"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scramble vertex ids in a graph  <a href="namespacecugraph.html#af138b768b2b98f7c72d74fca7135f6be">More...</a><br></td></tr>
<tr class="separator:af138b768b2b98f7c72d74fca7135f6be"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7d0bbe5af0b12a11b5c8aba2fb9826df"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a7d0bbe5af0b12a11b5c8aba2fb9826df"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a7d0bbe5af0b12a11b5c8aba2fb9826df">combine_edgelists</a> (raft::handle_t const  &amp;handle, std::vector&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;d_sources, std::vector&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;d_dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; weight_t &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges=true)</td></tr>
<tr class="memdesc:a7d0bbe5af0b12a11b5c8aba2fb9826df"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine edgelists from multiple sources into a single edgelist.  <a href="namespacecugraph.html#a7d0bbe5af0b12a11b5c8aba2fb9826df">More...</a><br></td></tr>
<tr class="separator:a7d0bbe5af0b12a11b5c8aba2fb9826df"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a635904784593c7a65aa80e9dd14cde1c"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a635904784593c7a65aa80e9dd14cde1c"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a635904784593c7a65aa80e9dd14cde1c">symmetrize_edgelist_from_triangular</a> (raft::handle_t const  &amp;handle, rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; weight_t &gt;&gt; &amp;&amp;optional_d_weights_v, bool check_diagonal=false)</td></tr>
<tr class="memdesc:a635904784593c7a65aa80e9dd14cde1c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetrize an edgelist from the edges in the lower (or upper but not both) triangular part of a graph adjacency matrix  <a href="namespacecugraph.html#a635904784593c7a65aa80e9dd14cde1c">More...</a><br></td></tr>
<tr class="separator:a635904784593c7a65aa80e9dd14cde1c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9556ab891cd85be954aa7f7bb91f3ca3"><td align="right" class="memItemLeft" valign="top"><a id="a9556ab891cd85be954aa7f7bb91f3ca3"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>scramble_vertex_ids</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;d_src_v, rmm::device_uvector&lt; int32_t &gt; &amp;d_dst_v, int32_t vertex_id_offset, uint64_t seed)</td></tr>
<tr class="separator:a9556ab891cd85be954aa7f7bb91f3ca3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afc43b8d231e18c513b67365b0ca788df"><td align="right" class="memItemLeft" valign="top"><a id="afc43b8d231e18c513b67365b0ca788df"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>scramble_vertex_ids</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;d_src_v, rmm::device_uvector&lt; int64_t &gt; &amp;d_dst_v, int64_t vertex_id_offset, uint64_t seed)</td></tr>
<tr class="separator:afc43b8d231e18c513b67365b0ca788df"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a865d17ec386427d8b976d3ec59d83189"><td align="right" class="memItemLeft" valign="top"><a id="a865d17ec386427d8b976d3ec59d83189"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>combine_edgelists</b> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;sources, std::vector&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; float &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges)</td></tr>
<tr class="separator:a865d17ec386427d8b976d3ec59d83189"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9e53568f2b73f262c55185380e4df25"><td align="right" class="memItemLeft" valign="top"><a id="ae9e53568f2b73f262c55185380e4df25"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>combine_edgelists</b> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;sources, std::vector&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; float &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges)</td></tr>
<tr class="separator:ae9e53568f2b73f262c55185380e4df25"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6ec8ccdcd6b79cff2272d28413ff796b"><td align="right" class="memItemLeft" valign="top"><a id="a6ec8ccdcd6b79cff2272d28413ff796b"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>combine_edgelists</b> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;sources, std::vector&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; double &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges)</td></tr>
<tr class="separator:a6ec8ccdcd6b79cff2272d28413ff796b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2225b09f1cdbb8e18e2776f9284cf2d8"><td align="right" class="memItemLeft" valign="top"><a id="a2225b09f1cdbb8e18e2776f9284cf2d8"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>combine_edgelists</b> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;sources, std::vector&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; double &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges)</td></tr>
<tr class="separator:a2225b09f1cdbb8e18e2776f9284cf2d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9e156c949a60135db8ec504e843ef3b8"><td align="right" class="memItemLeft" valign="top"><a id="a9e156c949a60135db8ec504e843ef3b8"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist_from_triangular</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;optional_d_weights_v, bool check_diagonal)</td></tr>
<tr class="separator:a9e156c949a60135db8ec504e843ef3b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a24324ded2d37dc493f802169a8153303"><td align="right" class="memItemLeft" valign="top"><a id="a24324ded2d37dc493f802169a8153303"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist_from_triangular</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;optional_d_weights_v, bool check_diagonal)</td></tr>
<tr class="separator:a24324ded2d37dc493f802169a8153303"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a22b2bfff68658fe9d9f429d28f2d23ce"><td align="right" class="memItemLeft" valign="top"><a id="a22b2bfff68658fe9d9f429d28f2d23ce"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist_from_triangular</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;optional_d_weights_v, bool check_diagonal)</td></tr>
<tr class="separator:a22b2bfff68658fe9d9f429d28f2d23ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7a164eebea76bc6b5aa82751ad763681"><td align="right" class="memItemLeft" valign="top"><a id="a7a164eebea76bc6b5aa82751ad763681"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist_from_triangular</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;optional_d_weights_v, bool check_diagonal)</td></tr>
<tr class="separator:a7a164eebea76bc6b5aa82751ad763681"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8a3648a479ef7e2b9634070d6ea00042"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a8a3648a479ef7e2b9634070d6ea00042"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a8a3648a479ef7e2b9634070d6ea00042">generate_path_graph_edgelist</a> (raft::handle_t const  &amp;handle, std::vector&lt; std::tuple&lt; vertex_t, vertex_t &gt;&gt; const  &amp;component_parameters_v)</td></tr>
<tr class="memdesc:a8a3648a479ef7e2b9634070d6ea00042"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge list for path graph  <a href="namespacecugraph.html#a8a3648a479ef7e2b9634070d6ea00042">More...</a><br></td></tr>
<tr class="separator:a8a3648a479ef7e2b9634070d6ea00042"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aedcf48ae5a40585d7bf6251fc86154ef"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:aedcf48ae5a40585d7bf6251fc86154ef"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aedcf48ae5a40585d7bf6251fc86154ef">generate_2d_mesh_graph_edgelist</a> (raft::handle_t const  &amp;handle, std::vector&lt; std::tuple&lt; vertex_t, vertex_t, vertex_t &gt;&gt; const  &amp;component_parameters_v)</td></tr>
<tr class="memdesc:aedcf48ae5a40585d7bf6251fc86154ef"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge list for a 2D Mesh Graph  <a href="namespacecugraph.html#aedcf48ae5a40585d7bf6251fc86154ef">More...</a><br></td></tr>
<tr class="separator:aedcf48ae5a40585d7bf6251fc86154ef"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a081898059b56a221acfac0608eb12b9a"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a081898059b56a221acfac0608eb12b9a"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a081898059b56a221acfac0608eb12b9a">generate_3d_mesh_graph_edgelist</a> (raft::handle_t const  &amp;handle, std::vector&lt; std::tuple&lt; vertex_t, vertex_t, vertex_t, vertex_t &gt;&gt; const  &amp;component_parameters_v)</td></tr>
<tr class="memdesc:a081898059b56a221acfac0608eb12b9a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge list for a 3D Mesh Graph  <a href="namespacecugraph.html#a081898059b56a221acfac0608eb12b9a">More...</a><br></td></tr>
<tr class="separator:a081898059b56a221acfac0608eb12b9a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8b38b80dc4a42fb491e6812916500b82"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a8b38b80dc4a42fb491e6812916500b82"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a8b38b80dc4a42fb491e6812916500b82">generate_complete_graph_edgelist</a> (raft::handle_t const  &amp;handle, std::vector&lt; std::tuple&lt; vertex_t, vertex_t &gt;&gt; const  &amp;component_parameters_v)</td></tr>
<tr class="memdesc:a8b38b80dc4a42fb491e6812916500b82"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge lists for some complete graphs  <a href="namespacecugraph.html#a8b38b80dc4a42fb491e6812916500b82">More...</a><br></td></tr>
<tr class="separator:a8b38b80dc4a42fb491e6812916500b82"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1a911000a3e1a9d31718aa5fb2aa2d0c"><td align="right" class="memItemLeft" valign="top"><a id="a1a911000a3e1a9d31718aa5fb2aa2d0c"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_path_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int32_t, int32_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a1a911000a3e1a9d31718aa5fb2aa2d0c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a35271fef987ae82b08e3767120160904"><td align="right" class="memItemLeft" valign="top"><a id="a35271fef987ae82b08e3767120160904"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_path_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int64_t, int64_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a35271fef987ae82b08e3767120160904"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7a20381a602f4192d4bac7d45418ad9f"><td align="right" class="memItemLeft" valign="top"><a id="a7a20381a602f4192d4bac7d45418ad9f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_2d_mesh_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int32_t, int32_t, int32_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a7a20381a602f4192d4bac7d45418ad9f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a33c385820a671c4c390023391166ddba"><td align="right" class="memItemLeft" valign="top"><a id="a33c385820a671c4c390023391166ddba"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_2d_mesh_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int64_t, int64_t, int64_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a33c385820a671c4c390023391166ddba"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af14d022dfb223107c789be80423123eb"><td align="right" class="memItemLeft" valign="top"><a id="af14d022dfb223107c789be80423123eb"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_3d_mesh_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int32_t, int32_t, int32_t, int32_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:af14d022dfb223107c789be80423123eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9bbaa953aee2c6049b7ecef3553662f"><td align="right" class="memItemLeft" valign="top"><a id="ae9bbaa953aee2c6049b7ecef3553662f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_3d_mesh_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int64_t, int64_t, int64_t, int64_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:ae9bbaa953aee2c6049b7ecef3553662f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a931c34cf451400d0da6dc01b3970d0a6"><td align="right" class="memItemLeft" valign="top"><a id="a931c34cf451400d0da6dc01b3970d0a6"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_complete_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int32_t, int32_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a931c34cf451400d0da6dc01b3970d0a6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7ec5d01cd2dbb2165eede989c621c49b"><td align="right" class="memItemLeft" valign="top"><a id="a7ec5d01cd2dbb2165eede989c621c49b"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_complete_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int64_t, int64_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a7ec5d01cd2dbb2165eede989c621c49b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad32a4d3984264ce62bf617164930fa4d"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:ad32a4d3984264ce62bf617164930fa4d"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad32a4d3984264ce62bf617164930fa4d">force_atlas2</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; &amp;graph, float *pos, const int max_iter=500, float *x_start=nullptr, float *y_start=nullptr, bool outbound_attraction_distribution=true, bool lin_log_mode=false, bool prevent_overlapping=false, const float edge_weight_influence=1.0, const float jitter_tolerance=1.0, bool barnes_hut_optimize=true, const float barnes_hut_theta=0.5, const float scaling_ratio=2.0, bool strong_gravity_mode=false, const float gravity=1.0, bool verbose=false, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback=nullptr)</td></tr>
<tr class="memdesc:ad32a4d3984264ce62bf617164930fa4d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ForceAtlas2 is a continuous graph layout algorithm for handy network visualization.  <a href="namespacecugraph.html#ad32a4d3984264ce62bf617164930fa4d">More...</a><br></td></tr>
<tr class="separator:ad32a4d3984264ce62bf617164930fa4d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3395e944c034f4993da883bc82e99b12"><td align="right" class="memItemLeft" valign="top"><a id="a3395e944c034f4993da883bc82e99b12"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>force_atlas2&lt; int, int, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int, int, float &gt; &amp;graph, float *pos, const int max_iter, float *x_start, float *y_start, bool outbound_attraction_distribution, bool lin_log_mode, bool prevent_overlapping, const float edge_weight_influence, const float jitter_tolerance, bool barnes_hut_optimize, const float barnes_hut_theta, const float scaling_ratio, bool strong_gravity_mode, const float gravity, bool verbose, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback)</td></tr>
<tr class="separator:a3395e944c034f4993da883bc82e99b12"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a50d52f67b5a40516b3971f4ccad06128"><td align="right" class="memItemLeft" valign="top"><a id="a50d52f67b5a40516b3971f4ccad06128"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>force_atlas2&lt; int, int, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int, int, double &gt; &amp;graph, float *pos, const int max_iter, float *x_start, float *y_start, bool outbound_attraction_distribution, bool lin_log_mode, bool prevent_overlapping, const float edge_weight_influence, const float jitter_tolerance, bool barnes_hut_optimize, const float barnes_hut_theta, const float scaling_ratio, bool strong_gravity_mode, const float gravity, bool verbose, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback)</td></tr>
<tr class="separator:a50d52f67b5a40516b3971f4ccad06128"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a867079c86af90114a5a687092e445e7f"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a867079c86af90114a5a687092e445e7f"><td align="right" class="memTemplItemLeft" valign="top">weight_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a867079c86af90114a5a687092e445e7f">hungarian</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; const  &amp;graph, vertex_t num_workers, vertex_t const  *workers, vertex_t *assignments)</td></tr>
<tr class="memdesc:a867079c86af90114a5a687092e445e7f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute Hungarian algorithm on a weighted bipartite graph.  <a href="namespacecugraph.html#a867079c86af90114a5a687092e445e7f">More...</a><br></td></tr>
<tr class="separator:a867079c86af90114a5a687092e445e7f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adc7e86752cf1de0fdcfae6fcb44753d8"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:adc7e86752cf1de0fdcfae6fcb44753d8"><td align="right" class="memTemplItemLeft" valign="top">weight_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#adc7e86752cf1de0fdcfae6fcb44753d8">hungarian</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; const  &amp;graph, vertex_t num_workers, vertex_t const  *workers, vertex_t *assignments, weight_t epsilon)</td></tr>
<tr class="memdesc:adc7e86752cf1de0fdcfae6fcb44753d8"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute Hungarian algorithm on a weighted bipartite graph.  <a href="namespacecugraph.html#adc7e86752cf1de0fdcfae6fcb44753d8">More...</a><br></td></tr>
<tr class="separator:adc7e86752cf1de0fdcfae6fcb44753d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4a2c748091318b4a79507a720b86dff7"><td align="right" class="memItemLeft" valign="top"><a id="a4a2c748091318b4a79507a720b86dff7"></a>
template int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, int32_t &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, int32_t &gt; const &amp;, int32_t, int32_t const *, int32_t *, int32_t)</td></tr>
<tr class="separator:a4a2c748091318b4a79507a720b86dff7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4b002185cd4c9e4955d599753041494c"><td align="right" class="memItemLeft" valign="top"><a id="a4b002185cd4c9e4955d599753041494c"></a>
template float&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, float &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t, int32_t const *, int32_t *, float)</td></tr>
<tr class="separator:a4b002185cd4c9e4955d599753041494c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2ff9e694507093fc7f4daa053e610b46"><td align="right" class="memItemLeft" valign="top"><a id="a2ff9e694507093fc7f4daa053e610b46"></a>
template double&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, double &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int32_t, int32_t const *, int32_t *, double)</td></tr>
<tr class="separator:a2ff9e694507093fc7f4daa053e610b46"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab24a34de2e61ed6de6873c4ea611e78d"><td align="right" class="memItemLeft" valign="top"><a id="ab24a34de2e61ed6de6873c4ea611e78d"></a>
template int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, int32_t &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, int32_t &gt; const &amp;, int32_t, int32_t const *, int32_t *)</td></tr>
<tr class="separator:ab24a34de2e61ed6de6873c4ea611e78d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0e7eba4343e3a80d6ed49a4aab68c7f7"><td align="right" class="memItemLeft" valign="top"><a id="a0e7eba4343e3a80d6ed49a4aab68c7f7"></a>
template float&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, float &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t, int32_t const *, int32_t *)</td></tr>
<tr class="separator:a0e7eba4343e3a80d6ed49a4aab68c7f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2d2fd94b804396e9b31aa8225dc5d54f"><td align="right" class="memItemLeft" valign="top"><a id="a2d2fd94b804396e9b31aa8225dc5d54f"></a>
template double&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, double &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int32_t, int32_t const *, int32_t *)</td></tr>
<tr class="separator:a2d2fd94b804396e9b31aa8225dc5d54f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aec1f7644b609686ffe31cd51dfef94d0"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:aec1f7644b609686ffe31cd51dfef94d0"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; weight_t, size_t &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aec1f7644b609686ffe31cd51dfef94d0">hits</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, true, multi_gpu &gt; const  &amp;graph_view, weight_t *hubs, weight_t *authorities, weight_t epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="memdesc:aec1f7644b609686ffe31cd51dfef94d0"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute HITS scores.  <a href="namespacecugraph.html#aec1f7644b609686ffe31cd51dfef94d0">More...</a><br></td></tr>
<tr class="separator:aec1f7644b609686ffe31cd51dfef94d0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a225d08630930501dec1cec6427b85335"><td align="right" class="memItemLeft" valign="top"><a id="a225d08630930501dec1cec6427b85335"></a>
template std::tuple&lt; float, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, true &gt; const &amp;graph_view, float *const hubs, float *const authorities, float epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a225d08630930501dec1cec6427b85335"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af61d4074dae5dfb55a52b48dba657f7a"><td align="right" class="memItemLeft" valign="top"><a id="af61d4074dae5dfb55a52b48dba657f7a"></a>
template std::tuple&lt; double, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, true &gt; const &amp;graph_view, double *const hubs, double *const authorities, double epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:af61d4074dae5dfb55a52b48dba657f7a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afff619c45a11372ff23200ed7eb8b2b3"><td align="right" class="memItemLeft" valign="top"><a id="afff619c45a11372ff23200ed7eb8b2b3"></a>
template std::tuple&lt; float, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, true &gt; const &amp;graph_view, float *const hubs, float *const authorities, float epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:afff619c45a11372ff23200ed7eb8b2b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a75320f5fbd51d4650b379c9771d34003"><td align="right" class="memItemLeft" valign="top"><a id="a75320f5fbd51d4650b379c9771d34003"></a>
template std::tuple&lt; double, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, true &gt; const &amp;graph_view, double *const hubs, double *const authorities, double epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a75320f5fbd51d4650b379c9771d34003"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0130beeac3fa3ecb38dd6e5a0a080791"><td align="right" class="memItemLeft" valign="top"><a id="a0130beeac3fa3ecb38dd6e5a0a080791"></a>
template std::tuple&lt; float, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, true &gt; const &amp;graph_view, float *const hubs, float *const authorities, float epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a0130beeac3fa3ecb38dd6e5a0a080791"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a82f2d86228a0df1073f5cb5836e2b9b2"><td align="right" class="memItemLeft" valign="top"><a id="a82f2d86228a0df1073f5cb5836e2b9b2"></a>
template std::tuple&lt; double, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, true &gt; const &amp;graph_view, double *const hubs, double *const authorities, double epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a82f2d86228a0df1073f5cb5836e2b9b2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae6a961cde9a36fe99a837b708798feff"><td align="right" class="memItemLeft" valign="top"><a id="ae6a961cde9a36fe99a837b708798feff"></a>
template std::tuple&lt; float, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, false &gt; const &amp;graph_view, float *const hubs, float *const authorities, float epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:ae6a961cde9a36fe99a837b708798feff"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9b7a6572685613f3d56358f6e999dc0b"><td align="right" class="memItemLeft" valign="top"><a id="a9b7a6572685613f3d56358f6e999dc0b"></a>
template std::tuple&lt; double, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, false &gt; const &amp;graph_view, double *const hubs, double *const authorities, double epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a9b7a6572685613f3d56358f6e999dc0b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae396210b7bb754e5e685fc2b03b09cfe"><td align="right" class="memItemLeft" valign="top"><a id="ae396210b7bb754e5e685fc2b03b09cfe"></a>
template std::tuple&lt; float, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, false &gt; const &amp;graph_view, float *const hubs, float *const authorities, float epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:ae396210b7bb754e5e685fc2b03b09cfe"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7a48fdbe97fe8bde4562d85c20e7c575"><td align="right" class="memItemLeft" valign="top"><a id="a7a48fdbe97fe8bde4562d85c20e7c575"></a>
template std::tuple&lt; double, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, false &gt; const &amp;graph_view, double *const hubs, double *const authorities, double epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a7a48fdbe97fe8bde4562d85c20e7c575"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a78872241d1c40adb24b9c9d990328cde"><td align="right" class="memItemLeft" valign="top"><a id="a78872241d1c40adb24b9c9d990328cde"></a>
template std::tuple&lt; float, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, false &gt; const &amp;graph_view, float *const hubs, float *const authorities, float epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a78872241d1c40adb24b9c9d990328cde"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a391c99c67b8fd15fb670c6088a93a58b"><td align="right" class="memItemLeft" valign="top"><a id="a391c99c67b8fd15fb670c6088a93a58b"></a>
template std::tuple&lt; double, size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>hits</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, false &gt; const &amp;graph_view, double *const hubs, double *const authorities, double epsilon, size_t max_iterations, bool has_initial_hubs_guess, bool normalize, bool do_expensive_check)</td></tr>
<tr class="separator:a391c99c67b8fd15fb670c6088a93a58b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7d8670fded63928475f245d51e797903"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a7d8670fded63928475f245d51e797903"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a7d8670fded63928475f245d51e797903">pagerank</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, true, multi_gpu &gt; const  &amp;graph_view, std::optional&lt; weight_t const  * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; vertex_t const  * &gt; personalization_vertices, std::optional&lt; result_t const  * &gt; personalization_values, std::optional&lt; vertex_t &gt; personalization_vector_size, result_t *pageranks, result_t alpha, result_t epsilon, size_t max_iterations=500, bool has_initial_guess=false, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a7d8670fded63928475f245d51e797903"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute PageRank scores.  <a href="namespacecugraph.html#a7d8670fded63928475f245d51e797903">More...</a><br></td></tr>
<tr class="separator:a7d8670fded63928475f245d51e797903"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abe8c25a1a1973d37bec30387bb52af7f"><td align="right" class="memItemLeft" valign="top"><a id="abe8c25a1a1973d37bec30387bb52af7f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, true &gt; const &amp;graph_view, std::optional&lt; float const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int32_t const * &gt; personalization_vertices, std::optional&lt; float const * &gt; personalization_values, std::optional&lt; int32_t &gt; personalization_vector_size, float *pageranks, float alpha, float epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:abe8c25a1a1973d37bec30387bb52af7f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0309ef945576fa9e7b4f655bbbbcb156"><td align="right" class="memItemLeft" valign="top"><a id="a0309ef945576fa9e7b4f655bbbbcb156"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, true &gt; const &amp;graph_view, std::optional&lt; double const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int32_t const * &gt; personalization_vertices, std::optional&lt; double const * &gt; personalization_values, std::optional&lt; int32_t &gt; personalization_vector_size, double *pageranks, double alpha, double epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:a0309ef945576fa9e7b4f655bbbbcb156"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2a7b9178524febd8d6dc384179285f77"><td align="right" class="memItemLeft" valign="top"><a id="a2a7b9178524febd8d6dc384179285f77"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, true &gt; const &amp;graph_view, std::optional&lt; float const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int32_t const * &gt; personalization_vertices, std::optional&lt; float const * &gt; personalization_values, std::optional&lt; int32_t &gt; personalization_vector_size, float *pageranks, float alpha, float epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:a2a7b9178524febd8d6dc384179285f77"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adf072f6b86123c3133b209558135ac5e"><td align="right" class="memItemLeft" valign="top"><a id="adf072f6b86123c3133b209558135ac5e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, true &gt; const &amp;graph_view, std::optional&lt; double const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int32_t const * &gt; personalization_vertices, std::optional&lt; double const * &gt; personalization_values, std::optional&lt; int32_t &gt; personalization_vector_size, double *pageranks, double alpha, double epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:adf072f6b86123c3133b209558135ac5e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa56b0d6e0f8399e3660ee83a9f8fcf55"><td align="right" class="memItemLeft" valign="top"><a id="aa56b0d6e0f8399e3660ee83a9f8fcf55"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, true &gt; const &amp;graph_view, std::optional&lt; float const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int64_t const * &gt; personalization_vertices, std::optional&lt; float const * &gt; personalization_values, std::optional&lt; int64_t &gt; personalization_vector_size, float *pageranks, float alpha, float epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:aa56b0d6e0f8399e3660ee83a9f8fcf55"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4f4cf31b4dd05c59f766a53ae5681e9d"><td align="right" class="memItemLeft" valign="top"><a id="a4f4cf31b4dd05c59f766a53ae5681e9d"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, true &gt; const &amp;graph_view, std::optional&lt; double const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int64_t const * &gt; personalization_vertices, std::optional&lt; double const * &gt; personalization_values, std::optional&lt; int64_t &gt; personalization_vector_size, double *pageranks, double alpha, double epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:a4f4cf31b4dd05c59f766a53ae5681e9d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab26885544494eff103c4532bd10c850c"><td align="right" class="memItemLeft" valign="top"><a id="ab26885544494eff103c4532bd10c850c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, false &gt; const &amp;graph_view, std::optional&lt; float const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int32_t const * &gt; personalization_vertices, std::optional&lt; float const * &gt; personalization_values, std::optional&lt; int32_t &gt; personalization_vector_size, float *pageranks, float alpha, float epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:ab26885544494eff103c4532bd10c850c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adb54c7be2ad1225543cf2d58ebce1d88"><td align="right" class="memItemLeft" valign="top"><a id="adb54c7be2ad1225543cf2d58ebce1d88"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, false &gt; const &amp;graph_view, std::optional&lt; double const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int32_t const * &gt; personalization_vertices, std::optional&lt; double const * &gt; personalization_values, std::optional&lt; int32_t &gt; personalization_vector_size, double *pageranks, double alpha, double epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:adb54c7be2ad1225543cf2d58ebce1d88"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8f844b96bd7fe670b5dcb1eef0b43cb3"><td align="right" class="memItemLeft" valign="top"><a id="a8f844b96bd7fe670b5dcb1eef0b43cb3"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, false &gt; const &amp;graph_view, std::optional&lt; float const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int32_t const * &gt; personalization_vertices, std::optional&lt; float const * &gt; personalization_values, std::optional&lt; int32_t &gt; personalization_vector_size, float *pageranks, float alpha, float epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:a8f844b96bd7fe670b5dcb1eef0b43cb3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aadc513e49c96124ca6c1c2939f78a757"><td align="right" class="memItemLeft" valign="top"><a id="aadc513e49c96124ca6c1c2939f78a757"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, false &gt; const &amp;graph_view, std::optional&lt; double const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int32_t const * &gt; personalization_vertices, std::optional&lt; double const * &gt; personalization_values, std::optional&lt; int32_t &gt; personalization_vector_size, double *pageranks, double alpha, double epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:aadc513e49c96124ca6c1c2939f78a757"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3b0441b655f075d1d37494201f684b74"><td align="right" class="memItemLeft" valign="top"><a id="a3b0441b655f075d1d37494201f684b74"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, false &gt; const &amp;graph_view, std::optional&lt; float const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int64_t const * &gt; personalization_vertices, std::optional&lt; float const * &gt; personalization_values, std::optional&lt; int64_t &gt; personalization_vector_size, float *pageranks, float alpha, float epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:a3b0441b655f075d1d37494201f684b74"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a669451349692a8e8fae99e0830f3340e"><td align="right" class="memItemLeft" valign="top"><a id="a669451349692a8e8fae99e0830f3340e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pagerank</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, false &gt; const &amp;graph_view, std::optional&lt; double const * &gt; precomputed_vertex_out_weight_sums, std::optional&lt; int64_t const * &gt; personalization_vertices, std::optional&lt; double const * &gt; personalization_values, std::optional&lt; int64_t &gt; personalization_vector_size, double *pageranks, double alpha, double epsilon, size_t max_iterations, bool has_initial_guess, bool do_expensive_check)</td></tr>
<tr class="separator:a669451349692a8e8fae99e0830f3340e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac234f529dba8fc868a9f9677e168e7b6"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ac234f529dba8fc868a9f9677e168e7b6"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac234f529dba8fc868a9f9677e168e7b6">jaccard</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const  &amp;graph, WT const  *weights, WT *result)</td></tr>
<tr class="memdesc:ac234f529dba8fc868a9f9677e168e7b6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute jaccard similarity coefficient for all vertices.  <a href="namespacecugraph.html#ac234f529dba8fc868a9f9677e168e7b6">More...</a><br></td></tr>
<tr class="separator:ac234f529dba8fc868a9f9677e168e7b6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac5263bdd552e7951abf3973cc358dfda"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ac5263bdd552e7951abf3973cc358dfda"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac5263bdd552e7951abf3973cc358dfda">jaccard_list</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const  &amp;graph, WT const  *weights, ET num_pairs, VT const  *first, VT const  *second, WT *result)</td></tr>
<tr class="memdesc:ac5263bdd552e7951abf3973cc358dfda"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute jaccard similarity coefficient for selected vertex pairs.  <a href="namespacecugraph.html#ac5263bdd552e7951abf3973cc358dfda">More...</a><br></td></tr>
<tr class="separator:ac5263bdd552e7951abf3973cc358dfda"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad99c1533b52e197d6f368ea19a4b7a20"><td align="right" class="memItemLeft" valign="top"><a id="ad99c1533b52e197d6f368ea19a4b7a20"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:ad99c1533b52e197d6f368ea19a4b7a20"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab8e228143e7b4e0465a9331fd4ee00d4"><td align="right" class="memItemLeft" valign="top"><a id="ab8e228143e7b4e0465a9331fd4ee00d4"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:ab8e228143e7b4e0465a9331fd4ee00d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a777b2e8b7ae6f6c5fdd959380a1c2877"><td align="right" class="memItemLeft" valign="top"><a id="a777b2e8b7ae6f6c5fdd959380a1c2877"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a777b2e8b7ae6f6c5fdd959380a1c2877"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa5fcd17bb750ce68eea3930db644a513"><td align="right" class="memItemLeft" valign="top"><a id="aa5fcd17bb750ce68eea3930db644a513"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:aa5fcd17bb750ce68eea3930db644a513"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5688c5ce727de4f1aa65f5c14973c92a"><td align="right" class="memItemLeft" valign="top"><a id="a5688c5ce727de4f1aa65f5c14973c92a"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, int32_t, int32_t const *, int32_t const *, float *)</td></tr>
<tr class="separator:a5688c5ce727de4f1aa65f5c14973c92a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7f19e3be86bf2e55946373e60f8e148c"><td align="right" class="memItemLeft" valign="top"><a id="a7f19e3be86bf2e55946373e60f8e148c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, int32_t, int32_t const *, int32_t const *, double *)</td></tr>
<tr class="separator:a7f19e3be86bf2e55946373e60f8e148c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae00b2067bf72154f177321c9fae70345"><td align="right" class="memItemLeft" valign="top"><a id="ae00b2067bf72154f177321c9fae70345"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, int64_t, int64_t const *, int64_t const *, float *)</td></tr>
<tr class="separator:ae00b2067bf72154f177321c9fae70345"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4347488a383805ba19f1d68d731733f4"><td align="right" class="memItemLeft" valign="top"><a id="a4347488a383805ba19f1d68d731733f4"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, int64_t, int64_t const *, int64_t const *, double *)</td></tr>
<tr class="separator:a4347488a383805ba19f1d68d731733f4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abf404506c99fd8a5550cb78f0123eaa8"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:abf404506c99fd8a5550cb78f0123eaa8"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#abf404506c99fd8a5550cb78f0123eaa8">overlap</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const  &amp;graph, WT const  *weights, WT *result)</td></tr>
<tr class="memdesc:abf404506c99fd8a5550cb78f0123eaa8"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute overlap coefficient for all vertices in the graph.  <a href="namespacecugraph.html#abf404506c99fd8a5550cb78f0123eaa8">More...</a><br></td></tr>
<tr class="separator:abf404506c99fd8a5550cb78f0123eaa8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa97e1cab7d65f1ae28b588c45dce0e06"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:aa97e1cab7d65f1ae28b588c45dce0e06"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aa97e1cab7d65f1ae28b588c45dce0e06">overlap_list</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const  &amp;graph, WT const  *weights, ET num_pairs, VT const  *first, VT const  *second, WT *result)</td></tr>
<tr class="memdesc:aa97e1cab7d65f1ae28b588c45dce0e06"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute overlap coefficient for select pairs of vertices.  <a href="namespacecugraph.html#aa97e1cab7d65f1ae28b588c45dce0e06">More...</a><br></td></tr>
<tr class="separator:aa97e1cab7d65f1ae28b588c45dce0e06"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0eb2a8fe78098e0918897c8cc0d87f4c"><td align="right" class="memItemLeft" valign="top"><a id="a0eb2a8fe78098e0918897c8cc0d87f4c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a0eb2a8fe78098e0918897c8cc0d87f4c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1944310684e44c6af8dd990a23d8c684"><td align="right" class="memItemLeft" valign="top"><a id="a1944310684e44c6af8dd990a23d8c684"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:a1944310684e44c6af8dd990a23d8c684"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a56c700e8216f7af04add2e72b7583e38"><td align="right" class="memItemLeft" valign="top"><a id="a56c700e8216f7af04add2e72b7583e38"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a56c700e8216f7af04add2e72b7583e38"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5c182611313178bdda4183f02692e041"><td align="right" class="memItemLeft" valign="top"><a id="a5c182611313178bdda4183f02692e041"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:a5c182611313178bdda4183f02692e041"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a591f4be153cd22cc42a8d4f0558ea99c"><td align="right" class="memItemLeft" valign="top"><a id="a591f4be153cd22cc42a8d4f0558ea99c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, int32_t, int32_t const *, int32_t const *, float *)</td></tr>
<tr class="separator:a591f4be153cd22cc42a8d4f0558ea99c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab84dfd1748fab4906a77a742bc71300b"><td align="right" class="memItemLeft" valign="top"><a id="ab84dfd1748fab4906a77a742bc71300b"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, int32_t, int32_t const *, int32_t const *, double *)</td></tr>
<tr class="separator:ab84dfd1748fab4906a77a742bc71300b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a75d16daf6a26c8c6d5b6e23a190f175d"><td align="right" class="memItemLeft" valign="top"><a id="a75d16daf6a26c8c6d5b6e23a190f175d"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, int64_t, int64_t const *, int64_t const *, float *)</td></tr>
<tr class="separator:a75d16daf6a26c8c6d5b6e23a190f175d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a831fab92a5c39af4c56e6d3bd4391d66"><td align="right" class="memItemLeft" valign="top"><a id="a831fab92a5c39af4c56e6d3bd4391d66"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, int64_t, int64_t const *, int64_t const *, double *)</td></tr>
<tr class="separator:a831fab92a5c39af4c56e6d3bd4391d66"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ace78b58645927d41224163bcb4b2a14b"><td align="right" class="memItemLeft" valign="top"><a id="ace78b58645927d41224163bcb4b2a14b"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; float &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>random_walks</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;gview, int32_t const *ptr_d_start, int32_t num_paths, int32_t max_depth, bool use_padding, std::unique_ptr&lt; <a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a> &gt; sampling_strategy)</td></tr>
<tr class="separator:ace78b58645927d41224163bcb4b2a14b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a69777b38e5fd51406c38e9f80e3173f9"><td align="right" class="memItemLeft" valign="top"><a id="a69777b38e5fd51406c38e9f80e3173f9"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; float &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>random_walks</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;gview, int32_t const *ptr_d_start, int64_t num_paths, int64_t max_depth, bool use_padding, std::unique_ptr&lt; <a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a> &gt; sampling_strategy)</td></tr>
<tr class="separator:a69777b38e5fd51406c38e9f80e3173f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a84f710a5494468c8003e51a83c35cfdb"><td align="right" class="memItemLeft" valign="top"><a id="a84f710a5494468c8003e51a83c35cfdb"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; float &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>random_walks</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;gview, int64_t const *ptr_d_start, int64_t num_paths, int64_t max_depth, bool use_padding, std::unique_ptr&lt; <a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a> &gt; sampling_strategy)</td></tr>
<tr class="separator:a84f710a5494468c8003e51a83c35cfdb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afc3f4528e523fc9b5ce19104a8a798b5"><td align="right" class="memItemLeft" valign="top"><a id="afc3f4528e523fc9b5ce19104a8a798b5"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; double &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>random_walks</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;gview, int32_t const *ptr_d_start, int32_t num_paths, int32_t max_depth, bool use_padding, std::unique_ptr&lt; <a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a> &gt; sampling_strategy)</td></tr>
<tr class="separator:afc3f4528e523fc9b5ce19104a8a798b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a920070ac0e6a06814ca76be03f135a98"><td align="right" class="memItemLeft" valign="top"><a id="a920070ac0e6a06814ca76be03f135a98"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; double &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>random_walks</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;gview, int32_t const *ptr_d_start, int64_t num_paths, int64_t max_depth, bool use_padding, std::unique_ptr&lt; <a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a> &gt; sampling_strategy)</td></tr>
<tr class="separator:a920070ac0e6a06814ca76be03f135a98"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2f3797f1fd04b8c11aa1b84bffc112fa"><td align="right" class="memItemLeft" valign="top"><a id="a2f3797f1fd04b8c11aa1b84bffc112fa"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; double &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>random_walks</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;gview, int64_t const *ptr_d_start, int64_t num_paths, int64_t max_depth, bool use_padding, std::unique_ptr&lt; <a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a> &gt; sampling_strategy)</td></tr>
<tr class="separator:a2f3797f1fd04b8c11aa1b84bffc112fa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3c9157b82764a86f2cf04aa14cd5638a"><td align="right" class="memItemLeft" valign="top"><a id="a3c9157b82764a86f2cf04aa14cd5638a"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>convert_paths_to_coo</b> (raft::handle_t const &amp;handle, int32_t coalesced_sz_v, int32_t num_paths, rmm::device_buffer &amp;&amp;d_coalesced_v, rmm::device_buffer &amp;&amp;d_sizes)</td></tr>
<tr class="separator:a3c9157b82764a86f2cf04aa14cd5638a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a65d85c45875873cbab30132865102834"><td align="right" class="memItemLeft" valign="top"><a id="a65d85c45875873cbab30132865102834"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>convert_paths_to_coo</b> (raft::handle_t const &amp;handle, int64_t coalesced_sz_v, int64_t num_paths, rmm::device_buffer &amp;&amp;d_coalesced_v, rmm::device_buffer &amp;&amp;d_sizes)</td></tr>
<tr class="separator:a65d85c45875873cbab30132865102834"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac2f3fc403f17e77b3042bb9f985d9efc"><td align="right" class="memItemLeft" valign="top"><a id="ac2f3fc403f17e77b3042bb9f985d9efc"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>query_rw_sizes_offsets</b> (raft::handle_t const &amp;handle, int32_t num_paths, int32_t const *ptr_d_sizes)</td></tr>
<tr class="separator:ac2f3fc403f17e77b3042bb9f985d9efc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1f55abd0b2ec9ac451b63bd33693caf5"><td align="right" class="memItemLeft" valign="top"><a id="a1f55abd0b2ec9ac451b63bd33693caf5"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>query_rw_sizes_offsets</b> (raft::handle_t const &amp;handle, int64_t num_paths, int64_t const *ptr_d_sizes)</td></tr>
<tr class="separator:a1f55abd0b2ec9ac451b63bd33693caf5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a179206df4869b42d6e5a7c28bcabcfd4"><td class="memTemplParams" colspan="2">template&lt;typename graph_t , typename index_t &gt; </td></tr>
<tr class="memitem:a179206df4869b42d6e5a7c28bcabcfd4"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; typename graph_t::vertex_type &gt;, rmm::device_uvector&lt; typename graph_t::weight_type &gt;, rmm::device_uvector&lt; index_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a179206df4869b42d6e5a7c28bcabcfd4">random_walks</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a> const &amp;graph, typename graph_t::vertex_type const *ptr_d_start, index_t num_paths, index_t max_depth, bool use_padding, std::unique_ptr&lt; <a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a> &gt; sampling_strategy)</td></tr>
<tr class="memdesc:a179206df4869b42d6e5a7c28bcabcfd4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns random walks (RW) from starting sources, where each path is of given maximum length. Uniform distribution is assumed for the random engine.  <a href="namespacecugraph.html#a179206df4869b42d6e5a7c28bcabcfd4">More...</a><br></td></tr>
<tr class="separator:a179206df4869b42d6e5a7c28bcabcfd4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6ce3d1cb61f337889ab06773e3234a7c"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename index_t &gt; </td></tr>
<tr class="memitem:a6ce3d1cb61f337889ab06773e3234a7c"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; index_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a6ce3d1cb61f337889ab06773e3234a7c">convert_paths_to_coo</a> (raft::handle_t const &amp;handle, index_t coalesced_sz_v, index_t num_paths, rmm::device_buffer &amp;&amp;d_coalesced_v, rmm::device_buffer &amp;&amp;d_sizes)</td></tr>
<tr class="memdesc:a6ce3d1cb61f337889ab06773e3234a7c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the COO format (src_vector, dst_vector) from the random walks (RW) paths.  <a href="namespacecugraph.html#a6ce3d1cb61f337889ab06773e3234a7c">More...</a><br></td></tr>
<tr class="separator:a6ce3d1cb61f337889ab06773e3234a7c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a08c8df4f0a0a151e4767a5f1d299a5bc"><td class="memTemplParams" colspan="2">template&lt;typename index_t &gt; </td></tr>
<tr class="memitem:a08c8df4f0a0a151e4767a5f1d299a5bc"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; index_t &gt;, rmm::device_uvector&lt; index_t &gt;, rmm::device_uvector&lt; index_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a08c8df4f0a0a151e4767a5f1d299a5bc">query_rw_sizes_offsets</a> (raft::handle_t const &amp;handle, index_t num_paths, index_t const *ptr_d_sizes)</td></tr>
<tr class="memdesc:a08c8df4f0a0a151e4767a5f1d299a5bc"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns additional RW information on vertex paths offsets and weight path sizes and offsets, for the coalesced case (the padded case does not need or provide this information)  <a href="namespacecugraph.html#a08c8df4f0a0a151e4767a5f1d299a5bc">More...</a><br></td></tr>
<tr class="separator:a08c8df4f0a0a151e4767a5f1d299a5bc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a815d2c249f061119aa65678ca2ba70ea"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool store_transposed, bool multi_gpu&gt; </td></tr>
<tr class="memitem:a815d2c249f061119aa65678ca2ba70ea"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu &gt; &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a815d2c249f061119aa65678ca2ba70ea">coarsen_graph</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu &gt; const  &amp;graph_view, vertex_t const  *labels, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a815d2c249f061119aa65678ca2ba70ea"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the coarsened graph.  <a href="namespacecugraph.html#a815d2c249f061119aa65678ca2ba70ea">More...</a><br></td></tr>
<tr class="separator:a815d2c249f061119aa65678ca2ba70ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaf97fce90668c6bf41197515105f548a"><td align="right" class="memItemLeft" valign="top"><a id="aaf97fce90668c6bf41197515105f548a"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int32_t, float, true, true &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, true &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:aaf97fce90668c6bf41197515105f548a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6c24c323fef4e70775eed0fb03a21d90"><td align="right" class="memItemLeft" valign="top"><a id="a6c24c323fef4e70775eed0fb03a21d90"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int32_t, float, false, true &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a6c24c323fef4e70775eed0fb03a21d90"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac151533d462b8b8e90ba234e78c72ddf"><td align="right" class="memItemLeft" valign="top"><a id="ac151533d462b8b8e90ba234e78c72ddf"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int64_t, float, true, true &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, true &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:ac151533d462b8b8e90ba234e78c72ddf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af7af06a507b4f7c102c0373d2bf0b405"><td align="right" class="memItemLeft" valign="top"><a id="af7af06a507b4f7c102c0373d2bf0b405"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int64_t, float, false, true &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:af7af06a507b4f7c102c0373d2bf0b405"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3cc381e91b1c966da221692044f87ca8"><td align="right" class="memItemLeft" valign="top"><a id="a3cc381e91b1c966da221692044f87ca8"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int64_t, int64_t, float, true, true &gt; &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, true &gt; const &amp;graph_view, int64_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a3cc381e91b1c966da221692044f87ca8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa5c80a937f4318c55a13b61da327e07a"><td align="right" class="memItemLeft" valign="top"><a id="aa5c80a937f4318c55a13b61da327e07a"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int64_t, int64_t, float, false, true &gt; &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;graph_view, int64_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:aa5c80a937f4318c55a13b61da327e07a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5ac204cb74c702354aa5334c1ef1a7f9"><td align="right" class="memItemLeft" valign="top"><a id="a5ac204cb74c702354aa5334c1ef1a7f9"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int32_t, double, true, true &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, true &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a5ac204cb74c702354aa5334c1ef1a7f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a97cecae5de724117123d76e22b8fcec9"><td align="right" class="memItemLeft" valign="top"><a id="a97cecae5de724117123d76e22b8fcec9"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int32_t, double, false, true &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a97cecae5de724117123d76e22b8fcec9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2e74947c7a6c8acd44df91e146f57d9d"><td align="right" class="memItemLeft" valign="top"><a id="a2e74947c7a6c8acd44df91e146f57d9d"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int64_t, double, true, true &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, true &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a2e74947c7a6c8acd44df91e146f57d9d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad72967454a955e049c0efeaeaf310acc"><td align="right" class="memItemLeft" valign="top"><a id="ad72967454a955e049c0efeaeaf310acc"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int64_t, double, false, true &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:ad72967454a955e049c0efeaeaf310acc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af3bdeddd58b7f938bce768c978ca3ce1"><td align="right" class="memItemLeft" valign="top"><a id="af3bdeddd58b7f938bce768c978ca3ce1"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int64_t, int64_t, double, true, true &gt; &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, true &gt; const &amp;graph_view, int64_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:af3bdeddd58b7f938bce768c978ca3ce1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9eef7febb011ac4b76c601dcdddc2b6a"><td align="right" class="memItemLeft" valign="top"><a id="a9eef7febb011ac4b76c601dcdddc2b6a"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int64_t, int64_t, double, false, true &gt; &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;graph_view, int64_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a9eef7febb011ac4b76c601dcdddc2b6a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa927010592a4b626112b7bc0d5db61ce"><td align="right" class="memItemLeft" valign="top"><a id="aa927010592a4b626112b7bc0d5db61ce"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int32_t, float, true, false &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, false &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:aa927010592a4b626112b7bc0d5db61ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a177114bfec2e146b7160f9205eca4275"><td align="right" class="memItemLeft" valign="top"><a id="a177114bfec2e146b7160f9205eca4275"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int32_t, float, false, false &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a177114bfec2e146b7160f9205eca4275"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9df77fe9b862a030b57f06bcdc8bf97b"><td align="right" class="memItemLeft" valign="top"><a id="a9df77fe9b862a030b57f06bcdc8bf97b"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int64_t, float, true, false &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, false &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a9df77fe9b862a030b57f06bcdc8bf97b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a93b3aef677da1aa3bcee835eef290db2"><td align="right" class="memItemLeft" valign="top"><a id="a93b3aef677da1aa3bcee835eef290db2"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int64_t, float, false, false &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a93b3aef677da1aa3bcee835eef290db2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8f01dea3bbf3dcecfc6378da05c6725a"><td align="right" class="memItemLeft" valign="top"><a id="a8f01dea3bbf3dcecfc6378da05c6725a"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int64_t, int64_t, float, true, false &gt; &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, false &gt; const &amp;graph_view, int64_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a8f01dea3bbf3dcecfc6378da05c6725a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac8cba11a8233bb7944421a046e652750"><td align="right" class="memItemLeft" valign="top"><a id="ac8cba11a8233bb7944421a046e652750"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int64_t, int64_t, float, false, false &gt; &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;graph_view, int64_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:ac8cba11a8233bb7944421a046e652750"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a27581db7d3bb8f90a281d8d6217446c5"><td align="right" class="memItemLeft" valign="top"><a id="a27581db7d3bb8f90a281d8d6217446c5"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int32_t, double, true, false &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, false &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a27581db7d3bb8f90a281d8d6217446c5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aedcfbb9a39b39a0a1b5476211b83ef0f"><td align="right" class="memItemLeft" valign="top"><a id="aedcfbb9a39b39a0a1b5476211b83ef0f"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int32_t, double, false, false &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:aedcfbb9a39b39a0a1b5476211b83ef0f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac7911c6c0c690c5bfe9d77e59d34ebb7"><td align="right" class="memItemLeft" valign="top"><a id="ac7911c6c0c690c5bfe9d77e59d34ebb7"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int64_t, double, true, false &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, false &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:ac7911c6c0c690c5bfe9d77e59d34ebb7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5235e84702306b88a30fba790b13a8f8"><td align="right" class="memItemLeft" valign="top"><a id="a5235e84702306b88a30fba790b13a8f8"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int32_t, int64_t, double, false, false &gt; &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;graph_view, int32_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a5235e84702306b88a30fba790b13a8f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5a54b9ecc8b98b92e93fb8436b1c0599"><td align="right" class="memItemLeft" valign="top"><a id="a5a54b9ecc8b98b92e93fb8436b1c0599"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int64_t, int64_t, double, true, false &gt; &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, false &gt; const &amp;graph_view, int64_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:a5a54b9ecc8b98b92e93fb8436b1c0599"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad2e99acd38dc531de531de4bfa3b54cc"><td align="right" class="memItemLeft" valign="top"><a id="ad2e99acd38dc531de531de4bfa3b54cc"></a>
template std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; int64_t, int64_t, double, false, false &gt; &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coarsen_graph</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;graph_view, int64_t const *labels, bool do_expensive_check)</td></tr>
<tr class="separator:ad2e99acd38dc531de531de4bfa3b54cc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a413a3caa38d75a30b21b4aface6c5ba3"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool store_transposed, bool multi_gpu&gt; </td></tr>
<tr class="memitem:a413a3caa38d75a30b21b4aface6c5ba3"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu &gt;, std::optional&lt; rmm::device_uvector&lt; vertex_t &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a413a3caa38d75a30b21b4aface6c5ba3">create_graph_from_edgelist</a> (raft::handle_t const  &amp;handle, std::optional&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;vertices, rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; weight_t &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a413a3caa38d75a30b21b4aface6c5ba3"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a graph from (the optional vertex list and) the given edge list.  <a href="namespacecugraph.html#a413a3caa38d75a30b21b4aface6c5ba3">More...</a><br></td></tr>
<tr class="separator:a413a3caa38d75a30b21b4aface6c5ba3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab7e0bfdee5ce302d581b431ada0905ec"><td align="right" class="memItemLeft" valign="top"><a id="ab7e0bfdee5ce302d581b431ada0905ec"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int32_t, float, false, true &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int32_t, float, false, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:ab7e0bfdee5ce302d581b431ada0905ec"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1fdf5c8fae477b151403841586fb6ea7"><td align="right" class="memItemLeft" valign="top"><a id="a1fdf5c8fae477b151403841586fb6ea7"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int32_t, float, true, true &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int32_t, float, true, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a1fdf5c8fae477b151403841586fb6ea7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa66a8dcd7c1f6203e209f570e0e87544"><td align="right" class="memItemLeft" valign="top"><a id="aa66a8dcd7c1f6203e209f570e0e87544"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int32_t, double, false, true &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int32_t, double, false, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:aa66a8dcd7c1f6203e209f570e0e87544"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1ab62a2dd5ae113fb4109cf7d1e7872f"><td align="right" class="memItemLeft" valign="top"><a id="a1ab62a2dd5ae113fb4109cf7d1e7872f"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int32_t, double, true, true &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int32_t, double, true, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a1ab62a2dd5ae113fb4109cf7d1e7872f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0ee31ff63b4aa0afd10eac7c741681f8"><td align="right" class="memItemLeft" valign="top"><a id="a0ee31ff63b4aa0afd10eac7c741681f8"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int64_t, float, false, true &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int64_t, float, false, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a0ee31ff63b4aa0afd10eac7c741681f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a069aacb066c563085882058dcb45cbe5"><td align="right" class="memItemLeft" valign="top"><a id="a069aacb066c563085882058dcb45cbe5"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int64_t, float, true, true &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int64_t, float, true, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a069aacb066c563085882058dcb45cbe5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a461786f06e504dae60819c7565056ea9"><td align="right" class="memItemLeft" valign="top"><a id="a461786f06e504dae60819c7565056ea9"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int64_t, double, false, true &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int64_t, double, false, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a461786f06e504dae60819c7565056ea9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1c58bdcb1c57bd77c97c6d3ff23cab03"><td align="right" class="memItemLeft" valign="top"><a id="a1c58bdcb1c57bd77c97c6d3ff23cab03"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int64_t, double, true, true &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int64_t, double, true, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a1c58bdcb1c57bd77c97c6d3ff23cab03"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a85f9e81c1b35715e87ad8fea8cfaf39a"><td align="right" class="memItemLeft" valign="top"><a id="a85f9e81c1b35715e87ad8fea8cfaf39a"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int64_t, int64_t, float, false, true &gt;, std::optional&lt; rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int64_t, int64_t, float, false, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a85f9e81c1b35715e87ad8fea8cfaf39a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9ed5c6a9e636f1e8a0847aae841431f7"><td align="right" class="memItemLeft" valign="top"><a id="a9ed5c6a9e636f1e8a0847aae841431f7"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int64_t, int64_t, float, true, true &gt;, std::optional&lt; rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int64_t, int64_t, float, true, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a9ed5c6a9e636f1e8a0847aae841431f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abd1606fac09fe5e801e270eb284a1ea9"><td align="right" class="memItemLeft" valign="top"><a id="abd1606fac09fe5e801e270eb284a1ea9"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int64_t, int64_t, double, false, true &gt;, std::optional&lt; rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int64_t, int64_t, double, false, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:abd1606fac09fe5e801e270eb284a1ea9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad280bc2cafc0ba52f5660742e39a49d2"><td align="right" class="memItemLeft" valign="top"><a id="ad280bc2cafc0ba52f5660742e39a49d2"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int64_t, int64_t, double, true, true &gt;, std::optional&lt; rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int64_t, int64_t, double, true, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:ad280bc2cafc0ba52f5660742e39a49d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9e3442523c65724ec722f79d69df4139"><td align="right" class="memItemLeft" valign="top"><a id="a9e3442523c65724ec722f79d69df4139"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int32_t, float, false, false &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int32_t, float, false, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a9e3442523c65724ec722f79d69df4139"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1c0a6133fcb9d9ace3add2ee5c334026"><td align="right" class="memItemLeft" valign="top"><a id="a1c0a6133fcb9d9ace3add2ee5c334026"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int32_t, float, true, false &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int32_t, float, true, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a1c0a6133fcb9d9ace3add2ee5c334026"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac7edbfe319ed0f341312fca35c8b3b6b"><td align="right" class="memItemLeft" valign="top"><a id="ac7edbfe319ed0f341312fca35c8b3b6b"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int32_t, double, false, false &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int32_t, double, false, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:ac7edbfe319ed0f341312fca35c8b3b6b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0f35f525aa754e9429ec3afe02ca86c7"><td align="right" class="memItemLeft" valign="top"><a id="a0f35f525aa754e9429ec3afe02ca86c7"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int32_t, double, true, false &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int32_t, double, true, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a0f35f525aa754e9429ec3afe02ca86c7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9d4a539f13142da4ad5a8badfaa560fc"><td align="right" class="memItemLeft" valign="top"><a id="a9d4a539f13142da4ad5a8badfaa560fc"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int64_t, float, false, false &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int64_t, float, false, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a9d4a539f13142da4ad5a8badfaa560fc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a15085d8419b0a124cbdacca6e0ad5c8e"><td align="right" class="memItemLeft" valign="top"><a id="a15085d8419b0a124cbdacca6e0ad5c8e"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int64_t, float, true, false &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int64_t, float, true, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a15085d8419b0a124cbdacca6e0ad5c8e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4fe34c61d41de2f8d535ddbde948816e"><td align="right" class="memItemLeft" valign="top"><a id="a4fe34c61d41de2f8d535ddbde948816e"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int64_t, double, false, false &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int64_t, double, false, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a4fe34c61d41de2f8d535ddbde948816e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a64318ee62635aff55f33fb68bd65ece8"><td align="right" class="memItemLeft" valign="top"><a id="a64318ee62635aff55f33fb68bd65ece8"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int32_t, int64_t, double, true, false &gt;, std::optional&lt; rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int32_t, int64_t, double, true, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a64318ee62635aff55f33fb68bd65ece8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1ca0dbc594e493570a5314551c36d6e3"><td align="right" class="memItemLeft" valign="top"><a id="a1ca0dbc594e493570a5314551c36d6e3"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int64_t, int64_t, float, false, false &gt;, std::optional&lt; rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int64_t, int64_t, float, false, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a1ca0dbc594e493570a5314551c36d6e3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a212640a44f374693944fe01ee23b3bfd"><td align="right" class="memItemLeft" valign="top"><a id="a212640a44f374693944fe01ee23b3bfd"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int64_t, int64_t, float, true, false &gt;, std::optional&lt; rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int64_t, int64_t, float, true, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a212640a44f374693944fe01ee23b3bfd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a101f5cc3ee1ab3211aaaddd4333a664a"><td align="right" class="memItemLeft" valign="top"><a id="a101f5cc3ee1ab3211aaaddd4333a664a"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int64_t, int64_t, double, false, false &gt;, std::optional&lt; rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int64_t, int64_t, double, false, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a101f5cc3ee1ab3211aaaddd4333a664a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a72c1d63db89296d2aa2ab11b0f14d103"><td align="right" class="memItemLeft" valign="top"><a id="a72c1d63db89296d2aa2ab11b0f14d103"></a>
template std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; int64_t, int64_t, double, true, false &gt;, std::optional&lt; rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_graph_from_edgelist&lt; int64_t, int64_t, double, true, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertex_span, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, <a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a> graph_properties, bool renumber, bool do_expensive_check)</td></tr>
<tr class="separator:a72c1d63db89296d2aa2ab11b0f14d103"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8cbce977abb844bc1b2b64c010958c2a"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool store_transposed, bool multi_gpu&gt; </td></tr>
<tr class="memitem:a8cbce977abb844bc1b2b64c010958c2a"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a8cbce977abb844bc1b2b64c010958c2a">extract_induced_subgraphs</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu &gt; const  &amp;graph_view, size_t const  *subgraph_offsets, vertex_t const  *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a8cbce977abb844bc1b2b64c010958c2a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">extract induced subgraph(s).  <a href="namespacecugraph.html#a8cbce977abb844bc1b2b64c010958c2a">More...</a><br></td></tr>
<tr class="separator:a8cbce977abb844bc1b2b64c010958c2a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac1038607fd2715b33cbb82d5441d4ad1"><td align="right" class="memItemLeft" valign="top"><a id="ac1038607fd2715b33cbb82d5441d4ad1"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:ac1038607fd2715b33cbb82d5441d4ad1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac2fa3384fbcfc959142ab78d4af8b088"><td align="right" class="memItemLeft" valign="top"><a id="ac2fa3384fbcfc959142ab78d4af8b088"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:ac2fa3384fbcfc959142ab78d4af8b088"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3d90e1577a42e541838bbe557b04fdd6"><td align="right" class="memItemLeft" valign="top"><a id="a3d90e1577a42e541838bbe557b04fdd6"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a3d90e1577a42e541838bbe557b04fdd6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a57de009d77bf7bae8cdaf1c43c3ac774"><td align="right" class="memItemLeft" valign="top"><a id="a57de009d77bf7bae8cdaf1c43c3ac774"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a57de009d77bf7bae8cdaf1c43c3ac774"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9dc879f92f12dc8c8a42f1ea60aef3df"><td align="right" class="memItemLeft" valign="top"><a id="a9dc879f92f12dc8c8a42f1ea60aef3df"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a9dc879f92f12dc8c8a42f1ea60aef3df"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5c0bc1467b46bf9d396fbc8733db1296"><td align="right" class="memItemLeft" valign="top"><a id="a5c0bc1467b46bf9d396fbc8733db1296"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a5c0bc1467b46bf9d396fbc8733db1296"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4ed882880c5eb9f4809e3f67748717f7"><td align="right" class="memItemLeft" valign="top"><a id="a4ed882880c5eb9f4809e3f67748717f7"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a4ed882880c5eb9f4809e3f67748717f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4e764f89ba64204f5e02425dd7efb041"><td align="right" class="memItemLeft" valign="top"><a id="a4e764f89ba64204f5e02425dd7efb041"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a4e764f89ba64204f5e02425dd7efb041"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6cb525444f9927f96fca1d2979c0b3dc"><td align="right" class="memItemLeft" valign="top"><a id="a6cb525444f9927f96fca1d2979c0b3dc"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int64_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a6cb525444f9927f96fca1d2979c0b3dc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a64bd6b30debdd29f9cc491533d2330f5"><td align="right" class="memItemLeft" valign="top"><a id="a64bd6b30debdd29f9cc491533d2330f5"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int64_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a64bd6b30debdd29f9cc491533d2330f5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab2da86e8ba592c1cdc243151a2dd87d0"><td align="right" class="memItemLeft" valign="top"><a id="ab2da86e8ba592c1cdc243151a2dd87d0"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int64_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:ab2da86e8ba592c1cdc243151a2dd87d0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5db92acc1676a5d8a407cec8e2cf49ae"><td align="right" class="memItemLeft" valign="top"><a id="a5db92acc1676a5d8a407cec8e2cf49ae"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;graph_view, size_t const *subgraph_offsets, int64_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a5db92acc1676a5d8a407cec8e2cf49ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1f414956b39eb6a7e78ca659f145920a"><td align="right" class="memItemLeft" valign="top"><a id="a1f414956b39eb6a7e78ca659f145920a"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, true, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a1f414956b39eb6a7e78ca659f145920a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad0534e60d0fa5f12f94f4fd4a04c63c4"><td align="right" class="memItemLeft" valign="top"><a id="ad0534e60d0fa5f12f94f4fd4a04c63c4"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:ad0534e60d0fa5f12f94f4fd4a04c63c4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa986f95230c1ce1abfa390cba8216aac"><td align="right" class="memItemLeft" valign="top"><a id="aa986f95230c1ce1abfa390cba8216aac"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, true, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:aa986f95230c1ce1abfa390cba8216aac"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae7a236ff2b1f03f1ffcea5d018d10237"><td align="right" class="memItemLeft" valign="top"><a id="ae7a236ff2b1f03f1ffcea5d018d10237"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:ae7a236ff2b1f03f1ffcea5d018d10237"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2afb9afb49f0c6fde7483b34fb288d86"><td align="right" class="memItemLeft" valign="top"><a id="a2afb9afb49f0c6fde7483b34fb288d86"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, true, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a2afb9afb49f0c6fde7483b34fb288d86"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abb78ea4d6003d64739f56fc12ab1c7e1"><td align="right" class="memItemLeft" valign="top"><a id="abb78ea4d6003d64739f56fc12ab1c7e1"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:abb78ea4d6003d64739f56fc12ab1c7e1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a31dab5cfa58cf1abb818c6ba22562f36"><td align="right" class="memItemLeft" valign="top"><a id="a31dab5cfa58cf1abb818c6ba22562f36"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, true, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a31dab5cfa58cf1abb818c6ba22562f36"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af3c686d42d604ebd443aea377b56264c"><td align="right" class="memItemLeft" valign="top"><a id="af3c686d42d604ebd443aea377b56264c"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int32_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:af3c686d42d604ebd443aea377b56264c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a66335da3b24ad5e9a257beeda0275b47"><td align="right" class="memItemLeft" valign="top"><a id="a66335da3b24ad5e9a257beeda0275b47"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, true, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int64_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a66335da3b24ad5e9a257beeda0275b47"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab17268715a529aa81fd75a087b693d69"><td align="right" class="memItemLeft" valign="top"><a id="ab17268715a529aa81fd75a087b693d69"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int64_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:ab17268715a529aa81fd75a087b693d69"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adadf8da81d399f285e5dc1af2ed0f8ec"><td align="right" class="memItemLeft" valign="top"><a id="adadf8da81d399f285e5dc1af2ed0f8ec"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, true, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int64_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:adadf8da81d399f285e5dc1af2ed0f8ec"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a49e13281a7ea95e08a2d7b74bf5ec33f"><td align="right" class="memItemLeft" valign="top"><a id="a49e13281a7ea95e08a2d7b74bf5ec33f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_induced_subgraphs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;graph_view, size_t const *subgraph_offsets, int64_t const *subgraph_vertices, size_t num_subgraphs, bool do_expensive_check)</td></tr>
<tr class="separator:a49e13281a7ea95e08a2d7b74bf5ec33f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7e8d4a7f63d0e7e3a9b17f81acc09403"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a7e8d4a7f63d0e7e3a9b17f81acc09403"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a7e8d4a7f63d0e7e3a9b17f81acc09403">relabel</a> (raft::handle_t const  &amp;handle, std::tuple&lt; vertex_t const  *, vertex_t const  * &gt; old_new_label_pairs, vertex_t num_label_pairs, vertex_t *labels, vertex_t num_labels, bool skip_missing_labels, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a7e8d4a7f63d0e7e3a9b17f81acc09403"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Relabel old labels to new labels.  <a href="namespacecugraph.html#a7e8d4a7f63d0e7e3a9b17f81acc09403">More...</a><br></td></tr>
<tr class="separator:a7e8d4a7f63d0e7e3a9b17f81acc09403"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2aecb806b46bdbea8eb862e2922b0772"><td align="right" class="memItemLeft" valign="top"><a id="a2aecb806b46bdbea8eb862e2922b0772"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>relabel&lt; int32_t, true &gt;</b> (raft::handle_t const &amp;handle, std::tuple&lt; int32_t const *, int32_t const * &gt; old_new_label_pairs, int32_t num_label_pairs, int32_t *labels, int32_t num_labels, bool skip_missing_labels, bool do_expensive_check)</td></tr>
<tr class="separator:a2aecb806b46bdbea8eb862e2922b0772"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9add02a528d54c342ad5b0c60b0593f"><td align="right" class="memItemLeft" valign="top"><a id="ae9add02a528d54c342ad5b0c60b0593f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>relabel&lt; int64_t, true &gt;</b> (raft::handle_t const &amp;handle, std::tuple&lt; int64_t const *, int64_t const * &gt; old_new_label_pairs, int64_t num_label_pairs, int64_t *labels, int64_t num_labels, bool skip_missing_labels, bool do_expensive_check)</td></tr>
<tr class="separator:ae9add02a528d54c342ad5b0c60b0593f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0439e0f1f329cfb152f168d3b7112af1"><td align="right" class="memItemLeft" valign="top"><a id="a0439e0f1f329cfb152f168d3b7112af1"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>relabel&lt; int32_t, false &gt;</b> (raft::handle_t const &amp;handle, std::tuple&lt; int32_t const *, int32_t const * &gt; old_new_label_pairs, int32_t num_label_pairs, int32_t *labels, int32_t num_labels, bool skip_missing_labels, bool do_expensive_check)</td></tr>
<tr class="separator:a0439e0f1f329cfb152f168d3b7112af1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7b7c0282426c8f1158125f6a27c2e99c"><td align="right" class="memItemLeft" valign="top"><a id="a7b7c0282426c8f1158125f6a27c2e99c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>relabel&lt; int64_t, false &gt;</b> (raft::handle_t const &amp;handle, std::tuple&lt; int64_t const *, int64_t const * &gt; old_new_label_pairs, int64_t num_label_pairs, int64_t *labels, int64_t num_labels, bool skip_missing_labels, bool do_expensive_check)</td></tr>
<tr class="separator:a7b7c0282426c8f1158125f6a27c2e99c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a13e2d6d33fde7df4df168f889a765cfd"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a13e2d6d33fde7df4df168f889a765cfd"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; multi_gpu, std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; vertex_t, edge_t, multi_gpu &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a13e2d6d33fde7df4df168f889a765cfd">renumber_edgelist</a> (raft::handle_t const  &amp;handle, std::optional&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;local_vertices, std::vector&lt; vertex_t * &gt; const  &amp;edgelist_majors, std::vector&lt; vertex_t * &gt; const  &amp;edgelist_minors, std::vector&lt; edge_t &gt; const  &amp;edgelist_edge_counts, std::optional&lt; std::vector&lt; std::vector&lt; edge_t &gt;&gt;&gt; const  &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a13e2d6d33fde7df4df168f889a765cfd"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">renumber edgelist (multi-GPU)  <a href="namespacecugraph.html#a13e2d6d33fde7df4df168f889a765cfd">More...</a><br></td></tr>
<tr class="separator:a13e2d6d33fde7df4df168f889a765cfd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae36c598906c8fa49f6fa40d5bc774b36"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:ae36c598906c8fa49f6fa40d5bc774b36"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; !multi_gpu, std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; vertex_t, edge_t, multi_gpu &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ae36c598906c8fa49f6fa40d5bc774b36">renumber_edgelist</a> (raft::handle_t const  &amp;handle, std::optional&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;vertices, vertex_t *edgelist_majors, vertex_t *edgelist_minors, edge_t num_edgelist_edges, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:ae36c598906c8fa49f6fa40d5bc774b36"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">renumber edgelist (single-GPU)  <a href="namespacecugraph.html#ae36c598906c8fa49f6fa40d5bc774b36">More...</a><br></td></tr>
<tr class="separator:ae36c598906c8fa49f6fa40d5bc774b36"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afb71fbc7a8a11a25f568e65fe2a788df"><td align="right" class="memItemLeft" valign="top"><a id="afb71fbc7a8a11a25f568e65fe2a788df"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; int32_t, int32_t, true &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_edgelist&lt; int32_t, int32_t, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;local_vertices, std::vector&lt; int32_t * &gt; const &amp;edgelist_majors, std::vector&lt; int32_t * &gt; const &amp;edgelist_minors, std::vector&lt; int32_t &gt; const &amp;edgelist_edge_counts, std::optional&lt; std::vector&lt; std::vector&lt; int32_t &gt;&gt;&gt; const &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check)</td></tr>
<tr class="separator:afb71fbc7a8a11a25f568e65fe2a788df"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a64a3b05cb209252b451c0777107fe8b7"><td align="right" class="memItemLeft" valign="top"><a id="a64a3b05cb209252b451c0777107fe8b7"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; int32_t, int64_t, true &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_edgelist&lt; int32_t, int64_t, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;local_vertices, std::vector&lt; int32_t * &gt; const &amp;edgelist_majors, std::vector&lt; int32_t * &gt; const &amp;edgelist_minors, std::vector&lt; int64_t &gt; const &amp;edgelist_edge_counts, std::optional&lt; std::vector&lt; std::vector&lt; int64_t &gt;&gt;&gt; const &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check)</td></tr>
<tr class="separator:a64a3b05cb209252b451c0777107fe8b7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae92efb229ad74f108bd77b833a9c7b33"><td align="right" class="memItemLeft" valign="top"><a id="ae92efb229ad74f108bd77b833a9c7b33"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; int64_t, int64_t, true &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_edgelist&lt; int64_t, int64_t, true &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;local_vertices, std::vector&lt; int64_t * &gt; const &amp;edgelist_majors, std::vector&lt; int64_t * &gt; const &amp;edgelist_minors, std::vector&lt; int64_t &gt; const &amp;edgelist_edge_counts, std::optional&lt; std::vector&lt; std::vector&lt; int64_t &gt;&gt;&gt; const &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check)</td></tr>
<tr class="separator:ae92efb229ad74f108bd77b833a9c7b33"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abc62820958d4558e85c1d848df22e20d"><td align="right" class="memItemLeft" valign="top"><a id="abc62820958d4558e85c1d848df22e20d"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; int32_t, int32_t, false &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_edgelist&lt; int32_t, int32_t, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertices, int32_t *edgelist_majors, int32_t *edgelist_minors, int32_t num_edgelist_edges, bool do_expensive_check)</td></tr>
<tr class="separator:abc62820958d4558e85c1d848df22e20d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6870b174b5cb3f84c5d83ef39ececdf3"><td align="right" class="memItemLeft" valign="top"><a id="a6870b174b5cb3f84c5d83ef39ececdf3"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; int32_t, int64_t, false &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_edgelist&lt; int32_t, int64_t, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;vertices, int32_t *edgelist_majors, int32_t *edgelist_minors, int64_t num_edgelist_edges, bool do_expensive_check)</td></tr>
<tr class="separator:a6870b174b5cb3f84c5d83ef39ececdf3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab492b62658b57ad46642226aa8ce3a53"><td align="right" class="memItemLeft" valign="top"><a id="ab492b62658b57ad46642226aa8ce3a53"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; int64_t, int64_t, false &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_edgelist&lt; int64_t, int64_t, false &gt;</b> (raft::handle_t const &amp;handle, std::optional&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;vertices, int64_t *edgelist_majors, int64_t *edgelist_minors, int64_t num_edgelist_edges, bool do_expensive_check)</td></tr>
<tr class="separator:ab492b62658b57ad46642226aa8ce3a53"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a431a64199aca6af92b8f9a5b62d0168f"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a431a64199aca6af92b8f9a5b62d0168f"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a431a64199aca6af92b8f9a5b62d0168f">renumber_ext_vertices</a> (raft::handle_t const  &amp;handle, vertex_t *vertices, size_t num_vertices, vertex_t const  *renumber_map_labels, vertex_t local_int_vertex_first, vertex_t local_int_vertex_last, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a431a64199aca6af92b8f9a5b62d0168f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renumber external vertices to internal vertices based on the provoided <code>renumber_map_labels</code>.  <a href="namespacecugraph.html#a431a64199aca6af92b8f9a5b62d0168f">More...</a><br></td></tr>
<tr class="separator:a431a64199aca6af92b8f9a5b62d0168f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab2d2829de3b33d7f394c8a1ff5169ca5"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:ab2d2829de3b33d7f394c8a1ff5169ca5"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ab2d2829de3b33d7f394c8a1ff5169ca5">unrenumber_local_int_vertices</a> (raft::handle_t const  &amp;handle, vertex_t *vertices, size_t num_vertices, vertex_t const  *renumber_map_labels, vertex_t local_int_vertex_first, vertex_t local_int_vertex_last, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:ab2d2829de3b33d7f394c8a1ff5169ca5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unrenumber local internal vertices to external vertices based on the providied <code>renumber_map_labels</code>.  <a href="namespacecugraph.html#ab2d2829de3b33d7f394c8a1ff5169ca5">More...</a><br></td></tr>
<tr class="separator:ab2d2829de3b33d7f394c8a1ff5169ca5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa7b7a7d3c7feeb4c367ad02b80d6df05"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:aa7b7a7d3c7feeb4c367ad02b80d6df05"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aa7b7a7d3c7feeb4c367ad02b80d6df05">unrenumber_int_vertices</a> (raft::handle_t const  &amp;handle, vertex_t *vertices, size_t num_vertices, vertex_t const  *renumber_map_labels, std::vector&lt; vertex_t &gt; const  &amp;vertex_partition_lasts, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:aa7b7a7d3c7feeb4c367ad02b80d6df05"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unrenumber (possibly non-local) internal vertices to external vertices based on the providied <code>renumber_map_labels</code>.  <a href="namespacecugraph.html#aa7b7a7d3c7feeb4c367ad02b80d6df05">More...</a><br></td></tr>
<tr class="separator:aa7b7a7d3c7feeb4c367ad02b80d6df05"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a14d7f0ff2d4c0d3d657c33c4577d6ef3"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , bool store_transposed, bool multi_gpu&gt; </td></tr>
<tr class="memitem:a14d7f0ff2d4c0d3d657c33c4577d6ef3"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; multi_gpu, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a14d7f0ff2d4c0d3d657c33c4577d6ef3">unrenumber_local_int_edges</a> (raft::handle_t const  &amp;handle, std::vector&lt; vertex_t * &gt; const  &amp;edgelist_rows, std::vector&lt; vertex_t * &gt; const  &amp;edgelist_cols, std::vector&lt; size_t &gt; const  &amp;edgelist_edge_counts, vertex_t const  *renumber_map_labels, std::vector&lt; vertex_t &gt; const  &amp;vertex_partition_lasts, std::optional&lt; std::vector&lt; std::vector&lt; size_t &gt;&gt;&gt; const  &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a14d7f0ff2d4c0d3d657c33c4577d6ef3"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unrenumber local edges' internal source &amp; destination IDs to external IDs based on the provided <code>renumber_map_labels</code> (multi-GPU).  <a href="namespacecugraph.html#a14d7f0ff2d4c0d3d657c33c4577d6ef3">More...</a><br></td></tr>
<tr class="separator:a14d7f0ff2d4c0d3d657c33c4577d6ef3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac3613b6995638d34ff5d7a8be5e355e8"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , bool store_transposed, bool multi_gpu&gt; </td></tr>
<tr class="memitem:ac3613b6995638d34ff5d7a8be5e355e8"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt;!multi_gpu, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac3613b6995638d34ff5d7a8be5e355e8">unrenumber_local_int_edges</a> (raft::handle_t const  &amp;handle, vertex_t *edgelist_rows, vertex_t *edgelist_cols, size_t num_edgelist_edges, vertex_t const  *renumber_map_labels, vertex_t num_vertices, bool do_expensive_check=false)</td></tr>
<tr class="memdesc:ac3613b6995638d34ff5d7a8be5e355e8"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unrenumber local edges' internal source &amp; destination IDs to external IDs based on the provided <code>renumber_map_labels</code> (single-GPU).  <a href="namespacecugraph.html#ac3613b6995638d34ff5d7a8be5e355e8">More...</a><br></td></tr>
<tr class="separator:ac3613b6995638d34ff5d7a8be5e355e8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5dd3dee8293c1467ff30339c62700464"><td align="right" class="memItemLeft" valign="top"><a id="a5dd3dee8293c1467ff30339c62700464"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_ext_vertices&lt; int32_t, true &gt;</b> (raft::handle_t const &amp;handle, int32_t *vertices, size_t num_vertices, int32_t const *renumber_map_labels, int32_t local_int_vertex_first, int32_t local_int_vertex_last, bool do_expensive_check)</td></tr>
<tr class="separator:a5dd3dee8293c1467ff30339c62700464"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae859d1ed97c02f23797c0fbf53e3a1df"><td align="right" class="memItemLeft" valign="top"><a id="ae859d1ed97c02f23797c0fbf53e3a1df"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_ext_vertices&lt; int64_t, true &gt;</b> (raft::handle_t const &amp;handle, int64_t *vertices, size_t num_vertices, int64_t const *renumber_map_labels, int64_t local_int_vertex_first, int64_t local_int_vertex_last, bool do_expensive_check)</td></tr>
<tr class="separator:ae859d1ed97c02f23797c0fbf53e3a1df"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a86d54e21bc4521c9f2f055973ef48ac2"><td align="right" class="memItemLeft" valign="top"><a id="a86d54e21bc4521c9f2f055973ef48ac2"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_int_vertices&lt; int32_t, true &gt;</b> (raft::handle_t const &amp;handle, int32_t *vertices, size_t num_vertices, int32_t const *renumber_map_labels, std::vector&lt; int32_t &gt; const &amp;vertex_partition_lasts, bool do_expensive_check)</td></tr>
<tr class="separator:a86d54e21bc4521c9f2f055973ef48ac2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5762e810206ffad3fe344d3caccd6afa"><td align="right" class="memItemLeft" valign="top"><a id="a5762e810206ffad3fe344d3caccd6afa"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_int_vertices&lt; int64_t, true &gt;</b> (raft::handle_t const &amp;handle, int64_t *vertices, size_t num_vertices, int64_t const *renumber_map_labels, std::vector&lt; int64_t &gt; const &amp;vertex_partition_lasts, bool do_expensive_check)</td></tr>
<tr class="separator:a5762e810206ffad3fe344d3caccd6afa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4bccacd8905640ef66b5cec592b3c33c"><td align="right" class="memItemLeft" valign="top"><a id="a4bccacd8905640ef66b5cec592b3c33c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_edges&lt; int32_t, false, true &gt;</b> (raft::handle_t const &amp;handle, std::vector&lt; int32_t * &gt; const &amp;edgelist_rows, std::vector&lt; int32_t * &gt; const &amp;edgelist_cols, std::vector&lt; size_t &gt; const &amp;edgelist_edge_counts, int32_t const *renumber_map_labels, std::vector&lt; int32_t &gt; const &amp;vertex_partition_lasts, std::optional&lt; std::vector&lt; std::vector&lt; size_t &gt;&gt;&gt; const &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check)</td></tr>
<tr class="separator:a4bccacd8905640ef66b5cec592b3c33c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af3ffc76e62fa0b81b634ee56f8b78dc6"><td align="right" class="memItemLeft" valign="top"><a id="af3ffc76e62fa0b81b634ee56f8b78dc6"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_edges&lt; int32_t, true, true &gt;</b> (raft::handle_t const &amp;handle, std::vector&lt; int32_t * &gt; const &amp;edgelist_rows, std::vector&lt; int32_t * &gt; const &amp;edgelist_cols, std::vector&lt; size_t &gt; const &amp;edgelist_edge_counts, int32_t const *renumber_map_labels, std::vector&lt; int32_t &gt; const &amp;vertex_partition_lasts, std::optional&lt; std::vector&lt; std::vector&lt; size_t &gt;&gt;&gt; const &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check)</td></tr>
<tr class="separator:af3ffc76e62fa0b81b634ee56f8b78dc6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6eb6f1491284608defd433b3a22553dd"><td align="right" class="memItemLeft" valign="top"><a id="a6eb6f1491284608defd433b3a22553dd"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_edges&lt; int64_t, false, true &gt;</b> (raft::handle_t const &amp;handle, std::vector&lt; int64_t * &gt; const &amp;edgelist_rows, std::vector&lt; int64_t * &gt; const &amp;edgelist_cols, std::vector&lt; size_t &gt; const &amp;edgelist_edge_counts, int64_t const *renumber_map_labels, std::vector&lt; int64_t &gt; const &amp;vertex_partition_lasts, std::optional&lt; std::vector&lt; std::vector&lt; size_t &gt;&gt;&gt; const &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check)</td></tr>
<tr class="separator:a6eb6f1491284608defd433b3a22553dd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa4700222500e4f2b6f6e7d001b01d3a7"><td align="right" class="memItemLeft" valign="top"><a id="aa4700222500e4f2b6f6e7d001b01d3a7"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_edges&lt; int64_t, true, true &gt;</b> (raft::handle_t const &amp;handle, std::vector&lt; int64_t * &gt; const &amp;edgelist_rows, std::vector&lt; int64_t * &gt; const &amp;edgelist_cols, std::vector&lt; size_t &gt; const &amp;edgelist_edge_counts, int64_t const *renumber_map_labels, std::vector&lt; int64_t &gt; const &amp;vertex_partition_lasts, std::optional&lt; std::vector&lt; std::vector&lt; size_t &gt;&gt;&gt; const &amp;edgelist_intra_partition_segment_offsets, bool do_expensive_check)</td></tr>
<tr class="separator:aa4700222500e4f2b6f6e7d001b01d3a7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4273686dad5e75b2259572d9df76498f"><td align="right" class="memItemLeft" valign="top"><a id="a4273686dad5e75b2259572d9df76498f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_ext_vertices&lt; int32_t, false &gt;</b> (raft::handle_t const &amp;handle, int32_t *vertices, size_t num_vertices, int32_t const *renumber_map_labels, int32_t local_int_vertex_first, int32_t local_int_vertex_last, bool do_expensive_check)</td></tr>
<tr class="separator:a4273686dad5e75b2259572d9df76498f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa832ebc8abc03052b9733390a81c9710"><td align="right" class="memItemLeft" valign="top"><a id="aa832ebc8abc03052b9733390a81c9710"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_ext_vertices&lt; int64_t, false &gt;</b> (raft::handle_t const &amp;handle, int64_t *vertices, size_t num_vertices, int64_t const *renumber_map_labels, int64_t local_int_vertex_first, int64_t local_int_vertex_last, bool do_expensive_check)</td></tr>
<tr class="separator:aa832ebc8abc03052b9733390a81c9710"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7704e28548abdbfc38c7f0f573cb5433"><td align="right" class="memItemLeft" valign="top"><a id="a7704e28548abdbfc38c7f0f573cb5433"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_vertices&lt; int32_t &gt;</b> (raft::handle_t const &amp;handle, int32_t *vertices, size_t num_vertices, int32_t const *renumber_map_labels, int32_t local_int_vertex_first, int32_t local_int_vertex_last, bool do_expensive_check)</td></tr>
<tr class="separator:a7704e28548abdbfc38c7f0f573cb5433"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a178fe19d7f0e51393c4f6f569f7489d8"><td align="right" class="memItemLeft" valign="top"><a id="a178fe19d7f0e51393c4f6f569f7489d8"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_vertices&lt; int64_t &gt;</b> (raft::handle_t const &amp;handle, int64_t *vertices, size_t num_vertices, int64_t const *renumber_map_labels, int64_t local_int_vertex_first, int64_t local_int_vertex_last, bool do_expensive_check)</td></tr>
<tr class="separator:a178fe19d7f0e51393c4f6f569f7489d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2fd6f59ff57d7326af0892791f941092"><td align="right" class="memItemLeft" valign="top"><a id="a2fd6f59ff57d7326af0892791f941092"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_int_vertices&lt; int32_t, false &gt;</b> (raft::handle_t const &amp;handle, int32_t *vertices, size_t num_vertices, int32_t const *renumber_map_labels, std::vector&lt; int32_t &gt; const &amp;vertex_partition_lasts, bool do_expensive_check)</td></tr>
<tr class="separator:a2fd6f59ff57d7326af0892791f941092"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7ac4af86780329f11d03b92c6575156f"><td align="right" class="memItemLeft" valign="top"><a id="a7ac4af86780329f11d03b92c6575156f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_int_vertices&lt; int64_t, false &gt;</b> (raft::handle_t const &amp;handle, int64_t *vertices, size_t num_vertices, int64_t const *renumber_map_labels, std::vector&lt; int64_t &gt; const &amp;vertex_partition_lasts, bool do_expensive_check)</td></tr>
<tr class="separator:a7ac4af86780329f11d03b92c6575156f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abfd9f9ea2bcf573a02b92ada2f62a9ae"><td align="right" class="memItemLeft" valign="top"><a id="abfd9f9ea2bcf573a02b92ada2f62a9ae"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_edges&lt; int32_t, false, false &gt;</b> (raft::handle_t const &amp;handle, int32_t *edgelist_rows, int32_t *edgelist_cols, size_t num_edgelist_edges, int32_t const *renumber_map_labels, int32_t num_vertices, bool do_expensive_check)</td></tr>
<tr class="separator:abfd9f9ea2bcf573a02b92ada2f62a9ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac677ff741231f7b884158589bda26c5c"><td align="right" class="memItemLeft" valign="top"><a id="ac677ff741231f7b884158589bda26c5c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_edges&lt; int32_t, true, false &gt;</b> (raft::handle_t const &amp;handle, int32_t *edgelist_rows, int32_t *edgelist_cols, size_t num_edgelist_edges, int32_t const *renumber_map_labels, int32_t num_vertices, bool do_expensive_check)</td></tr>
<tr class="separator:ac677ff741231f7b884158589bda26c5c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8f42a9371b856e690414a60a1403b4c8"><td align="right" class="memItemLeft" valign="top"><a id="a8f42a9371b856e690414a60a1403b4c8"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_edges&lt; int64_t, false, false &gt;</b> (raft::handle_t const &amp;handle, int64_t *edgelist_rows, int64_t *edgelist_cols, size_t num_edgelist_edges, int64_t const *renumber_map_labels, int64_t num_vertices, bool do_expensive_check)</td></tr>
<tr class="separator:a8f42a9371b856e690414a60a1403b4c8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a13d979f51291082994744d0259eca7b6"><td align="right" class="memItemLeft" valign="top"><a id="a13d979f51291082994744d0259eca7b6"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unrenumber_local_int_edges&lt; int64_t, true, false &gt;</b> (raft::handle_t const &amp;handle, int64_t *edgelist_rows, int64_t *edgelist_cols, size_t num_edgelist_edges, int64_t const *renumber_map_labels, int64_t num_vertices, bool do_expensive_check)</td></tr>
<tr class="separator:a13d979f51291082994744d0259eca7b6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a35166b1ee111f0ff757d850eb89fb70a"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename weight_t , bool store_transposed, bool multi_gpu&gt; </td></tr>
<tr class="memitem:a35166b1ee111f0ff757d850eb89fb70a"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a35166b1ee111f0ff757d850eb89fb70a">symmetrize_edgelist</a> (raft::handle_t const  &amp;handle, rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; weight_t &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="memdesc:a35166b1ee111f0ff757d850eb89fb70a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Symmetrize edgelist.  <a href="namespacecugraph.html#a35166b1ee111f0ff757d850eb89fb70a">More...</a><br></td></tr>
<tr class="separator:a35166b1ee111f0ff757d850eb89fb70a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:add00aeb7af1513ff97b2cbfdf32ade16"><td align="right" class="memItemLeft" valign="top"><a id="add00aeb7af1513ff97b2cbfdf32ade16"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int32_t, float, false, true &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:add00aeb7af1513ff97b2cbfdf32ade16"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5f8f83543668b49ecd64dc36d08409a7"><td align="right" class="memItemLeft" valign="top"><a id="a5f8f83543668b49ecd64dc36d08409a7"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int32_t, float, true, true &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a5f8f83543668b49ecd64dc36d08409a7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abcc1da382e000536f6551520c94f7a89"><td align="right" class="memItemLeft" valign="top"><a id="abcc1da382e000536f6551520c94f7a89"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int32_t, double, false, true &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:abcc1da382e000536f6551520c94f7a89"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aae968410b7d17a5d5166fa0bbe6e204f"><td align="right" class="memItemLeft" valign="top"><a id="aae968410b7d17a5d5166fa0bbe6e204f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int32_t, double, true, true &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:aae968410b7d17a5d5166fa0bbe6e204f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5f238a4b5596235ecdebc7f59f919624"><td align="right" class="memItemLeft" valign="top"><a id="a5f238a4b5596235ecdebc7f59f919624"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int64_t, float, false, true &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a5f238a4b5596235ecdebc7f59f919624"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7bf16acbe0debf50b52a6e265a5a34ae"><td align="right" class="memItemLeft" valign="top"><a id="a7bf16acbe0debf50b52a6e265a5a34ae"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int64_t, float, true, true &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a7bf16acbe0debf50b52a6e265a5a34ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9fc3de0fd09001be44ff4e7d01e2c2e9"><td align="right" class="memItemLeft" valign="top"><a id="a9fc3de0fd09001be44ff4e7d01e2c2e9"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int64_t, double, false, true &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a9fc3de0fd09001be44ff4e7d01e2c2e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:add16042fa011927d7f4482cb5d947f44"><td align="right" class="memItemLeft" valign="top"><a id="add16042fa011927d7f4482cb5d947f44"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int64_t, double, true, true &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:add16042fa011927d7f4482cb5d947f44"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a539f6b4b891a0f47c50eb21f6c26d030"><td align="right" class="memItemLeft" valign="top"><a id="a539f6b4b891a0f47c50eb21f6c26d030"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int32_t, float, false, false &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a539f6b4b891a0f47c50eb21f6c26d030"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac8e00db2faf0da4199b4fe88e2a72ea7"><td align="right" class="memItemLeft" valign="top"><a id="ac8e00db2faf0da4199b4fe88e2a72ea7"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int32_t, float, true, false &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:ac8e00db2faf0da4199b4fe88e2a72ea7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5195c36b7938219e21e36bab0fbe90f7"><td align="right" class="memItemLeft" valign="top"><a id="a5195c36b7938219e21e36bab0fbe90f7"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int32_t, double, false, false &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a5195c36b7938219e21e36bab0fbe90f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a37474ef76f53bf544385b0265c3120ee"><td align="right" class="memItemLeft" valign="top"><a id="a37474ef76f53bf544385b0265c3120ee"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int32_t, double, true, false &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a37474ef76f53bf544385b0265c3120ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac60e749d0062f259eac5b1728857e99a"><td align="right" class="memItemLeft" valign="top"><a id="ac60e749d0062f259eac5b1728857e99a"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int64_t, float, false, false &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:ac60e749d0062f259eac5b1728857e99a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ada0875ec26b666bfdaab544ca6ee83e8"><td align="right" class="memItemLeft" valign="top"><a id="ada0875ec26b666bfdaab544ca6ee83e8"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int64_t, float, true, false &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:ada0875ec26b666bfdaab544ca6ee83e8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0672a2530ca2a287cf17234a53f326da"><td align="right" class="memItemLeft" valign="top"><a id="a0672a2530ca2a287cf17234a53f326da"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int64_t, double, false, false &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a0672a2530ca2a287cf17234a53f326da"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a816d45eb40641c62fb65798a57f0cf27"><td align="right" class="memItemLeft" valign="top"><a id="a816d45eb40641c62fb65798a57f0cf27"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist&lt; int64_t, double, true, false &gt;</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_rows, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;edgelist_cols, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;edgelist_weights, bool reciprocal)</td></tr>
<tr class="separator:a816d45eb40641c62fb65798a57f0cf27"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a49a08cae7fb4bf2791c7dbb5e1438c8a"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a49a08cae7fb4bf2791c7dbb5e1438c8a"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a49a08cae7fb4bf2791c7dbb5e1438c8a">bfs</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const  &amp;graph_view, vertex_t *distances, vertex_t *predecessors, vertex_t const  *sources, size_t n_sources=1, bool direction_optimizing=false, vertex_t depth_limit=std::numeric_limits&lt; vertex_t &gt;::max(), bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a49a08cae7fb4bf2791c7dbb5e1438c8a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run breadth-first search to find the distances (and predecessors) from the source vertex.  <a href="namespacecugraph.html#a49a08cae7fb4bf2791c7dbb5e1438c8a">More...</a><br></td></tr>
<tr class="separator:a49a08cae7fb4bf2791c7dbb5e1438c8a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaa3ce39d13f2737ef23c5c6df976573b"><td align="right" class="memItemLeft" valign="top"><a id="aaa3ce39d13f2737ef23c5c6df976573b"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;graph_view, int32_t *distances, int32_t *predecessors, int32_t const *sources, size_t n_sources, bool direction_optimizing, int32_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:aaa3ce39d13f2737ef23c5c6df976573b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6541205d72f51a93812931bfd1a5ed9e"><td align="right" class="memItemLeft" valign="top"><a id="a6541205d72f51a93812931bfd1a5ed9e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;graph_view, int32_t *distances, int32_t *predecessors, int32_t const *sources, size_t n_sources, bool direction_optimizing, int32_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:a6541205d72f51a93812931bfd1a5ed9e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af6fb09b2d58a71d4807cd64750e0271a"><td align="right" class="memItemLeft" valign="top"><a id="af6fb09b2d58a71d4807cd64750e0271a"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;graph_view, int32_t *distances, int32_t *predecessors, int32_t const *sources, size_t n_sources, bool direction_optimizing, int32_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:af6fb09b2d58a71d4807cd64750e0271a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a70ac3bcd0fa2205cb8e75a000c351008"><td align="right" class="memItemLeft" valign="top"><a id="a70ac3bcd0fa2205cb8e75a000c351008"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;graph_view, int32_t *distances, int32_t *predecessors, int32_t const *sources, size_t n_sources, bool direction_optimizing, int32_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:a70ac3bcd0fa2205cb8e75a000c351008"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2b63e0213d24515d5e9870933016ec9b"><td align="right" class="memItemLeft" valign="top"><a id="a2b63e0213d24515d5e9870933016ec9b"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;graph_view, int64_t *distances, int64_t *predecessors, int64_t const *sources, size_t n_sources, bool direction_optimizing, int64_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:a2b63e0213d24515d5e9870933016ec9b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae6a090feafe917f4d0ace411f0418475"><td align="right" class="memItemLeft" valign="top"><a id="ae6a090feafe917f4d0ace411f0418475"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;graph_view, int64_t *distances, int64_t *predecessors, int64_t const *sources, size_t n_sources, bool direction_optimizing, int64_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:ae6a090feafe917f4d0ace411f0418475"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac423433eef9aa9fb53954622ce967fc6"><td align="right" class="memItemLeft" valign="top"><a id="ac423433eef9aa9fb53954622ce967fc6"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;graph_view, int32_t *distances, int32_t *predecessors, int32_t const *sources, size_t n_sources, bool direction_optimizing, int32_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:ac423433eef9aa9fb53954622ce967fc6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa548e8cb5effb85c56a84fb5896a3c8c"><td align="right" class="memItemLeft" valign="top"><a id="aa548e8cb5effb85c56a84fb5896a3c8c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;graph_view, int32_t *distances, int32_t *predecessors, int32_t const *sources, size_t n_sources, bool direction_optimizing, int32_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:aa548e8cb5effb85c56a84fb5896a3c8c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0483897ae25e034e784ab35f22bfa155"><td align="right" class="memItemLeft" valign="top"><a id="a0483897ae25e034e784ab35f22bfa155"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;graph_view, int32_t *distances, int32_t *predecessors, int32_t const *sources, size_t n_sources, bool direction_optimizing, int32_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:a0483897ae25e034e784ab35f22bfa155"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a317e050114ccdd75aa3827cab011fa81"><td align="right" class="memItemLeft" valign="top"><a id="a317e050114ccdd75aa3827cab011fa81"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;graph_view, int32_t *distances, int32_t *predecessors, int32_t const *sources, size_t n_sources, bool direction_optimizing, int32_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:a317e050114ccdd75aa3827cab011fa81"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8558c0433f274471f7412cc5bbac5439"><td align="right" class="memItemLeft" valign="top"><a id="a8558c0433f274471f7412cc5bbac5439"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;graph_view, int64_t *distances, int64_t *predecessors, int64_t const *sources, size_t n_sources, bool direction_optimizing, int64_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:a8558c0433f274471f7412cc5bbac5439"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6b9cc1d587343a8ebde158fe5d978fc2"><td align="right" class="memItemLeft" valign="top"><a id="a6b9cc1d587343a8ebde158fe5d978fc2"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;graph_view, int64_t *distances, int64_t *predecessors, int64_t const *sources, size_t n_sources, bool direction_optimizing, int64_t depth_limit, bool do_expensive_check)</td></tr>
<tr class="separator:a6b9cc1d587343a8ebde158fe5d978fc2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9dc29cc93342ec5e630aa8ab056b4229"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a9dc29cc93342ec5e630aa8ab056b4229"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, vertex_t &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a9dc29cc93342ec5e630aa8ab056b4229">extract_bfs_paths</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const  &amp;graph_view, vertex_t const  *distances, vertex_t const  *predecessors, vertex_t const  *destinations, size_t n_destinations)</td></tr>
<tr class="memdesc:a9dc29cc93342ec5e630aa8ab056b4229"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract paths from breadth-first search output.  <a href="namespacecugraph.html#a9dc29cc93342ec5e630aa8ab056b4229">More...</a><br></td></tr>
<tr class="separator:a9dc29cc93342ec5e630aa8ab056b4229"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1057a2ec33cdee7958104512d0f5419c"><td align="right" class="memItemLeft" valign="top"><a id="a1057a2ec33cdee7958104512d0f5419c"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;graph_view, int32_t const *distances, int32_t const *predecessors, int32_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:a1057a2ec33cdee7958104512d0f5419c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a33c7f25ebc2eee2e6d9db5e11e9fc193"><td align="right" class="memItemLeft" valign="top"><a id="a33c7f25ebc2eee2e6d9db5e11e9fc193"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;graph_view, int32_t const *distances, int32_t const *predecessors, int32_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:a33c7f25ebc2eee2e6d9db5e11e9fc193"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a17078581526dadaa8ed9babc46c0fc4a"><td align="right" class="memItemLeft" valign="top"><a id="a17078581526dadaa8ed9babc46c0fc4a"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, int64_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;graph_view, int64_t const *distances, int64_t const *predecessors, int64_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:a17078581526dadaa8ed9babc46c0fc4a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adc7c837b5729318619aba900f390cfb8"><td align="right" class="memItemLeft" valign="top"><a id="adc7c837b5729318619aba900f390cfb8"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;graph_view, int32_t const *distances, int32_t const *predecessors, int32_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:adc7c837b5729318619aba900f390cfb8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa93ded21a181000740ab7af3b28e2911"><td align="right" class="memItemLeft" valign="top"><a id="aa93ded21a181000740ab7af3b28e2911"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;graph_view, int32_t const *distances, int32_t const *predecessors, int32_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:aa93ded21a181000740ab7af3b28e2911"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8b71f5a68dc8d3ea068e9f0ef8b1b8b7"><td align="right" class="memItemLeft" valign="top"><a id="a8b71f5a68dc8d3ea068e9f0ef8b1b8b7"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, int64_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;graph_view, int64_t const *distances, int64_t const *predecessors, int64_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:a8b71f5a68dc8d3ea068e9f0ef8b1b8b7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0c994e28a42b15f67e3b3016e80962ca"><td align="right" class="memItemLeft" valign="top"><a id="a0c994e28a42b15f67e3b3016e80962ca"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;graph_view, int32_t const *distances, int32_t const *predecessors, int32_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:a0c994e28a42b15f67e3b3016e80962ca"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ade8eb08102d56bc56c7cfa415a1c4931"><td align="right" class="memItemLeft" valign="top"><a id="ade8eb08102d56bc56c7cfa415a1c4931"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;graph_view, int32_t const *distances, int32_t const *predecessors, int32_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:ade8eb08102d56bc56c7cfa415a1c4931"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a88e7717b8f73a027f62ccef76c5de166"><td align="right" class="memItemLeft" valign="top"><a id="a88e7717b8f73a027f62ccef76c5de166"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, int64_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;graph_view, int64_t const *distances, int64_t const *predecessors, int64_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:a88e7717b8f73a027f62ccef76c5de166"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa169d9a9032faa4f65746fc05e664ff1"><td align="right" class="memItemLeft" valign="top"><a id="aa169d9a9032faa4f65746fc05e664ff1"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;graph_view, int32_t const *distances, int32_t const *predecessors, int32_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:aa169d9a9032faa4f65746fc05e664ff1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6e9656cf88f74c2532a5dc07f9c16275"><td align="right" class="memItemLeft" valign="top"><a id="a6e9656cf88f74c2532a5dc07f9c16275"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;graph_view, int32_t const *distances, int32_t const *predecessors, int32_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:a6e9656cf88f74c2532a5dc07f9c16275"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a709a462ef3958bdf4a18ada4f2844205"><td align="right" class="memItemLeft" valign="top"><a id="a709a462ef3958bdf4a18ada4f2844205"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, int64_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>extract_bfs_paths</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;graph_view, int64_t const *distances, int64_t const *predecessors, int64_t const *destinations, size_t n_destinations)</td></tr>
<tr class="separator:a709a462ef3958bdf4a18ada4f2844205"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3152bc145253db9d0ed6a44a33a1c2bc"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a3152bc145253db9d0ed6a44a33a1c2bc"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a3152bc145253db9d0ed6a44a33a1c2bc">bfs</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, VT *distances, VT *predecessors, double *sp_counters, const VT start_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a3152bc145253db9d0ed6a44a33a1c2bc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a79b34e5fe21bfaf8414bf0ca23cac932"><td align="right" class="memItemLeft" valign="top"><a id="a79b34e5fe21bfaf8414bf0ca23cac932"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; uint32_t, uint32_t, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; uint32_t, uint32_t, float &gt; const &amp;graph, uint32_t *distances, uint32_t *predecessors, double *sp_counters, const uint32_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a79b34e5fe21bfaf8414bf0ca23cac932"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae825cc6a17a7ce58201e0c207e154619"><td align="right" class="memItemLeft" valign="top"><a id="ae825cc6a17a7ce58201e0c207e154619"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; uint32_t, uint32_t, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; uint32_t, uint32_t, double &gt; const &amp;graph, uint32_t *distances, uint32_t *predecessors, double *sp_counters, const uint32_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:ae825cc6a17a7ce58201e0c207e154619"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a646b9f1639fa5eb793927895fa7b4070"><td align="right" class="memItemLeft" valign="top"><a id="a646b9f1639fa5eb793927895fa7b4070"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; int32_t, int32_t, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;graph, int32_t *distances, int32_t *predecessors, double *sp_counters, const int32_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a646b9f1639fa5eb793927895fa7b4070"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3b0194dcb44be6f27e2658cefb40f487"><td align="right" class="memItemLeft" valign="top"><a id="a3b0194dcb44be6f27e2658cefb40f487"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; int32_t, int32_t, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;graph, int32_t *distances, int32_t *predecessors, double *sp_counters, const int32_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a3b0194dcb44be6f27e2658cefb40f487"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a179115b28ac415170a25ef53988b55a4"><td align="right" class="memItemLeft" valign="top"><a id="a179115b28ac415170a25ef53988b55a4"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; int64_t, int64_t, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;graph, int64_t *distances, int64_t *predecessors, double *sp_counters, const int64_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a179115b28ac415170a25ef53988b55a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9b6e88ff6a89cca8005df98b5ecef343"><td align="right" class="memItemLeft" valign="top"><a id="a9b6e88ff6a89cca8005df98b5ecef343"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; int64_t, int64_t, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;graph, int64_t *distances, int64_t *predecessors, double *sp_counters, const int64_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a9b6e88ff6a89cca8005df98b5ecef343"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7242c3b7c0b51bae7bb6377e10b5f1c4"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a7242c3b7c0b51bae7bb6377e10b5f1c4"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a7242c3b7c0b51bae7bb6377e10b5f1c4">sssp</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT *distances, VT *predecessors, const VT source_vertex)</td></tr>
<tr class="memdesc:a7242c3b7c0b51bae7bb6377e10b5f1c4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Native sssp with predecessors.  <a href="namespacecugraph.html#a7242c3b7c0b51bae7bb6377e10b5f1c4">More...</a><br></td></tr>
<tr class="separator:a7242c3b7c0b51bae7bb6377e10b5f1c4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a306da97943a4f41abc5126ba3ec2ae1a"><td align="right" class="memItemLeft" valign="top"><a id="a306da97943a4f41abc5126ba3ec2ae1a"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, float &gt; const &amp;graph, float *distances, int *predecessors, const int source_vertex)</td></tr>
<tr class="separator:a306da97943a4f41abc5126ba3ec2ae1a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adc3c8b061b102037a644881b6d365af7"><td align="right" class="memItemLeft" valign="top"><a id="adc3c8b061b102037a644881b6d365af7"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, double &gt; const &amp;graph, double *distances, int *predecessors, const int source_vertex)</td></tr>
<tr class="separator:adc3c8b061b102037a644881b6d365af7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a77988dffedeb1ec7b5d1fa588f5267ec"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a77988dffedeb1ec7b5d1fa588f5267ec"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a77988dffedeb1ec7b5d1fa588f5267ec">sssp</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const  &amp;graph_view, weight_t *distances, vertex_t *predecessors, vertex_t source_vertex, weight_t cutoff=std::numeric_limits&lt; weight_t &gt;::max(), bool do_expensive_check=false)</td></tr>
<tr class="memdesc:a77988dffedeb1ec7b5d1fa588f5267ec"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run single-source shortest-path to compute the minimum distances (and predecessors) from the source vertex.  <a href="namespacecugraph.html#a77988dffedeb1ec7b5d1fa588f5267ec">More...</a><br></td></tr>
<tr class="separator:a77988dffedeb1ec7b5d1fa588f5267ec"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9a64bc20ffcf2d5aba685e51e9588c05"><td align="right" class="memItemLeft" valign="top"><a id="a9a64bc20ffcf2d5aba685e51e9588c05"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;graph_view, float *distances, int32_t *predecessors, int32_t source_vertex, float cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:a9a64bc20ffcf2d5aba685e51e9588c05"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1b627406dc860e3c4dae3e6118c153b1"><td align="right" class="memItemLeft" valign="top"><a id="a1b627406dc860e3c4dae3e6118c153b1"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;graph_view, double *distances, int32_t *predecessors, int32_t source_vertex, double cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:a1b627406dc860e3c4dae3e6118c153b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afda021ae84f149d245964a75cc6fef78"><td align="right" class="memItemLeft" valign="top"><a id="afda021ae84f149d245964a75cc6fef78"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;graph_view, float *distances, int32_t *predecessors, int32_t source_vertex, float cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:afda021ae84f149d245964a75cc6fef78"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaab5a2b0bade0d93114498d813ba700a"><td align="right" class="memItemLeft" valign="top"><a id="aaab5a2b0bade0d93114498d813ba700a"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;graph_view, double *distances, int32_t *predecessors, int32_t source_vertex, double cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:aaab5a2b0bade0d93114498d813ba700a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad980aa76aff5f267da8bfbcc9d405250"><td align="right" class="memItemLeft" valign="top"><a id="ad980aa76aff5f267da8bfbcc9d405250"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;graph_view, float *distances, int64_t *predecessors, int64_t source_vertex, float cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:ad980aa76aff5f267da8bfbcc9d405250"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a26999741360e76d6957e933999c8d26e"><td align="right" class="memItemLeft" valign="top"><a id="a26999741360e76d6957e933999c8d26e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;graph_view, double *distances, int64_t *predecessors, int64_t source_vertex, double cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:a26999741360e76d6957e933999c8d26e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa679b266152df0bf44bc8961497a7b66"><td align="right" class="memItemLeft" valign="top"><a id="aa679b266152df0bf44bc8961497a7b66"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;graph_view, float *distances, int32_t *predecessors, int32_t source_vertex, float cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:aa679b266152df0bf44bc8961497a7b66"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a438f8c628c333e764016d4eaa0b814fc"><td align="right" class="memItemLeft" valign="top"><a id="a438f8c628c333e764016d4eaa0b814fc"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;graph_view, double *distances, int32_t *predecessors, int32_t source_vertex, double cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:a438f8c628c333e764016d4eaa0b814fc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac2ec9e6dd43a262e8924847058b921de"><td align="right" class="memItemLeft" valign="top"><a id="ac2ec9e6dd43a262e8924847058b921de"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;graph_view, float *distances, int32_t *predecessors, int32_t source_vertex, float cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:ac2ec9e6dd43a262e8924847058b921de"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a88f51a75ae0197f65a166fe37be91116"><td align="right" class="memItemLeft" valign="top"><a id="a88f51a75ae0197f65a166fe37be91116"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;graph_view, double *distances, int32_t *predecessors, int32_t source_vertex, double cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:a88f51a75ae0197f65a166fe37be91116"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6d89b6d921af230e788e4600a10179b5"><td align="right" class="memItemLeft" valign="top"><a id="a6d89b6d921af230e788e4600a10179b5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;graph_view, float *distances, int64_t *predecessors, int64_t source_vertex, float cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:a6d89b6d921af230e788e4600a10179b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9b96fe122a7aa1185da847892725c62f"><td align="right" class="memItemLeft" valign="top"><a id="a9b96fe122a7aa1185da847892725c62f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;graph_view, double *distances, int64_t *predecessors, int64_t source_vertex, double cutoff, bool do_expensive_check)</td></tr>
<tr class="separator:a9b96fe122a7aa1185da847892725c62f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6274817ef7b6e503565b2188f03c68ea"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a6274817ef7b6e503565b2188f03c68ea"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; VT, ET, WT &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a6274817ef7b6e503565b2188f03c68ea">get_two_hop_neighbors</a> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const  &amp;graph)</td></tr>
<tr class="memdesc:a6274817ef7b6e503565b2188f03c68ea"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all 2-hop neighbors in the graph.  <a href="namespacecugraph.html#a6274817ef7b6e503565b2188f03c68ea">More...</a><br></td></tr>
<tr class="separator:a6274817ef7b6e503565b2188f03c68ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a02eea4acfaedb4997244f9923cc9bcef"><td align="right" class="memItemLeft" valign="top"><a id="a02eea4acfaedb4997244f9923cc9bcef"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; int, int, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_two_hop_neighbors</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, float &gt; const &amp;)</td></tr>
<tr class="separator:a02eea4acfaedb4997244f9923cc9bcef"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a738dd538d848076e6cd46914a7141f35"><td align="right" class="memItemLeft" valign="top"><a id="a738dd538d848076e6cd46914a7141f35"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; int, int, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_two_hop_neighbors</b> (<a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, double &gt; const &amp;)</td></tr>
<tr class="separator:a738dd538d848076e6cd46914a7141f35"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a07372c78e975cd7a73daecc486b00dcf"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a07372c78e975cd7a73daecc486b00dcf"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; vertex_t, edge_t, weight_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a07372c78e975cd7a73daecc486b00dcf">minimum_spanning_tree</a> (raft::handle_t const  &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const  &amp;graph, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a07372c78e975cd7a73daecc486b00dcf"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate edges in a minimum spanning forest of an undirected weighted graph.  <a href="namespacecugraph.html#a07372c78e975cd7a73daecc486b00dcf">More...</a><br></td></tr>
<tr class="separator:a07372c78e975cd7a73daecc486b00dcf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a26b0b8ff8a5e8dfd0ba0077293871e6d"><td align="right" class="memItemLeft" valign="top"><a id="a26b0b8ff8a5e8dfd0ba0077293871e6d"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; int, int, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>minimum_spanning_tree&lt; int, int, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, float &gt; const &amp;graph, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:a26b0b8ff8a5e8dfd0ba0077293871e6d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a52bccd0ec3df6e4c63dc87037b2e1aaf"><td align="right" class="memItemLeft" valign="top"><a id="a52bccd0ec3df6e4c63dc87037b2e1aaf"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; int, int, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>minimum_spanning_tree&lt; int, int, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; int, int, double &gt; const &amp;graph, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:a52bccd0ec3df6e4c63dc87037b2e1aaf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2030539438fda442003a14cbe9352fee"><td align="right" class="memItemLeft" valign="top"><a id="a2030539438fda442003a14cbe9352fee"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>host_barrier</b> (raft::comms::comms_t const &amp;comm, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a2030539438fda442003a14cbe9352fee"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a41a71fac845f1af9f992e9857cf9f942"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a41a71fac845f1af9f992e9857cf9f942"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a41a71fac845f1af9f992e9857cf9f942">get_traversed_cost</a> (raft::handle_t const  &amp;handle, vertex_t const  *vertices, vertex_t const  *preds, weight_t const  *info_weights, weight_t *out, vertex_t stop_vertex, vertex_t num_vertices)</td></tr>
<tr class="memdesc:a41a71fac845f1af9f992e9857cf9f942"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes the results of BFS or SSSP function call and sums the given weights along the path to the starting vertex.  <a href="namespacecugraph.html#a41a71fac845f1af9f992e9857cf9f942">More...</a><br></td></tr>
<tr class="separator:a41a71fac845f1af9f992e9857cf9f942"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0a1ea0ebaa6d020cbe75218ceacc3407"><td align="right" class="memItemLeft" valign="top"><a id="a0a1ea0ebaa6d020cbe75218ceacc3407"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_traversed_cost&lt; int32_t, float &gt;</b> (raft::handle_t const &amp;handle, int32_t const *vertices, int32_t const *preds, float const *info_weights, float *out, int32_t stop_vertex, int32_t num_vertices)</td></tr>
<tr class="separator:a0a1ea0ebaa6d020cbe75218ceacc3407"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab8d6554f98dc75a902c445d930f6db6d"><td align="right" class="memItemLeft" valign="top"><a id="ab8d6554f98dc75a902c445d930f6db6d"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_traversed_cost&lt; int32_t, double &gt;</b> (raft::handle_t const &amp;handle, int32_t const *vertices, int32_t const *preds, double const *info_weights, double *out, int32_t stop_vertex, int32_t num_vertices)</td></tr>
<tr class="separator:ab8d6554f98dc75a902c445d930f6db6d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a93dbff34f1cdabe885afe72b31c2c20f"><td align="right" class="memItemLeft" valign="top"><a id="a93dbff34f1cdabe885afe72b31c2c20f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_traversed_cost&lt; int64_t, float &gt;</b> (raft::handle_t const &amp;handle, int64_t const *vertices, int64_t const *preds, float const *info_weights, float *out, int64_t stop_vertex, int64_t num_vertices)</td></tr>
<tr class="separator:a93dbff34f1cdabe885afe72b31c2c20f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3baa4799c8c1aa3dd6711f257f5483b5"><td align="right" class="memItemLeft" valign="top"><a id="a3baa4799c8c1aa3dd6711f257f5483b5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_traversed_cost&lt; int64_t, double &gt;</b> (raft::handle_t const &amp;handle, int64_t const *vertices, int64_t const *preds, double const *info_weights, double *out, int64_t stop_vertex, int64_t num_vertices)</td></tr>
<tr class="separator:a3baa4799c8c1aa3dd6711f257f5483b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3ea68fa26fc144e25e2bb392903c4ec4"><td class="memTemplParams" colspan="2">template&lt;typename value_t &gt; </td></tr>
<tr class="memitem:a3ea68fa26fc144e25e2bb392903c4ec4"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a3ea68fa26fc144e25e2bb392903c4ec4">comms_bcast</a> (const raft::handle_t &amp;handle, value_t *value, size_t count)</td></tr>
<tr class="memdesc:a3ea68fa26fc144e25e2bb392903c4ec4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast using handle communicator.  <a href="namespacecugraph.html#a3ea68fa26fc144e25e2bb392903c4ec4">More...</a><br></td></tr>
<tr class="separator:a3ea68fa26fc144e25e2bb392903c4ec4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af50fb6a14eef4f2d39fb988a62c59bb5"><td class="memTemplParams" colspan="2"><a id="af50fb6a14eef4f2d39fb988a62c59bb5"></a>
template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:af50fb6a14eef4f2d39fb988a62c59bb5"><td align="right" class="memTemplItemLeft" valign="top">__host__ __device__ std::enable_if_t&lt; std::is_signed&lt; vertex_t &gt;::value, bool &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>is_valid_vertex</b> (vertex_t num_vertices, vertex_t v)</td></tr>
<tr class="separator:af50fb6a14eef4f2d39fb988a62c59bb5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaa952ad38036abce2a33394529af8669"><td class="memTemplParams" colspan="2"><a id="aaa952ad38036abce2a33394529af8669"></a>
template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:aaa952ad38036abce2a33394529af8669"><td align="right" class="memTemplItemLeft" valign="top">__host__ __device__ std::enable_if_t&lt; std::is_unsigned&lt; vertex_t &gt;::value, bool &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>is_valid_vertex</b> (vertex_t num_vertices, vertex_t v)</td></tr>
<tr class="separator:aaa952ad38036abce2a33394529af8669"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a80cff02d99194b9dd3a9d5a5dead4693"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename VertexValueInputIterator &gt; </td></tr>
<tr class="memitem:a80cff02d99194b9dd3a9d5a5dead4693"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a80cff02d99194b9dd3a9d5a5dead4693">copy_to_adj_matrix_row</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexValueInputIterator vertex_value_input_first, <a class="el" href="classcugraph_1_1row__properties__t.html">row_properties_t</a>&lt; GraphViewType, typename std::iterator_traits&lt; VertexValueInputIterator &gt;::value_type &gt; &amp;adj_matrix_row_value_output)</td></tr>
<tr class="memdesc:a80cff02d99194b9dd3a9d5a5dead4693"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy vertex property values to the corresponding graph adjacency matrix row property variables.  <a href="namespacecugraph.html#a80cff02d99194b9dd3a9d5a5dead4693">More...</a><br></td></tr>
<tr class="separator:a80cff02d99194b9dd3a9d5a5dead4693"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afe0fc3924325baf54a603910516ba6a6"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename VertexIterator , typename VertexValueInputIterator &gt; </td></tr>
<tr class="memitem:afe0fc3924325baf54a603910516ba6a6"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#afe0fc3924325baf54a603910516ba6a6">copy_to_adj_matrix_row</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexIterator vertex_first, VertexIterator vertex_last, VertexValueInputIterator vertex_value_input_first, <a class="el" href="classcugraph_1_1row__properties__t.html">row_properties_t</a>&lt; GraphViewType, typename std::iterator_traits&lt; VertexValueInputIterator &gt;::value_type &gt; &amp;adj_matrix_row_value_output)</td></tr>
<tr class="memdesc:afe0fc3924325baf54a603910516ba6a6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy vertex property values to the corresponding graph adjacency matrix row property variables.  <a href="namespacecugraph.html#afe0fc3924325baf54a603910516ba6a6">More...</a><br></td></tr>
<tr class="separator:afe0fc3924325baf54a603910516ba6a6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a70fb6fb7f9e128c20c21ebaac26a5b1e"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename VertexValueInputIterator &gt; </td></tr>
<tr class="memitem:a70fb6fb7f9e128c20c21ebaac26a5b1e"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a70fb6fb7f9e128c20c21ebaac26a5b1e">copy_to_adj_matrix_col</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexValueInputIterator vertex_value_input_first, <a class="el" href="classcugraph_1_1col__properties__t.html">col_properties_t</a>&lt; GraphViewType, typename std::iterator_traits&lt; VertexValueInputIterator &gt;::value_type &gt; &amp;adj_matrix_col_value_output)</td></tr>
<tr class="memdesc:a70fb6fb7f9e128c20c21ebaac26a5b1e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy vertex property values to the corresponding graph adjacency matrix column property variables.  <a href="namespacecugraph.html#a70fb6fb7f9e128c20c21ebaac26a5b1e">More...</a><br></td></tr>
<tr class="separator:a70fb6fb7f9e128c20c21ebaac26a5b1e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a19bb40d654a65d9941810d4c2a920c55"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename VertexIterator , typename VertexValueInputIterator &gt; </td></tr>
<tr class="memitem:a19bb40d654a65d9941810d4c2a920c55"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a19bb40d654a65d9941810d4c2a920c55">copy_to_adj_matrix_col</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexIterator vertex_first, VertexIterator vertex_last, VertexValueInputIterator vertex_value_input_first, <a class="el" href="classcugraph_1_1col__properties__t.html">col_properties_t</a>&lt; GraphViewType, typename std::iterator_traits&lt; VertexValueInputIterator &gt;::value_type &gt; &amp;adj_matrix_col_value_output)</td></tr>
<tr class="memdesc:a19bb40d654a65d9941810d4c2a920c55"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy vertex property values to the corresponding graph adjacency matrix column property variables.  <a href="namespacecugraph.html#a19bb40d654a65d9941810d4c2a920c55">More...</a><br></td></tr>
<tr class="separator:a19bb40d654a65d9941810d4c2a920c55"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa4a52730884b78287f89852451df911e"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp , typename T , typename VertexValueOutputIterator &gt; </td></tr>
<tr class="memitem:aa4a52730884b78287f89852451df911e"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aa4a52730884b78287f89852451df911e">copy_v_transform_reduce_in_nbr</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColValueInputWrapper adj_matrix_col_value_input, EdgeOp e_op, T init, VertexValueOutputIterator vertex_value_output_first)</td></tr>
<tr class="memdesc:aa4a52730884b78287f89852451df911e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the incoming edges to update vertex properties.  <a href="namespacecugraph.html#aa4a52730884b78287f89852451df911e">More...</a><br></td></tr>
<tr class="separator:aa4a52730884b78287f89852451df911e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afd2f999156ec60b8b167229c2660a910"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp , typename T , typename VertexValueOutputIterator &gt; </td></tr>
<tr class="memitem:afd2f999156ec60b8b167229c2660a910"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#afd2f999156ec60b8b167229c2660a910">copy_v_transform_reduce_out_nbr</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColValueInputWrapper adj_matrix_col_value_input, EdgeOp e_op, T init, VertexValueOutputIterator vertex_value_output_first)</td></tr>
<tr class="memdesc:afd2f999156ec60b8b167229c2660a910"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the outgoing edges to update vertex properties.  <a href="namespacecugraph.html#afd2f999156ec60b8b167229c2660a910">More...</a><br></td></tr>
<tr class="separator:afd2f999156ec60b8b167229c2660a910"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1d7595004cf3024f60a8fe6c3b9eae89"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColKeyInputWrapper , typename VertexIterator , typename ValueIterator , typename KeyAggregatedEdgeOp , typename ReduceOp , typename T , typename VertexValueOutputIterator &gt; </td></tr>
<tr class="memitem:a1d7595004cf3024f60a8fe6c3b9eae89"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a1d7595004cf3024f60a8fe6c3b9eae89">copy_v_transform_reduce_key_aggregated_out_nbr</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColKeyInputWrapper adj_matrix_col_key_input, VertexIterator map_unique_key_first, VertexIterator map_unique_key_last, ValueIterator map_value_first, KeyAggregatedEdgeOp key_aggregated_e_op, ReduceOp reduce_op, T init, VertexValueOutputIterator vertex_value_output_first)</td></tr>
<tr class="memdesc:a1d7595004cf3024f60a8fe6c3b9eae89"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over every vertex's key-aggregated outgoing edges to update vertex properties.  <a href="namespacecugraph.html#a1d7595004cf3024f60a8fe6c3b9eae89">More...</a><br></td></tr>
<tr class="separator:a1d7595004cf3024f60a8fe6c3b9eae89"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac324d18256a22d04536a2b854665a8ff"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp &gt; </td></tr>
<tr class="memitem:ac324d18256a22d04536a2b854665a8ff"><td align="right" class="memTemplItemLeft" valign="top">GraphViewType::edge_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac324d18256a22d04536a2b854665a8ff">count_if_e</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColValueInputWrapper adj_matrix_col_value_input, EdgeOp e_op)</td></tr>
<tr class="memdesc:ac324d18256a22d04536a2b854665a8ff"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of edges that satisfies the given predicate.  <a href="namespacecugraph.html#ac324d18256a22d04536a2b854665a8ff">More...</a><br></td></tr>
<tr class="separator:ac324d18256a22d04536a2b854665a8ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abe23b1b58ab369299effd2337abac8b5"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename VertexValueInputIterator , typename VertexOp &gt; </td></tr>
<tr class="memitem:abe23b1b58ab369299effd2337abac8b5"><td align="right" class="memTemplItemLeft" valign="top">GraphViewType::vertex_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#abe23b1b58ab369299effd2337abac8b5">count_if_v</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexValueInputIterator vertex_value_input_first, VertexOp v_op)</td></tr>
<tr class="memdesc:abe23b1b58ab369299effd2337abac8b5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of vertices that satisfies the given predicate.  <a href="namespacecugraph.html#abe23b1b58ab369299effd2337abac8b5">More...</a><br></td></tr>
<tr class="separator:abe23b1b58ab369299effd2337abac8b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7e723b9bf2c48c9c9572af50f9ea74f5"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename InputIterator , typename VertexOp &gt; </td></tr>
<tr class="memitem:a7e723b9bf2c48c9c9572af50f9ea74f5"><td align="right" class="memTemplItemLeft" valign="top">GraphViewType::vertex_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a7e723b9bf2c48c9c9572af50f9ea74f5">count_if_v</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, InputIterator input_first, InputIterator input_last, VertexOp v_op)</td></tr>
<tr class="memdesc:a7e723b9bf2c48c9c9572af50f9ea74f5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of vertices that satisfies the given predicate.  <a href="namespacecugraph.html#a7e723b9bf2c48c9c9572af50f9ea74f5">More...</a><br></td></tr>
<tr class="separator:a7e723b9bf2c48c9c9572af50f9ea74f5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aff1311c0a4ecb5b140333976d007a0e6"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp &gt; </td></tr>
<tr class="memitem:aff1311c0a4ecb5b140333976d007a0e6"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; typename GraphViewType::vertex_type &gt;, rmm::device_uvector&lt; typename GraphViewType::vertex_type &gt;, std::optional&lt; rmm::device_uvector&lt; typename GraphViewType::weight_type &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aff1311c0a4ecb5b140333976d007a0e6">extract_if_e</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColValueInputWrapper adj_matrix_col_value_input, EdgeOp e_op)</td></tr>
<tr class="memdesc:aff1311c0a4ecb5b140333976d007a0e6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the entire set of edges and return an edge list with the edges with <code>edge_op</code> evaluated to be true.  <a href="namespacecugraph.html#aff1311c0a4ecb5b140333976d007a0e6">More...</a><br></td></tr>
<tr class="separator:aff1311c0a4ecb5b140333976d007a0e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2b1028ad20d825339306bd44cc2b3b3d"><td class="memTemplParams" colspan="2"><a id="a2b1028ad20d825339306bd44cc2b3b3d"></a>
template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a2b1028ad20d825339306bd44cc2b3b3d"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>op_dispatch</b> (raft::comms::op_t op, F &amp;&amp;f)</td></tr>
<tr class="separator:a2b1028ad20d825339306bd44cc2b3b3d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a69cf216ca09ffe1d421a320684277c0d"><td class="memTemplParams" colspan="2"><a id="a69cf216ca09ffe1d421a320684277c0d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69cf216ca09ffe1d421a320684277c0d"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>identity_element</b> (raft::comms::op_t op)</td></tr>
<tr class="separator:a69cf216ca09ffe1d421a320684277c0d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ace022163285fd07e2e78fd2f28b888d4"><td class="memTemplParams" colspan="2"><a id="ace022163285fd07e2e78fd2f28b888d4"></a>
template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:ace022163285fd07e2e78fd2f28b888d4"><td align="right" class="memTemplItemLeft" valign="top">__device__ std::enable_if_t&lt; thrust::detail::is_discard_iterator&lt; Iterator &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>atomic_accumulate_edge_op_result</b> (Iterator iter, T const &amp;value)</td></tr>
<tr class="separator:ace022163285fd07e2e78fd2f28b888d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2f69a1d93b440258b52b9e7b15a9fa16"><td class="memTemplParams" colspan="2"><a id="a2f69a1d93b440258b52b9e7b15a9fa16"></a>
template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:a2f69a1d93b440258b52b9e7b15a9fa16"><td align="right" class="memTemplItemLeft" valign="top">__device__ std::enable_if_t&lt; std::is_same&lt; typename thrust::iterator_traits&lt; Iterator &gt;::value_type, T &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>atomic_accumulate_edge_op_result</b> (Iterator iter, T const &amp;value)</td></tr>
<tr class="separator:a2f69a1d93b440258b52b9e7b15a9fa16"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8bfe56023b6b2a0ec9b15824c0bfa3f6"><td class="memTemplParams" colspan="2"><a id="a8bfe56023b6b2a0ec9b15824c0bfa3f6"></a>
template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:a8bfe56023b6b2a0ec9b15824c0bfa3f6"><td align="right" class="memTemplItemLeft" valign="top">__device__ std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; T &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>atomic_accumulate_edge_op_result</b> (Iterator iter, T const &amp;value)</td></tr>
<tr class="separator:a8bfe56023b6b2a0ec9b15824c0bfa3f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac478ff292d511164e35224dcc90725dc"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename VertexValueInputIterator , typename T &gt; </td></tr>
<tr class="memitem:ac478ff292d511164e35224dcc90725dc"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac478ff292d511164e35224dcc90725dc">reduce_v</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexValueInputIterator vertex_value_input_first, T init, raft::comms::op_t op=raft::comms::op_t::SUM)</td></tr>
<tr class="memdesc:ac478ff292d511164e35224dcc90725dc"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce the vertex properties.  <a href="namespacecugraph.html#ac478ff292d511164e35224dcc90725dc">More...</a><br></td></tr>
<tr class="separator:ac478ff292d511164e35224dcc90725dc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a949a39ee7ad148f83104f99f413a5869"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename InputIterator , typename T &gt; </td></tr>
<tr class="memitem:a949a39ee7ad148f83104f99f413a5869"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a949a39ee7ad148f83104f99f413a5869">reduce_v</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, InputIterator input_first, InputIterator input_last, T init=T{}, raft::comms::op_t op=raft::comms::op_t::SUM)</td></tr>
<tr class="memdesc:a949a39ee7ad148f83104f99f413a5869"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce the vertex properties.  <a href="namespacecugraph.html#a949a39ee7ad148f83104f99f413a5869">More...</a><br></td></tr>
<tr class="separator:a949a39ee7ad148f83104f99f413a5869"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a060c985f371190ca9f396324ba85e1ab"><td class="memTemplParams" colspan="2"><a id="a060c985f371190ca9f396324ba85e1ab"></a>
template&lt;typename vertex_t , typename... Ts&gt; </td></tr>
<tr class="memitem:a060c985f371190ca9f396324ba85e1ab"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_view_concat</b> (<a class="el" href="classcugraph_1_1detail_1_1major__properties__device__view__t.html">detail::major_properties_device_view_t</a>&lt; vertex_t, Ts &gt; const &amp;... device_views)</td></tr>
<tr class="separator:a060c985f371190ca9f396324ba85e1ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ada05e18661d1011f3a255fdeffa39479"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename AdjMatrixRowKeyInputWrapper , typename EdgeOp , typename T &gt; </td></tr>
<tr class="memitem:ada05e18661d1011f3a255fdeffa39479"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ada05e18661d1011f3a255fdeffa39479">transform_reduce_by_adj_matrix_row_key_e</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColValueInputWrapper adj_matrix_col_value_input, AdjMatrixRowKeyInputWrapper adj_matrix_row_key_input, EdgeOp e_op, T init)</td></tr>
<tr class="memdesc:ada05e18661d1011f3a255fdeffa39479"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the entire set of edges and reduce <code>edge_op</code> outputs to (key, value) pairs.  <a href="namespacecugraph.html#ada05e18661d1011f3a255fdeffa39479">More...</a><br></td></tr>
<tr class="separator:ada05e18661d1011f3a255fdeffa39479"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaf698d4569a93c1c25213f924354d0a8"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename AdjMatrixColKeyInputWrapper , typename EdgeOp , typename T &gt; </td></tr>
<tr class="memitem:aaf698d4569a93c1c25213f924354d0a8"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aaf698d4569a93c1c25213f924354d0a8">transform_reduce_by_adj_matrix_col_key_e</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColValueInputWrapper adj_matrix_col_value_input, AdjMatrixColKeyInputWrapper adj_matrix_col_key_input, EdgeOp e_op, T init)</td></tr>
<tr class="memdesc:aaf698d4569a93c1c25213f924354d0a8"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the entire set of edges and reduce <code>edge_op</code> outputs to (key, value) pairs.  <a href="namespacecugraph.html#aaf698d4569a93c1c25213f924354d0a8">More...</a><br></td></tr>
<tr class="separator:aaf698d4569a93c1c25213f924354d0a8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad5857a3c37a0a082ca091cca563aaeb2"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp , typename T &gt; </td></tr>
<tr class="memitem:ad5857a3c37a0a082ca091cca563aaeb2"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad5857a3c37a0a082ca091cca563aaeb2">transform_reduce_e</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColValueInputWrapper adj_matrix_col_value_input, EdgeOp e_op, T init)</td></tr>
<tr class="memdesc:ad5857a3c37a0a082ca091cca563aaeb2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the entire set of edges and reduce <code>edge_op</code> outputs.  <a href="namespacecugraph.html#ad5857a3c37a0a082ca091cca563aaeb2">More...</a><br></td></tr>
<tr class="separator:ad5857a3c37a0a082ca091cca563aaeb2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0e7e61c7e241227b475e054174f99def"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename VertexValueInputIterator , typename VertexOp , typename T &gt; </td></tr>
<tr class="memitem:a0e7e61c7e241227b475e054174f99def"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a0e7e61c7e241227b475e054174f99def">transform_reduce_v</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexValueInputIterator vertex_value_input_first, VertexOp v_op, T init, raft::comms::op_t op=raft::comms::op_t::SUM)</td></tr>
<tr class="memdesc:a0e7e61c7e241227b475e054174f99def"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply an operator to the vertex properties and reduce.  <a href="namespacecugraph.html#a0e7e61c7e241227b475e054174f99def">More...</a><br></td></tr>
<tr class="separator:a0e7e61c7e241227b475e054174f99def"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a58cd28238cf2744964acd78007b1c11b"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename InputIterator , typename VertexOp , typename T &gt; </td></tr>
<tr class="memitem:a58cd28238cf2744964acd78007b1c11b"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a58cd28238cf2744964acd78007b1c11b">transform_reduce_v</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, InputIterator input_first, InputIterator input_last, VertexOp v_op, T init=T{}, raft::comms::op_t op=raft::comms::op_t::SUM)</td></tr>
<tr class="memdesc:a58cd28238cf2744964acd78007b1c11b"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply an operator to the vertex properties and reduce.  <a href="namespacecugraph.html#a58cd28238cf2744964acd78007b1c11b">More...</a><br></td></tr>
<tr class="separator:a58cd28238cf2744964acd78007b1c11b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9c8ecd0bacfc320869b1459d33b33ebe"><td class="memTemplParams" colspan="2"><a id="a9c8ecd0bacfc320869b1459d33b33ebe"></a>
template&lt;typename GraphViewType , typename VertexFrontierType &gt; </td></tr>
<tr class="memitem:a9c8ecd0bacfc320869b1459d33b33ebe"><td align="right" class="memTemplItemLeft" valign="top">GraphViewType::edge_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>compute_num_out_nbrs_from_frontier</b> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexFrontierType const &amp;frontier, size_t cur_frontier_bucket_idx)</td></tr>
<tr class="separator:a9c8ecd0bacfc320869b1459d33b33ebe"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad18b474e61601d1b82dad8dd10d7f505"><td class="memTemplParams" colspan="2">template&lt;typename GraphViewType , typename VertexFrontierType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp , typename ReduceOp , typename VertexValueInputIterator , typename VertexValueOutputIterator , typename VertexOp &gt; </td></tr>
<tr class="memitem:ad18b474e61601d1b82dad8dd10d7f505"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad18b474e61601d1b82dad8dd10d7f505">update_frontier_v_push_if_out_nbr</a> (raft::handle_t const &amp;handle, GraphViewType const &amp;graph_view, VertexFrontierType &amp;frontier, size_t cur_frontier_bucket_idx, std::vector&lt; size_t &gt; const &amp;next_frontier_bucket_indices, AdjMatrixRowValueInputWrapper adj_matrix_row_value_input, AdjMatrixColValueInputWrapper adj_matrix_col_value_input, EdgeOp e_op, ReduceOp reduce_op, VertexValueInputIterator vertex_value_input_first, VertexValueOutputIterator vertex_value_output_first, VertexOp v_op)</td></tr>
<tr class="memdesc:ad18b474e61601d1b82dad8dd10d7f505"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update (tagged-)vertex frontier and (tagged-)vertex property values iterating over the outgoing edges from the frontier.  <a href="namespacecugraph.html#ad18b474e61601d1b82dad8dd10d7f505">More...</a><br></td></tr>
<tr class="separator:ad18b474e61601d1b82dad8dd10d7f505"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa76613e0f9474b8b9d99c28dc15e7542"><td class="memTemplParams" colspan="2"><a id="aa76613e0f9474b8b9d99c28dc15e7542"></a>
template&lt;typename VertexIterator0 , typename VertexIterator1 , typename ValueIterator , typename KeyToGPUIdOp &gt; </td></tr>
<tr class="memitem:aa76613e0f9474b8b9d99c28dc15e7542"><td align="right" class="memTemplItemLeft" valign="top">decltype(allocate_dataframe_buffer&lt; typename std::iterator_traits&lt; ValueIterator &gt;::value_type &gt;(0, cudaStream_t{nullptr}))&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>collect_values_for_keys</b> (raft::comms::comms_t const &amp;comm, VertexIterator0 map_key_first, VertexIterator0 map_key_last, ValueIterator map_value_first, VertexIterator1 collect_key_first, VertexIterator1 collect_key_last, KeyToGPUIdOp key_to_gpu_id_op, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:aa76613e0f9474b8b9d99c28dc15e7542"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a56bc31d6bdb4d11bc5082a05f7ad5564"><td class="memTemplParams" colspan="2"><a id="a56bc31d6bdb4d11bc5082a05f7ad5564"></a>
template&lt;typename VertexIterator0 , typename VertexIterator1 , typename ValueIterator , typename KeyToGPUIdOp &gt; </td></tr>
<tr class="memitem:a56bc31d6bdb4d11bc5082a05f7ad5564"><td align="right" class="memTemplItemLeft" valign="top">decltype(allocate_dataframe_buffer&lt; typename std::iterator_traits&lt; ValueIterator &gt;::value_type &gt;(0, cudaStream_t{nullptr}))&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>collect_values_for_unique_keys</b> (raft::comms::comms_t const &amp;comm, VertexIterator0 map_key_first, VertexIterator0 map_key_last, ValueIterator map_value_first, VertexIterator1 collect_unique_key_first, VertexIterator1 collect_unique_key_last, KeyToGPUIdOp key_to_gpu_id_op, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a56bc31d6bdb4d11bc5082a05f7ad5564"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6da78818dc11615d8d2344070127ae02"><td class="memTemplParams" colspan="2"><a id="a6da78818dc11615d8d2344070127ae02"></a>
template&lt;typename vertex_t , typename ValueIterator &gt; </td></tr>
<tr class="memitem:a6da78818dc11615d8d2344070127ae02"><td align="right" class="memTemplItemLeft" valign="top">decltype(allocate_dataframe_buffer&lt; typename std::iterator_traits&lt; ValueIterator &gt;::value_type &gt;(0, cudaStream_t{nullptr}))&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>collect_values_for_sorted_unique_vertices</b> (raft::comms::comms_t const &amp;comm, vertex_t const *collect_unique_vertex_first, vertex_t num_vertices, ValueIterator local_value_first, std::vector&lt; vertex_t &gt; const &amp;vertex_partition_lasts, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a6da78818dc11615d8d2344070127ae02"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abf684b838532287a640fb2f402e59dab"><td class="memTemplParams" colspan="2"><a id="abf684b838532287a640fb2f402e59dab"></a>
template&lt;typename VertexIterator , typename ValueIterator &gt; </td></tr>
<tr class="memitem:abf684b838532287a640fb2f402e59dab"><td align="right" class="memTemplItemLeft" valign="top">decltype(allocate_dataframe_buffer&lt; typename std::iterator_traits&lt; ValueIterator &gt;::value_type &gt;(0, cudaStream_t{nullptr}))&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>collect_values_for_vertices</b> (raft::comms::comms_t const &amp;comm, VertexIterator collect_vertex_first, VertexIterator collect_vertex_last, ValueIterator local_value_first, std::vector&lt; typename std::iterator_traits&lt; VertexIterator &gt;::value_type &gt; const &amp;vertex_partition_lasts, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:abf684b838532287a640fb2f402e59dab"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2ce89e5d593f13eb44ab8e4007755bf8"><td class="memTemplParams" colspan="2"><a id="a2ce89e5d593f13eb44ab8e4007755bf8"></a>
template&lt;typename T , typename std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ce89e5d593f13eb44ab8e4007755bf8"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>allocate_dataframe_buffer</b> (size_t buffer_size, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a2ce89e5d593f13eb44ab8e4007755bf8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a370a172e567edcae6411fb71a258a6f9"><td class="memTemplParams" colspan="2"><a id="a370a172e567edcae6411fb71a258a6f9"></a>
template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a370a172e567edcae6411fb71a258a6f9"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>resize_dataframe_buffer</b> (Type &amp;buffer, size_t new_buffer_size, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a370a172e567edcae6411fb71a258a6f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a45cea08b908d5eb8087561341e861ddc"><td class="memTemplParams" colspan="2"><a id="a45cea08b908d5eb8087561341e861ddc"></a>
template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a45cea08b908d5eb8087561341e861ddc"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>shrink_to_fit_dataframe_buffer</b> (Type &amp;buffer, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a45cea08b908d5eb8087561341e861ddc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab6755504ca94e60a8e0c11951e9118ff"><td class="memTemplParams" colspan="2"><a id="ab6755504ca94e60a8e0c11951e9118ff"></a>
template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ab6755504ca94e60a8e0c11951e9118ff"><td align="right" class="memTemplItemLeft" valign="top">size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>size_dataframe_buffer</b> (Type &amp;buffer)</td></tr>
<tr class="separator:ab6755504ca94e60a8e0c11951e9118ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1a13cfe35c2549879a48877d66a34ef1"><td class="memTemplParams" colspan="2"><a id="a1a13cfe35c2549879a48877d66a34ef1"></a>
template&lt;typename BufferType , typename std::enable_if_t&lt; is_arithmetic_vector&lt; std::remove_cv_t&lt; BufferType &gt;, rmm::device_uvector &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1a13cfe35c2549879a48877d66a34ef1"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>get_dataframe_buffer_begin</b> (BufferType &amp;buffer)</td></tr>
<tr class="separator:a1a13cfe35c2549879a48877d66a34ef1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a50cab22cd2eefc87f9e07916a619aa2c"><td class="memTemplParams" colspan="2"><a id="a50cab22cd2eefc87f9e07916a619aa2c"></a>
template&lt;typename BufferType , typename std::enable_if_t&lt; is_arithmetic_vector&lt; std::remove_cv_t&lt; BufferType &gt;, rmm::device_uvector &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a50cab22cd2eefc87f9e07916a619aa2c"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>get_dataframe_buffer_cbegin</b> (BufferType &amp;buffer)</td></tr>
<tr class="separator:a50cab22cd2eefc87f9e07916a619aa2c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3b890d432029fab0c2dc52eb9c1ef710"><td class="memTemplParams" colspan="2"><a id="a3b890d432029fab0c2dc52eb9c1ef710"></a>
template&lt;typename BufferType , typename std::enable_if_t&lt; is_arithmetic_vector&lt; std::remove_cv_t&lt; BufferType &gt;, rmm::device_uvector &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b890d432029fab0c2dc52eb9c1ef710"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>get_dataframe_buffer_end</b> (BufferType &amp;buffer)</td></tr>
<tr class="separator:a3b890d432029fab0c2dc52eb9c1ef710"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a14856cd86bdfe4721ff556c53ca10239"><td class="memTemplParams" colspan="2"><a id="a14856cd86bdfe4721ff556c53ca10239"></a>
template&lt;typename BufferType , typename std::enable_if_t&lt; is_arithmetic_vector&lt; std::remove_cv_t&lt; BufferType &gt;, rmm::device_uvector &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a14856cd86bdfe4721ff556c53ca10239"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>get_dataframe_buffer_cend</b> (BufferType &amp;buffer)</td></tr>
<tr class="separator:a14856cd86bdfe4721ff556c53ca10239"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a30ea64c76269be7f2a876b88c7837ba5"><td class="memTemplParams" colspan="2"><a id="a30ea64c76269be7f2a876b88c7837ba5"></a>
template&lt;typename BufferType , typename Op &gt; </td></tr>
<tr class="memitem:a30ea64c76269be7f2a876b88c7837ba5"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>transform</b> (const BufferType &amp;input, BufferType &amp;output, Op &amp;&amp;op)</td></tr>
<tr class="separator:a30ea64c76269be7f2a876b88c7837ba5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a06c48a98b7317d7375f0190fe4f861ca"><td class="memTemplParams" colspan="2"><a id="a06c48a98b7317d7375f0190fe4f861ca"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a06c48a98b7317d7375f0190fe4f861ca"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_isend</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, size_t count, int dst, int base_tag, raft::comms::request_t *requests)</td></tr>
<tr class="separator:a06c48a98b7317d7375f0190fe4f861ca"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2b7d76242239891871bd5e1461e13ee9"><td class="memTemplParams" colspan="2"><a id="a2b7d76242239891871bd5e1461e13ee9"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a2b7d76242239891871bd5e1461e13ee9"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_isend</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, size_t count, int dst, int base_tag, raft::comms::request_t *requests)</td></tr>
<tr class="separator:a2b7d76242239891871bd5e1461e13ee9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2b2a12b5b218c4ddbbd7cc4f1fcde8ea"><td class="memTemplParams" colspan="2"><a id="a2b2a12b5b218c4ddbbd7cc4f1fcde8ea"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a2b2a12b5b218c4ddbbd7cc4f1fcde8ea"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_irecv</b> (raft::comms::comms_t const &amp;comm, OutputIterator output_first, size_t count, int src, int base_tag, raft::comms::request_t *requests)</td></tr>
<tr class="separator:a2b2a12b5b218c4ddbbd7cc4f1fcde8ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab9978489019f39f07a03d4a72fc85d8f"><td class="memTemplParams" colspan="2"><a id="ab9978489019f39f07a03d4a72fc85d8f"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ab9978489019f39f07a03d4a72fc85d8f"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_irecv</b> (raft::comms::comms_t const &amp;comm, OutputIterator output_first, size_t count, int src, int base_tag, raft::comms::request_t *requests)</td></tr>
<tr class="separator:ab9978489019f39f07a03d4a72fc85d8f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a113dd69ee5e242d868deae18828ac2af"><td class="memTemplParams" colspan="2"><a id="a113dd69ee5e242d868deae18828ac2af"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a113dd69ee5e242d868deae18828ac2af"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_sendrecv</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, size_t tx_count, int dst, OutputIterator output_first, size_t rx_count, int src, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a113dd69ee5e242d868deae18828ac2af"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac8612f3fc1e541498b0b6f9f3a80a587"><td class="memTemplParams" colspan="2"><a id="ac8612f3fc1e541498b0b6f9f3a80a587"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ac8612f3fc1e541498b0b6f9f3a80a587"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_sendrecv</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, size_t tx_count, int dst, OutputIterator output_first, size_t rx_count, int src, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:ac8612f3fc1e541498b0b6f9f3a80a587"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad5ea5e0ce6984d6ef550fcbbce8ad0bb"><td class="memTemplParams" colspan="2"><a id="ad5ea5e0ce6984d6ef550fcbbce8ad0bb"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ad5ea5e0ce6984d6ef550fcbbce8ad0bb"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_multicast_sendrecv</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, std::vector&lt; size_t &gt; const &amp;tx_counts, std::vector&lt; size_t &gt; const &amp;tx_offsets, std::vector&lt; int &gt; const &amp;tx_dst_ranks, OutputIterator output_first, std::vector&lt; size_t &gt; const &amp;rx_counts, std::vector&lt; size_t &gt; const &amp;rx_offsets, std::vector&lt; int &gt; const &amp;rx_src_ranks, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:ad5ea5e0ce6984d6ef550fcbbce8ad0bb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8d14035734c867e5c86b5017ada1f9f9"><td class="memTemplParams" colspan="2"><a id="a8d14035734c867e5c86b5017ada1f9f9"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a8d14035734c867e5c86b5017ada1f9f9"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_multicast_sendrecv</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, std::vector&lt; size_t &gt; const &amp;tx_counts, std::vector&lt; size_t &gt; const &amp;tx_offsets, std::vector&lt; int &gt; const &amp;tx_dst_ranks, OutputIterator output_first, std::vector&lt; size_t &gt; const &amp;rx_counts, std::vector&lt; size_t &gt; const &amp;rx_offsets, std::vector&lt; int &gt; const &amp;rx_src_ranks, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a8d14035734c867e5c86b5017ada1f9f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a57e5f20cb9df64b1f9728050127ba20e"><td class="memTemplParams" colspan="2"><a id="a57e5f20cb9df64b1f9728050127ba20e"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a57e5f20cb9df64b1f9728050127ba20e"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_bcast</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, size_t count, int root, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a57e5f20cb9df64b1f9728050127ba20e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a92b9f40dc53a1d9c03324c878e7742e2"><td class="memTemplParams" colspan="2"><a id="a92b9f40dc53a1d9c03324c878e7742e2"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a92b9f40dc53a1d9c03324c878e7742e2"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_bcast</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, size_t count, int root, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a92b9f40dc53a1d9c03324c878e7742e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3d2f5cfc56bacb92cb143f28cc31ce3e"><td class="memTemplParams" colspan="2"><a id="a3d2f5cfc56bacb92cb143f28cc31ce3e"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a3d2f5cfc56bacb92cb143f28cc31ce3e"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_allreduce</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, size_t count, raft::comms::op_t op, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a3d2f5cfc56bacb92cb143f28cc31ce3e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abf0127b8d49b3d1a7c0aefdb812a9ded"><td class="memTemplParams" colspan="2"><a id="abf0127b8d49b3d1a7c0aefdb812a9ded"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:abf0127b8d49b3d1a7c0aefdb812a9ded"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_allreduce</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, size_t count, raft::comms::op_t op, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:abf0127b8d49b3d1a7c0aefdb812a9ded"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0c6644d3c741c5eddd06e901aee8855f"><td class="memTemplParams" colspan="2"><a id="a0c6644d3c741c5eddd06e901aee8855f"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a0c6644d3c741c5eddd06e901aee8855f"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_reduce</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, size_t count, raft::comms::op_t op, int root, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a0c6644d3c741c5eddd06e901aee8855f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a39e349e5a6434d499681b3fa9f28e1a1"><td class="memTemplParams" colspan="2"><a id="a39e349e5a6434d499681b3fa9f28e1a1"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a39e349e5a6434d499681b3fa9f28e1a1"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_reduce</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, size_t count, raft::comms::op_t op, int root, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a39e349e5a6434d499681b3fa9f28e1a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7e6c8fe8833363aee4902bcad5bfa8bb"><td class="memTemplParams" colspan="2"><a id="a7e6c8fe8833363aee4902bcad5bfa8bb"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a7e6c8fe8833363aee4902bcad5bfa8bb"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_allgatherv</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, std::vector&lt; size_t &gt; const &amp;recvcounts, std::vector&lt; size_t &gt; const &amp;displacements, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a7e6c8fe8833363aee4902bcad5bfa8bb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2913eb807560db6264c7db71dd6f8db0"><td class="memTemplParams" colspan="2"><a id="a2913eb807560db6264c7db71dd6f8db0"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a2913eb807560db6264c7db71dd6f8db0"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_allgatherv</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, std::vector&lt; size_t &gt; const &amp;recvcounts, std::vector&lt; size_t &gt; const &amp;displacements, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a2913eb807560db6264c7db71dd6f8db0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a220104859a74b5010358d0ce1338f802"><td class="memTemplParams" colspan="2"><a id="a220104859a74b5010358d0ce1338f802"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a220104859a74b5010358d0ce1338f802"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_gatherv</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, size_t sendcount, std::vector&lt; size_t &gt; const &amp;recvcounts, std::vector&lt; size_t &gt; const &amp;displacements, int root, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a220104859a74b5010358d0ce1338f802"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae62c589cfe65b1269d01cd883829863f"><td class="memTemplParams" colspan="2"><a id="ae62c589cfe65b1269d01cd883829863f"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ae62c589cfe65b1269d01cd883829863f"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">is_thrust_tuple_of_arithmetic</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structcugraph_1_1is__thrust__tuple.html">is_thrust_tuple</a>&lt; typename std::iterator_traits&lt; OutputIterator &gt;::value_type &gt;::value, void &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>device_gatherv</b> (raft::comms::comms_t const &amp;comm, InputIterator input_first, OutputIterator output_first, size_t sendcount, std::vector&lt; size_t &gt; const &amp;recvcounts, std::vector&lt; size_t &gt; const &amp;displacements, int root, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:ae62c589cfe65b1269d01cd883829863f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3b38717807a64d8f209a18e8e0055c65"><td class="memTemplParams" colspan="2"><a id="a3b38717807a64d8f209a18e8e0055c65"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b38717807a64d8f209a18e8e0055c65"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_allreduce</b> (raft::comms::comms_t const &amp;comm, T input, raft::comms::op_t op, cudaStream_t stream)</td></tr>
<tr class="separator:a3b38717807a64d8f209a18e8e0055c65"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a20289b62828dfa5a774523f9618c9858"><td class="memTemplParams" colspan="2"><a id="a20289b62828dfa5a774523f9618c9858"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20289b62828dfa5a774523f9618c9858"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">cugraph::is_thrust_tuple_of_arithmetic</a>&lt; T &gt;::value, T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_allreduce</b> (raft::comms::comms_t const &amp;comm, T input, raft::comms::op_t op, cudaStream_t stream)</td></tr>
<tr class="separator:a20289b62828dfa5a774523f9618c9858"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a243c766e3a4984a4fed689133ec7b1aa"><td class="memTemplParams" colspan="2"><a id="a243c766e3a4984a4fed689133ec7b1aa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a243c766e3a4984a4fed689133ec7b1aa"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_reduce</b> (raft::comms::comms_t const &amp;comm, T input, raft::comms::op_t op, int root, cudaStream_t stream)</td></tr>
<tr class="separator:a243c766e3a4984a4fed689133ec7b1aa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a279103f963161664494eee415513730f"><td class="memTemplParams" colspan="2"><a id="a279103f963161664494eee415513730f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a279103f963161664494eee415513730f"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">cugraph::is_thrust_tuple_of_arithmetic</a>&lt; T &gt;::value, T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_reduce</b> (raft::comms::comms_t const &amp;comm, T input, raft::comms::op_t op, int root, cudaStream_t stream)</td></tr>
<tr class="separator:a279103f963161664494eee415513730f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0ccf93a32a731a3360e84ffe4a48692a"><td class="memTemplParams" colspan="2"><a id="a0ccf93a32a731a3360e84ffe4a48692a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ccf93a32a731a3360e84ffe4a48692a"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_bcast</b> (raft::comms::comms_t const &amp;comm, T input, int root, cudaStream_t stream)</td></tr>
<tr class="separator:a0ccf93a32a731a3360e84ffe4a48692a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adf704c7c00bc29884c1e37dc216fbde9"><td class="memTemplParams" colspan="2"><a id="adf704c7c00bc29884c1e37dc216fbde9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf704c7c00bc29884c1e37dc216fbde9"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">cugraph::is_thrust_tuple_of_arithmetic</a>&lt; T &gt;::value, T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_bcast</b> (raft::comms::comms_t const &amp;comm, T input, int root, cudaStream_t stream)</td></tr>
<tr class="separator:adf704c7c00bc29884c1e37dc216fbde9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abbc520d28f3dd9136dd703405c0460bd"><td class="memTemplParams" colspan="2"><a id="abbc520d28f3dd9136dd703405c0460bd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbc520d28f3dd9136dd703405c0460bd"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, std::vector&lt; T &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_allgather</b> (raft::comms::comms_t const &amp;comm, T input, cudaStream_t stream)</td></tr>
<tr class="separator:abbc520d28f3dd9136dd703405c0460bd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afc11f724ed45469687b10ed9ebf91cb1"><td class="memTemplParams" colspan="2"><a id="afc11f724ed45469687b10ed9ebf91cb1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc11f724ed45469687b10ed9ebf91cb1"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">cugraph::is_thrust_tuple_of_arithmetic</a>&lt; T &gt;::value, std::vector&lt; T &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_allgather</b> (raft::comms::comms_t const &amp;comm, T input, cudaStream_t stream)</td></tr>
<tr class="separator:afc11f724ed45469687b10ed9ebf91cb1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a446ec3f5aab4615c499f5639b108d05e"><td class="memTemplParams" colspan="2"><a id="a446ec3f5aab4615c499f5639b108d05e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a446ec3f5aab4615c499f5639b108d05e"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, std::vector&lt; T &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_gather</b> (raft::comms::comms_t const &amp;comm, T input, int root, cudaStream_t stream)</td></tr>
<tr class="separator:a446ec3f5aab4615c499f5639b108d05e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9023bc6e7301fd706b0b74d9cf642332"><td class="memTemplParams" colspan="2"><a id="a9023bc6e7301fd706b0b74d9cf642332"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9023bc6e7301fd706b0b74d9cf642332"><td align="right" class="memTemplItemLeft" valign="top">std::enable_if_t&lt; <a class="el" href="structcugraph_1_1is__thrust__tuple__of__arithmetic.html">cugraph::is_thrust_tuple_of_arithmetic</a>&lt; T &gt;::value, std::vector&lt; T &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>host_scalar_gather</b> (raft::comms::comms_t const &amp;comm, T input, int root, cudaStream_t stream)</td></tr>
<tr class="separator:a9023bc6e7301fd706b0b74d9cf642332"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab0b65e67810f6aa299409971ccabe1af"><td class="memTemplParams" colspan="2"><a id="ab0b65e67810f6aa299409971ccabe1af"></a>
template&lt;typename ValueIterator , typename ValueToGPUIdOp &gt; </td></tr>
<tr class="memitem:ab0b65e67810f6aa299409971ccabe1af"><td align="right" class="memTemplItemLeft" valign="top">rmm::device_uvector&lt; size_t &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>groupby_and_count</b> (ValueIterator tx_value_first, ValueIterator tx_value_last, ValueToGPUIdOp value_to_group_id_op, int num_groups, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:ab0b65e67810f6aa299409971ccabe1af"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a292a04115d522f93f86c9613748b3740"><td class="memTemplParams" colspan="2"><a id="a292a04115d522f93f86c9613748b3740"></a>
template&lt;typename VertexIterator , typename ValueIterator , typename KeyToGPUIdOp &gt; </td></tr>
<tr class="memitem:a292a04115d522f93f86c9613748b3740"><td align="right" class="memTemplItemLeft" valign="top">rmm::device_uvector&lt; size_t &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>groupby_and_count</b> (VertexIterator tx_key_first, VertexIterator tx_key_last, ValueIterator tx_value_first, KeyToGPUIdOp key_to_group_id_op, int num_groups, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a292a04115d522f93f86c9613748b3740"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6e3c14a1a95d309bd59b553ee781f641"><td class="memTemplParams" colspan="2"><a id="a6e3c14a1a95d309bd59b553ee781f641"></a>
template&lt;typename TxValueIterator &gt; </td></tr>
<tr class="memitem:a6e3c14a1a95d309bd59b553ee781f641"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>shuffle_values</b> (raft::comms::comms_t const &amp;comm, TxValueIterator tx_value_first, std::vector&lt; size_t &gt; const &amp;tx_value_counts, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a6e3c14a1a95d309bd59b553ee781f641"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a63cb1fa6dd800e774c6860fb9a0a5970"><td class="memTemplParams" colspan="2"><a id="a63cb1fa6dd800e774c6860fb9a0a5970"></a>
template&lt;typename ValueIterator , typename ValueToGPUIdOp &gt; </td></tr>
<tr class="memitem:a63cb1fa6dd800e774c6860fb9a0a5970"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>groupby_gpuid_and_shuffle_values</b> (raft::comms::comms_t const &amp;comm, ValueIterator tx_value_first, ValueIterator tx_value_last, ValueToGPUIdOp value_to_gpu_id_op, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:a63cb1fa6dd800e774c6860fb9a0a5970"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afd496a6d804bc869b9fe070b9b7acf8f"><td class="memTemplParams" colspan="2"><a id="afd496a6d804bc869b9fe070b9b7acf8f"></a>
template&lt;typename VertexIterator , typename ValueIterator , typename KeyToGPUIdOp &gt; </td></tr>
<tr class="memitem:afd496a6d804bc869b9fe070b9b7acf8f"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>groupby_gpuid_and_shuffle_kv_pairs</b> (raft::comms::comms_t const &amp;comm, VertexIterator tx_key_first, VertexIterator tx_key_last, ValueIterator tx_value_first, KeyToGPUIdOp key_to_gpu_id_op, rmm::cuda_stream_view stream_view)</td></tr>
<tr class="separator:afd496a6d804bc869b9fe070b9b7acf8f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4d3a3284bd3057d7a1b9aa0ca776a409"><td class="memTemplParams" colspan="2"><a id="a4d3a3284bd3057d7a1b9aa0ca776a409"></a>
template&lt;typename TupleType &gt; </td></tr>
<tr class="memitem:a4d3a3284bd3057d7a1b9aa0ca776a409"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>thrust_tuple_to_std_tuple</b> (TupleType tup)</td></tr>
<tr class="separator:a4d3a3284bd3057d7a1b9aa0ca776a409"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac25bdab55d4ee691bfaf133ca54198e7"><td class="memTemplParams" colspan="2"><a id="ac25bdab55d4ee691bfaf133ca54198e7"></a>
template&lt;typename TupleType &gt; </td></tr>
<tr class="memitem:ac25bdab55d4ee691bfaf133ca54198e7"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>std_tuple_to_thrust_tuple</b> (TupleType tup)</td></tr>
<tr class="separator:ac25bdab55d4ee691bfaf133ca54198e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adeb3d1993597fd08242aeacaec37f581"><td class="memTemplParams" colspan="2"><a id="adeb3d1993597fd08242aeacaec37f581"></a>
template&lt;typename... TupleTypes&gt; </td></tr>
<tr class="memitem:adeb3d1993597fd08242aeacaec37f581"><td align="right" class="memTemplItemLeft" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>thrust_tuple_cat</b> (TupleTypes... tups)</td></tr>
<tr class="separator:adeb3d1993597fd08242aeacaec37f581"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Katz Centrality implementation. </p>
<p>Set of classes abstracting the type-erasure, templates, and template constraints to client code that must supply run-time type information (RTTI) and has no template constructs.</p>
<p>Set of type-erased wrappers, following the (almost) universal general signature: graph_envelope reference; erased_pack_t pack of erased arguments, that the caller is responsible to set correctly (FIXME: handshake protocol must be put in place); return set;.</p>
<p>Wrapper functions for MST.</p>
<p>Functions for computing the two hop neighbor pairs of a graph.</p>
<p>The cugraph Jaccard core functionality.</p>
<p>Wrapper functions for Spectral Clustering.</p>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md1"></a>
@file katz_centrality.cu</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md3"></a>
@file spectral_clustering.cu</h2>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md4"></a>
@brief wrapper calling gunrock's HITS analytic</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md5"></a>
@file jaccard.cu</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md6"></a>
@file jaccard.cu</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md8"></a>
@file two_hop_neighbors.cu</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md10"></a>
@file mst.cu</h2>
<pre class="fragment">Goal: be able to call an algorithm (say. louvain() on a type erased graph created from RTTI:
</pre><p> { auto graph = make_graph(flags...); auto res = louvain(graph, params...); } params will be also type-erased (or same type regardless of graph-type); and will be appropriately passed to the Factory and then converted and passed to Visitor constructor </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a365647c6c8b681e9af24661537ee6e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365647c6c8b681e9af24661537ee6e27">&nbsp;</a></span>cugraph_cc_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph::cugraph_cc_t</a></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a365647c6c8b681e9af24661537ee6e27a5882369885616cc6ba190202b140ee02"></a>CUGRAPH_STRONG&nbsp;</td><td class="fielddoc"><blockquote class="doxtable">
<p>Weakly Connected Components </p>
</blockquote>
</td></tr>
<tr><td class="fieldname"><a id="a365647c6c8b681e9af24661537ee6e27a436bdad1238dd6b8309bdbd0150c0e65"></a>NUM_CONNECTIVITY_TYPES&nbsp;</td><td class="fielddoc"><blockquote class="doxtable">
<p>Strongly Connected Components </p>
</blockquote>
</td></tr>
</tbody></table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7e9a199ea9d7c11038c43641f88e8a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9a199ea9d7c11038c43641f88e8a58">&nbsp;</a></span>betweenness_centrality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::betweenness_centrality </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t *&nbsp;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>normalized</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>endpoints</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t const *&nbsp;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>vertices</em> = <code>nullptr</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute betweenness centrality for a graph. </p>
<p>Betweenness centrality for a vertex is the sum of the fraction of all pairs shortest paths that pass through the vertex.</p>
<p>The current implementation does not support a weighted graph.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>if <code>result == nullptr</code> or <code>number_of_sources &lt; 0</code> or <code>number_of_sources !=0 and sources == nullptr</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double. </td></tr>
    <tr><td class="paramname">result_t</td><td>Type of computed result. Supported values : float or double </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a CSR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device array of centrality scores </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalized</td><td>If true, return normalized scores, if false return unnormalized scores. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoints</td><td>If true, include endpoints of paths in score, if false do not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>If specified, device array of weights for each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>If specified, number of vertex samples defined in the vertices array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>If specified, host array of vertex ids to estimate betweenness these vertices will serve as sources for the traversal algorihtm to obtain shortest path counters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">total_number_of_source_used</td><td>If specified use this number to normalize results when using subsampling, it allows accumulation of results across multiple calls. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a49a08cae7fb4bf2791c7dbb5e1438c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a08cae7fb4bf2791c7dbb5e1438c8a">&nbsp;</a></span>bfs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::bfs </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_sources</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>direction_optimizing</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>depth_limit</em> = <code>std::numeric_limits&lt;&nbsp;vertex_t&nbsp;&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Run breadth-first search to find the distances (and predecessors) from the source vertex. </p>
<p>This function computes the distances (minimum number of hops to reach the vertex) from the source vertex. If <code>predecessors</code> is not <code>nullptr</code>, this function calculates the predecessor of each vertex (parent vertex in the breadth-first search tree) as well.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>on erroneous input arguments.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object. </td></tr>
    <tr><td class="paramname">distances</td><td>Pointer to the output distance array. </td></tr>
    <tr><td class="paramname">predecessors</td><td>Pointer to the output predecessor array or <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">sources</td><td>Source vertices to start breadth-first search (root vertex of the breath-first search tree). If more than one source is passed, there must be a single source per component. In a multi-gpu context the source vertices should be local to this GPU. </td></tr>
    <tr><td class="paramname">n_sources</td><td>number of sources (one source per component at most). </td></tr>
    <tr><td class="paramname">direction_optimizing</td><td>If set to true, this algorithm switches between the push based breadth-first search and pull based breadth-first search depending on the size of the breadth-first search frontier (currently unsupported). This option is valid only for symmetric input graphs. </td></tr>
    <tr><td class="paramname">depth_limit</td><td>Sets the maximum number of breadth-first search iterations. Any vertices farther than <code>depth_limit</code> hops from <code>source_vertex</code> will be marked as unreachable. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a3152bc145253db9d0ed6a44a33a1c2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3152bc145253db9d0ed6a44a33a1c2bc">&nbsp;</a></span>bfs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::bfs </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT *&nbsp;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT *&nbsp;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>sp_counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VT&nbsp;</td>
          <td class="paramname"><em>start_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>mg_batch</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>@Synopsis Performs a breadth first search traversal of a graph starting from a vertex.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : int (signed, 32-bit)</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>If set to a valid pointer, this is populated by distance of every vertex in the graph from the starting vertex</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">predecessors</td><td>If set to a valid pointer, this is populated by bfs traversal predecessor of every vertex</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sp_counters</td><td>If set to a valid pointer, this is populated by bfs traversal shortest_path counter of every vertex</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_vertex</td><td>The starting vertex for breadth first search traversal</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">directed</td><td>Treat the input graph as directed</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mg_batch</td><td>If set to true use SG BFS path when comms are initialized. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a815d2c249f061119aa65678ca2ba70ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815d2c249f061119aa65678ca2ba70ea">&nbsp;</a></span>coarsen_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool store_transposed, bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu &gt; &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::coarsen_graph </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute the coarsened graph. </p>
<p>Aggregates the vertices with the same label to a new vertex in the output coarsened graph. Multi-edges in the coarsened graph are collapsed to a single edge with its weight equal to the sum of multi-edge weights.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">store_transposed</td><td>Flag indicating whether to store the graph adjacency matrix as is or as transposed. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object of the input graph to be coarsened. </td></tr>
    <tr><td class="paramname">labels</td><td>Vertex labels (assigned to this process in multi-GPU) to be used in coarsening. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;std::unique_ptr&lt;<a class="el" href="classcugraph_1_1graph__t.html">graph_t</a>&lt;vertex_t, edge_t, weight_t, store_transposed, multi_gpu&gt;&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; Tuple of the coarsened graph and labels mapped to the vertices (assigned to this process in multi-GPU) in the coarsened graph. </dd></dl>

</div>
</div>
<a id="a7d0bbe5af0b12a11b5c8aba2fb9826df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0bbe5af0b12a11b5c8aba2fb9826df">&nbsp;</a></span>combine_edgelists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt; cugraph::combine_edgelists </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>d_sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>d_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::vector&lt; rmm::device_uvector&lt; weight_t &gt;&gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>optional_d_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>remove_multi_edges</em> = <code>true</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Combine edgelists from multiple sources into a single edgelist. </p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will operate only on its subset of data. Any shuffling to get edges onto the same GPU should be done prior to calling this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">sources</td><td>The source vertex ids to combine </td></tr>
    <tr><td class="paramname">dests</td><td>The destination vertex ids to combine </td></tr>
    <tr><td class="paramname">weights</td><td>Optional vector of weights to combine </td></tr>
    <tr><td class="paramname">remove_multi_edges</td><td>If true (the default) then remove multi edges, if false leave them in </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;weight_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs and edge weights. </dd></dl>

</div>
</div>
<a id="a3ea68fa26fc144e25e2bb392903c4ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea68fa26fc144e25e2bb392903c4ec4">&nbsp;</a></span>comms_bcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::comms_bcast </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t *&nbsp;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>count</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Broadcast using handle communicator. </p>
<p>Use handle's communicator to operate broadcasting.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">value_t</td><td>Type of the data to broadcast</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Point to the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to broadcast </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a5d2693f86441fd77a28bacadc7687a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2693f86441fd77a28bacadc7687a91">&nbsp;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::connected_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a>&nbsp;</td>
          <td class="paramname"><em>connectivity_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT *&nbsp;</td>
          <td class="paramname"><em>labels</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute connected components. </p>
<p>The weak version (for undirected graphs, only) was imported from cuML. This implementation comes from [1] and solves component labeling problem in parallel on CSR-indexes based upon the vertex degree and adjacency graph.</p>
<p>[1] Hawick, K.A et al, 2010. "Parallel graph component labelling with GPUs and CUDA"</p>
<p>The strong version (for directed or undirected graphs) is based on: [2] Gilbert, J. et al, 2011. "Graph Algorithms in the Language of Linear Algebra"</p>
<p>C = I | A | A^2 |...| A^k where matrix multiplication is via semi-ring: (combine, reduce) == (&amp;, |) (bitwise ops) Then: X = C &amp; transpose(C); and finally, apply get_labels(X);</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectivity_type</td><td>STRONG or WEAK </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">labels</td><td>Device array of component labels (labels[i] indicates the label associated with vertex id i. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a6ce3d1cb61f337889ab06773e3234a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce3d1cb61f337889ab06773e3234a7c">&nbsp;</a></span>convert_paths_to_coo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename index_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; index_t &gt; &gt; cugraph::convert_paths_to_coo </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&nbsp;</td>
          <td class="paramname"><em>coalesced_sz_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&nbsp;</td>
          <td class="paramname"><em>num_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_buffer &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>d_coalesced_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_buffer &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>d_sizes</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>returns the COO format (src_vector, dst_vector) from the random walks (RW) paths. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex indices. </td></tr>
    <tr><td class="paramname">index_t</td><td>Type used to store indexing and sizes. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">coalesced_sz_v</td><td>coalesced vertex vector size. </td></tr>
    <tr><td class="paramname">num_paths</td><td>number of paths. </td></tr>
    <tr><td class="paramname">d_coalesced_v</td><td>coalesced vertex buffer. </td></tr>
    <tr><td class="paramname">d_sizes</td><td>paths size buffer. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple of (src_vertex_vector, dst_Vertex_vector, path_offsets), where path_offsets are the offsets where the COO set of each path starts. </dd></dl>

</div>
</div>
<a id="a0e4e7507413b75cac2580707c1ad8e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4e7507413b75cac2580707c1ad8e04">&nbsp;</a></span>coo_to_csr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCSR.html">legacy::GraphCSR</a>&lt; VT, ET, WT &gt; &gt; cugraph::coo_to_csr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Convert COO to CSR. </p>
<p>Takes a list of edges in COOrdinate format and generates a CSR format.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>type of vertex index </td></tr>
    <tr><td class="paramname">ET</td><td>type of edge index </td></tr>
    <tr><td class="paramname">WT</td><td>type of the edge weight</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph in coordinate format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to generate Compressed Sparse Row graph </dd></dl>

</div>
</div>
<a id="a19bb40d654a65d9941810d4c2a920c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bb40d654a65d9941810d4c2a920c55">&nbsp;</a></span>copy_to_adj_matrix_col() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename VertexIterator , typename VertexValueInputIterator &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::copy_to_adj_matrix_col </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>vertex_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>vertex_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueInputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1col__properties__t.html">col_properties_t</a>&lt; GraphViewType, typename std::iterator_traits&lt; VertexValueInputIterator &gt;::value_type &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_output</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copy vertex property values to the corresponding graph adjacency matrix column property variables. </p>
<p>This version fills only a subset of graph adjacency matrix column property values. [<code>vertex_first</code>, <code>vertex_last</code>) specifies the vertices with new values to be copied to graph adjacency matrix column property variables.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">VertexIterator</td><td>Type of the iterator for vertex identifiers. </td></tr>
    <tr><td class="paramname">VertexValueInputIterator</td><td>Type of the iterator for vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">vertex_first</td><td>Iterator pointing to the first (inclusive) vertex with new values to be copied. v in [vertex_first, vertex_last) should be distinct (and should belong to this process in multi-GPU), otherwise undefined behavior </td></tr>
    <tr><td class="paramname">vertex_last</td><td>Iterator pointing to the last (exclusive) vertex with new values to be copied. </td></tr>
    <tr><td class="paramname">vertex_value_input_first</td><td>Iterator pointing to the vertex properties for the first (inclusive) vertex (assigned to this process in multi-GPU). <code>vertex_value_input_last</code> (exclusive) is deduced as <code>vertex_value_input_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_output</td><td>Wrapper used to access data storage to copy column properties (for the columns assigned to this process in multi-GPU). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a70fb6fb7f9e128c20c21ebaac26a5b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fb6fb7f9e128c20c21ebaac26a5b1e">&nbsp;</a></span>copy_to_adj_matrix_col() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename VertexValueInputIterator &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::copy_to_adj_matrix_col </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueInputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1col__properties__t.html">col_properties_t</a>&lt; GraphViewType, typename std::iterator_traits&lt; VertexValueInputIterator &gt;::value_type &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_output</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copy vertex property values to the corresponding graph adjacency matrix column property variables. </p>
<p>This version fills the entire set of graph adjacency matrix column property values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">VertexValueInputIterator</td><td>Type of the iterator for vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">vertex_value_input_first</td><td>Iterator pointing to the vertex properties for the first (inclusive) vertex (assigned to this process in multi-GPU). <code>vertex_value_input_last</code> (exclusive) is deduced as <code>vertex_value_input_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_output</td><td>Wrapper used to access data storage to copy column properties (for the columns assigned to this process in multi-GPU). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="afe0fc3924325baf54a603910516ba6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0fc3924325baf54a603910516ba6a6">&nbsp;</a></span>copy_to_adj_matrix_row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename VertexIterator , typename VertexValueInputIterator &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::copy_to_adj_matrix_row </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>vertex_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>vertex_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueInputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1row__properties__t.html">row_properties_t</a>&lt; GraphViewType, typename std::iterator_traits&lt; VertexValueInputIterator &gt;::value_type &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_output</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copy vertex property values to the corresponding graph adjacency matrix row property variables. </p>
<p>This version fills only a subset of graph adjacency matrix row property values. [<code>vertex_first</code>, <code>vertex_last</code>) specifies the vertices with new values to be copied to graph adjacency matrix row property variables.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">VertexIterator</td><td>Type of the iterator for vertex identifiers. </td></tr>
    <tr><td class="paramname">VertexValueInputIterator</td><td>Type of the iterator for vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">vertex_first</td><td>Iterator pointing to the first (inclusive) vertex with new values to be copied. v in [vertex_first, vertex_last) should be distinct (and should belong to this process in multi-GPU), otherwise undefined behavior </td></tr>
    <tr><td class="paramname">vertex_last</td><td>Iterator pointing to the last (exclusive) vertex with new values to be copied. </td></tr>
    <tr><td class="paramname">vertex_value_input_first</td><td>Iterator pointing to the vertex properties for the first (inclusive) vertex (assigned to this process in multi-GPU). <code>vertex_value_input_last</code> (exclusive) is deduced as <code>vertex_value_input_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_output</td><td>Wrapper used to access data storage to copy row properties (for the rows assigned to this process in multi-GPU). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a80cff02d99194b9dd3a9d5a5dead4693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cff02d99194b9dd3a9d5a5dead4693">&nbsp;</a></span>copy_to_adj_matrix_row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename VertexValueInputIterator &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::copy_to_adj_matrix_row </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueInputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1row__properties__t.html">row_properties_t</a>&lt; GraphViewType, typename std::iterator_traits&lt; VertexValueInputIterator &gt;::value_type &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_output</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copy vertex property values to the corresponding graph adjacency matrix row property variables. </p>
<p>This version fills the entire set of graph adjacency matrix row property values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">VertexValueInputIterator</td><td>Type of the iterator for vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">vertex_value_input_first</td><td>Iterator pointing to the vertex properties for the first (inclusive) vertex (assigned to this process in multi-GPU). <code>vertex_value_input_last</code> (exclusive) is deduced as <code>vertex_value_input_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_output</td><td>Wrapper used to access data storage to copy row properties (for the rows assigned to this process in multi-GPU). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="aa4a52730884b78287f89852451df911e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a52730884b78287f89852451df911e">&nbsp;</a></span>copy_v_transform_reduce_in_nbr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp , typename T , typename VertexValueOutputIterator &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::copy_v_transform_reduce_in_nbr </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOp&nbsp;</td>
          <td class="paramname"><em>e_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueOutputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_output_first</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Iterate over the incoming edges to update vertex properties. </p>
<p>This function is inspired by thrust::transfrom_reduce() (iteration over the incoming edges part) and thrust::copy() (update vertex properties part, take transform_reduce output as copy input).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column input properties. </td></tr>
    <tr><td class="paramname">EdgeOp</td><td>Type of the quaternary (or quinary) edge operator. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the initial value for reduction over the incoming edges. </td></tr>
    <tr><td class="paramname">VertexValueOutputIterator</td><td>Type of the iterator for vertex output property variables. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_input</td><td>Device-copyable wrapper used to access column input properties (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view() (if <code>e_op</code> needs to access column properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access column properties). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">e_op</td><td>Quaternary (or quinary) operator takes edge source, edge destination, (optional edge weight), properties for the row (i.e. source), and properties for the column (i.e. destination) and returns a value to be reduced. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the reduced <code>e_op</code> return values for each vertex. </td></tr>
    <tr><td class="paramname">vertex_value_output_first</td><td>Iterator pointing to the vertex property variables for the first (inclusive) vertex (assigned to tihs process in multi-GPU). <code>vertex_value_output_last</code> (exclusive) is deduced as <code>vertex_value_output_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a1d7595004cf3024f60a8fe6c3b9eae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7595004cf3024f60a8fe6c3b9eae89">&nbsp;</a></span>copy_v_transform_reduce_key_aggregated_out_nbr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColKeyInputWrapper , typename VertexIterator , typename ValueIterator , typename KeyAggregatedEdgeOp , typename ReduceOp , typename T , typename VertexValueOutputIterator &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::copy_v_transform_reduce_key_aggregated_out_nbr </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColKeyInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_key_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>map_unique_key_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexIterator&nbsp;</td>
          <td class="paramname"><em>map_unique_key_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueIterator&nbsp;</td>
          <td class="paramname"><em>map_value_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyAggregatedEdgeOp&nbsp;</td>
          <td class="paramname"><em>key_aggregated_e_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOp&nbsp;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueOutputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_output_first</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Iterate over every vertex's key-aggregated outgoing edges to update vertex properties. </p>
<p>This function is inspired by thrust::transfrom_reduce() (iteration over the outgoing edges part) and thrust::copy() (update vertex properties part, take transform_reduce output as copy input). Unlike copy_v_transform_reduce_out_nbr, this function first aggregates outgoing edges by key to support two level reduction for every vertex.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColKeyInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column keys. </td></tr>
    <tr><td class="paramname">VertexIterator</td><td>Type of the iterator for graph adjacency matrix column key values for aggregation (key type should coincide with vertex type). </td></tr>
    <tr><td class="paramname">ValueIterator</td><td>Type of the iterator for values in (key, value) pairs. </td></tr>
    <tr><td class="paramname">KeyAggregatedEdgeOp</td><td>Type of the quinary key-aggregated edge operator. </td></tr>
    <tr><td class="paramname">ReduceOp</td><td>Type of the binary reduction operator. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the initial value for reduction over the key-aggregated outgoing edges. </td></tr>
    <tr><td class="paramname">VertexValueOutputIterator</td><td>Type of the iterator for vertex output property variables. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_key_input</td><td>Device-copyable wrapper used to access column keys (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view(). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">map_unique_key_first</td><td>Iterator pointing to the first (inclusive) key in (key, value) pairs (assigned to this process in multi-GPU, <code><a class="el" href="structcugraph_1_1detail_1_1compute__gpu__id__from__vertex__t.html">cugraph::detail::compute_gpu_id_from_vertex_t</a></code> is used to map keys to processes). (Key, value) pairs may be provided by <a class="el" href="namespacecugraph.html#ada05e18661d1011f3a255fdeffa39479" title="Iterate over the entire set of edges and reduce edge_op outputs to (key, value) pairs.">transform_reduce_by_adj_matrix_row_key_e()</a> or <a class="el" href="namespacecugraph.html#aaf698d4569a93c1c25213f924354d0a8" title="Iterate over the entire set of edges and reduce edge_op outputs to (key, value) pairs.">transform_reduce_by_adj_matrix_col_key_e()</a>. </td></tr>
    <tr><td class="paramname">map_unique_key_last</td><td>Iterator pointing to the last (exclusive) key in (key, value) pairs (assigned to this process in multi-GPU). </td></tr>
    <tr><td class="paramname">map_value_first</td><td>Iterator pointing to the first (inclusive) value in (key, value) pairs (assigned to this process in multi-GPU). <code>map_value_last</code> (exclusive) is deduced as <code>map_value_first</code> + thrust::distance(<code>map_unique_key_first</code>, <code>map_unique_key_last</code>). </td></tr>
    <tr><td class="paramname">key_aggregated_e_op</td><td>Quinary operator takes edge source, key, aggregated edge weight, *(<code>adj_matrix_row_value_input_first</code> + i), and value for the key stored in the input (key, value) pairs provided by <code>map_unique_key_first</code>, <code>map_unique_key_last</code>, and <code>map_value_first</code> (aggregated over the entire set of processes in multi-GPU). </td></tr>
    <tr><td class="paramname">reduce_op</td><td>Binary operator takes two input arguments and reduce the two variables to one. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the reduced <code>reduce_op</code> return values for each vertex. </td></tr>
    <tr><td class="paramname">vertex_value_output_first</td><td>Iterator pointing to the vertex property variables for the first (inclusive) vertex (assigned to tihs process in multi-GPU). <code>vertex_value_output_last</code> (exclusive) is deduced as <code>vertex_value_output_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="afd2f999156ec60b8b167229c2660a910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2f999156ec60b8b167229c2660a910">&nbsp;</a></span>copy_v_transform_reduce_out_nbr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp , typename T , typename VertexValueOutputIterator &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::copy_v_transform_reduce_out_nbr </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOp&nbsp;</td>
          <td class="paramname"><em>e_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueOutputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_output_first</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Iterate over the outgoing edges to update vertex properties. </p>
<p>This function is inspired by thrust::transfrom_reduce() (iteration over the outgoing edges part) and thrust::copy() (update vertex properties part, take transform_reduce output as copy input).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column input properties. </td></tr>
    <tr><td class="paramname">EdgeOp</td><td>Type of the quaternary (or quinary) edge operator. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the initial value for reduction over the outgoing edges. </td></tr>
    <tr><td class="paramname">VertexValueOutputIterator</td><td>Type of the iterator for vertex output property variables. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_input</td><td>Device-copyable wrapper used to access column input properties (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view() (if <code>e_op</code> needs to access column properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access column properties). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">e_op</td><td>Quaternary (or quinary) operator takes edge source, edge destination, (optional edge weight), properties for the row (i.e. source), and properties for the column (i.e. destination) and returns a value to be reduced. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the reduced <code>e_op</code> return values for each vertex. </td></tr>
    <tr><td class="paramname">vertex_value_output_first</td><td>Iterator pointing to the vertex property variables for the first (inclusive) vertex (assigned to tihs process in multi-GPU). <code>vertex_value_output_last</code> (exclusive) is deduced as <code>vertex_value_output_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a01fa3a11aa66f35b9ae35a67e11bcd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fa3a11aa66f35b9ae35a67e11bcd08">&nbsp;</a></span>core_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::core_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT *&nbsp;</td>
          <td class="paramname"><em>core_number</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute the Core Number for the nodes of the graph G. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor with a valid edgeList or adjList </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">core_number</td><td>Populated by the core number of every vertex in the graph</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a4ebeef531f3dc12f614ce8990ec8ad83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebeef531f3dc12f614ce8990ec8ad83">&nbsp;</a></span>core_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::core_number </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">edge_t *&nbsp;</td>
          <td class="paramname"><em>core_numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">k_core_degree_type_t&nbsp;</td>
          <td class="paramname"><em>degree_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>k_first</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>k_last</em> = <code>std::numeric_limits&lt;&nbsp;size_t&nbsp;&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute core numbers of individual vertices from K-core decomposition. </p>
<p>The input graph should not have self-loops nor multi-edges. Currently, only undirected graphs are supported.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object. </td></tr>
    <tr><td class="paramname">core_numbers</td><td>Pointer to the output core number array. </td></tr>
    <tr><td class="paramname">degree_type</td><td>Dictate whether to compute the K-core decomposition based on in-degrees, out-degrees, or in-degrees + out_degrees. </td></tr>
    <tr><td class="paramname">k_first</td><td>Find K-cores from K = k_first. Any vertices that do not belong to k_first-core will have core numbers of 0. </td></tr>
    <tr><td class="paramname">k_last</td><td>Find K-cores to K = k_last. Any vertices that belong to (k_last)-core will have their core numbers set to their degrees on k_last-core. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ac324d18256a22d04536a2b854665a8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac324d18256a22d04536a2b854665a8ff">&nbsp;</a></span>count_if_e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">GraphViewType::edge_type cugraph::count_if_e </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOp&nbsp;</td>
          <td class="paramname"><em>e_op</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Count the number of edges that satisfies the given predicate. </p>
<p>This function is inspired by thrust::count_if().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column input properties. </td></tr>
    <tr><td class="paramname">EdgeOp</td><td>Type of the quaternary (or quinary) edge operator. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_input</td><td>Device-copyable wrapper used to access column input properties (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view() (if <code>e_op</code> needs to access column properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access column properties). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">e_op</td><td>Quaternary (or quinary) operator takes edge source, edge destination, (optional edge weight), properties for the row (i.e. source), and properties for the column (i.e. destination) and returns true if this edge should be included in the returned count. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GraphViewType::edge_type Number of times <code>e_op</code> returned true. </dd></dl>

</div>
</div>
<a id="a7e723b9bf2c48c9c9572af50f9ea74f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e723b9bf2c48c9c9572af50f9ea74f5">&nbsp;</a></span>count_if_v() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename InputIterator , typename VertexOp &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">GraphViewType::vertex_type cugraph::count_if_v </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"><em>input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"><em>input_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexOp&nbsp;</td>
          <td class="paramname"><em>v_op</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Count the number of vertices that satisfies the given predicate. </p>
<p>This version (conceptually) iterates over only a subset of the graph vertices. This function actually works as thrust::count_if() on [<code>input_first</code>, <code>input_last</code>) (followed by inter-process reduction in multi-GPU). <code>input_last</code> - <code>input_first</code> (or the sum of <code>input_last</code> - <code>input_first</code> values in multi-GPU) should not overflow GraphViewType::vertex_type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Type of the iterator for input values. </td></tr>
    <tr><td class="paramname">VertexOp</td><td>VertexOp Type of the unary predicate operator. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">input_first</td><td>Iterator pointing to the beginning (inclusive) of the values to be passed to <code>v_op</code>. </td></tr>
    <tr><td class="paramname">input_last</td><td>Iterator pointing to the end (exclusive) of the values to be passed to <code>v_op</code>. </td></tr>
    <tr><td class="paramname">v_op</td><td>Unary operator takes *(<code>input_first</code> + i) (where i is [0, <code>input_last</code> - <code>input_first</code>)) and returns true if this vertex should be included in the returned count. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GraphViewType::vertex_type Number of times <code>v_op</code> returned true. </dd></dl>

</div>
</div>
<a id="abe23b1b58ab369299effd2337abac8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe23b1b58ab369299effd2337abac8b5">&nbsp;</a></span>count_if_v() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename VertexValueInputIterator , typename VertexOp &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">GraphViewType::vertex_type cugraph::count_if_v </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueInputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexOp&nbsp;</td>
          <td class="paramname"><em>v_op</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Count the number of vertices that satisfies the given predicate. </p>
<p>This version iterates over the entire set of graph vertices. This function is inspired by thrust::count_if().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">VertexValueInputIterator</td><td>Type of the iterator for vertex properties. </td></tr>
    <tr><td class="paramname">VertexOp</td><td>Type of the unary predicate operator. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">vertex_value_input_first</td><td>Iterator pointing to the vertex properties for the first (inclusive) vertex (assigned to this process in multi-GPU). <code>vertex_value_input_last</code> (exclusive) is deduced as <code>vertex_value_input_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">v_op</td><td>Unary operator takes *(<code>vertex_value_input_first</code> + i) (where i is [0, <code>graph_view.get_number_of_local_vertices()</code>)) and returns true if this vertex should be included in the returned count. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GraphViewType::vertex_type Number of times <code>v_op</code> returned true. </dd></dl>

</div>
</div>
<a id="a413a3caa38d75a30b21b4aface6c5ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413a3caa38d75a30b21b4aface6c5ba3">&nbsp;</a></span>create_graph_from_edgelist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool store_transposed, bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu &gt;, std::optional&lt; rmm::device_uvector&lt; vertex_t &gt; &gt; &gt; cugraph::create_graph_from_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; rmm::device_uvector&lt; weight_t &gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcugraph_1_1graph__properties__t.html">graph_properties_t</a>&nbsp;</td>
          <td class="paramname"><em>graph_properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>renumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>create a graph from (the optional vertex list and) the given edge list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">store_transposed</td><td>Flag indicating whether to store the graph adjacency matrix as is or as transposed. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">vertices</td><td>If valid, part of the entire set of vertices in the graph to be renumbered. This parameter can be used to include isolated vertices. If multi-GPU, applying the compute_gpu_id_from_vertex_t to every vertex should return the local GPU ID for this function to work (vertices should be pre-shuffled). </td></tr>
    <tr><td class="paramname">edgelist_rows</td><td>Vector of edge row (source) vertex IDs. If multi-GPU, applying the compute_gpu_id_from_edge_t to every edge should return the local GPU ID for this function to work (edges should be pre-shuffled). </td></tr>
    <tr><td class="paramname">edgelist_cols</td><td>Vector of edge column (destination) vertex IDs. </td></tr>
    <tr><td class="paramname">edgelist_weights</td><td>Vector of edge weights. </td></tr>
    <tr><td class="paramname">graph_properties</td><td>Properties of the graph represented by the input (optional vertex list and) edge list. </td></tr>
    <tr><td class="paramname">renumber</td><td>Flag indicating whether to renumber vertices or not. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;<a class="el" href="classcugraph_1_1graph__t.html">cugraph::graph_t</a>&lt;vertex_t, edge_t, weight_t, store_transposed, multi_gpu&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; Pair of the generated graph and the renumber map (if <code>renumber</code> is true) or std::nullopt (if <code>renumber</code> is false). </dd></dl>

</div>
</div>
<a id="aa3062d0437821f23a9b1a5b37814bfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3062d0437821f23a9b1a5b37814bfb9">&nbsp;</a></span>ecg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::ecg </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t&nbsp;</td>
          <td class="paramname"><em>min_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>ensemble_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>clustering</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Computes the ecg clustering of the given graph. </p>
<p>ECG runs truncated <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> on an ensemble of permutations of the input graph, then uses the ensemble partitions to determine weights for the input graph. The final result is found by running full <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> on the input graph using the determined weights. See <a href="https://arxiv.org/abs/1809.05578">https://arxiv.org/abs/1809.05578</a> for further information.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph_coo</td><td>input graph object (COO) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph_csr</td><td>input graph object (CSR) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_weight</td><td>The minimum weight parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ensemble_size</td><td>The ensemble size parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>A device pointer to array where the partitioning should be written </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a0a1f1874fab344455c686bcb7c086fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1f1874fab344455c686bcb7c086fbb">&nbsp;</a></span>edge_betweenness_centrality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::edge_betweenness_centrality </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t *&nbsp;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>normalized</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t const *&nbsp;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>vertices</em> = <code>nullptr</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute edge betweenness centrality for a graph. </p>
<p>Betweenness centrality of an edge is the sum of the fraction of all-pairs shortest paths that pass through this edge. The weight parameter is currenlty not supported</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>if <code>result == nullptr</code> or <code>number_of_sources &lt; 0</code> or <code>number_of_sources !=0 and sources == nullptr</code> or <code>endpoints == true</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double. </td></tr>
    <tr><td class="paramname">result_t</td><td>Type of computed result. Supported values : float or double </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device array of centrality scores </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalized</td><td>If true, return normalized scores, if false return unnormalized scores. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>If specified, device array of weights for each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>If specified, number of vertex samples defined in the vertices array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>If specified, host array of vertex ids to estimate betweenness these vertices will serve as sources for the traversal algorihtm to obtain shortest path counters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">total_number_of_source_used</td><td>If specified use this number to normalize results when using subsampling, it allows accumulation of results across multiple calls. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a9dc29cc93342ec5e630aa8ab056b4229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc29cc93342ec5e630aa8ab056b4229">&nbsp;</a></span>extract_bfs_paths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, vertex_t &gt; cugraph::extract_bfs_paths </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_destinations</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Extract paths from breadth-first search output. </p>
<p>This function extracts paths from the BFS output. BFS outputs distances and predecessors. The path from a vertex v back to the original source vertex can be extracted by recursively looking up the predecessor vertex until you arrive back at the original source vertex.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>on erroneous input arguments.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object. </td></tr>
    <tr><td class="paramname">distances</td><td>Pointer to the distance array constructed by bfs. </td></tr>
    <tr><td class="paramname">predecessors</td><td>Pointer to the predecessor array constructed by bfs. </td></tr>
    <tr><td class="paramname">destinations</td><td>Destination vertices, extract path from source to each of these destinations In a multi-gpu context the destination vertex should be local to this GPU. </td></tr>
    <tr><td class="paramname">n_destinations</td><td>number of destinations (one source per component at most).</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, vertex_t&gt; pair containing the paths as a dense matrix in the vector and the maximum path length. Unused elements in the paths * will be set to <a class="el" href="structcugraph_1_1invalid__vertex__id.html">invalid_vertex_id</a> (-1 for a signed vertex_t, std::numeric_limits&lt;vertex_t&gt;::max() for an unsigned vertex_t type). </dd></dl>

</div>
</div>
<a id="a73675c501c55f4633b34da4475c9c5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73675c501c55f4633b34da4475c9c5ed">&nbsp;</a></span>extract_ego()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt; cugraph::extract_ego </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>source_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>n_subgraphs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>radius</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>returns induced EgoNet subgraph(s) of neighbors centered at nodes in source_vertex within a given radius. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. Must have at least one worker stream. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object of, we extract induced egonet subgraphs from <code>graph_view</code>. </td></tr>
    <tr><td class="paramname">source_vertex</td><td>Pointer to egonet center vertices (size == <code>n_subgraphs</code>). </td></tr>
    <tr><td class="paramname">n_subgraphs</td><td>Number of induced EgoNet subgraphs to extract (ie. number of elements in <code>source_vertex</code>). </td></tr>
    <tr><td class="paramname">radius</td><td>Include all neighbors of distance &lt;= radius from <code>source_vertex</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;weight_t&gt;, rmm::device_uvector&lt;size_t&gt;&gt; Quadraplet of edge source vertices, edge destination vertices, edge weights, and edge offsets for each induced EgoNet subgraph. </dd></dl>

</div>
</div>
<a id="aff1311c0a4ecb5b140333976d007a0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1311c0a4ecb5b140333976d007a0e6">&nbsp;</a></span>extract_if_e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt;rmm::device_uvector&lt;typename GraphViewType::vertex_type&gt;, rmm::device_uvector&lt;typename GraphViewType::vertex_type&gt;, std::optional&lt;rmm::device_uvector&lt;typename GraphViewType::weight_type&gt; &gt; &gt; cugraph::extract_if_e </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOp&nbsp;</td>
          <td class="paramname"><em>e_op</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Iterate over the entire set of edges and return an edge list with the edges with <code>edge_op</code> evaluated to be true. </p>
<p>This function is inspired by thrust::copy_if &amp; thrust::remove_if().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column input properties. </td></tr>
    <tr><td class="paramname">EdgeOp</td><td>Type of the quaternary (or quinary) edge operator. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_input</td><td>Device-copyable wrapper used to access column input properties (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view() (if <code>e_op</code> needs to access column properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access column properties). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">e_op</td><td>Quaternary (or quinary) operator takes edge source, edge destination, (optional edge weight), properties for the row (i.e. source), and properties for the column (i.e. destination) and returns a boolean value to designate whether to include this edge in the returned edge list (if true is returned) or not (if false is returned). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;typename GraphViewType::vertex_type&gt;, rmm::device_uvector&lt;typename GraphViewType::vertex_type&gt;, std::optional&lt;rmm::device_uvector&lt;typename GraphViewType::weight_type&gt;&gt;&gt; Tuple storing an extracted edge list (sources, destinations, and optional weights). </dd></dl>

</div>
</div>
<a id="a8cbce977abb844bc1b2b64c010958c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbce977abb844bc1b2b64c010958c2a">&nbsp;</a></span>extract_induced_subgraphs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool store_transposed, bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt;, rmm::device_uvector&lt; size_t &gt; &gt; cugraph::extract_induced_subgraphs </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, store_transposed, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const *&nbsp;</td>
          <td class="paramname"><em>subgraph_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>subgraph_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>num_subgraphs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>extract induced subgraph(s). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. </td></tr>
    <tr><td class="paramname">store_transposed</td><td>Flag indicating whether to store the graph adjacency matrix as is or as transposed. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object, we extract induced subgraphs from <code>graph_view</code>. </td></tr>
    <tr><td class="paramname">subgraph_offsets</td><td>Pointer to subgraph vertex offsets (size == <code>num_subgraphs</code> + 1). </td></tr>
    <tr><td class="paramname">subgraph_vertices</td><td>Pointer to subgraph vertices (size == <code>subgraph_offsets</code>[<code>num_subgraphs</code>]). The elements of <code>subgraph_vertices</code> for each subgraph should be sorted in ascending order and unique. </td></tr>
    <tr><td class="paramname">num_subgraphs</td><td>Number of induced subgraphs to extract. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;weight_t&gt;, rmm::device_uvector&lt;size_t&gt;&gt; Quadraplet of edge major (destination if <code>store_transposed</code> is true, source otherwise) vertices, edge minor (source if <code>store_transposed</code> is true, destination otherwise) vertices, edge weights, and edge offsets for each induced subgraphs (size == num_subgraphs + 1). The sizes of the edge major &amp; minor vertices are edge_offsets[num_subgraphs]. The size of the edge weights is either edge_offsets[num_subgraphs] (if <code>graph_view</code> is weighted) or 0 (if <code>graph_view</code> is unweighted). </dd></dl>

</div>
</div>
<a id="a42db40269afe962c9edd2937ecae051d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42db40269afe962c9edd2937ecae051d">&nbsp;</a></span>flatten_dendrogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graph_view_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::flatten_dendrogram </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; typename graph_view_t::vertex_type &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>dendrogram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename graph_view_t::vertex_type *&nbsp;</td>
          <td class="paramname"><em>clustering</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Flatten a <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a> at a particular level. </p>
<p>A <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a> represents a hierarchical clustering/partitioning of a graph. This function will flatten the hierarchical clustering into a label for each vertex representing the final cluster/partition to which it is assigned</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a></td><td>Type of graph</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>input graph object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dendrogram</td><td>input dendrogram object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>Pointer to device array where the clustering should be stored </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ad32a4d3984264ce62bf617164930fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32a4d3984264ce62bf617164930fa4d">&nbsp;</a></span>force_atlas2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::force_atlas2 </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"><em>max_iter</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>x_start</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>y_start</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>outbound_attraction_distribution</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>lin_log_mode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>prevent_overlapping</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"><em>edge_weight_influence</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"><em>jitter_tolerance</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>barnes_hut_optimize</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"><em>barnes_hut_theta</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"><em>scaling_ratio</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>strong_gravity_mode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"><em>gravity</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *&nbsp;</td>
          <td class="paramname"><em>callback</em> = <code>nullptr</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>ForceAtlas2 is a continuous graph layout algorithm for handy network visualization. </p>
<pre class="fragment">                                         NOTE: Peak memory allocation occurs at 17*V.
</pre><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a COO. Graph is considered undirected. Edge weights are used for this algorithm and set to 1 by default. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Device array (2, n) containing x-axis and y-axis positions; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations Force Atlas 2 should run for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_start</td><td>Device array containing starting x-axis positions; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_start</td><td>Device array containing starting y-axis positions; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outbound_attraction_distribution</td><td>Distributes attraction along outbound edges. Hubs attract less and thus are pushed to the borders. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lin_log_mode</td><td>Switch ForceAtlas&rsquo; model from lin-lin to lin-log (tribute to Andreas Noack). Makes clusters more tight. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevent_overlapping</td><td>Prevent nodes from overlapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_weight_influence</td><td>How much influence you give to the edges weight. 0 is &ldquo;no influence&rdquo; and 1 is &ldquo;normal&rdquo;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jitter_tolerance</td><td>How much swinging you allow. Above 1 discouraged. Lower gives less speed and more precision. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut_optimize</td><td>Whether to use the Barnes Hut approximation or the slower exact version. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut_theta</td><td>Float between 0 and 1. Tradeoff for speed (1) vs accuracy (0) for Barnes Hut only. @params[in] scaling_ratio Float strictly positive. How much repulsion you want. More makes a more sparse graph. Switching from regular mode to LinLog mode needs a readjustment of the scaling parameter. @params[in] strong_gravity_mode Sets a force that attracts the nodes that are distant from the center more. It is so strong that it can sometimes dominate other forces. @params[in] gravity Attracts nodes to the center. Prevents islands from drifting away. @params[in] verbose Output convergence info at each interation. @params[in] callback An instance of GraphBasedDimRedCallback class to intercept the internal state of positions while they are being trained. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="aedcf48ae5a40585d7bf6251fc86154ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcf48ae5a40585d7bf6251fc86154ef">&nbsp;</a></span>generate_2d_mesh_graph_edgelist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_2d_mesh_graph_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; vertex_t, vertex_t, vertex_t &gt;&gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>component_parameters_v</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>generate an edge list for a 2D Mesh Graph </p>
<p>A sequence of 2D mesh graphs will be constructed according to the component specifications. Each 2D mesh graph is configured with a tuple containing (x, y, base_vertex_id). <code>component_parameters_v</code> will contain a tuple for each component.</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate disjoint 2D mesh constructs of equal size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">component_parameters_v</td><td>Vector containing tuple defining the configuration of each component </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="a081898059b56a221acfac0608eb12b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081898059b56a221acfac0608eb12b9a">&nbsp;</a></span>generate_3d_mesh_graph_edgelist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_3d_mesh_graph_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; vertex_t, vertex_t, vertex_t, vertex_t &gt;&gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>component_parameters_v</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>generate an edge list for a 3D Mesh Graph </p>
<p>A sequence of 3D mesh graphs will be constructed according to the component specifications. Each 3D mesh graph is configured with a tuple containing (x, y, z, base_vertex_id). <code>component_parameters_v</code> will contain a tuple for each component.</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate disjoint 3D mesh constructs of equal size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">component_parameters_v</td><td>Vector containing tuple defining the configuration of each component </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="a8b38b80dc4a42fb491e6812916500b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b38b80dc4a42fb491e6812916500b82">&nbsp;</a></span>generate_complete_graph_edgelist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_complete_graph_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; vertex_t, vertex_t &gt;&gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>component_parameters_v</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>generate an edge lists for some complete graphs </p>
<p>A sequence of complete graphs will be constructed according to the component specifications. Each complete graph is configured with a tuple containing (n, base_vertex_id). <code>component_parameters_v</code> will contain a tuple for each component.</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate disjoint complete graph constructs of equal size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">component_parameters_v</td><td>Vector containing tuple defining the configuration of each component </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="a1e86bcbf7be7a1d9d7afd0c3bc326acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e86bcbf7be7a1d9d7afd0c3bc326acd">&nbsp;</a></span>generate_erdos_renyi_graph_edgelist_gnm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_erdos_renyi_graph_edgelist_gnm </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>base_vertex_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>generate an edge lists for an Erdos-Renyi graph </p>
<p>This API supports the G(n,m) model</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate Erdos-Renyi edges for its portion of the 2D partitioning of the adjacency matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>Number of vertices to use in each complete graph </td></tr>
    <tr><td class="paramname">m</td><td>Number of edges to generate </td></tr>
    <tr><td class="paramname">base_vertex_id</td><td>Starting vertex id for the generated graph </td></tr>
    <tr><td class="paramname">seed</td><td>Seed value for the random number generator. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="af11f1d7615d6d81abe5e1904cd4772bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11f1d7615d6d81abe5e1904cd4772bf">&nbsp;</a></span>generate_erdos_renyi_graph_edgelist_gnp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_erdos_renyi_graph_edgelist_gnp </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>base_vertex_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>generate an edge lists for an Erdos-Renyi graph </p>
<p>This API supports the G(n,p) model which requires O(n^2) work.</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate Erdos-Renyi edges for its portion of the 2D partitioning of the adjacency matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>Number of vertices to use in the generated graph </td></tr>
    <tr><td class="paramname">p</td><td>Probability for edge creation </td></tr>
    <tr><td class="paramname">base_vertex_id</td><td>Starting vertex id for the generated graph </td></tr>
    <tr><td class="paramname">seed</td><td>Seed value for the random number generator. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="a8a3648a479ef7e2b9634070d6ea00042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3648a479ef7e2b9634070d6ea00042">&nbsp;</a></span>generate_path_graph_edgelist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_path_graph_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; vertex_t, vertex_t &gt;&gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>component_parameters_v</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>generate an edge list for path graph </p>
<p>A path graph of size n connects the vertices from 0 to (n - 1) in a single long path: ((0,1), (1,2), ..., (n - 2, n - 1)</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) the path will span all GPUs including an edge from the last vertex on GPU i to the first vertex on GPU (i+1)</p>
<p>This function will generate a collection of path graphs. <code>component_parameters_v</code> defines the parameters for generating each component. Each element of <code>component_parameters_v</code> defines a tuple consisting of the number of vertices and the base vertex id for the component.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">component_parameters_v</td><td>A vector containing tuples consisting of the number of vertices and base vertex id for each component to generate. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="ad63e55a56aafcb092d524d0cbe9bfe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63e55a56aafcb092d524d0cbe9bfe2a">&nbsp;</a></span>generate_rmat_edgelist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_rmat_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>num_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>a</em> = <code>0.57</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>b</em> = <code>0.19</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>c</em> = <code>0.19</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>clip_and_flip</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>generate an edge list for an R-mat graph. </p>
<p>This function allows multi-edges and self-loops similar to the Graph 500 reference implementation.</p>
<p>NOTE: The scramble_vertex_ids function needs to be called in order to generate a graph conforming to the Graph 500 specification (note that scrambling does not affect cuGraph's graph construction performance, so this is generally unnecessary). If <code>edge_factor</code> is given (e.g. Graph 500), set <code>num_edges</code> to (size_t{1} &lt;&lt; <code>scale</code>) * <code>edge_factor</code>. To generate an undirected graph, set <code>b</code> == <code>c</code> and <code>clip_and_flip</code> = true. All the resulting edges will be placed in the lower triangular part (including the diagonal) of the graph adjacency matrix.</p>
<p>For multi-GPU generation with <code>P</code> GPUs, <code>seed</code> should be set to different values in different GPUs to avoid every GPU generating the same set of edges. <code>num_edges</code> should be adjusted as well; e.g. assuming <code>edge_factor</code> is given, set <code>num_edges</code> = (size_t{1} &lt;&lt; <code>scale</code>) * <code>edge_factor</code> / <code>P</code> + (rank &lt; (((size_t{1} &lt;&lt; <code>scale</code>) * <code>edge_factor</code>) % P) ? 1 : 0).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor to set the number of verties in the graph. Vertex IDs have values in [0, V), where V = 1 &lt;&lt; <code>scale</code>. </td></tr>
    <tr><td class="paramname">num_edges</td><td>Number of edges to generate. </td></tr>
    <tr><td class="paramname">a</td><td>a, b, c, d (= 1.0 - (a + b + c)) in the R-mat graph generator (vist <a href="https://graph500.org">https://graph500.org</a> for additional details). a, b, c, d should be non-negative and a + b + c should be no larger than 1.0. </td></tr>
    <tr><td class="paramname">b</td><td>a, b, c, d (= 1.0 - (a + b + c)) in the R-mat graph generator (vist <a href="https://graph500.org">https://graph500.org</a> for additional details). a, b, c, d should be non-negative and a + b + c should be no larger than 1.0. </td></tr>
    <tr><td class="paramname">c</td><td>a, b, c, d (= 1.0 - (a + b + c)) in the R-mat graph generator (vist <a href="https://graph500.org">https://graph500.org</a> for additional details). a, b, c, d should be non-negative and a + b + c should be no larger than 1.0. </td></tr>
    <tr><td class="paramname">seed</td><td>Seed value for the random number generator. </td></tr>
    <tr><td class="paramname">clip_and_flip</td><td>Flag controlling whether to generate edges only in the lower triangular part (including the diagonal) of the graph adjacency matrix (if set to <code>true</code>) or not (if set to <code>false</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="ac04e233fc46602ad3e67478f4ed4076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04e233fc46602ad3e67478f4ed4076a">&nbsp;</a></span>generate_rmat_edgelists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::vector&lt; std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; &gt; cugraph::generate_rmat_edgelists </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_edgelists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>min_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>max_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>edge_factor</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">generator_distribution_t&nbsp;</td>
          <td class="paramname"><em>size_distribution</em> = <code>generator_distribution_t::POWER_LAW</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">generator_distribution_t&nbsp;</td>
          <td class="paramname"><em>edge_distribution</em> = <code>generator_distribution_t::POWER_LAW</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>clip_and_flip</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>generate multiple edge lists using the R-mat graph generator. </p>
<p>This function allows multi-edges and self-loops similar to the Graph 500 reference implementation.</p>
<p>NOTE: The scramble_vertex_ids function needs to be called in order to generate a graph conforming to the Graph 500 specification (note that scrambling does not affect cuGraph's graph construction performance, so this is generally unnecessary). If <code>edge_factor</code> is given (e.g. Graph 500), set <code>num_edges</code> to (size_t{1} &lt;&lt; <code>scale</code>) * <code>edge_factor</code>. To generate an undirected graph, set <code>b</code> == <code>c</code> and <code>clip_and_flip</code> = true. All the resulting edges will be placed in the lower triangular part (including the diagonal) of the graph adjacency matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">n_edgelists</td><td>Number of edge lists (graphs) to generate </td></tr>
    <tr><td class="paramname">min_scale</td><td>Scale factor to set the minimum number of verties in the graph. </td></tr>
    <tr><td class="paramname">max_scale</td><td>Scale factor to set the maximum number of verties in the graph. </td></tr>
    <tr><td class="paramname">edge_factor</td><td>Average number of edges per vertex to generate. </td></tr>
    <tr><td class="paramname">size_distribution</td><td>Distribution of the graph sizes, impacts the scale parameter of the R-MAT generator </td></tr>
    <tr><td class="paramname">edge_distribution</td><td>Edges distribution for each graph, impacts how R-MAT parameters a,b,c,d, are set. </td></tr>
    <tr><td class="paramname">seed</td><td>Seed value for the random number generator. </td></tr>
    <tr><td class="paramname">clip_and_flip</td><td>Flag controlling whether to generate edges only in the lower triangular part (including the diagonal) of the graph adjacency matrix (if set to <code>true</code>) or not (if set to <code>false</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; of size <code>n_edgelists</code>, each vector element being a tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="a41a71fac845f1af9f992e9857cf9f942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a71fac845f1af9f992e9857cf9f942">&nbsp;</a></span>get_traversed_cost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::get_traversed_cost </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>preds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t const *&nbsp;</td>
          <td class="paramname"><em>info_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t *&nbsp;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>stop_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>num_vertices</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Takes the results of BFS or SSSP function call and sums the given weights along the path to the starting vertex. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. Must have at least one worker stream. </td></tr>
    <tr><td class="paramname">vertices</td><td>Pointer to vertex ids. </td></tr>
    <tr><td class="paramname">preds</td><td>Pointer to predecessors. </td></tr>
    <tr><td class="paramname">info_weights</td><td>Secondary weights along the edge from predecessor to vertex. </td></tr>
    <tr><td class="paramname">out</td><td>Contains for each index the sum of weights along the path unfolding. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>Number of vertices. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a6274817ef7b6e503565b2188f03c68ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6274817ef7b6e503565b2188f03c68ea">&nbsp;</a></span>get_two_hop_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::get_two_hop_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Find all 2-hop neighbors in the graph. </p>
<p>Find pairs of vertices in the input graph such that each pair is connected by a path that is two hops in length.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph in COO format </dd></dl>

</div>
</div>
<a id="aec1f7644b609686ffe31cd51dfef94d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1f7644b609686ffe31cd51dfef94d0">&nbsp;</a></span>hits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; weight_t, size_t &gt; cugraph::hits </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, true, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t *&nbsp;</td>
          <td class="paramname"><em>hubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t *&nbsp;</td>
          <td class="paramname"><em>authorities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t&nbsp;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>has_initial_hubs_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>normalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute HITS scores. </p>
<p>This function computes HITS scores for the vertices of a graph</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>on erroneous input arguments</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object. </td></tr>
    <tr><td class="paramname">hubs</td><td>Pointer to the input/output hub score array. </td></tr>
    <tr><td class="paramname">authorities</td><td>Pointer to the output authorities score array. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Error tolerance to check convergence. Convergence is assumed if the sum of the differences in hub values between two consecutive iterations is less than <code>epsilon</code> </td></tr>
    <tr><td class="paramname">max_iterations</td><td>Maximum number of HITS iterations. </td></tr>
    <tr><td class="paramname">has_initial_guess</td><td>If set to <code>true</code>, values in the hubs output array (pointed by <code>hubs</code>) is used as initial hub values. If false, initial hub values are set to 1.0 divided by the number of vertices in the graph. </td></tr>
    <tr><td class="paramname">normalize</td><td>If set to <code>true</code>, final hub and authority scores are normalized (the L1-norm of the returned hub and authority score arrays is 1.0) before returning. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;weight_t, size_t&gt; A tuple of sum of the differences of hub scores of the last two iterations and the total number of iterations taken to reach the final result </dd></dl>

</div>
</div>
<a id="a867079c86af90114a5a687092e445e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867079c86af90114a5a687092e445e7f">&nbsp;</a></span>hungarian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">weight_t cugraph::hungarian </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>num_workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>assignments</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute Hungarian algorithm on a weighted bipartite graph. </p>
<p>The Hungarian algorithm computes an assigment of "jobs" to "workers". This function accepts a weighted graph and a vertex list identifying the "workers". The weights in the weighted graph identify the cost of assigning a particular job to a worker. The algorithm computes a minimum cost assignment and returns the cost as well as a vector identifying the assignment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH COO graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_workers</td><td>number of vertices in the worker set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workers</td><td>device pointer to an array of worker vertex ids </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assignments</td><td>device pointer to an array to which the assignment will be written. The array should be num_workers long, and will identify which vertex id (job) is assigned to that worker </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="adc7e86752cf1de0fdcfae6fcb44753d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7e86752cf1de0fdcfae6fcb44753d8">&nbsp;</a></span>hungarian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">weight_t cugraph::hungarian </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>num_workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>workers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t&nbsp;</td>
          <td class="paramname"><em>epsilon</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute Hungarian algorithm on a weighted bipartite graph. </p>
<p>The Hungarian algorithm computes an assigment of "jobs" to "workers". This function accepts a weighted graph and a vertex list identifying the "workers". The weights in the weighted graph identify the cost of assigning a particular job to a worker. The algorithm computes a minimum cost assignment and returns the cost as well as a vector identifying the assignment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH COO graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_workers</td><td>number of vertices in the worker set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workers</td><td>device pointer to an array of worker vertex ids </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assignments</td><td>device pointer to an array to which the assignment will be written. The array should be num_workers long, and will identify which vertex id (job) is assigned to that worker </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>parameter to define precision of comparisons in reducing weights to zero. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ac234f529dba8fc868a9f9677e168e7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac234f529dba8fc868a9f9677e168e7b6">&nbsp;</a></span>jaccard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::jaccard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT const *&nbsp;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT *&nbsp;</td>
          <td class="paramname"><em>result</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute jaccard similarity coefficient for all vertices. </p>
<p>Computes the Jaccard similarity coefficient for every pair of vertices in the graph which are connected by an edge.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted Jaccard, may be NULL for unweighted Jaccard. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ac5263bdd552e7951abf3973cc358dfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5263bdd552e7951abf3973cc358dfda">&nbsp;</a></span>jaccard_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::jaccard_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT const *&nbsp;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&nbsp;</td>
          <td class="paramname"><em>num_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT const *&nbsp;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT const *&nbsp;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT *&nbsp;</td>
          <td class="paramname"><em>result</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute jaccard similarity coefficient for selected vertex pairs. </p>
<p>Computes the Jaccard similarity coefficient for each pair of specified vertices. Vertices are specified as pairs where pair[n] = (first[n], second[n])</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The input vertex weights for weighted Jaccard, may be NULL for unweighted Jaccard. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_pairs</td><td>The number of vertex ID pairs specified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Device pointer to first vertex ID of each pair </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Device pointer to second vertex ID of each pair </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a8c4ad5a6f48fbdf620c9007189af32ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4ad5a6f48fbdf620c9007189af32ea">&nbsp;</a></span>k_core()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::k_core </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT const *&nbsp;</td>
          <td class="paramname"><em>vertex_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT const *&nbsp;</td>
          <td class="paramname"><em>core_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT&nbsp;</td>
          <td class="paramname"><em>num_vertex_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute K Core of the graph G. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph in coordinate format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Order of the core. This value must not be negative. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_id</td><td>User specified vertex identifiers for which core number values are supplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">core_number</td><td>User supplied core number values corresponding to vertex_id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertex_ids</td><td>Number of elements in vertex_id/core_number arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_graph</td><td>Unique pointer to K Core subgraph in COO format </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ad7ff468bf1c4237f65af7a3a581c1db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ff468bf1c4237f65af7a3a581c1db7">&nbsp;</a></span>k_truss_subgraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::k_truss_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCOOView.html">legacy::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute k truss for a graph. </p>
<p>K Truss is the maximal subgraph of a graph which contains at least three vertices where every edge is incident to at least k-2 triangles.</p>
<p>Note that current implementation does not support a weighted graph.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a COO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The order of the truss </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to K Truss subgraph in COO format </dd></dl>

</div>
</div>
<a id="a049ce498c5e78992d28049763f9c04f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049ce498c5e78992d28049763f9c04f8">&nbsp;</a></span>katz_centrality() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT , typename result_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::katz_centrality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t *&nbsp;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>has_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>normalized</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute the Katz centrality for the nodes of the graph G. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double. </td></tr>
    <tr><td class="paramname">result_t</td><td>Type of computed result. Supported values : float</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device array of centrality scores </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Attenuation factor with a default value of 0.1. Alpha is set to 1/(lambda_max) if it is greater where lambda_max is the maximum degree of the graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations before an answer is returned. This can be used to limit the execution time and do an early exit before the solver reaches the convergence tolerance. If this value is lower or equal to 0 cuGraph will use the default value, which is 100. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Set the tolerance the approximation, this parameter should be a small magnitude value. The lower the tolerance the better the approximation. If this value is 0.0f, cuGraph will use the default value which is 1.0E-5. Setting too small a tolerance can lead to non-convergence due to numerical roundoff. Usually values between 0.01 and 0.00001 are acceptable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">has_guess</td><td>Flag to determine whether <code>katz_centrality</code> contains an initial guess for katz centrality values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalized</td><td>If True normalize the resulting katz centrality values </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a9942a275444c2e0b96d90feec4ab6e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9942a275444c2e0b96d90feec4ab6e90">&nbsp;</a></span>katz_centrality() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::katz_centrality </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, true, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t const *&nbsp;</td>
          <td class="paramname"><em>betas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t *&nbsp;</td>
          <td class="paramname"><em>katz_centralities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t&nbsp;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t&nbsp;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t&nbsp;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>max_iterations</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>has_initial_guess</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>normalize</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute Katz Centrality scores. </p>
<p>This function computes Katz Centrality scores.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>on erroneous input arguments or if fails to converge before <code>max_iterations</code>.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">result_t</td><td>Type of Katz Centrality scores. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object. </td></tr>
    <tr><td class="paramname">betas</td><td>Pointer to an array holding the values to be added to each vertex's new Katz Centrality score in every iteration or <code>nullptr</code>. If set to <code>nullptr</code>, constant <code>beta</code> is used instead. </td></tr>
    <tr><td class="paramname">katz_centralities</td><td>Pointer to the output Katz Centrality score array. </td></tr>
    <tr><td class="paramname">alpha</td><td>Katz Centrality attenuation factor. This should be smaller than the inverse of the maximum eigenvalue of the adjacency matrix of <code>graph</code>. </td></tr>
    <tr><td class="paramname">beta</td><td>Constant value to be added to each vertex's new Katz Centrality score in every iteration. Relevant only when <code>betas</code> is <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Error tolerance to check convergence. Convergence is assuemd if the sum of the differences in Katz Centrality values between two consecutive iterations is less than the number of vertices in the graph multiplied by <code>epsilon</code>. </td></tr>
    <tr><td class="paramname">max_iterations</td><td>Maximum number of Katz Centrality iterations. </td></tr>
    <tr><td class="paramname">has_initial_guess</td><td>If set to <code>true</code>, values in the Katz Centrality output array (pointed by <code>katz_centralities</code>) is used as initial Katz Centrality values. If false, zeros are used as initial Katz Centrality values. </td></tr>
    <tr><td class="paramname">normalize</td><td>If set to <code>true</code>, final Katz Centrality scores are normalized (the L2-norm of the returned Katz Centrality score array is 1.0) before returning. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a55cf4ef622742e6f1717a7995f1a82ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cf4ef622742e6f1717a7995f1a82ee">&nbsp;</a></span>leiden()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::pair&lt; size_t, weight_t &gt; cugraph::leiden </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>clustering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>max_iter</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t&nbsp;</td>
          <td class="paramname"><em>resolution</em> = <code>weight_t{1}</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Leiden implementation. </p>
<p>Compute a clustering of the graph by maximizing modularity using the Leiden improvements to the <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> method.</p>
<p>Computed using the Leiden method described in:</p>
<p>Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> to Leiden: guaranteeing well-connected communities. Scientific reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>input graph object (CSR) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>Pointer to device array where the clustering should be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>(optional) maximum number of iterations to run (default 100) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>(optional) The value of the resolution parameter to use. Called gamma in the modularity formula, this changes the size of the communities. Higher resolutions lead to more smaller communities, lower resolutions lead to fewer larger communities. (default 1)</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing: 1) number of levels of the returned clustering 2) modularity of the returned clustering </dd></dl>

</div>
</div>
<a id="aba90b00d58c83e321421dab7a2ae3776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba90b00d58c83e321421dab7a2ae3776">&nbsp;</a></span>louvain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graph_view_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; typename graph_view_t::vertex_type &gt; &gt;, typename graph_view_t::weight_type &gt; cugraph::louvain </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>max_level</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename graph_view_t::weight_type&nbsp;</td>
          <td class="paramname"><em>resolution</em> = <code>typename&nbsp;graph_view_t::weight_type{1}</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> implementation, returning dendrogram. </p>
<p>Compute a clustering of the graph by maximizing modularity</p>
<p>Computed using the <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> method described in:</p>
<p>VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008), <a href="http://arxiv.org/abs/0803.0476">http://arxiv.org/abs/0803.0476</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a></td><td>Type of graph</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph_view</td><td>Input graph view object (CSR) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_level</td><td>(optional) maximum number of levels to run (default 100) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>(optional) The value of the resolution parameter to use. Called gamma in the modularity formula, this changes the size of the communities. Higher resolutions lead to more smaller communities, lower resolutions lead to fewer larger communities. (default 1)</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing: 1) unique pointer to dendrogram 2) modularity of the returned clustering </dd></dl>

</div>
</div>
<a id="a936a52eb10e269e918a2a8e9490080ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936a52eb10e269e918a2a8e9490080ca">&nbsp;</a></span>louvain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graph_view_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::pair&lt; size_t, typename graph_view_t::weight_type &gt; cugraph::louvain </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename graph_view_t::vertex_type *&nbsp;</td>
          <td class="paramname"><em>clustering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>max_level</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename graph_view_t::weight_type&nbsp;</td>
          <td class="paramname"><em>resolution</em> = <code>typename&nbsp;graph_view_t::weight_type{1}</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> implementation. </p>
<p>Compute a clustering of the graph by maximizing modularity</p>
<p>Computed using the <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> method described in:</p>
<p>VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008), <a href="http://arxiv.org/abs/0803.0476">http://arxiv.org/abs/0803.0476</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a></td><td>Type of graph</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>input graph object (CSR) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>Pointer to device array where the clustering should be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_level</td><td>(optional) maximum number of levels to run (default 100) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>(optional) The value of the resolution parameter to use. Called gamma in the modularity formula, this changes the size of the communities. Higher resolutions lead to more smaller communities, lower resolutions lead to fewer larger communities. (default 1)</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing: 1) number of levels of the returned clustering 2) modularity of the returned clustering </dd></dl>

</div>
</div>
<a id="a07372c78e975cd7a73daecc486b00dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07372c78e975cd7a73daecc486b00dcf">&nbsp;</a></span>minimum_spanning_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1legacy_1_1GraphCOO.html">legacy::GraphCOO</a>&lt; vertex_t, edge_t, weight_t &gt; &gt; cugraph::minimum_spanning_tree </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Generate edges in a minimum spanning forest of an undirected weighted graph. </p>
<p>A minimum spanning tree is a subgraph of the graph (a tree) with the minimum sum of edge weights. A spanning forest is a union of the spanning trees for each connected component of the graph. If the graph is connected it returns the minimum spanning tree.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph_csr</td><td>input graph object (CSR) expected to be symmetric </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>out_graph Unique pointer to MSF subgraph in COO format </dd></dl>

</div>
</div>
<a id="abf404506c99fd8a5550cb78f0123eaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf404506c99fd8a5550cb78f0123eaa8">&nbsp;</a></span>overlap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::overlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT const *&nbsp;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT *&nbsp;</td>
          <td class="paramname"><em>result</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute overlap coefficient for all vertices in the graph. </p>
<p>Computes the Overlap Coefficient for every pair of vertices in the graph which are connected by an edge.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted overlap, may be NULL for unweighted overlap. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="aa97e1cab7d65f1ae28b588c45dce0e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97e1cab7d65f1ae28b588c45dce0e06">&nbsp;</a></span>overlap_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::overlap_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT const *&nbsp;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&nbsp;</td>
          <td class="paramname"><em>num_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT const *&nbsp;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT const *&nbsp;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT *&nbsp;</td>
          <td class="paramname"><em>result</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute overlap coefficient for select pairs of vertices. </p>
<p>Computes the overlap coefficient for each pair of specified vertices. Vertices are specified as pairs where pair[n] = (first[n], second[n])</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted overlap, may be NULL for unweighted overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_pairs</td><td>The number of vertex ID pairs specified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Device pointer to first vertex ID of each pair </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Device pointer to second vertex ID of each pair </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a7d8670fded63928475f245d51e797903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8670fded63928475f245d51e797903">&nbsp;</a></span>pagerank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::pagerank </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, true, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; weight_t const * &gt;&nbsp;</td>
          <td class="paramname"><em>precomputed_vertex_out_weight_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; vertex_t const * &gt;&nbsp;</td>
          <td class="paramname"><em>personalization_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; result_t const * &gt;&nbsp;</td>
          <td class="paramname"><em>personalization_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; vertex_t &gt;&nbsp;</td>
          <td class="paramname"><em>personalization_vector_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t *&nbsp;</td>
          <td class="paramname"><em>pageranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t&nbsp;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">result_t&nbsp;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>max_iterations</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>has_initial_guess</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Compute PageRank scores. </p>
<p>This function computes general (if <code>personalization_vertices</code> is <code>nullptr</code>) or personalized (if <code>personalization_vertices</code> is not <code>nullptr</code>.) PageRank scores.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>on erroneous input arguments or if fails to converge before <code>max_iterations</code>.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">result_t</td><td>Type of PageRank scores. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object. </td></tr>
    <tr><td class="paramname">precomputed_vertex_out_weight_sums</td><td>Pointer to an array storing sums of out-going edge weights for the vertices (for re-use) or <code>std::nullopt</code>. If <code>std::nullopt</code>, these values are freshly computed. Computing these values outside this function reduces the number of memory allocations/deallocations and computing if a user repeatedly computes PageRank scores using the same graph with different personalization vectors. </td></tr>
    <tr><td class="paramname">personalization_vertices</td><td>Pointer to an array storing personalization vertex identifiers (compute personalized PageRank) or <code>std::nullopt</code> (compute general PageRank). </td></tr>
    <tr><td class="paramname">personalization_values</td><td>Pointer to an array storing personalization values for the vertices in the personalization set. Relevant only if <code>personalization_vertices</code> is not <code>std::nullopt</code>. </td></tr>
    <tr><td class="paramname">personalization_vector_size</td><td>Size of the personalization set. If @personalization_vertices is not <code>std::nullopt</code>, the sizes of the arrays pointed by <code>personalization_vertices</code> and <code>personalization_values</code> should be <code>personalization_vector_size</code>. </td></tr>
    <tr><td class="paramname">pageranks</td><td>Pointer to the output PageRank score array. </td></tr>
    <tr><td class="paramname">alpha</td><td>PageRank damping factor. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Error tolerance to check convergence. Convergence is assumed if the sum of the differences in PageRank values between two consecutive iterations is less than the number of vertices in the graph multiplied by <code>epsilon</code>. </td></tr>
    <tr><td class="paramname">max_iterations</td><td>Maximum number of PageRank iterations. </td></tr>
    <tr><td class="paramname">has_initial_guess</td><td>If set to <code>true</code>, values in the PageRank output array (pointed by <code>pageranks</code>) is used as initial PageRank values. If false, initial PageRank values are set to 1.0 divided by the number of vertices in the graph. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a08c8df4f0a0a151e4767a5f1d299a5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c8df4f0a0a151e4767a5f1d299a5bc">&nbsp;</a></span>query_rw_sizes_offsets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; index_t &gt;, rmm::device_uvector&lt; index_t &gt;, rmm::device_uvector&lt; index_t &gt; &gt; cugraph::query_rw_sizes_offsets </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&nbsp;</td>
          <td class="paramname"><em>num_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t const *&nbsp;</td>
          <td class="paramname"><em>ptr_d_sizes</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>returns additional RW information on vertex paths offsets and weight path sizes and offsets, for the coalesced case (the padded case does not need or provide this information) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">index_t</td><td>Type used to store indexing and sizes. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">num_paths</td><td>number of paths. </td></tr>
    <tr><td class="paramname">ptr_d_sizes</td><td>sizes of vertex paths. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple of (vertex_path_offsets, weight_path_sizes, weight_path_offsets), where offsets are exclusive scan of corresponding sizes. </dd></dl>

</div>
</div>
<a id="a179206df4869b42d6e5a7c28bcabcfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179206df4869b42d6e5a7c28bcabcfd4">&nbsp;</a></span>random_walks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graph_t , typename index_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; typename graph_t::vertex_type &gt;, rmm::device_uvector&lt; typename graph_t::weight_type &gt;, rmm::device_uvector&lt; index_t &gt; &gt; cugraph::random_walks </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__t.html">graph_t</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename graph_t::vertex_type const *&nbsp;</td>
          <td class="paramname"><em>ptr_d_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&nbsp;</td>
          <td class="paramname"><em>num_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_t&nbsp;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>use_padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="structcugraph_1_1sampling__params__t.html">sampling_params_t</a> &gt;&nbsp;</td>
          <td class="paramname"><em>sampling_strategy</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>returns random walks (RW) from starting sources, where each path is of given maximum length. Uniform distribution is assumed for the random engine. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname"><a class="el" href="classcugraph_1_1graph__t.html">graph_t</a></td><td>Type of graph/view (typically, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>). </td></tr>
    <tr><td class="paramname">index_t</td><td>Type used to store indexing and sizes. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph</td><td>Graph (view )object to generate RW on. </td></tr>
    <tr><td class="paramname">ptr_d_start</td><td>Device pointer to set of starting vertex indices for the RW. </td></tr>
    <tr><td class="paramname">num_paths</td><td>= number(paths). </td></tr>
    <tr><td class="paramname">max_depth</td><td>maximum length of RWs. </td></tr>
    <tr><td class="paramname">use_padding</td><td>(optional) specifies if return uses padded format (true), or coalesced (compressed) format; when padding is used the output is a matrix of vertex paths and a matrix of edges paths (weights); in this case the matrices are stored in row major order; the vertex path matrix is padded with <code>num_vertices</code> values and the weight matrix is padded with <code>0</code> values; </td></tr>
    <tr><td class="paramname">selector_type</td><td>identifier for sampling strategy: uniform, biased, etc.; defaults to uniform = 0; </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;weight_t&gt;, rmm::device_uvector&lt;index_t&gt;&gt; Triplet of either padded or coalesced RW paths; in the coalesced case (default), the return consists of corresponding vertex and edge weights for each, and corresponding path sizes. This is meant to minimize the number of DF's to be passed to the Python layer. The meaning of "coalesced" here is that a 2D array of paths of different sizes is represented as a 1D contiguous array. In the padded case the return is a matrix of num_paths x max_depth vertex paths; and num_paths x (max_depth-1) edge (weight) paths, with an empty array of sizes. Note: if the graph is un-weighted the edge (weight) paths consists of <code>weight_t{1}</code> entries;</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname"><a class="el" href="classcugraph_1_1graph__t.html">graph_t</a></td><td>Type of graph/view (typically, <a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>). </td></tr>
    <tr><td class="paramname">index_t</td><td>Type used to store indexing and sizes. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph</td><td>Graph (view )object to generate RW on. </td></tr>
    <tr><td class="paramname">ptr_d_start</td><td>Device pointer to set of starting vertex indices for the RW. </td></tr>
    <tr><td class="paramname">num_paths</td><td>= number(paths). </td></tr>
    <tr><td class="paramname">max_depth</td><td>maximum length of RWs. </td></tr>
    <tr><td class="paramname">use_padding</td><td>(optional) specifies if return uses padded format (true), or coalesced (compressed) format; when padding is used the output is a matrix of vertex paths and a matrix of edges paths (weights); in this case the matrices are stored in row major order; the vertex path matrix is padded with <code>num_vertices</code> values and the weight matrix is padded with <code>0</code> values; </td></tr>
    <tr><td class="paramname">sampling_strategy</td><td>pointer for sampling strategy: uniform, biased, etc.; possible values{0==uniform, 1==biased, 2==node2vec}; defaults to nullptr == uniform; </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;weight_t&gt;, rmm::device_uvector&lt;index_t&gt;&gt; Triplet of either padded or coalesced RW paths; in the coalesced case (default), the return consists of corresponding vertex and edge weights for each, and corresponding path sizes. This is meant to minimize the number of DF's to be passed to the Python layer. The meaning of "coalesced" here is that a 2D array of paths of different sizes is represented as a 1D contiguous array. In the padded case the return is a matrix of num_paths x max_depth vertex paths; and num_paths x (max_depth-1) edge (weight) paths, with an empty array of sizes. Note: if the graph is un-weighted the edge (weight) paths consists of <code>weight_t{1}</code> entries; </dd></dl>

</div>
</div>
<a id="a949a39ee7ad148f83104f99f413a5869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949a39ee7ad148f83104f99f413a5869">&nbsp;</a></span>reduce_v() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename InputIterator , typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">T cugraph::reduce_v </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"><em>input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"><em>input_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em> = <code>T{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::comms::op_t&nbsp;</td>
          <td class="paramname"><em>op</em> = <code>raft::comms::op_t::SUM</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Reduce the vertex properties. </p>
<p>This version (conceptually) iterates over only a subset of the graph vertices. This function actually works as thrust::reduce() on [<code>input_first</code>, <code>input_last</code>) (followed by inter-process reduction in multi-GPU).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Type of the iterator for input values. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the initial value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">input_first</td><td>Iterator pointing to the beginning (inclusive) of the values to be reduced. </td></tr>
    <tr><td class="paramname">input_last</td><td>Iterator pointing to the end (exclusive) of the values to be reduced. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the reduced input vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T Reduction of the input vertex properties. </dd></dl>

</div>
</div>
<a id="ac478ff292d511164e35224dcc90725dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac478ff292d511164e35224dcc90725dc">&nbsp;</a></span>reduce_v() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename VertexValueInputIterator , typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">T cugraph::reduce_v </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueInputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::comms::op_t&nbsp;</td>
          <td class="paramname"><em>op</em> = <code>raft::comms::op_t::SUM</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Reduce the vertex properties. </p>
<p>This version iterates over the entire set of graph vertices. This function is inspired by thrust::reduce().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">VertexValueInputIterator</td><td>Type of the iterator for vertex properties. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the initial value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">vertex_value_input_first</td><td>Iterator pointing to the vertex properties for the first (inclusive) vertex (assigned to this process in multi-GPU). <code>vertex_value_input_last</code> (exclusive) is deduced as <code>vertex_value_input_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the reduced input vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T Reduction of the input vertex properties. </dd></dl>

</div>
</div>
<a id="a7e8d4a7f63d0e7e3a9b17f81acc09403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8d4a7f63d0e7e3a9b17f81acc09403">&nbsp;</a></span>relabel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::relabel </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; vertex_t const *, vertex_t const * &gt;&nbsp;</td>
          <td class="paramname"><em>old_new_label_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>num_label_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>num_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>skip_missing_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Relabel old labels to new labels. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">old_new_label_pairs</td><td>Pairs of an old label and the corresponding new label (each process holds only part of the entire old labels and the corresponding new labels; partitioning can be arbitrary). </td></tr>
    <tr><td class="paramname">num_label_pairs</td><td>Number of (old, new) label pairs. </td></tr>
    <tr><td class="paramname">labels</td><td>Labels to be relabeled. This initially holds old labels. Old labels are updated to new labels in-place ([INOUT] parameter). </td></tr>
    <tr><td class="paramname">num_labels</td><td>Number of labels to be relabeled. </td></tr>
    <tr><td class="paramname">skip_missing_labels</td><td>Flag dictating the behavior on missing labels (<code>labels</code> contains old labels missing in <code>old_new_label_pairs</code>). If set to true, missing elements are skipped (not relabeled). If set to false, undefined behavior (if <code>do_expensive_check</code> is set to true, this function will throw an exception). </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmm::device_uvector&lt;vertex_t&gt; New labels corresponding to the <code>old_labels</code>. </dd></dl>

</div>
</div>
<a id="a13e2d6d33fde7df4df168f889a765cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e2d6d33fde7df4df168f889a765cfd">&nbsp;</a></span>renumber_edgelist() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::enable_if_t&lt; multi_gpu, std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; vertex_t, edge_t, multi_gpu &gt; &gt; &gt; cugraph::renumber_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>local_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vertex_t * &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_majors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vertex_t * &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_minors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; edge_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_edge_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::vector&lt; std::vector&lt; edge_t &gt;&gt;&gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_intra_partition_segment_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>renumber edgelist (multi-GPU) </p>
<p>This function assumes that vertices and edges are pre-shuffled to their target processes using the compute_gpu_id_from_vertex_t &amp; compute_gpu_id_from_edge_t functors, respectively.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">local_vertices</td><td>If valid, part of the entire set of vertices in the graph to be renumbered. This parameter can be used to include isolated vertices. Applying the compute_gpu_id_from_vertex_t to every vertex should return the local GPU ID for this function to work (vertices should be pre-shuffled). </td></tr>
    <tr><td class="paramname">edgelist_majors</td><td>Pointers (one pointer per local graph adjacency matrix partition assigned to this process) to edge source vertex IDs (if the graph adjacency matrix is stored as is) or edge destination vertex IDs (if the transposed graph adjacency matrix is stored). Vertex IDs are updated in-place ([INOUT] parameter). Edges should be pre-shuffled to their final target process &amp; matrix partition; i.e. applying the compute_gpu_id_from_edge_t functor to every (major, minor) pair should return the GPU ID of this process and applying the compute_partition_id_from_edge_t fuctor to every (major, minor) pair for a local matrix partition should return the partition ID of the corresponding matrix partition. </td></tr>
    <tr><td class="paramname">edgelist_minors</td><td>Pointers (one pointer per local graph adjacency matrix partition assigned to this process) to edge destination vertex IDs (if the graph adjacency matrix is stored as is) or edge source vertex IDs (if the transposed graph adjacency matrix is stored). Vertex IDs are updated in-place ([INOUT] parameter). Edges should be pre-shuffled to their final target process &amp; matrix partition; i.e. applying the compute_gpu_id_from_edge_t functor to every (major, minor) pair should return the GPU ID of this process and applying the compute_partition_id_from_edge_t fuctor to every (major, minor) pair for a local matrix partition should return the partition ID of the corresponding matrix partition. </td></tr>
    <tr><td class="paramname">edgelist_edge_counts</td><td>Edge counts (one count per local graph adjacency matrix partition assigned to this process). </td></tr>
    <tr><td class="paramname">edgelist_intra_partition_segment_offsets</td><td>If valid, store segment offsets within a local graph adjacency matrix partition; a local partition can be further segmented by applying the compute_gpu_id_from_vertex_t function to edge minor vertex IDs. This optinoal information is used for further memory footprint optimization if provided. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, renumber_meta_t&lt;vertex_t, edge_t, multi_gpu&gt;&gt; Tuple of labels (vertex IDs before renumbering) for the entire set of vertices (assigned to this process in multi-GPU) and meta-data collected while renumbering. The meta-data includes total number of vertices, total number of edges, <a class="el" href="classcugraph_1_1partition__t.html" title="store vertex partitioning map">partition_t</a> object storing graph partitioning information, vertex partition segment offsets (a vertex partition is partitioned to multiple segments based on vertex degrees), and the number of local unique edge major &amp; minor vertex IDs. This meta-data is expected to be used in graph construction &amp; graph primitives. </dd></dl>

</div>
</div>
<a id="ae36c598906c8fa49f6fa40d5bc774b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36c598906c8fa49f6fa40d5bc774b36">&nbsp;</a></span>renumber_edgelist() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::enable_if_t&lt; !multi_gpu, std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, <a class="el" href="structcugraph_1_1renumber__meta__t.html">renumber_meta_t</a>&lt; vertex_t, edge_t, multi_gpu &gt; &gt; &gt; cugraph::renumber_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>edgelist_majors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>edgelist_minors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">edge_t&nbsp;</td>
          <td class="paramname"><em>num_edgelist_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>renumber edgelist (single-GPU) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">vertices</td><td>If valid, vertices in the graph to be renumbered. This parameter can be used to include isolated vertices. </td></tr>
    <tr><td class="paramname">edgelist_majors</td><td>Edge source vertex IDs (if the graph adjacency matrix is stored as is) or edge destination vertex IDs (if the transposed graph adjacency matrix is stored). Vertex IDs are updated in-place ([INOUT] parameter). </td></tr>
    <tr><td class="paramname">edgelist_minors</td><td>Edge destination vertex IDs (if the graph adjacency matrix is stored as is) or edge source vertex IDs (if the transposed graph adjacency matrix is stored). Vertex IDs are updated in-place ([INOUT] parameter). </td></tr>
    <tr><td class="paramname">num_edgelist_edges</td><td>Number of edges in the edgelist. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, renumber_meta_t&lt;vertex_t, edge_t, multi_gpu&gt;&gt; Tuple of labels (vertex IDs before renumbering) for the entire set of vertices and meta-data collected while renumbering. The meta-data includes vertex partition segment offsets (a vertex partition is partitioned to multiple segments based on vertex degrees). This meta-data is expected to be used in graph construction &amp; graph primitives. </dd></dl>

</div>
</div>
<a id="a431a64199aca6af92b8f9a5b62d0168f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431a64199aca6af92b8f9a5b62d0168f">&nbsp;</a></span>renumber_ext_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::renumber_ext_vertices </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>renumber_map_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>local_int_vertex_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>local_int_vertex_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Renumber external vertices to internal vertices based on the provoided <code>renumber_map_labels</code>. </p>
<p>Note cugraph::invalid_id&lt;vertex_t&gt;::value remains unchanged.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">vertices</td><td>Pointer to the vertices to be renumbered. The input external vertices are renumbered to internal vertices in-place. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>Number of vertices to be renumbered. </td></tr>
    <tr><td class="paramname">renumber_map_labels</td><td>Pointer to the external vertices corresponding to the internal vertices in the range [<code>local_int_vertex_first</code>, <code>local_int_vertex_last</code>). </td></tr>
    <tr><td class="paramname">local_int_vertex_first</td><td>The first local internal vertex (inclusive, assigned to this process in multi-GPU). </td></tr>
    <tr><td class="paramname">local_int_vertex_last</td><td>The last local internal vertex (exclusive, assigned to this process in multi-GPU). </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="af138b768b2b98f7c72d74fca7135f6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af138b768b2b98f7c72d74fca7135f6be">&nbsp;</a></span>scramble_vertex_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::scramble_vertex_ids </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>d_src_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>d_dst_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>vertex_id_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>scramble vertex ids in a graph </p>
<p>Given an edgelist for a graph, scramble all vertex ids by the given offset. This translation is done in place.</p>
<p>The scramble code here follows the algorithm in the Graph 500 reference implementation version 3.0.0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">d_src_v</td><td>Vector of source vertices </td></tr>
    <tr><td class="paramname">d_dst_v</td><td>Vector of destination vertices </td></tr>
    <tr><td class="paramname">vertex_id_offset</td><td>Offset to add to each vertex id </td></tr>
    <tr><td class="paramname">seed</td><td>Used to initialize random number generator </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a7242c3b7c0b51bae7bb6377e10b5f1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7242c3b7c0b51bae7bb6377e10b5f1c4">&nbsp;</a></span>sssp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::sssp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1legacy_1_1GraphCSRView.html">legacy::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WT *&nbsp;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT *&nbsp;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VT&nbsp;</td>
          <td class="paramname"><em>source_vertex</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Native sssp with predecessors. </p>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md7"></a>
@file sssp.cu</h2>
<p>@Synopsis Performs a single source shortest path traversal of a graph starting from a vertex.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
    <tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>If set to a valid pointer, array of size V populated by distance of every vertex in the graph from the starting vertex. Memory is provided and owned by the caller.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">predecessors</td><td>If set to a valid pointer, array of size V populated by the SSSP predecessor of every vertex. Memory is provided and owned by the caller.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_vertex</td><td>The starting vertex for SSSP </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a77988dffedeb1ec7b5d1fa588f5267ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77988dffedeb1ec7b5d1fa588f5267ec">&nbsp;</a></span>sssp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::sssp </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t *&nbsp;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>source_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weight_t&nbsp;</td>
          <td class="paramname"><em>cutoff</em> = <code>std::numeric_limits&lt;&nbsp;weight_t&nbsp;&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Run single-source shortest-path to compute the minimum distances (and predecessors) from the source vertex. </p>
<p>This function computes the distances (minimum edge weight sums) from the source vertex. If <code>predecessors</code> is not <code>nullptr</code>, this function calculates the predecessor of each vertex in the shortest-path as well. Graph edge weights should be non-negative.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>on erroneous input arguments.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object. </td></tr>
    <tr><td class="paramname">distances</td><td>Pointer to the output distance array. </td></tr>
    <tr><td class="paramname">predecessors</td><td>Pointer to the output predecessor array or <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">source_vertex</td><td>Source vertex to start single-source shortest-path. In a multi-gpu context the source vertex should be local to this GPU. </td></tr>
    <tr><td class="paramname">cutoff</td><td>Single-source shortest-path terminates if no more vertices are reachable within the distance of <code>cutoff</code>. Any vertex farther than <code>cutoff</code> will be marked as unreachable. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a35166b1ee111f0ff757d850eb89fb70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35166b1ee111f0ff757d850eb89fb70a">&nbsp;</a></span>symmetrize_edgelist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename weight_t , bool store_transposed, bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt; cugraph::symmetrize_edgelist </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; rmm::device_uvector&lt; weight_t &gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>reciprocal</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Symmetrize edgelist. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">store_transposed</td><td>Flag indicating whether to store the graph adjacency matrix as is or as transposed. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">edgelist_rows</td><td>Vector of edge row (source) vertex IDs. If multi-GPU, applying the compute_gpu_id_from_edge_t to every edge should return the local GPU ID for this function to work (edges should be pre-shuffled). </td></tr>
    <tr><td class="paramname">edgelist_cols</td><td>Vector of edge column (destination) vertex IDs. </td></tr>
    <tr><td class="paramname">edgelist_weights</td><td>Vector of edge weights. </td></tr>
    <tr><td class="paramname">reciprocal</td><td>Flag indicating whether to keep (if set to <code>false</code>) or discard (if set to <code>true</code>) edges that appear only in one direction. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;, std::optional&lt;rmm::device_uvector&lt;weight_t&gt;&gt;&gt; Tuple of symmetrized rows, columns, and optional weights (if <code>edgelist_weights</code> is valid). </dd></dl>

</div>
</div>
<a id="a635904784593c7a65aa80e9dd14cde1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635904784593c7a65aa80e9dd14cde1c">&nbsp;</a></span>symmetrize_edgelist_from_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename weight_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt; cugraph::symmetrize_edgelist_from_triangular </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>d_src_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>d_dst_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; rmm::device_uvector&lt; weight_t &gt;&gt; &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>optional_d_weights_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>check_diagonal</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>symmetrize an edgelist from the edges in the lower (or upper but not both) triangular part of a graph adjacency matrix </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of weights. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">d_src_v</td><td>Vector of source vertices </td></tr>
    <tr><td class="paramname">d_dst_v</td><td>Vector of destination vertices </td></tr>
    <tr><td class="paramname">d_weights_v</td><td>Optional vector of edge weights </td></tr>
    <tr><td class="paramname">check_diagonal</td><td>Flag indicating whether to check for diagonal edges or not. If set to true, symmetrize only the edges with source != destination (to avoid duplicating every self-loops). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>

</div>
</div>
<a id="aaf698d4569a93c1c25213f924354d0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf698d4569a93c1c25213f924354d0a8">&nbsp;</a></span>transform_reduce_by_adj_matrix_col_key_e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename AdjMatrixColKeyInputWrapper , typename EdgeOp , typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">auto cugraph::transform_reduce_by_adj_matrix_col_key_e </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColKeyInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_key_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOp&nbsp;</td>
          <td class="paramname"><em>e_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Iterate over the entire set of edges and reduce <code>edge_op</code> outputs to (key, value) pairs. </p>
<p>This function is inspired by thrust::transform_reduce() and thrust::reduce_by_key(). Keys for edges are determined by the graph adjacency matrix columns.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColKeyInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column keys. </td></tr>
    <tr><td class="paramname">EdgeOp</td><td>Type of the quaternary (or quinary) edge operator. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the values in (key, value) pairs. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_input</td><td>Device-copyable wrapper used to access column input properties (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view() (if <code>e_op</code> needs to access column properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access column properties). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_key_input</td><td>Device-copyable wrapper used to access column keys(for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view(). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">e_op</td><td>Quaternary (or quinary) operator takes edge source, edge destination, (optional edge weight), properties for the row (i.e. source), and properties for the column (i.e. destination) and returns a transformed value to be reduced. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the value in each transform-reduced (key, value) pair. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple Tuple of rmm::device_uvector&lt;typename GraphView::vertex_type&gt; and rmm::device_uvector&lt;T&gt; (if T is arithmetic scalar) or a tuple of rmm::device_uvector objects (if T is a thrust::tuple type of arithmetic scalar types, one rmm::device_uvector object per scalar type). </dd></dl>

</div>
</div>
<a id="ada05e18661d1011f3a255fdeffa39479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada05e18661d1011f3a255fdeffa39479">&nbsp;</a></span>transform_reduce_by_adj_matrix_row_key_e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename AdjMatrixRowKeyInputWrapper , typename EdgeOp , typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">auto cugraph::transform_reduce_by_adj_matrix_row_key_e </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowKeyInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_key_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOp&nbsp;</td>
          <td class="paramname"><em>e_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Iterate over the entire set of edges and reduce <code>edge_op</code> outputs to (key, value) pairs. </p>
<p>This function is inspired by thrust::transform_reduce() and thrust::reduce_by_key(). Keys for edges are determined by the graph adjacency matrix rows.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixRowKeyInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row keys. </td></tr>
    <tr><td class="paramname">EdgeOp</td><td>Type of the quaternary (or quinary) edge operator. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the values in (key, value) pairs. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_input</td><td>Device-copyable wrapper used to access column input properties (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view() (if <code>e_op</code> needs to access column properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access column properties). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_row_key_input</td><td>Device-copyable wrapper used to access row keys(for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view(). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">e_op</td><td>Quaternary (or quinary) operator takes edge source, edge destination, (optional edge weight), properties for the row (i.e. source), and properties for the column (i.e. destination) and returns a transformed value to be reduced. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the value in each transform-reduced (key, value) pair. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple Tuple of rmm::device_uvector&lt;typename GraphView::vertex_type&gt; and rmm::device_uvector&lt;T&gt; (if T is arithmetic scalar) or a tuple of rmm::device_uvector objects (if T is a thrust::tuple type of arithmetic scalar types, one rmm::device_uvector object per scalar type). </dd></dl>

</div>
</div>
<a id="ad5857a3c37a0a082ca091cca563aaeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5857a3c37a0a082ca091cca563aaeb2">&nbsp;</a></span>transform_reduce_e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp , typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">T cugraph::transform_reduce_e </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOp&nbsp;</td>
          <td class="paramname"><em>e_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Iterate over the entire set of edges and reduce <code>edge_op</code> outputs. </p>
<p>This function is inspired by thrust::transform_reduce().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column input properties. </td></tr>
    <tr><td class="paramname">EdgeOp</td><td>Type of the quaternary (or quinary) edge operator. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the initial value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_input</td><td>Device-copyable wrapper used to access column input properties (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view() (if <code>e_op</code> needs to access column properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access column properties). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">e_op</td><td>Quaternary (or quinary) operator takes edge source, edge destination, (optional edge weight), properties for the row (i.e. source), and properties for the column (i.e. destination) and returns a value to be reduced. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the transform-reduced input vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T Reduction of the <code>edge_op</code> outputs. </dd></dl>

</div>
</div>
<a id="a58cd28238cf2744964acd78007b1c11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cd28238cf2744964acd78007b1c11b">&nbsp;</a></span>transform_reduce_v() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename InputIterator , typename VertexOp , typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">T cugraph::transform_reduce_v </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"><em>input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"><em>input_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexOp&nbsp;</td>
          <td class="paramname"><em>v_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em> = <code>T{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::comms::op_t&nbsp;</td>
          <td class="paramname"><em>op</em> = <code>raft::comms::op_t::SUM</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Apply an operator to the vertex properties and reduce. </p>
<p>This version (conceptually) iterates over only a subset of the graph vertices. This function actually works as thrust::transform_reduce() on [<code>input_first</code>, <code>input_last</code>) (followed by inter-process reduction in multi-GPU).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Type of the iterator for input values. </td></tr>
    <tr><td class="paramname">VertexOp</td><td></td></tr>
    <tr><td class="paramname">T</td><td>Type of the initial value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">input_first</td><td>Iterator pointing to the beginning (inclusive) of the values to be passed to <code>v_op</code>. </td></tr>
    <tr><td class="paramname">input_last</td><td>Iterator pointing to the end (exclusive) of the values to be passed to <code>v_op</code>. </td></tr>
    <tr><td class="paramname">v_op</td><td>Unary operator takes *(<code>input_first</code> + i) (where i is [0, <code>input_last</code> - <code>input_first</code>)) and returns a transformed value to be reduced. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the transform-reduced input vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T Reduction of the <code>v_op</code> outputs. </dd></dl>

</div>
</div>
<a id="a0e7e61c7e241227b475e054174f99def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7e61c7e241227b475e054174f99def">&nbsp;</a></span>transform_reduce_v() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename VertexValueInputIterator , typename VertexOp , typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">T cugraph::transform_reduce_v </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueInputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexOp&nbsp;</td>
          <td class="paramname"><em>v_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::comms::op_t&nbsp;</td>
          <td class="paramname"><em>op</em> = <code>raft::comms::op_t::SUM</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Apply an operator to the vertex properties and reduce. </p>
<p>This version iterates over the entire set of graph vertices. This function is inspired by thrust::transform_reduce().</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">VertexValueInputIterator</td><td>Type of the iterator for vertex properties. </td></tr>
    <tr><td class="paramname">VertexOp</td><td>Type of the unary vertex operator. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the initial value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">vertex_value_input_first</td><td>Iterator pointing to the vertex properties for the first (inclusive) vertex (assigned to this process in multi-GPU). <code>vertex_value_input_last</code> (exclusive) is deduced as <code>vertex_value_input_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">v_op</td><td>Unary operator takes *(<code>vertex_value_input_first</code> + i) (where i is [0, <code>graph_view.get_number_of_local_vertices()</code>)) and returns a transformed value to be reduced. </td></tr>
    <tr><td class="paramname">init</td><td>Initial value to be added to the transform-reduced input vertex properties. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T Reduction of the <code>v_op</code> outputs. </dd></dl>

</div>
</div>
<a id="aa7b7a7d3c7feeb4c367ad02b80d6df05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b7a7d3c7feeb4c367ad02b80d6df05">&nbsp;</a></span>unrenumber_int_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::unrenumber_int_vertices </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>renumber_map_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vertex_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>vertex_partition_lasts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unrenumber (possibly non-local) internal vertices to external vertices based on the providied <code>renumber_map_labels</code>. </p>
<p>Note cugraph::invalid_id&lt;vertex_t&gt;::value remains unchanged.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">vertices</td><td>Pointer to the internal vertices to be unrenumbered. The input internal vertices are renumbered to external vertices in-place. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>Number of vertices to be unrenumbered. </td></tr>
    <tr><td class="paramname">renumber_map_labels</td><td>Pointer to the external vertices corresponding to the internal vertices in the range [<code>local_int_vertex_first</code>, <code>local_int_vertex_last</code>). </td></tr>
    <tr><td class="paramname">vertex_partition_lasts</td><td>Last local internal vertices (exclusive, assigned to each process in multi-GPU). </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a14d7f0ff2d4c0d3d657c33c4577d6ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d7f0ff2d4c0d3d657c33c4577d6ef3">&nbsp;</a></span>unrenumber_local_int_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , bool store_transposed, bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::enable_if_t&lt; multi_gpu, void &gt; cugraph::unrenumber_local_int_edges </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vertex_t * &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vertex_t * &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_edge_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>renumber_map_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vertex_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>vertex_partition_lasts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::vector&lt; std::vector&lt; size_t &gt;&gt;&gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>edgelist_intra_partition_segment_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unrenumber local edges' internal source &amp; destination IDs to external IDs based on the provided <code>renumber_map_labels</code> (multi-GPU). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">store_transposed</td><td>Flag indicating whether to store the graph adjacency matrix as is or as transposed. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. @params edgelist_rows Pointers (one pointer per local graph adjacency matrix partition assigned to this process) to the local internal row (source) vertex IDs to be unrenumbered. The input row (source) vertex Ids are renumbered to external IDs in-place. @params edgelist_cols Pointers (one pointer per local graph adjacency matrix partition assigned to this process) to the local internal column (destination) vertex IDs to be unrenumbered. The input column (destination) vertex Ids are renumbered to external IDs in-place. </td></tr>
    <tr><td class="paramname">edgelist_edge_counts</td><td>Edge counts (one count per local graph adjacency matrix partition assigned to this process). </td></tr>
    <tr><td class="paramname">renumber_map_labels</td><td>Pointer to the external vertices corresponding to the internal vertices in the range assigned to this process. </td></tr>
    <tr><td class="paramname">vertex_partition_lasts</td><td>Last local internal vertices (exclusive, assigned to each process in multi-GPU). </td></tr>
    <tr><td class="paramname">edgelist_intra_partition_segment_offsets</td><td>If valid, store segment offsets within a local graph adjacency matrix partition; a local partition can be further segmented by applying the compute_gpu_id_from_vertex_t function to edge minor vertex IDs. This optinoal information is used for further memory footprint optimization if provided. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ac3613b6995638d34ff5d7a8be5e355e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3613b6995638d34ff5d7a8be5e355e8">&nbsp;</a></span>unrenumber_local_int_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , bool store_transposed, bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::enable_if_t&lt;!multi_gpu, void &gt; cugraph::unrenumber_local_int_edges </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>edgelist_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>edgelist_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>num_edgelist_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>renumber_map_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unrenumber local edges' internal source &amp; destination IDs to external IDs based on the provided <code>renumber_map_labels</code> (single-GPU). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">store_transposed</td><td>Flag indicating whether to store the graph adjacency matrix as is or as transposed. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. @params edgelist_rows Pointer to the local internal row (source) vertex IDs to be unrenumbered. The input row (source) vertex Ids are renumbered to external IDs in-place. @params edgelist_cols Pointer to the local internal column (destination) vertex IDs to be unrenumbered. The input column (destination) vertex Ids are renumbered to external IDs in-place. </td></tr>
    <tr><td class="paramname">num_edgelist_edges</td><td>Number of edges in the edge list. </td></tr>
    <tr><td class="paramname">renumber_map_labels</td><td>Pointer to the external vertices corresponding to the internal vertices. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>Number of vertices to be unrenumbered. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ab2d2829de3b33d7f394c8a1ff5169ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d2829de3b33d7f394c8a1ff5169ca5">&nbsp;</a></span>unrenumber_local_int_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::unrenumber_local_int_vertices </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t const *&nbsp;</td>
          <td class="paramname"><em>renumber_map_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>local_int_vertex_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t&nbsp;</td>
          <td class="paramname"><em>local_int_vertex_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Unrenumber local internal vertices to external vertices based on the providied <code>renumber_map_labels</code>. </p>
<p>Note cugraph::invalid_id&lt;vertex_t&gt;::value remains unchanged.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">vertices</td><td>Pointer to the local internal vertices to be unrenumbered. Each input element should be in [<code>local_int_vertex_first</code>, <code>local_int_vertex_last</code>). The input internal vertices are renumbered to external vertices in-place. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>Number of vertices to be unrenumbered. </td></tr>
    <tr><td class="paramname">renumber_map_labels</td><td>Pointer to the external vertices corresponding to the internal vertices in the range [<code>local_int_vertex_first</code>, <code>local_int_vertex_last</code>). </td></tr>
    <tr><td class="paramname">local_int_vertex_first</td><td>The first local internal vertex (inclusive, assigned to this process in multi-GPU). </td></tr>
    <tr><td class="paramname">local_int_vertex_last</td><td>The last local internal vertex (exclusive, assigned to this process in multi-GPU). </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ad18b474e61601d1b82dad8dd10d7f505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18b474e61601d1b82dad8dd10d7f505">&nbsp;</a></span>update_frontier_v_push_if_out_nbr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphViewType , typename VertexFrontierType , typename AdjMatrixRowValueInputWrapper , typename AdjMatrixColValueInputWrapper , typename EdgeOp , typename ReduceOp , typename VertexValueInputIterator , typename VertexValueOutputIterator , typename VertexOp &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::update_frontier_v_push_if_out_nbr </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphViewType const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexFrontierType &amp;&nbsp;</td>
          <td class="paramname"><em>frontier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>cur_frontier_bucket_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>next_frontier_bucket_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixRowValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_row_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjMatrixColValueInputWrapper&nbsp;</td>
          <td class="paramname"><em>adj_matrix_col_value_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeOp&nbsp;</td>
          <td class="paramname"><em>e_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOp&nbsp;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueInputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_input_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexValueOutputIterator&nbsp;</td>
          <td class="paramname"><em>vertex_value_output_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexOp&nbsp;</td>
          <td class="paramname"><em>v_op</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Update (tagged-)vertex frontier and (tagged-)vertex property values iterating over the outgoing edges from the frontier. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">GraphViewType</td><td>Type of the passed non-owning graph object. </td></tr>
    <tr><td class="paramname">VertexFrontierType</td><td>Type of the vertex frontier class which abstracts vertex frontier managements. </td></tr>
    <tr><td class="paramname">AdjMatrixRowValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix row input properties. </td></tr>
    <tr><td class="paramname">AdjMatrixColValueInputWrapper</td><td>Type of the wrapper for graph adjacency matrix column input properties. </td></tr>
    <tr><td class="paramname">EdgeOp</td><td>Type of the quaternary (or quinary) edge operator. </td></tr>
    <tr><td class="paramname">ReduceOp</td><td>Type of the binary reduction operator. </td></tr>
    <tr><td class="paramname">VertexValueInputIterator</td><td>Type of the iterator for vertex properties. </td></tr>
    <tr><td class="paramname">VertexValueOutputIterator</td><td>Type of the iterator for vertex property variables. </td></tr>
    <tr><td class="paramname">VertexOp</td><td>Type of the binary vertex operator. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Non-owning graph object. </td></tr>
    <tr><td class="paramname">frontier</td><td><a class="el" href="classcugraph_1_1VertexFrontier.html">VertexFrontier</a> class object for vertex frontier managements. This object includes multiple bucket objects. </td></tr>
    <tr><td class="paramname">cur_frontier_bucket_idx</td><td>Index of the <a class="el" href="classcugraph_1_1VertexFrontier.html">VertexFrontier</a> bucket holding vertices for the current iteration. </td></tr>
    <tr><td class="paramname">next_frontier_bucket_indices</td><td>Indices of the <a class="el" href="classcugraph_1_1VertexFrontier.html">VertexFrontier</a> buckets to store new frontier vertices for the next iteration. </td></tr>
    <tr><td class="paramname">adj_matrix_row_value_input</td><td>Device-copyable wrapper used to access row input properties (for the rows assigned to this process in multi-GPU). Use either cugraph::row_properties_t::device_view() (if <code>e_op</code> needs to access row properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access row properties). Use copy_to_adj_matrix_row to fill the wrapper. </td></tr>
    <tr><td class="paramname">adj_matrix_col_value_input</td><td>Device-copyable wrapper used to access column input properties (for the columns assigned to this process in multi-GPU). Use either cugraph::col_properties_t::device_view() (if <code>e_op</code> needs to access column properties) or cugraph::dummy_properties_t::device_view() (if <code>e_op</code> does not access column properties). Use copy_to_adj_matrix_col to fill the wrapper. </td></tr>
    <tr><td class="paramname">e_op</td><td>Quaternary (or quinary) operator takes edge source, edge destination, (optional edge weight), properties for the row (i.e. source), and properties for the column (i.e. destination) and returns a value to be reduced the <code>reduce_op</code>. </td></tr>
    <tr><td class="paramname">reduce_op</td><td>Binary operator takes two input arguments and reduce the two variables to one. </td></tr>
    <tr><td class="paramname">vertex_value_input_first</td><td>Iterator pointing to the vertex properties for the first (inclusive) vertex (assigned to this process in multi-GPU). <code>vertex_value_input_last</code> (exclusive) is deduced as <code>vertex_value_input_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">vertex_value_output_first</td><td>Iterator pointing to the vertex property variables for the first (inclusive) vertex (assigned to tihs process in multi-GPU). <code>vertex_value_output_last</code> (exclusive) is deduced as <code>vertex_value_output_first</code> + <code>graph_view.get_number_of_local_vertices()</code>. </td></tr>
    <tr><td class="paramname">v_op</td><td>Ternary operator takes (tagged-)vertex ID, *(<code>vertex_value_input_first</code> + i) (where i is [0, <code>graph_view.get_number_of_local_vertices()</code>)) and reduced value of the <code>e_op</code> outputs for this vertex and returns the target bucket index (for frontier update) and new verrtex property values (to update *(<code>vertex_value_output_first</code> + i)). The target bucket index should either be VertexFrontierType::kInvalidBucketIdx or an index in <code>next_frontier_bucket_indices</code>. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a8a74317d58e73cb48b1240070e9a1c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a74317d58e73cb48b1240070e9a1c44">&nbsp;</a></span>weakly_connected_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , bool multi_gpu&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cugraph::weakly_connected_components </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugraph_1_1graph__view__t.html">graph_view_t</a>&lt; vertex_t, edge_t, weight_t, false, multi_gpu &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>graph_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_t *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_expensive_check</em> = <code>false</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Finds (weakly-connected-)component IDs of each vertices in the input graph. </p>
<p>The input graph must be symmetric. Component IDs can be arbitrary integers (they can be non-consecutive and are not ordered by component size or any other criterion).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Needs to be an integral type. </td></tr>
    <tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
    <tr><td class="paramname">multi_gpu</td><td>Flag indicating whether template instantiation should target single-GPU (false) or multi-GPU (true). </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
    <tr><td class="paramname">graph_view</td><td>Graph view object. </td></tr>
    <tr><td class="paramname">components</td><td>Pointer to the output component ID array. </td></tr>
    <tr><td class="paramname">do_expensive_check</td><td>A flag to run expensive checks for input arguments (if set to <code>true</code>). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body></html>