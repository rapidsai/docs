<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.20" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>libcugraph: cugraph::experimental::partition_t&lt; vertex_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcugraph</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (0.17)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcugraph/nightly">nightly (0.19)</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">stable (0.18)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcugraph/legacy">legacy (0.17)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="navpath" id="nav-path">
<ul>
<li class="navelem"><a class="el" href="namespacecugraph.html">cugraph</a></li><li class="navelem"><b>experimental</b></li><li class="navelem"><a class="el" href="classcugraph_1_1experimental_1_1partition__t.html">partition_t</a></li> </ul>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="classcugraph_1_1experimental_1_1partition__t-members.html">List of all members</a> </div>
<div class="headertitle">
<div class="title">cugraph::experimental::partition_t&lt; vertex_t &gt; Class Template Reference</div> </div>
</div><!--header-->
<div class="contents">
<p>store vertex partitioning map  
 <a href="classcugraph_1_1experimental_1_1partition__t.html#details">More...</a></p>
<p><code>#include &lt;<a class="el" href="graph__view_8hpp_source.html">graph_view.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcf46847057c24cde68d204d00668cd2"><td align="right" class="memItemLeft" valign="top"><a id="adcf46847057c24cde68d204d00668cd2"></a>
 </td><td class="memItemRight" valign="bottom"><b>partition_t</b> (std::vector&lt; vertex_t &gt; const &amp;vertex_partition_offsets, bool hypergraph_partitioned, int row_comm_size, int col_comm_size, int row_comm_rank, int col_comm_rank)</td></tr>
<tr class="separator:adcf46847057c24cde68d204d00668cd2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a751b0cf6b85a136d3a70387222c00916"><td align="right" class="memItemLeft" valign="top"><a id="a751b0cf6b85a136d3a70387222c00916"></a>
int </td><td class="memItemRight" valign="bottom"><b>get_row_size</b> () const</td></tr>
<tr class="separator:a751b0cf6b85a136d3a70387222c00916"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e57d72d4378e9529a0163563f46c7e5"><td align="right" class="memItemLeft" valign="top"><a id="a5e57d72d4378e9529a0163563f46c7e5"></a>
int </td><td class="memItemRight" valign="bottom"><b>get_col_size</b> () const</td></tr>
<tr class="separator:a5e57d72d4378e9529a0163563f46c7e5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38e918e647776cbe235718043511cdc2"><td align="right" class="memItemLeft" valign="top"><a id="a38e918e647776cbe235718043511cdc2"></a>
int </td><td class="memItemRight" valign="bottom"><b>get_comm_rank</b> () const</td></tr>
<tr class="separator:a38e918e647776cbe235718043511cdc2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a371495e3e89229d9839dcfb65b726c54"><td align="right" class="memItemLeft" valign="top"><a id="a371495e3e89229d9839dcfb65b726c54"></a>
std::vector&lt; vertex_t &gt; const  &amp; </td><td class="memItemRight" valign="bottom"><b>get_vertex_partition_offsets</b> () const</td></tr>
<tr class="separator:a371495e3e89229d9839dcfb65b726c54"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac05238b5f0e4de8474c4c583dec5fa98"><td align="right" class="memItemLeft" valign="top"><a id="ac05238b5f0e4de8474c4c583dec5fa98"></a>
std::tuple&lt; vertex_t, vertex_t &gt; </td><td class="memItemRight" valign="bottom"><b>get_local_vertex_range</b> () const</td></tr>
<tr class="separator:ac05238b5f0e4de8474c4c583dec5fa98"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aef4c4b2df913f7508e1e70710beca9fb"><td align="right" class="memItemLeft" valign="top"><a id="aef4c4b2df913f7508e1e70710beca9fb"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_local_vertex_first</b> () const</td></tr>
<tr class="separator:aef4c4b2df913f7508e1e70710beca9fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3942e46a8f224a92b89d3b2bbb526fea"><td align="right" class="memItemLeft" valign="top"><a id="a3942e46a8f224a92b89d3b2bbb526fea"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_local_vertex_last</b> () const</td></tr>
<tr class="separator:a3942e46a8f224a92b89d3b2bbb526fea"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a49ee8002366460367b083f53877f237b"><td align="right" class="memItemLeft" valign="top"><a id="a49ee8002366460367b083f53877f237b"></a>
std::tuple&lt; vertex_t, vertex_t &gt; </td><td class="memItemRight" valign="bottom"><b>get_vertex_partition_range</b> (size_t vertex_partition_idx) const</td></tr>
<tr class="separator:a49ee8002366460367b083f53877f237b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac831e090eeb16761dc859372f5e090c1"><td align="right" class="memItemLeft" valign="top"><a id="ac831e090eeb16761dc859372f5e090c1"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_vertex_partition_first</b> (size_t vertex_partition_idx) const</td></tr>
<tr class="separator:ac831e090eeb16761dc859372f5e090c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6d9cc7de8f047c9826800beb4b11e6e1"><td align="right" class="memItemLeft" valign="top"><a id="a6d9cc7de8f047c9826800beb4b11e6e1"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_vertex_partition_last</b> (size_t vertex_partition_idx) const</td></tr>
<tr class="separator:a6d9cc7de8f047c9826800beb4b11e6e1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad18f4f75b61c7c60b203fe3afcd0af6c"><td align="right" class="memItemLeft" valign="top"><a id="ad18f4f75b61c7c60b203fe3afcd0af6c"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_vertex_partition_size</b> (size_t vertex_partition_idx) const</td></tr>
<tr class="separator:ad18f4f75b61c7c60b203fe3afcd0af6c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab54de3ab89161d2193d6a6e636d81676"><td align="right" class="memItemLeft" valign="top"><a id="ab54de3ab89161d2193d6a6e636d81676"></a>
size_t </td><td class="memItemRight" valign="bottom"><b>get_number_of_matrix_partitions</b> () const</td></tr>
<tr class="separator:ab54de3ab89161d2193d6a6e636d81676"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adcaf3904f47400ee6f4e5d3a8f7fbd86"><td align="right" class="memItemLeft" valign="top"><a id="adcaf3904f47400ee6f4e5d3a8f7fbd86"></a>
std::tuple&lt; vertex_t, vertex_t &gt; </td><td class="memItemRight" valign="bottom"><b>get_matrix_partition_major_range</b> (size_t partition_idx) const</td></tr>
<tr class="separator:adcaf3904f47400ee6f4e5d3a8f7fbd86"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adfc1ab9ace02cf33d2006cbe1de803be"><td align="right" class="memItemLeft" valign="top"><a id="adfc1ab9ace02cf33d2006cbe1de803be"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_matrix_partition_major_first</b> (size_t partition_idx) const</td></tr>
<tr class="separator:adfc1ab9ace02cf33d2006cbe1de803be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3e2fd6e644351522128f84aa62e66538"><td align="right" class="memItemLeft" valign="top"><a id="a3e2fd6e644351522128f84aa62e66538"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_matrix_partition_major_last</b> (size_t partition_idx) const</td></tr>
<tr class="separator:a3e2fd6e644351522128f84aa62e66538"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a956a1482ab8282823b79b6fd975015"><td align="right" class="memItemLeft" valign="top"><a id="a4a956a1482ab8282823b79b6fd975015"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_matrix_partition_major_value_start_offset</b> (size_t partition_idx) const</td></tr>
<tr class="separator:a4a956a1482ab8282823b79b6fd975015"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a93292f5f11e34afd0e915874c03cc93d"><td align="right" class="memItemLeft" valign="top"><a id="a93292f5f11e34afd0e915874c03cc93d"></a>
std::tuple&lt; vertex_t, vertex_t &gt; </td><td class="memItemRight" valign="bottom"><b>get_matrix_partition_minor_range</b> () const</td></tr>
<tr class="separator:a93292f5f11e34afd0e915874c03cc93d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab5bd223a07b2037ee2784148c9f87edb"><td align="right" class="memItemLeft" valign="top"><a id="ab5bd223a07b2037ee2784148c9f87edb"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_matrix_partition_minor_first</b> () const</td></tr>
<tr class="separator:ab5bd223a07b2037ee2784148c9f87edb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab9fb2468076cd8b7805d1396f5599ec2"><td align="right" class="memItemLeft" valign="top"><a id="ab9fb2468076cd8b7805d1396f5599ec2"></a>
vertex_t </td><td class="memItemRight" valign="bottom"><b>get_matrix_partition_minor_last</b> () const</td></tr>
<tr class="separator:ab9fb2468076cd8b7805d1396f5599ec2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5a48725526c41fa49821f4b180d213dc"><td align="right" class="memItemLeft" valign="top"><a id="a5a48725526c41fa49821f4b180d213dc"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_hypergraph_partitioned</b> () const</td></tr>
<tr class="separator:a5a48725526c41fa49821f4b180d213dc"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename vertex_t&gt;<br/>
class cugraph::experimental::partition_t&lt; vertex_t &gt;</h3>
<p>store vertex partitioning map </p>
<p>Say P = P_row * P_col GPUs. For communication, we need P_row row communicators of size P_col and P_col column communicators of size P_row. row_comm_size = P_col and col_comm_size = P_row. row_comm_rank &amp; col_comm_rank are ranks within the row &amp; column communicators, respectively.</p>
<p>We need to partition 1D vertex arrays (storing per vertex values) and the 2D graph adjacency matrix (or transposed 2D graph adjacency matrix) of G. An 1D vertex array of size V is divided to P linear partitions; each partition has the size close to V / P. We consider two different strategies to partition the 2D matrix: the default strategy and the hypergraph partitioning based strategy (the latter is for future extension). FIXME: in the future we may use the latter for both as this leads to simpler communication patterns and better control over parallelism vs memory footprint trade-off.</p>
<p>In the default case, one GPU will be responsible for 1 rectangular partition. The matrix will be horizontally partitioned first to P_row slabs. Each slab will be further vertically partitioned to P_col rectangles. Each rectangular partition will have the size close to V / P_row by V / P_col.</p>
<p>To be more specific, a GPU with (col_comm_rank, row_comm_rank) will be responsible for one rectangular partition [a,b) by [c,d) where a = vertex_partition_offsets[row_comm_size * col_comm_rank], b = vertex_partition_offsets[row_comm_size * (col_comm_rank + 1)], c = vertex_partition_offsets[col_comm_size * row_comm_rank], and d = vertex_partition_offsets[col_comm_size * (row_comm_rank + 1)].</p>
<p>In the future, we may apply hyper-graph partitioning to divide V vertices to P groups minimizing edge cuts across groups while balancing the number of vertices in each group. We will also renumber vertices so the vertices in each group are mapped to consecutive integers. Then, there will be more non-zeros in the diagonal partitions of the 2D graph adjacency matrix (or the transposed 2D graph adjacency matrix) than the off-diagonal partitions. The default strategy does not balance the number of nonzeros if hyper-graph partitioning is applied. To solve this problem, the matrix is first horizontally partitioned to P slabs, then each slab will be further vertically partitioned to P_row (instead of P_col in the default case) rectangles. One GPU will be responsible col_comm_size rectangular partitions in this case.</p>
<p>To be more specific, a GPU with (col_comm_rank, row_comm_rank) will be responsible for col_comm_size rectangular partitions [a_i,b_i) by [c,d) where a_i = vertex_partition_offsets[row_comm_size * i + row_comm_rank] and b_i = vertex_partition_offsets[row_comm_size * i + row_comm_rank + 1]. c is vertex_partition_offsets[row_comm_size * col_comm_rank] and d = vertex_partition_offsests[row_comm_size * (col_comm_rank + 1)].</p>
<p>See E. G. Boman et. al., “Scalable matrix computations on large scale-free graphs using 2D graph partitioning”, 2013 for additional detail.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">vertex_t</td><td>Type of vertex ID </td></tr>
</table>
</dd>
</dl>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="graph__view_8hpp_source.html">graph_view.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"/></a> 1.8.20
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
