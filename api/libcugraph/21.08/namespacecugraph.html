<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcugraph: cugraph Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcugraph</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (21.08)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcugraph/nightly">nightly (21.08)</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">stable (21.06)</a><a class="rapids-selector__menu-item" href="/api/libcugraph/legacy">legacy (0.19)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">cugraph Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">
<p>Katz Centrality implementation.  
<a href="namespacecugraph.html#details">More...</a></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecugraph_1_1ext__raft"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugraph_1_1ext__raft.html">ext_raft</a></td></tr>
<tr class="memdesc:namespacecugraph_1_1ext__raft"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper function for Nvgraph balanced cut clustering. <br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphCompressedSparseBase.html">GraphCompressedSparseBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for constructted graphs stored in CSR (Compressed Sparse Row) format or CSC (Compressed Sparse Column) format.  <a href="classcugraph_1_1GraphCompressedSparseBase.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphCompressedSparseBaseView.html">GraphCompressedSparseBaseView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for graph stored in CSR (Compressed Sparse Row) format or CSC (Compressed Sparse Column) format.  <a href="classcugraph_1_1GraphCompressedSparseBaseView.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constructed graph stored in COO (COOrdinate) format.  <a href="classcugraph_1_1GraphCOO.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1GraphCOOContents.html">GraphCOOContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TODO : Change this Take ownership of the provided graph arrays in COO format.  <a href="structcugraph_1_1GraphCOOContents.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A graph stored in COO (COOrdinate) format.  <a href="classcugraph_1_1GraphCOOView.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphCSC.html">GraphCSC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constructed graph stored in CSC (Compressed Sparse Column) format.  <a href="classcugraph_1_1GraphCSC.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphCSCView.html">GraphCSCView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A graph stored in CSC (Compressed Sparse Column) format.  <a href="classcugraph_1_1GraphCSCView.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constructed graph stored in CSR (Compressed Sparse Row) format.  <a href="classcugraph_1_1GraphCSR.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A graph stored in CSR (Compressed Sparse Row) format.  <a href="classcugraph_1_1GraphCSRView.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1GraphProperties.html">GraphProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1GraphSparseContents.html">GraphSparseContents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1GraphViewBase.html">GraphViewBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class graphs, all but vertices and edges.  <a href="classcugraph_1_1GraphViewBase.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__edge__id.html">invalid_edge_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__idx.html">invalid_idx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__idx_3_01T_00_01typename_01std_1_1enable__if__t_3_01std_1_1is__integrala86ae2d93d44d918b9efbc21d0fbe771.html">invalid_idx&lt; T, typename std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__idx_3_01T_00_01typename_01std_1_1enable__if__t_3_01std_1_1is__integral45babf51909e2de1c13670b29d67cf51.html">invalid_idx&lt; T, typename std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1invalid__vertex__id.html">invalid_vertex_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1Leiden.html">Leiden</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when logical precondition is violated.  <a href="structcugraph_1_1logic__error.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a365647c6c8b681e9af24661537ee6e27"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a> { <b>CUGRAPH_WEAK</b> = 0, 
<a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27a5882369885616cc6ba190202b140ee02">cugraph_cc_t::CUGRAPH_STRONG</a>, 
<a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27a436bdad1238dd6b8309bdbd0150c0e65">cugraph_cc_t::NUM_CONNECTIVITY_TYPES</a>
 }</td></tr>
<tr class="separator:a365647c6c8b681e9af24661537ee6e27"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a91489b4d246b221996c9c8941767630b"><td align="right" class="memItemLeft" valign="top"><a id="a91489b4d246b221996c9c8941767630b"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>PropType</b> { <b>PROP_UNDEF</b>, 
<b>PROP_FALSE</b>, 
<b>PROP_TRUE</b>
 }</td></tr>
<tr class="separator:a91489b4d246b221996c9c8941767630b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a31902d040f48ca34b65c041847c3cd98"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a31902d040f48ca34b65c041847c3cd98">DegreeDirection</a> { <b>IN_PLUS_OUT</b> = 0, 
<a class="el" href="namespacecugraph.html#a31902d040f48ca34b65c041847c3cd98ac86ee0d9d7ed3e7b4fdbf486fa6c0ebb">DegreeDirection::IN</a>, 
<a class="el" href="namespacecugraph.html#a31902d040f48ca34b65c041847c3cd98aef373774188a51f80463f37b6bd9e83a">DegreeDirection::OUT</a>, 
<a class="el" href="namespacecugraph.html#a31902d040f48ca34b65c041847c3cd98afa48476d9be3504d991897f564b32427">DegreeDirection::DEGREE_DIRECTION_COUNT</a>
 }</td></tr>
<tr class="separator:a31902d040f48ca34b65c041847c3cd98"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1ac5777ac96f1f7ecef0c3c2aee6d711"><td align="right" class="memItemLeft" valign="top"><a id="a1ac5777ac96f1f7ecef0c3c2aee6d711"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>generator_distribution_t</b> { <b>POWER_LAW</b> = 0, 
<b>UNIFORM</b>
 }</td></tr>
<tr class="separator:a1ac5777ac96f1f7ecef0c3c2aee6d711"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afa8eadf92af49adf18fe1403b7c5d62e"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t &gt; </td></tr>
<tr class="memitem:afa8eadf92af49adf18fe1403b7c5d62e"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#afa8eadf92af49adf18fe1403b7c5d62e">betweenness_centrality</a> (const raft::handle_t &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;graph, result_t *result, bool normalized=true, bool endpoints=false, weight_t const *weight=nullptr, vertex_t k=0, vertex_t const *vertices=nullptr)</td></tr>
<tr class="memdesc:afa8eadf92af49adf18fe1403b7c5d62e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute betweenness centrality for a graph.  <a href="namespacecugraph.html#afa8eadf92af49adf18fe1403b7c5d62e">More...</a><br></td></tr>
<tr class="separator:afa8eadf92af49adf18fe1403b7c5d62e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9759187f6fd2f83b25b009e9b77b4d2c"><td align="right" class="memItemLeft" valign="top"><a id="a9759187f6fd2f83b25b009e9b77b4d2c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>betweenness_centrality&lt; int, int, float, float &gt;</b> (const raft::handle_t &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, float &gt; const &amp;, float *, bool, bool, float const *, int, int const *)</td></tr>
<tr class="separator:a9759187f6fd2f83b25b009e9b77b4d2c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af8969e93755bf3c17fa7685486f0f7de"><td align="right" class="memItemLeft" valign="top"><a id="af8969e93755bf3c17fa7685486f0f7de"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>betweenness_centrality&lt; int, int, double, double &gt;</b> (const raft::handle_t &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, double &gt; const &amp;, double *, bool, bool, double const *, int, int const *)</td></tr>
<tr class="separator:af8969e93755bf3c17fa7685486f0f7de"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a74ceda7a5e01d0d2b31ebc128fd4dfa0"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t &gt; </td></tr>
<tr class="memitem:a74ceda7a5e01d0d2b31ebc128fd4dfa0"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a74ceda7a5e01d0d2b31ebc128fd4dfa0">edge_betweenness_centrality</a> (const raft::handle_t &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;graph, result_t *result, bool normalized=true, weight_t const *weight=nullptr, vertex_t k=0, vertex_t const *vertices=nullptr)</td></tr>
<tr class="memdesc:a74ceda7a5e01d0d2b31ebc128fd4dfa0"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute edge betweenness centrality for a graph.  <a href="namespacecugraph.html#a74ceda7a5e01d0d2b31ebc128fd4dfa0">More...</a><br></td></tr>
<tr class="separator:a74ceda7a5e01d0d2b31ebc128fd4dfa0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acc93d1820527815706474d41b40d730e"><td align="right" class="memItemLeft" valign="top"><a id="acc93d1820527815706474d41b40d730e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>edge_betweenness_centrality&lt; int, int, float, float &gt;</b> (const raft::handle_t &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, float &gt; const &amp;, float *, bool, float const *, int, int const *)</td></tr>
<tr class="separator:acc93d1820527815706474d41b40d730e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac2a7ceb2cd0aa69933022ed574d17c60"><td align="right" class="memItemLeft" valign="top"><a id="ac2a7ceb2cd0aa69933022ed574d17c60"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>edge_betweenness_centrality&lt; int, int, double, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, double &gt; const &amp;, double *, bool, double const *, int, int const *)</td></tr>
<tr class="separator:ac2a7ceb2cd0aa69933022ed574d17c60"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaba8880b35e0a04f7e216a43ea180fa9"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT , typename result_t &gt; </td></tr>
<tr class="memitem:aaba8880b35e0a04f7e216a43ea180fa9"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aaba8880b35e0a04f7e216a43ea180fa9">katz_centrality</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, result_t *result, double alpha, int max_iter, double tol, bool has_guess, bool normalized)</td></tr>
<tr class="memdesc:aaba8880b35e0a04f7e216a43ea180fa9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the Katz centrality for the nodes of the graph G.  <a href="namespacecugraph.html#aaba8880b35e0a04f7e216a43ea180fa9">More...</a><br></td></tr>
<tr class="separator:aaba8880b35e0a04f7e216a43ea180fa9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aed9ff7b26e642f4ec8ce3c3aa9efe537"><td align="right" class="memItemLeft" valign="top"><a id="aed9ff7b26e642f4ec8ce3c3aa9efe537"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>katz_centrality&lt; int, int, float, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, float &gt; const &amp;, double *, double, int, double, bool, bool)</td></tr>
<tr class="separator:aed9ff7b26e642f4ec8ce3c3aa9efe537"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afb3648213e150cbe1c0e7a3a9fd40915"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:afb3648213e150cbe1c0e7a3a9fd40915"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#afb3648213e150cbe1c0e7a3a9fd40915">ecg</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;graph, weight_t min_weight, vertex_t ensemble_size, vertex_t *clustering)</td></tr>
<tr class="memdesc:afb3648213e150cbe1c0e7a3a9fd40915"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the ecg clustering of the given graph.  <a href="namespacecugraph.html#afb3648213e150cbe1c0e7a3a9fd40915">More...</a><br></td></tr>
<tr class="separator:afb3648213e150cbe1c0e7a3a9fd40915"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3c4a858e57fc20f7517b54dd8a23b19c"><td align="right" class="memItemLeft" valign="top"><a id="a3c4a858e57fc20f7517b54dd8a23b19c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ecg&lt; int32_t, int32_t, float &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;graph, float min_weight, int32_t ensemble_size, int32_t *clustering)</td></tr>
<tr class="separator:a3c4a858e57fc20f7517b54dd8a23b19c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a940e4ab2e18091548b59551a2838908f"><td align="right" class="memItemLeft" valign="top"><a id="a940e4ab2e18091548b59551a2838908f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ecg&lt; int32_t, int32_t, double &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;graph, double min_weight, int32_t ensemble_size, int32_t *clustering)</td></tr>
<tr class="separator:a940e4ab2e18091548b59551a2838908f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8055199c8d2f78e6c757e671a1b2f568"><td class="memTemplParams" colspan="2"><a id="a8055199c8d2f78e6c757e671a1b2f568"></a>
template&lt;typename vertex_t , bool multi_gpu&gt; </td></tr>
<tr class="memitem:a8055199c8d2f78e6c757e671a1b2f568"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>partition_at_level</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; vertex_t &gt; const &amp;dendrogram, vertex_t const *d_vertex_ids, vertex_t *d_partition, size_t level)</td></tr>
<tr class="separator:a8055199c8d2f78e6c757e671a1b2f568"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aae82739c377ed2fa66944475a901434b"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:aae82739c377ed2fa66944475a901434b"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; VT, ET, WT &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aae82739c377ed2fa66944475a901434b">k_truss_subgraph</a> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;graph, int k, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:aae82739c377ed2fa66944475a901434b"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute k truss for a graph.  <a href="namespacecugraph.html#aae82739c377ed2fa66944475a901434b">More...</a><br></td></tr>
<tr class="separator:aae82739c377ed2fa66944475a901434b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6ac0affd7e9830d704653ae27fd808c9"><td align="right" class="memItemLeft" valign="top"><a id="a6ac0affd7e9830d704653ae27fd808c9"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; int32_t, int32_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>k_truss_subgraph&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int, int, float &gt; const &amp;, int, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a6ac0affd7e9830d704653ae27fd808c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a313df33f11ea44b292998f07907de0b6"><td align="right" class="memItemLeft" valign="top"><a id="a313df33f11ea44b292998f07907de0b6"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; int32_t, int32_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>k_truss_subgraph&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int, int, double &gt; const &amp;, int, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a313df33f11ea44b292998f07907de0b6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af87fd2140039558d0764aecbf58ccfc5"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:af87fd2140039558d0764aecbf58ccfc5"><td align="right" class="memTemplItemLeft" valign="top">std::pair&lt; size_t, weight_t &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#af87fd2140039558d0764aecbf58ccfc5">leiden</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;graph, vertex_t *clustering, size_t max_iter=100, weight_t resolution=weight_t{1})</td></tr>
<tr class="memdesc:af87fd2140039558d0764aecbf58ccfc5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcugraph_1_1Leiden.html">Leiden</a> implementation.  <a href="namespacecugraph.html#af87fd2140039558d0764aecbf58ccfc5">More...</a><br></td></tr>
<tr class="separator:af87fd2140039558d0764aecbf58ccfc5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1fbdd626a80624369e3736f92592ea2d"><td align="right" class="memItemLeft" valign="top"><a id="a1fbdd626a80624369e3736f92592ea2d"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>leiden</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:a1fbdd626a80624369e3736f92592ea2d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a62bca790d5c41f68aed57c836423f54a"><td align="right" class="memItemLeft" valign="top"><a id="a62bca790d5c41f68aed57c836423f54a"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>leiden</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:a62bca790d5c41f68aed57c836423f54a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a467270ee534ba7cc7fcdd597dc582c0a"><td class="memTemplParams" colspan="2">template&lt;typename graph_view_t &gt; </td></tr>
<tr class="memitem:a467270ee534ba7cc7fcdd597dc582c0a"><td align="right" class="memTemplItemLeft" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; typename graph_view_t::vertex_type &gt; &gt;, typename graph_view_t::weight_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a467270ee534ba7cc7fcdd597dc582c0a">louvain</a> (raft::handle_t const &amp;handle, graph_view_t const &amp;graph_view, size_t max_level=100, typename graph_view_t::weight_type resolution=typename graph_view_t::weight_type{1})</td></tr>
<tr class="memdesc:a467270ee534ba7cc7fcdd597dc582c0a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> implementation, returning dendrogram.  <a href="namespacecugraph.html#a467270ee534ba7cc7fcdd597dc582c0a">More...</a><br></td></tr>
<tr class="separator:a467270ee534ba7cc7fcdd597dc582c0a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a14ff99325a9b1360a3ae2a3b3ff30c58"><td class="memTemplParams" colspan="2">template&lt;typename graph_view_t &gt; </td></tr>
<tr class="memitem:a14ff99325a9b1360a3ae2a3b3ff30c58"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a14ff99325a9b1360a3ae2a3b3ff30c58">flatten_dendrogram</a> (raft::handle_t const &amp;handle, graph_view_t const &amp;graph_view, <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; typename graph_view_t::vertex_type &gt; const &amp;dendrogram, typename graph_view_t::vertex_type *clustering)</td></tr>
<tr class="memdesc:a14ff99325a9b1360a3ae2a3b3ff30c58"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flatten a <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a> at a particular level.  <a href="namespacecugraph.html#a14ff99325a9b1360a3ae2a3b3ff30c58">More...</a><br></td></tr>
<tr class="separator:a14ff99325a9b1360a3ae2a3b3ff30c58"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a07626b2e51010662d12ad4d5d85e6b1d"><td class="memTemplParams" colspan="2">template&lt;typename graph_view_t &gt; </td></tr>
<tr class="memitem:a07626b2e51010662d12ad4d5d85e6b1d"><td align="right" class="memTemplItemLeft" valign="top">std::pair&lt; size_t, typename graph_view_t::weight_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a07626b2e51010662d12ad4d5d85e6b1d">louvain</a> (raft::handle_t const &amp;handle, graph_view_t const &amp;graph_view, typename graph_view_t::vertex_type *clustering, size_t max_level=100, typename graph_view_t::weight_type resolution=typename graph_view_t::weight_type{1})</td></tr>
<tr class="memdesc:a07626b2e51010662d12ad4d5d85e6b1d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> implementation.  <a href="namespacecugraph.html#a07626b2e51010662d12ad4d5d85e6b1d">More...</a><br></td></tr>
<tr class="separator:a07626b2e51010662d12ad4d5d85e6b1d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a15acb694bc114420af8c900a281a6bc4"><td align="right" class="memItemLeft" valign="top"><a id="a15acb694bc114420af8c900a281a6bc4"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:a15acb694bc114420af8c900a281a6bc4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8d3d58773bc751bf3728993e828e7f80"><td align="right" class="memItemLeft" valign="top"><a id="a8d3d58773bc751bf3728993e828e7f80"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:a8d3d58773bc751bf3728993e828e7f80"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1bee0832b7d9f540984710fcaa1134c8"><td align="right" class="memItemLeft" valign="top"><a id="a1bee0832b7d9f540984710fcaa1134c8"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int64_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:a1bee0832b7d9f540984710fcaa1134c8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6f82fc0c58281d2d4ceedc7f116d5015"><td align="right" class="memItemLeft" valign="top"><a id="a6f82fc0c58281d2d4ceedc7f116d5015"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:a6f82fc0c58281d2d4ceedc7f116d5015"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa83b92e1b5ac6b694b17595939560eed"><td align="right" class="memItemLeft" valign="top"><a id="aa83b92e1b5ac6b694b17595939560eed"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:aa83b92e1b5ac6b694b17595939560eed"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adeea5d3eff827a506b8519d173c1addd"><td align="right" class="memItemLeft" valign="top"><a id="adeea5d3eff827a506b8519d173c1addd"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int64_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:adeea5d3eff827a506b8519d173c1addd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae0f1e54e3dad194f3408c16e65088b6f"><td align="right" class="memItemLeft" valign="top"><a id="ae0f1e54e3dad194f3408c16e65088b6f"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:ae0f1e54e3dad194f3408c16e65088b6f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2ba055a443dee70f8233c742fd89f919"><td align="right" class="memItemLeft" valign="top"><a id="a2ba055a443dee70f8233c742fd89f919"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:a2ba055a443dee70f8233c742fd89f919"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab35ca89c20fa088bca74e2ddfbb1d6ea"><td align="right" class="memItemLeft" valign="top"><a id="ab35ca89c20fa088bca74e2ddfbb1d6ea"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int64_t &gt; &gt;, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;, size_t, float)</td></tr>
<tr class="separator:ab35ca89c20fa088bca74e2ddfbb1d6ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aecbb853ac21b27570f0402076053fe56"><td align="right" class="memItemLeft" valign="top"><a id="aecbb853ac21b27570f0402076053fe56"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:aecbb853ac21b27570f0402076053fe56"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2160b028dca92432be5f3954bc464819"><td align="right" class="memItemLeft" valign="top"><a id="a2160b028dca92432be5f3954bc464819"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int32_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:a2160b028dca92432be5f3954bc464819"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a90b152d5285d3a936bd8d9eb14e6974c"><td align="right" class="memItemLeft" valign="top"><a id="a90b152d5285d3a936bd8d9eb14e6974c"></a>
template std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; int64_t &gt; &gt;, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;, size_t, double)</td></tr>
<tr class="separator:a90b152d5285d3a936bd8d9eb14e6974c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a26dfd9440a09690421450c8b37c05c84"><td align="right" class="memItemLeft" valign="top"><a id="a26dfd9440a09690421450c8b37c05c84"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:a26dfd9440a09690421450c8b37c05c84"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad84ee9ec1d3894449ff6ae92dfbc6231"><td align="right" class="memItemLeft" valign="top"><a id="ad84ee9ec1d3894449ff6ae92dfbc6231"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:ad84ee9ec1d3894449ff6ae92dfbc6231"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab1e30f2b71ec895726212fb3259a42a8"><td align="right" class="memItemLeft" valign="top"><a id="ab1e30f2b71ec895726212fb3259a42a8"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int32_t, float, false, false &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:ab1e30f2b71ec895726212fb3259a42a8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a92f37a8e9ccec53a9776be6a7901e22c"><td align="right" class="memItemLeft" valign="top"><a id="a92f37a8e9ccec53a9776be6a7901e22c"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int32_t, double, false, false &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:a92f37a8e9ccec53a9776be6a7901e22c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a91467fbb9639c0114ffa0bfd95fb6eca"><td align="right" class="memItemLeft" valign="top"><a id="a91467fbb9639c0114ffa0bfd95fb6eca"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int64_t, float, false, false &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:a91467fbb9639c0114ffa0bfd95fb6eca"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aafbbde394f245395b53c40a08a643788"><td align="right" class="memItemLeft" valign="top"><a id="aafbbde394f245395b53c40a08a643788"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int64_t, double, false, false &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:aafbbde394f245395b53c40a08a643788"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a67bf27e9c06a2a24f484a4b210c4bb0e"><td align="right" class="memItemLeft" valign="top"><a id="a67bf27e9c06a2a24f484a4b210c4bb0e"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int64_t, int64_t, float, false, false &gt; const &amp;, int64_t *, size_t, float)</td></tr>
<tr class="separator:a67bf27e9c06a2a24f484a4b210c4bb0e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3917d480f6849ee26aeebfec29770743"><td align="right" class="memItemLeft" valign="top"><a id="a3917d480f6849ee26aeebfec29770743"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int64_t, int64_t, double, false, false &gt; const &amp;, int64_t *, size_t, double)</td></tr>
<tr class="separator:a3917d480f6849ee26aeebfec29770743"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a50802e35ee9d1a20c7d4bc6fa089cbf5"><td align="right" class="memItemLeft" valign="top"><a id="a50802e35ee9d1a20c7d4bc6fa089cbf5"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int32_t, float, false, true &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:a50802e35ee9d1a20c7d4bc6fa089cbf5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a766f41263aae631493e7b68d291947aa"><td align="right" class="memItemLeft" valign="top"><a id="a766f41263aae631493e7b68d291947aa"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int32_t, double, false, true &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:a766f41263aae631493e7b68d291947aa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac1b96c50e53968b0cbb2bae3c94eb2c9"><td align="right" class="memItemLeft" valign="top"><a id="ac1b96c50e53968b0cbb2bae3c94eb2c9"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int64_t, float, false, true &gt; const &amp;, int32_t *, size_t, float)</td></tr>
<tr class="separator:ac1b96c50e53968b0cbb2bae3c94eb2c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa9bf78e7e8a66d9b29ad59548b7ffc32"><td align="right" class="memItemLeft" valign="top"><a id="aa9bf78e7e8a66d9b29ad59548b7ffc32"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int32_t, int64_t, double, false, true &gt; const &amp;, int32_t *, size_t, double)</td></tr>
<tr class="separator:aa9bf78e7e8a66d9b29ad59548b7ffc32"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a300d3dd36874f7b56e2903d5beb9bb79"><td align="right" class="memItemLeft" valign="top"><a id="a300d3dd36874f7b56e2903d5beb9bb79"></a>
template std::pair&lt; size_t, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int64_t, int64_t, float, false, true &gt; const &amp;, int64_t *, size_t, float)</td></tr>
<tr class="separator:a300d3dd36874f7b56e2903d5beb9bb79"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac5db52d2cfd9935ba44fa67923a30424"><td align="right" class="memItemLeft" valign="top"><a id="ac5db52d2cfd9935ba44fa67923a30424"></a>
template std::pair&lt; size_t, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>louvain</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1experimental_1_1graph__view__t.html">experimental::graph_view_t</a>&lt; int64_t, int64_t, double, false, true &gt; const &amp;, int64_t *, size_t, double)</td></tr>
<tr class="separator:ac5db52d2cfd9935ba44fa67923a30424"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6c61241ace7da8b4f3b3f35a8a3f3980"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a6c61241ace7da8b4f3b3f35a8a3f3980"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a6c61241ace7da8b4f3b3f35a8a3f3980">connected_components</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a> connectivity_type, VT *labels)</td></tr>
<tr class="memdesc:a6c61241ace7da8b4f3b3f35a8a3f3980"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute connected components.  <a href="namespacecugraph.html#a6c61241ace7da8b4f3b3f35a8a3f3980">More...</a><br></td></tr>
<tr class="separator:a6c61241ace7da8b4f3b3f35a8a3f3980"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4eb3e72f7b8090ffa9afdb9c52b889d5"><td align="right" class="memItemLeft" valign="top"><a id="a4eb3e72f7b8090ffa9afdb9c52b889d5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>connected_components&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a>, int32_t *)</td></tr>
<tr class="separator:a4eb3e72f7b8090ffa9afdb9c52b889d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1f4a33d64b3c322fd75c8b45882c17b8"><td align="right" class="memItemLeft" valign="top"><a id="a1f4a33d64b3c322fd75c8b45882c17b8"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>connected_components&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a>, int64_t *)</td></tr>
<tr class="separator:a1f4a33d64b3c322fd75c8b45882c17b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9405b7bc608cc8c05139e52d9c892b61"><td align="right" class="memItemLeft" valign="top"><a id="a9405b7bc608cc8c05139e52d9c892b61"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a>&lt; uint32_t, uint32_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; uint32_t, uint32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; uint32_t, uint32_t, float &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a9405b7bc608cc8c05139e52d9c892b61"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0b5a310ebc41180d7706977b00ebcf46"><td align="right" class="memItemLeft" valign="top"><a id="a0b5a310ebc41180d7706977b00ebcf46"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a>&lt; uint32_t, uint32_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; uint32_t, uint32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; uint32_t, uint32_t, double &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a0b5a310ebc41180d7706977b00ebcf46"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a83969eeef16a4674cfea9a4b5b236bcb"><td align="right" class="memItemLeft" valign="top"><a id="a83969eeef16a4674cfea9a4b5b236bcb"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a>&lt; int32_t, int32_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a83969eeef16a4674cfea9a4b5b236bcb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae867241dc68e1cae777b5bff3e692584"><td align="right" class="memItemLeft" valign="top"><a id="ae867241dc68e1cae777b5bff3e692584"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a>&lt; int32_t, int32_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:ae867241dc68e1cae777b5bff3e692584"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afc2b592742803ec288a790f30ebd3525"><td align="right" class="memItemLeft" valign="top"><a id="afc2b592742803ec288a790f30ebd3525"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a>&lt; int64_t, int64_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int64_t, int64_t, float &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:afc2b592742803ec288a790f30ebd3525"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2369bc09a2bfe00416a98d9b690be3d4"><td align="right" class="memItemLeft" valign="top"><a id="a2369bc09a2bfe00416a98d9b690be3d4"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a>&lt; int64_t, int64_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int64_t, int64_t, double &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a2369bc09a2bfe00416a98d9b690be3d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a76953ba934b3254f592f71a9a16c0764"><td align="right" class="memItemLeft" valign="top"><a id="a76953ba934b3254f592f71a9a16c0764"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; uint32_t, uint32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; uint32_t, uint32_t, float &gt; &amp;graph, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; uint32_t, uint32_t, float &gt; &amp;result)</td></tr>
<tr class="separator:a76953ba934b3254f592f71a9a16c0764"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7379dc75fcaabccf9b7151de7963db68"><td align="right" class="memItemLeft" valign="top"><a id="a7379dc75fcaabccf9b7151de7963db68"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; uint32_t, uint32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; uint32_t, uint32_t, double &gt; &amp;graph, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; uint32_t, uint32_t, double &gt; &amp;result)</td></tr>
<tr class="separator:a7379dc75fcaabccf9b7151de7963db68"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad4c21d924aa11b2b0133eeac01d14357"><td align="right" class="memItemLeft" valign="top"><a id="ad4c21d924aa11b2b0133eeac01d14357"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, float &gt; &amp;graph, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; &amp;result)</td></tr>
<tr class="separator:ad4c21d924aa11b2b0133eeac01d14357"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac7be69a811f1e9a6ed1375464469cd5c"><td align="right" class="memItemLeft" valign="top"><a id="ac7be69a811f1e9a6ed1375464469cd5c"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, double &gt; &amp;graph, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; &amp;result)</td></tr>
<tr class="separator:ac7be69a811f1e9a6ed1375464469cd5c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6e96e42f25b596e8bc9733f0f1b08028"><td align="right" class="memItemLeft" valign="top"><a id="a6e96e42f25b596e8bc9733f0f1b08028"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int64_t, int64_t, float &gt; &amp;graph, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, float &gt; &amp;result)</td></tr>
<tr class="separator:a6e96e42f25b596e8bc9733f0f1b08028"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0a373d1547cc8fd9ff7e09fc7938f801"><td align="right" class="memItemLeft" valign="top"><a id="a0a373d1547cc8fd9ff7e09fc7938f801"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr_inplace&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int64_t, int64_t, double &gt; &amp;graph, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, double &gt; &amp;result)</td></tr>
<tr class="separator:a0a373d1547cc8fd9ff7e09fc7938f801"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4ddfbabee24b22217e4bbfdecb55980e"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a4ddfbabee24b22217e4bbfdecb55980e"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a>&lt; VT, ET, WT &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a4ddfbabee24b22217e4bbfdecb55980e">coo_to_csr</a> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;graph, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a4ddfbabee24b22217e4bbfdecb55980e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert COO to CSR.  <a href="namespacecugraph.html#a4ddfbabee24b22217e4bbfdecb55980e">More...</a><br></td></tr>
<tr class="separator:a4ddfbabee24b22217e4bbfdecb55980e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a377ac6f41da5ed3d1b2b6ec175dc4b39"><td class="memTemplParams" colspan="2"><a id="a377ac6f41da5ed3d1b2b6ec175dc4b39"></a>
template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a377ac6f41da5ed3d1b2b6ec175dc4b39"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>coo_to_csr_inplace</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; VT, ET, WT &gt; &amp;graph, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; &amp;result)</td></tr>
<tr class="separator:a377ac6f41da5ed3d1b2b6ec175dc4b39"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae0e49dce7b1e20902d940e8156a83ea9"><td class="memTemplParams" colspan="2">template&lt;typename VT_IN , typename VT_OUT , typename ET &gt; </td></tr>
<tr class="memitem:ae0e49dce7b1e20902d940e8156a83ea9"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; rmm::device_buffer &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ae0e49dce7b1e20902d940e8156a83ea9">renumber_vertices</a> (ET number_of_edges, VT_IN const *src, VT_IN const *dst, VT_OUT *src_renumbered, VT_OUT *dst_renumbered, ET *map_size, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ae0e49dce7b1e20902d940e8156a83ea9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renumber source and destination indices.  <a href="namespacecugraph.html#ae0e49dce7b1e20902d940e8156a83ea9">More...</a><br></td></tr>
<tr class="separator:ae0e49dce7b1e20902d940e8156a83ea9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a74a3fb865292a09ae8c07c12dfdd48e2"><td align="right" class="memItemLeft" valign="top"><a id="a74a3fb865292a09ae8c07c12dfdd48e2"></a>
template std::unique_ptr&lt; rmm::device_buffer &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_vertices</b> (int32_t, int64_t const *, int64_t const *, int32_t *, int32_t *, int32_t *, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a74a3fb865292a09ae8c07c12dfdd48e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa0ebd3d21f6da446ed6e6772e8c2c60f"><td align="right" class="memItemLeft" valign="top"><a id="aa0ebd3d21f6da446ed6e6772e8c2c60f"></a>
template std::unique_ptr&lt; rmm::device_buffer &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>renumber_vertices</b> (int32_t, int32_t const *, int32_t const *, int32_t *, int32_t *, int32_t *, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:aa0ebd3d21f6da446ed6e6772e8c2c60f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa9d5c8e792f3082f524d07e0f8e489b2"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:aa9d5c8e792f3082f524d07e0f8e489b2"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aa9d5c8e792f3082f524d07e0f8e489b2">core_number</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, VT *core_number)</td></tr>
<tr class="memdesc:aa9d5c8e792f3082f524d07e0f8e489b2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the Core Number for the nodes of the graph G.  <a href="namespacecugraph.html#aa9d5c8e792f3082f524d07e0f8e489b2">More...</a><br></td></tr>
<tr class="separator:aa9d5c8e792f3082f524d07e0f8e489b2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad2abd72fff71904ed9def45a89b3eee7"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ad2abd72fff71904ed9def45a89b3eee7"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; VT, ET, WT &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad2abd72fff71904ed9def45a89b3eee7">k_core</a> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;graph, int k, VT const *vertex_id, VT const *<a class="el" href="namespacecugraph.html#aa9d5c8e792f3082f524d07e0f8e489b2">core_number</a>, VT num_vertex_ids, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ad2abd72fff71904ed9def45a89b3eee7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute K Core of the graph G.  <a href="namespacecugraph.html#ad2abd72fff71904ed9def45a89b3eee7">More...</a><br></td></tr>
<tr class="separator:ad2abd72fff71904ed9def45a89b3eee7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5f503f9cc13c9e37058134916a45af53"><td align="right" class="memItemLeft" valign="top"><a id="a5f503f9cc13c9e37058134916a45af53"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>core_number&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t *<a class="el" href="namespacecugraph.html#aa9d5c8e792f3082f524d07e0f8e489b2">core_number</a>)</td></tr>
<tr class="separator:a5f503f9cc13c9e37058134916a45af53"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1491abd499672575afb8a557481967e6"><td align="right" class="memItemLeft" valign="top"><a id="a1491abd499672575afb8a557481967e6"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; int32_t, int32_t, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>k_core&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int, int32_t const *, int32_t const *, int32_t, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a1491abd499672575afb8a557481967e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a921722879c311590142be600238af20b"><td align="right" class="memItemLeft" valign="top"><a id="a921722879c311590142be600238af20b"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; int32_t, int32_t, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>k_core&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int, int32_t const *, int32_t const *, int32_t, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a921722879c311590142be600238af20b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa0a5f26d9d1f8e7f5be618b169afab13"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:aa0a5f26d9d1f8e7f5be618b169afab13"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aa0a5f26d9d1f8e7f5be618b169afab13">generate_erdos_renyi_graph_edgelist_gnp</a> (raft::handle_t const &amp;handle, vertex_t num_vertices, float p, vertex_t base_vertex_id, uint64_t seed=0)</td></tr>
<tr class="memdesc:aa0a5f26d9d1f8e7f5be618b169afab13"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge lists for an Erdos-Renyi graph  <a href="namespacecugraph.html#aa0a5f26d9d1f8e7f5be618b169afab13">More...</a><br></td></tr>
<tr class="separator:aa0a5f26d9d1f8e7f5be618b169afab13"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a72ced6246f6172491c08ee1719e0afe1"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a72ced6246f6172491c08ee1719e0afe1"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a72ced6246f6172491c08ee1719e0afe1">generate_erdos_renyi_graph_edgelist_gnm</a> (raft::handle_t const &amp;handle, vertex_t num_vertices, size_t m, vertex_t base_vertex_id, uint64_t seed=0)</td></tr>
<tr class="memdesc:a72ced6246f6172491c08ee1719e0afe1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge lists for an Erdos-Renyi graph  <a href="namespacecugraph.html#a72ced6246f6172491c08ee1719e0afe1">More...</a><br></td></tr>
<tr class="separator:a72ced6246f6172491c08ee1719e0afe1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa996401923e74bb039bc422c4c26f686"><td align="right" class="memItemLeft" valign="top"><a id="aa996401923e74bb039bc422c4c26f686"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_erdos_renyi_graph_edgelist_gnp</b> (raft::handle_t const &amp;handle, int32_t num_vertices, float p, int32_t base_vertex_id, uint64_t seed)</td></tr>
<tr class="separator:aa996401923e74bb039bc422c4c26f686"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae3c7ee53bf5ce6d070aaa2828f23430d"><td align="right" class="memItemLeft" valign="top"><a id="ae3c7ee53bf5ce6d070aaa2828f23430d"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_erdos_renyi_graph_edgelist_gnp</b> (raft::handle_t const &amp;handle, int64_t num_vertices, float p, int64_t base_vertex_id, uint64_t seed)</td></tr>
<tr class="separator:ae3c7ee53bf5ce6d070aaa2828f23430d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8310f60a3ed7cfc94cdc0fa371b4ae0b"><td align="right" class="memItemLeft" valign="top"><a id="a8310f60a3ed7cfc94cdc0fa371b4ae0b"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_erdos_renyi_graph_edgelist_gnm</b> (raft::handle_t const &amp;handle, int32_t num_vertices, size_t m, int32_t base_vertex_id, uint64_t seed)</td></tr>
<tr class="separator:a8310f60a3ed7cfc94cdc0fa371b4ae0b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae85f9586885517386275a74aaee7849f"><td align="right" class="memItemLeft" valign="top"><a id="ae85f9586885517386275a74aaee7849f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_erdos_renyi_graph_edgelist_gnm</b> (raft::handle_t const &amp;handle, int64_t num_vertices, size_t m, int64_t base_vertex_id, uint64_t seed)</td></tr>
<tr class="separator:ae85f9586885517386275a74aaee7849f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a868438c616436c2e2f2017d46479c3f7"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a868438c616436c2e2f2017d46479c3f7"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a868438c616436c2e2f2017d46479c3f7">generate_rmat_edgelist</a> (raft::handle_t const &amp;handle, size_t scale, size_t num_edges, double a=0.57, double b=0.19, double c=0.19, uint64_t seed=0, bool clip_and_flip=false)</td></tr>
<tr class="memdesc:a868438c616436c2e2f2017d46479c3f7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge list for an R-mat graph.  <a href="namespacecugraph.html#a868438c616436c2e2f2017d46479c3f7">More...</a><br></td></tr>
<tr class="separator:a868438c616436c2e2f2017d46479c3f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aefc59061788cff241d12089e0162b3bb"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:aefc59061788cff241d12089e0162b3bb"><td align="right" class="memTemplItemLeft" valign="top">std::vector&lt; std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aefc59061788cff241d12089e0162b3bb">generate_rmat_edgelists</a> (raft::handle_t const &amp;handle, size_t n_edgelists, size_t min_scale, size_t max_scale, size_t edge_factor=16, generator_distribution_t size_distribution=generator_distribution_t::POWER_LAW, generator_distribution_t edge_distribution=generator_distribution_t::POWER_LAW, uint64_t seed=0, bool clip_and_flip=false)</td></tr>
<tr class="memdesc:aefc59061788cff241d12089e0162b3bb"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate multiple edge lists using the R-mat graph generator.  <a href="namespacecugraph.html#aefc59061788cff241d12089e0162b3bb">More...</a><br></td></tr>
<tr class="separator:aefc59061788cff241d12089e0162b3bb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a84de876392aef937cf70fda769cd417f"><td align="right" class="memItemLeft" valign="top"><a id="a84de876392aef937cf70fda769cd417f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_rmat_edgelist&lt; int32_t &gt;</b> (raft::handle_t const &amp;handle, size_t scale, size_t num_edges, double a, double b, double c, uint64_t seed, bool clip_and_flip)</td></tr>
<tr class="separator:a84de876392aef937cf70fda769cd417f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a20fcf14b8ad581459cad3834c400af6c"><td align="right" class="memItemLeft" valign="top"><a id="a20fcf14b8ad581459cad3834c400af6c"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_rmat_edgelist&lt; int64_t &gt;</b> (raft::handle_t const &amp;handle, size_t scale, size_t num_edges, double a, double b, double c, uint64_t seed, bool clip_and_flip)</td></tr>
<tr class="separator:a20fcf14b8ad581459cad3834c400af6c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8078ea85bbed316071b1d029312c6c84"><td align="right" class="memItemLeft" valign="top"><a id="a8078ea85bbed316071b1d029312c6c84"></a>
template std::vector&lt; std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_rmat_edgelists&lt; int32_t &gt;</b> (raft::handle_t const &amp;handle, size_t n_edgelists, size_t min_scale, size_t max_scale, size_t edge_factor, generator_distribution_t component_distribution, generator_distribution_t edge_distribution, uint64_t seed, bool clip_and_flip)</td></tr>
<tr class="separator:a8078ea85bbed316071b1d029312c6c84"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5fa6f7683ff630c2673f986b35c6a0b5"><td align="right" class="memItemLeft" valign="top"><a id="a5fa6f7683ff630c2673f986b35c6a0b5"></a>
template std::vector&lt; std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_rmat_edgelists&lt; int64_t &gt;</b> (raft::handle_t const &amp;handle, size_t n_edgelists, size_t min_scale, size_t max_scale, size_t edge_factor, generator_distribution_t component_distribution, generator_distribution_t edge_distribution, uint64_t seed, bool clip_and_flip)</td></tr>
<tr class="separator:a5fa6f7683ff630c2673f986b35c6a0b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af8f46f02fbf60659c432be4882f89be1"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:af8f46f02fbf60659c432be4882f89be1"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#af8f46f02fbf60659c432be4882f89be1">scramble_vertex_ids</a> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; vertex_t &gt; &amp;d_src_v, rmm::device_uvector&lt; vertex_t &gt; &amp;d_dst_v, vertex_t vertex_id_offset, uint64_t seed=0)</td></tr>
<tr class="memdesc:af8f46f02fbf60659c432be4882f89be1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scramble vertex ids in a graph  <a href="namespacecugraph.html#af8f46f02fbf60659c432be4882f89be1">More...</a><br></td></tr>
<tr class="separator:af8f46f02fbf60659c432be4882f89be1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3da3282a0c1ee7afc2cb91f6e17a8835"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a3da3282a0c1ee7afc2cb91f6e17a8835"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a3da3282a0c1ee7afc2cb91f6e17a8835">combine_edgelists</a> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;d_sources, std::vector&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;d_dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; weight_t &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges=true)</td></tr>
<tr class="memdesc:a3da3282a0c1ee7afc2cb91f6e17a8835"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine edgelists from multiple sources into a single edgelist.  <a href="namespacecugraph.html#a3da3282a0c1ee7afc2cb91f6e17a8835">More...</a><br></td></tr>
<tr class="separator:a3da3282a0c1ee7afc2cb91f6e17a8835"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a533136dac7270bcd27fe8655c17730fa"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a533136dac7270bcd27fe8655c17730fa"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a533136dac7270bcd27fe8655c17730fa">symmetrize_edgelist</a> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; weight_t &gt;&gt; &amp;&amp;optional_d_weights_v)</td></tr>
<tr class="memdesc:a533136dac7270bcd27fe8655c17730fa"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">symmetrize an edgelist  <a href="namespacecugraph.html#a533136dac7270bcd27fe8655c17730fa">More...</a><br></td></tr>
<tr class="separator:a533136dac7270bcd27fe8655c17730fa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9556ab891cd85be954aa7f7bb91f3ca3"><td align="right" class="memItemLeft" valign="top"><a id="a9556ab891cd85be954aa7f7bb91f3ca3"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>scramble_vertex_ids</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;d_src_v, rmm::device_uvector&lt; int32_t &gt; &amp;d_dst_v, int32_t vertex_id_offset, uint64_t seed)</td></tr>
<tr class="separator:a9556ab891cd85be954aa7f7bb91f3ca3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afc43b8d231e18c513b67365b0ca788df"><td align="right" class="memItemLeft" valign="top"><a id="afc43b8d231e18c513b67365b0ca788df"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>scramble_vertex_ids</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;d_src_v, rmm::device_uvector&lt; int64_t &gt; &amp;d_dst_v, int64_t vertex_id_offset, uint64_t seed)</td></tr>
<tr class="separator:afc43b8d231e18c513b67365b0ca788df"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a865d17ec386427d8b976d3ec59d83189"><td align="right" class="memItemLeft" valign="top"><a id="a865d17ec386427d8b976d3ec59d83189"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>combine_edgelists</b> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;sources, std::vector&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; float &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges)</td></tr>
<tr class="separator:a865d17ec386427d8b976d3ec59d83189"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9e53568f2b73f262c55185380e4df25"><td align="right" class="memItemLeft" valign="top"><a id="ae9e53568f2b73f262c55185380e4df25"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>combine_edgelists</b> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;sources, std::vector&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; float &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges)</td></tr>
<tr class="separator:ae9e53568f2b73f262c55185380e4df25"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6ec8ccdcd6b79cff2272d28413ff796b"><td align="right" class="memItemLeft" valign="top"><a id="a6ec8ccdcd6b79cff2272d28413ff796b"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>combine_edgelists</b> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;sources, std::vector&lt; rmm::device_uvector&lt; int32_t &gt;&gt; &amp;&amp;dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; double &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges)</td></tr>
<tr class="separator:a6ec8ccdcd6b79cff2272d28413ff796b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2225b09f1cdbb8e18e2776f9284cf2d8"><td align="right" class="memItemLeft" valign="top"><a id="a2225b09f1cdbb8e18e2776f9284cf2d8"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>combine_edgelists</b> (raft::handle_t const &amp;handle, std::vector&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;sources, std::vector&lt; rmm::device_uvector&lt; int64_t &gt;&gt; &amp;&amp;dests, std::optional&lt; std::vector&lt; rmm::device_uvector&lt; double &gt;&gt;&gt; &amp;&amp;optional_d_weights, bool remove_multi_edges)</td></tr>
<tr class="separator:a2225b09f1cdbb8e18e2776f9284cf2d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac4330a1ac482175bae0ed1e1d23cd34e"><td align="right" class="memItemLeft" valign="top"><a id="ac4330a1ac482175bae0ed1e1d23cd34e"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;optional_d_weights_v)</td></tr>
<tr class="separator:ac4330a1ac482175bae0ed1e1d23cd34e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a34f0096f0b0efff56d3d773eb2188816"><td align="right" class="memItemLeft" valign="top"><a id="a34f0096f0b0efff56d3d773eb2188816"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; float &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; float &gt;&gt; &amp;&amp;optional_d_weights_v)</td></tr>
<tr class="separator:a34f0096f0b0efff56d3d773eb2188816"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae4efc089e0b7a4af601613a65ee1c1f5"><td align="right" class="memItemLeft" valign="top"><a id="ae4efc089e0b7a4af601613a65ee1c1f5"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; int32_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;optional_d_weights_v)</td></tr>
<tr class="separator:ae4efc089e0b7a4af601613a65ee1c1f5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac4c5dd9865a89bd34533ced783abc601"><td align="right" class="memItemLeft" valign="top"><a id="ac4c5dd9865a89bd34533ced783abc601"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt;, std::optional&lt; rmm::device_uvector&lt; double &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>symmetrize_edgelist</b> (raft::handle_t const &amp;handle, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;d_src_v, rmm::device_uvector&lt; int64_t &gt; &amp;&amp;d_dst_v, std::optional&lt; rmm::device_uvector&lt; double &gt;&gt; &amp;&amp;optional_d_weights_v)</td></tr>
<tr class="separator:ac4c5dd9865a89bd34533ced783abc601"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a22e8e5b35a3e17bcb609162b38d681a7"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a22e8e5b35a3e17bcb609162b38d681a7"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a22e8e5b35a3e17bcb609162b38d681a7">generate_path_graph_edgelist</a> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; vertex_t, vertex_t &gt;&gt; const &amp;component_parameters_v)</td></tr>
<tr class="memdesc:a22e8e5b35a3e17bcb609162b38d681a7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge list for path graph  <a href="namespacecugraph.html#a22e8e5b35a3e17bcb609162b38d681a7">More...</a><br></td></tr>
<tr class="separator:a22e8e5b35a3e17bcb609162b38d681a7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adc635cbe97462344e74adf1ed7a44a72"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:adc635cbe97462344e74adf1ed7a44a72"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#adc635cbe97462344e74adf1ed7a44a72">generate_2d_mesh_graph_edgelist</a> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; vertex_t, vertex_t, vertex_t &gt;&gt; const &amp;component_parameters_v)</td></tr>
<tr class="memdesc:adc635cbe97462344e74adf1ed7a44a72"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge list for a 2D Mesh Graph  <a href="namespacecugraph.html#adc635cbe97462344e74adf1ed7a44a72">More...</a><br></td></tr>
<tr class="separator:adc635cbe97462344e74adf1ed7a44a72"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a16c815a628f002265faa58797bfeab3b"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a16c815a628f002265faa58797bfeab3b"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a16c815a628f002265faa58797bfeab3b">generate_3d_mesh_graph_edgelist</a> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; vertex_t, vertex_t, vertex_t, vertex_t &gt;&gt; const &amp;component_parameters_v)</td></tr>
<tr class="memdesc:a16c815a628f002265faa58797bfeab3b"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge list for a 3D Mesh Graph  <a href="namespacecugraph.html#a16c815a628f002265faa58797bfeab3b">More...</a><br></td></tr>
<tr class="separator:a16c815a628f002265faa58797bfeab3b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a35c787db93f9ec4165a8430f965254c7"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t &gt; </td></tr>
<tr class="memitem:a35c787db93f9ec4165a8430f965254c7"><td align="right" class="memTemplItemLeft" valign="top">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a35c787db93f9ec4165a8430f965254c7">generate_complete_graph_edgelist</a> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; vertex_t, vertex_t &gt;&gt; const &amp;component_parameters_v)</td></tr>
<tr class="memdesc:a35c787db93f9ec4165a8430f965254c7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate an edge lists for some complete graphs  <a href="namespacecugraph.html#a35c787db93f9ec4165a8430f965254c7">More...</a><br></td></tr>
<tr class="separator:a35c787db93f9ec4165a8430f965254c7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1a911000a3e1a9d31718aa5fb2aa2d0c"><td align="right" class="memItemLeft" valign="top"><a id="a1a911000a3e1a9d31718aa5fb2aa2d0c"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_path_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int32_t, int32_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a1a911000a3e1a9d31718aa5fb2aa2d0c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a35271fef987ae82b08e3767120160904"><td align="right" class="memItemLeft" valign="top"><a id="a35271fef987ae82b08e3767120160904"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_path_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int64_t, int64_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a35271fef987ae82b08e3767120160904"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7a20381a602f4192d4bac7d45418ad9f"><td align="right" class="memItemLeft" valign="top"><a id="a7a20381a602f4192d4bac7d45418ad9f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_2d_mesh_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int32_t, int32_t, int32_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a7a20381a602f4192d4bac7d45418ad9f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a33c385820a671c4c390023391166ddba"><td align="right" class="memItemLeft" valign="top"><a id="a33c385820a671c4c390023391166ddba"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_2d_mesh_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int64_t, int64_t, int64_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a33c385820a671c4c390023391166ddba"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af14d022dfb223107c789be80423123eb"><td align="right" class="memItemLeft" valign="top"><a id="af14d022dfb223107c789be80423123eb"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_3d_mesh_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int32_t, int32_t, int32_t, int32_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:af14d022dfb223107c789be80423123eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9bbaa953aee2c6049b7ecef3553662f"><td align="right" class="memItemLeft" valign="top"><a id="ae9bbaa953aee2c6049b7ecef3553662f"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_3d_mesh_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int64_t, int64_t, int64_t, int64_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:ae9bbaa953aee2c6049b7ecef3553662f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a931c34cf451400d0da6dc01b3970d0a6"><td align="right" class="memItemLeft" valign="top"><a id="a931c34cf451400d0da6dc01b3970d0a6"></a>
template std::tuple&lt; rmm::device_uvector&lt; int32_t &gt;, rmm::device_uvector&lt; int32_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_complete_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int32_t, int32_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a931c34cf451400d0da6dc01b3970d0a6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7ec5d01cd2dbb2165eede989c621c49b"><td align="right" class="memItemLeft" valign="top"><a id="a7ec5d01cd2dbb2165eede989c621c49b"></a>
template std::tuple&lt; rmm::device_uvector&lt; int64_t &gt;, rmm::device_uvector&lt; int64_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>generate_complete_graph_edgelist</b> (raft::handle_t const &amp;handle, std::vector&lt; std::tuple&lt; int64_t, int64_t &gt;&gt; const &amp;component_parms_v)</td></tr>
<tr class="separator:a7ec5d01cd2dbb2165eede989c621c49b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aba1813aba5fc057cdbf5bcd62ea2ec84"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:aba1813aba5fc057cdbf5bcd62ea2ec84"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aba1813aba5fc057cdbf5bcd62ea2ec84">force_atlas2</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; &amp;graph, float *pos, const int max_iter=500, float *x_start=nullptr, float *y_start=nullptr, bool outbound_attraction_distribution=true, bool lin_log_mode=false, bool prevent_overlapping=false, const float edge_weight_influence=1.0, const float jitter_tolerance=1.0, bool barnes_hut_optimize=true, const float barnes_hut_theta=0.5, const float scaling_ratio=2.0, bool strong_gravity_mode=false, const float gravity=1.0, bool verbose=false, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback=nullptr)</td></tr>
<tr class="memdesc:aba1813aba5fc057cdbf5bcd62ea2ec84"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ForceAtlas2 is a continuous graph layout algorithm for handy network visualization.  <a href="namespacecugraph.html#aba1813aba5fc057cdbf5bcd62ea2ec84">More...</a><br></td></tr>
<tr class="separator:aba1813aba5fc057cdbf5bcd62ea2ec84"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:add3c78f9c1cf8b57dad3b4316657b59b"><td align="right" class="memItemLeft" valign="top"><a id="add3c78f9c1cf8b57dad3b4316657b59b"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>force_atlas2&lt; int, int, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int, int, float &gt; &amp;graph, float *pos, const int max_iter, float *x_start, float *y_start, bool outbound_attraction_distribution, bool lin_log_mode, bool prevent_overlapping, const float edge_weight_influence, const float jitter_tolerance, bool barnes_hut_optimize, const float barnes_hut_theta, const float scaling_ratio, bool strong_gravity_mode, const float gravity, bool verbose, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback)</td></tr>
<tr class="separator:add3c78f9c1cf8b57dad3b4316657b59b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a63140dc8a3cd1490822938bf52cec115"><td align="right" class="memItemLeft" valign="top"><a id="a63140dc8a3cd1490822938bf52cec115"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>force_atlas2&lt; int, int, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int, int, double &gt; &amp;graph, float *pos, const int max_iter, float *x_start, float *y_start, bool outbound_attraction_distribution, bool lin_log_mode, bool prevent_overlapping, const float edge_weight_influence, const float jitter_tolerance, bool barnes_hut_optimize, const float barnes_hut_theta, const float scaling_ratio, bool strong_gravity_mode, const float gravity, bool verbose, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback)</td></tr>
<tr class="separator:a63140dc8a3cd1490822938bf52cec115"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6709c56fbbb108b4d54b5f3d8b542bdf"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a6709c56fbbb108b4d54b5f3d8b542bdf"><td align="right" class="memTemplItemLeft" valign="top">weight_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a6709c56fbbb108b4d54b5f3d8b542bdf">hungarian</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;graph, vertex_t num_workers, vertex_t const *workers, vertex_t *assignments)</td></tr>
<tr class="memdesc:a6709c56fbbb108b4d54b5f3d8b542bdf"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute Hungarian algorithm on a weighted bipartite graph.  <a href="namespacecugraph.html#a6709c56fbbb108b4d54b5f3d8b542bdf">More...</a><br></td></tr>
<tr class="separator:a6709c56fbbb108b4d54b5f3d8b542bdf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aeaae3689f14f2c3a41e59ce326b08116"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:aeaae3689f14f2c3a41e59ce326b08116"><td align="right" class="memTemplItemLeft" valign="top">weight_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aeaae3689f14f2c3a41e59ce326b08116">hungarian</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;graph, vertex_t num_workers, vertex_t const *workers, vertex_t *assignments, weight_t epsilon)</td></tr>
<tr class="memdesc:aeaae3689f14f2c3a41e59ce326b08116"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute Hungarian algorithm on a weighted bipartite graph.  <a href="namespacecugraph.html#aeaae3689f14f2c3a41e59ce326b08116">More...</a><br></td></tr>
<tr class="separator:aeaae3689f14f2c3a41e59ce326b08116"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac0a4e0c24770d0330332f85120f130d2"><td align="right" class="memItemLeft" valign="top"><a id="ac0a4e0c24770d0330332f85120f130d2"></a>
template int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, int32_t &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, int32_t &gt; const &amp;, int32_t, int32_t const *, int32_t *, int32_t)</td></tr>
<tr class="separator:ac0a4e0c24770d0330332f85120f130d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afad7a4a538f310fa701627f200ef647f"><td align="right" class="memItemLeft" valign="top"><a id="afad7a4a538f310fa701627f200ef647f"></a>
template float&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, float &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t, int32_t const *, int32_t *, float)</td></tr>
<tr class="separator:afad7a4a538f310fa701627f200ef647f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa481d36cedf69242cdc816b5ff223836"><td align="right" class="memItemLeft" valign="top"><a id="aa481d36cedf69242cdc816b5ff223836"></a>
template double&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, double &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int32_t, int32_t const *, int32_t *, double)</td></tr>
<tr class="separator:aa481d36cedf69242cdc816b5ff223836"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9f74d87f826a0243cd791a0f8b2e2aeb"><td align="right" class="memItemLeft" valign="top"><a id="a9f74d87f826a0243cd791a0f8b2e2aeb"></a>
template int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, int32_t &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, int32_t &gt; const &amp;, int32_t, int32_t const *, int32_t *)</td></tr>
<tr class="separator:a9f74d87f826a0243cd791a0f8b2e2aeb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adeef144547f07f584a7ecebd4d4a7ddc"><td align="right" class="memItemLeft" valign="top"><a id="adeef144547f07f584a7ecebd4d4a7ddc"></a>
template float&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, float &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t, int32_t const *, int32_t *)</td></tr>
<tr class="separator:adeef144547f07f584a7ecebd4d4a7ddc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aca5f943e00e27fb1552ae03df2507ac5"><td align="right" class="memItemLeft" valign="top"><a id="aca5f943e00e27fb1552ae03df2507ac5"></a>
template double&nbsp;</td><td class="memItemRight" valign="bottom"><b>hungarian&lt; int32_t, int32_t, double &gt;</b> (raft::handle_t const &amp;, <a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int32_t, int32_t const *, int32_t *)</td></tr>
<tr class="separator:aca5f943e00e27fb1552ae03df2507ac5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa581ef3206fc57bc0bfaaaf87a1e7428"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:aa581ef3206fc57bc0bfaaaf87a1e7428"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aa581ef3206fc57bc0bfaaaf87a1e7428">jaccard</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT const *weights, WT *result)</td></tr>
<tr class="memdesc:aa581ef3206fc57bc0bfaaaf87a1e7428"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute jaccard similarity coefficient for all vertices.  <a href="namespacecugraph.html#aa581ef3206fc57bc0bfaaaf87a1e7428">More...</a><br></td></tr>
<tr class="separator:aa581ef3206fc57bc0bfaaaf87a1e7428"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aada0a5fdbdfb025445745dd6dcc15436"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:aada0a5fdbdfb025445745dd6dcc15436"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aada0a5fdbdfb025445745dd6dcc15436">jaccard_list</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT const *weights, ET num_pairs, VT const *first, VT const *second, WT *result)</td></tr>
<tr class="memdesc:aada0a5fdbdfb025445745dd6dcc15436"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute jaccard similarity coefficient for selected vertex pairs.  <a href="namespacecugraph.html#aada0a5fdbdfb025445745dd6dcc15436">More...</a><br></td></tr>
<tr class="separator:aada0a5fdbdfb025445745dd6dcc15436"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a881fec13f35882b5859024214536d6f8"><td align="right" class="memItemLeft" valign="top"><a id="a881fec13f35882b5859024214536d6f8"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a881fec13f35882b5859024214536d6f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a516d92b42f71abe8afd838340af2a5c1"><td align="right" class="memItemLeft" valign="top"><a id="a516d92b42f71abe8afd838340af2a5c1"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:a516d92b42f71abe8afd838340af2a5c1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a616b641efca9049e4483cf7a053896b4"><td align="right" class="memItemLeft" valign="top"><a id="a616b641efca9049e4483cf7a053896b4"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a616b641efca9049e4483cf7a053896b4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac9f3328d709aad58fb307d4949a78d1b"><td align="right" class="memItemLeft" valign="top"><a id="ac9f3328d709aad58fb307d4949a78d1b"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:ac9f3328d709aad58fb307d4949a78d1b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a64ad868ecf50a8eb156d60a0c8e19e18"><td align="right" class="memItemLeft" valign="top"><a id="a64ad868ecf50a8eb156d60a0c8e19e18"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, int32_t, int32_t const *, int32_t const *, float *)</td></tr>
<tr class="separator:a64ad868ecf50a8eb156d60a0c8e19e18"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5f798af329f7620cc0895fe92eeb320f"><td align="right" class="memItemLeft" valign="top"><a id="a5f798af329f7620cc0895fe92eeb320f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, int32_t, int32_t const *, int32_t const *, double *)</td></tr>
<tr class="separator:a5f798af329f7620cc0895fe92eeb320f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4673562026d38fb06aed8fcbeb3e37f2"><td align="right" class="memItemLeft" valign="top"><a id="a4673562026d38fb06aed8fcbeb3e37f2"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, int64_t, int64_t const *, int64_t const *, float *)</td></tr>
<tr class="separator:a4673562026d38fb06aed8fcbeb3e37f2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5785b7dd99c052f180ca3cab67ec11d5"><td align="right" class="memItemLeft" valign="top"><a id="a5785b7dd99c052f180ca3cab67ec11d5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, int64_t, int64_t const *, int64_t const *, double *)</td></tr>
<tr class="separator:a5785b7dd99c052f180ca3cab67ec11d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aeaa48eeaac66fa304ce189d280c93579"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:aeaa48eeaac66fa304ce189d280c93579"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#aeaa48eeaac66fa304ce189d280c93579">overlap</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT const *weights, WT *result)</td></tr>
<tr class="memdesc:aeaa48eeaac66fa304ce189d280c93579"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute overlap coefficient for all vertices in the graph.  <a href="namespacecugraph.html#aeaa48eeaac66fa304ce189d280c93579">More...</a><br></td></tr>
<tr class="separator:aeaa48eeaac66fa304ce189d280c93579"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a08982e910178f088d24bd943769131d1"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a08982e910178f088d24bd943769131d1"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a08982e910178f088d24bd943769131d1">overlap_list</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT const *weights, ET num_pairs, VT const *first, VT const *second, WT *result)</td></tr>
<tr class="memdesc:a08982e910178f088d24bd943769131d1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute overlap coefficient for select pairs of vertices.  <a href="namespacecugraph.html#a08982e910178f088d24bd943769131d1">More...</a><br></td></tr>
<tr class="separator:a08982e910178f088d24bd943769131d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a10725032cbcd24d2c287eeb301402925"><td align="right" class="memItemLeft" valign="top"><a id="a10725032cbcd24d2c287eeb301402925"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a10725032cbcd24d2c287eeb301402925"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a94ed5c694e713fc7229703adb31a023e"><td align="right" class="memItemLeft" valign="top"><a id="a94ed5c694e713fc7229703adb31a023e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:a94ed5c694e713fc7229703adb31a023e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a714f4fe0bfa293bd52f88322ba26d525"><td align="right" class="memItemLeft" valign="top"><a id="a714f4fe0bfa293bd52f88322ba26d525"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a714f4fe0bfa293bd52f88322ba26d525"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7ba07d239512050840efe8dac8a34ef5"><td align="right" class="memItemLeft" valign="top"><a id="a7ba07d239512050840efe8dac8a34ef5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:a7ba07d239512050840efe8dac8a34ef5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6b94b1338211f54eb73f3854e292305f"><td align="right" class="memItemLeft" valign="top"><a id="a6b94b1338211f54eb73f3854e292305f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, int32_t, int32_t const *, int32_t const *, float *)</td></tr>
<tr class="separator:a6b94b1338211f54eb73f3854e292305f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5f5b7effecbaae96f94821647c1b79c8"><td align="right" class="memItemLeft" valign="top"><a id="a5f5b7effecbaae96f94821647c1b79c8"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, int32_t, int32_t const *, int32_t const *, double *)</td></tr>
<tr class="separator:a5f5b7effecbaae96f94821647c1b79c8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a907c423e61b08240632a78828411bc03"><td align="right" class="memItemLeft" valign="top"><a id="a907c423e61b08240632a78828411bc03"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, int64_t, int64_t const *, int64_t const *, float *)</td></tr>
<tr class="separator:a907c423e61b08240632a78828411bc03"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af1b65829693ca296e9f50ade26518562"><td align="right" class="memItemLeft" valign="top"><a id="af1b65829693ca296e9f50ade26518562"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, int64_t, int64_t const *, int64_t const *, double *)</td></tr>
<tr class="separator:af1b65829693ca296e9f50ade26518562"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a007a963984961523802b2b66a6dd33db"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a007a963984961523802b2b66a6dd33db"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a007a963984961523802b2b66a6dd33db">bfs</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, VT *distances, VT *predecessors, double *sp_counters, const VT start_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a007a963984961523802b2b66a6dd33db"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9467dd147430d6e65fe9105f0e1bad4"><td align="right" class="memItemLeft" valign="top"><a id="ae9467dd147430d6e65fe9105f0e1bad4"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; uint32_t, uint32_t, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; uint32_t, uint32_t, float &gt; const &amp;graph, uint32_t *distances, uint32_t *predecessors, double *sp_counters, const uint32_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:ae9467dd147430d6e65fe9105f0e1bad4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac1d530dffcca644594132aa57bb85619"><td align="right" class="memItemLeft" valign="top"><a id="ac1d530dffcca644594132aa57bb85619"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; uint32_t, uint32_t, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; uint32_t, uint32_t, double &gt; const &amp;graph, uint32_t *distances, uint32_t *predecessors, double *sp_counters, const uint32_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:ac1d530dffcca644594132aa57bb85619"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4782633c28f44e90cb0923aa5ab632d3"><td align="right" class="memItemLeft" valign="top"><a id="a4782633c28f44e90cb0923aa5ab632d3"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; int32_t, int32_t, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;graph, int32_t *distances, int32_t *predecessors, double *sp_counters, const int32_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a4782633c28f44e90cb0923aa5ab632d3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6ad16d5075edfebf5262f9cec30ab374"><td align="right" class="memItemLeft" valign="top"><a id="a6ad16d5075edfebf5262f9cec30ab374"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; int32_t, int32_t, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;graph, int32_t *distances, int32_t *predecessors, double *sp_counters, const int32_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a6ad16d5075edfebf5262f9cec30ab374"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9093108910b8c57784b25b866465620f"><td align="right" class="memItemLeft" valign="top"><a id="a9093108910b8c57784b25b866465620f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; int64_t, int64_t, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;graph, int64_t *distances, int64_t *predecessors, double *sp_counters, const int64_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:a9093108910b8c57784b25b866465620f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab01260fa4821ff7aa3c6d2221b2a4a07"><td align="right" class="memItemLeft" valign="top"><a id="ab01260fa4821ff7aa3c6d2221b2a4a07"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bfs&lt; int64_t, int64_t, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;graph, int64_t *distances, int64_t *predecessors, double *sp_counters, const int64_t source_vertex, bool directed, bool mg_batch)</td></tr>
<tr class="separator:ab01260fa4821ff7aa3c6d2221b2a4a07"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afbcb939cffaf811289ba6a5edc7f6b04"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:afbcb939cffaf811289ba6a5edc7f6b04"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#afbcb939cffaf811289ba6a5edc7f6b04">sssp</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT *distances, VT *predecessors, const VT source_vertex)</td></tr>
<tr class="memdesc:afbcb939cffaf811289ba6a5edc7f6b04"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Native sssp with predecessors.  <a href="namespacecugraph.html#afbcb939cffaf811289ba6a5edc7f6b04">More...</a><br></td></tr>
<tr class="separator:afbcb939cffaf811289ba6a5edc7f6b04"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a134ecdec6bca8ae3bbd8b05cb924a112"><td align="right" class="memItemLeft" valign="top"><a id="a134ecdec6bca8ae3bbd8b05cb924a112"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, float &gt; const &amp;graph, float *distances, int *predecessors, const int source_vertex)</td></tr>
<tr class="separator:a134ecdec6bca8ae3bbd8b05cb924a112"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0c62368ae0207e9192b5d7f6c90a1b5e"><td align="right" class="memItemLeft" valign="top"><a id="a0c62368ae0207e9192b5d7f6c90a1b5e"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sssp&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, double &gt; const &amp;graph, double *distances, int *predecessors, const int source_vertex)</td></tr>
<tr class="separator:a0c62368ae0207e9192b5d7f6c90a1b5e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a75cae03f49d08c9257d7eb1e81e19530"><td align="right" class="memItemLeft" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a75cae03f49d08c9257d7eb1e81e19530">traveling_salesperson</a> (raft::handle_t const &amp;handle, int const *vtx_ptr, float const *x_pos, float const *y_pos, int nodes, int restarts, bool beam_search, int k, int nstart, bool verbose, int *route)</td></tr>
<tr class="memdesc:a75cae03f49d08c9257d7eb1e81e19530"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds an approximate solution to the traveling salesperson problem (TSP). cuGraph computes an approximation of the TSP problem using hill climbing optimization.  <a href="namespacecugraph.html#a75cae03f49d08c9257d7eb1e81e19530">More...</a><br></td></tr>
<tr class="separator:a75cae03f49d08c9257d7eb1e81e19530"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0a543daa87bfbef69b255ea2d5441877"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a0a543daa87bfbef69b255ea2d5441877"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; VT, ET, WT &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a0a543daa87bfbef69b255ea2d5441877">get_two_hop_neighbors</a> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph)</td></tr>
<tr class="memdesc:a0a543daa87bfbef69b255ea2d5441877"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all 2-hop neighbors in the graph.  <a href="namespacecugraph.html#a0a543daa87bfbef69b255ea2d5441877">More...</a><br></td></tr>
<tr class="separator:a0a543daa87bfbef69b255ea2d5441877"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7c8fbf3b9095dafb1e0b4bfac02f6f40"><td align="right" class="memItemLeft" valign="top"><a id="a7c8fbf3b9095dafb1e0b4bfac02f6f40"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; int, int, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_two_hop_neighbors</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, float &gt; const &amp;)</td></tr>
<tr class="separator:a7c8fbf3b9095dafb1e0b4bfac02f6f40"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adf8251078dbb571f66d902eca924f304"><td align="right" class="memItemLeft" valign="top"><a id="adf8251078dbb571f66d902eca924f304"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; int, int, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_two_hop_neighbors</b> (<a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, double &gt; const &amp;)</td></tr>
<tr class="separator:adf8251078dbb571f66d902eca924f304"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5454f11df761214623aba6c416adadf1"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a5454f11df761214623aba6c416adadf1"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; vertex_t, edge_t, weight_t &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a5454f11df761214623aba6c416adadf1">minimum_spanning_tree</a> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;graph, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a5454f11df761214623aba6c416adadf1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate edges in a minimum spanning forest of an undirected weighted graph.  <a href="namespacecugraph.html#a5454f11df761214623aba6c416adadf1">More...</a><br></td></tr>
<tr class="separator:a5454f11df761214623aba6c416adadf1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0cf6e2dab8b0a34566522114ec98f051"><td align="right" class="memItemLeft" valign="top"><a id="a0cf6e2dab8b0a34566522114ec98f051"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; int, int, float &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>minimum_spanning_tree&lt; int, int, float &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, float &gt; const &amp;graph, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:a0cf6e2dab8b0a34566522114ec98f051"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad636910fbd154da9d8a15e0b19fbf874"><td align="right" class="memItemLeft" valign="top"><a id="ad636910fbd154da9d8a15e0b19fbf874"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; int, int, double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>minimum_spanning_tree&lt; int, int, double &gt;</b> (raft::handle_t const &amp;handle, <a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; int, int, double &gt; const &amp;graph, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ad636910fbd154da9d8a15e0b19fbf874"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a08fb902125ff27b1bd3b386c09450436"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a08fb902125ff27b1bd3b386c09450436"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a08fb902125ff27b1bd3b386c09450436">get_traversed_cost</a> (raft::handle_t const &amp;handle, vertex_t const *vertices, vertex_t const *preds, weight_t const *info_weights, weight_t *out, vertex_t stop_vertex, vertex_t num_vertices)</td></tr>
<tr class="memdesc:a08fb902125ff27b1bd3b386c09450436"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes the results of BFS or SSSP function call and sums the given weights along the path to the starting vertex.  <a href="namespacecugraph.html#a08fb902125ff27b1bd3b386c09450436">More...</a><br></td></tr>
<tr class="separator:a08fb902125ff27b1bd3b386c09450436"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0a1ea0ebaa6d020cbe75218ceacc3407"><td align="right" class="memItemLeft" valign="top"><a id="a0a1ea0ebaa6d020cbe75218ceacc3407"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_traversed_cost&lt; int32_t, float &gt;</b> (raft::handle_t const &amp;handle, int32_t const *vertices, int32_t const *preds, float const *info_weights, float *out, int32_t stop_vertex, int32_t num_vertices)</td></tr>
<tr class="separator:a0a1ea0ebaa6d020cbe75218ceacc3407"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab8d6554f98dc75a902c445d930f6db6d"><td align="right" class="memItemLeft" valign="top"><a id="ab8d6554f98dc75a902c445d930f6db6d"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_traversed_cost&lt; int32_t, double &gt;</b> (raft::handle_t const &amp;handle, int32_t const *vertices, int32_t const *preds, double const *info_weights, double *out, int32_t stop_vertex, int32_t num_vertices)</td></tr>
<tr class="separator:ab8d6554f98dc75a902c445d930f6db6d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a93dbff34f1cdabe885afe72b31c2c20f"><td align="right" class="memItemLeft" valign="top"><a id="a93dbff34f1cdabe885afe72b31c2c20f"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_traversed_cost&lt; int64_t, float &gt;</b> (raft::handle_t const &amp;handle, int64_t const *vertices, int64_t const *preds, float const *info_weights, float *out, int64_t stop_vertex, int64_t num_vertices)</td></tr>
<tr class="separator:a93dbff34f1cdabe885afe72b31c2c20f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3baa4799c8c1aa3dd6711f257f5483b5"><td align="right" class="memItemLeft" valign="top"><a id="a3baa4799c8c1aa3dd6711f257f5483b5"></a>
template void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_traversed_cost&lt; int64_t, double &gt;</b> (raft::handle_t const &amp;handle, int64_t const *vertices, int64_t const *preds, double const *info_weights, double *out, int64_t stop_vertex, int64_t num_vertices)</td></tr>
<tr class="separator:a3baa4799c8c1aa3dd6711f257f5483b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3ea68fa26fc144e25e2bb392903c4ec4"><td class="memTemplParams" colspan="2">template&lt;typename value_t &gt; </td></tr>
<tr class="memitem:a3ea68fa26fc144e25e2bb392903c4ec4"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a3ea68fa26fc144e25e2bb392903c4ec4">comms_bcast</a> (const raft::handle_t &amp;handle, value_t *value, size_t count)</td></tr>
<tr class="memdesc:a3ea68fa26fc144e25e2bb392903c4ec4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast using handle communicator.  <a href="namespacecugraph.html#a3ea68fa26fc144e25e2bb392903c4ec4">More...</a><br></td></tr>
<tr class="separator:a3ea68fa26fc144e25e2bb392903c4ec4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Katz Centrality implementation. </p>
<p>Wrapper functions for MST.</p>
<p>Functions for computing the two hop neighbor pairs of a graph.</p>
<p>The cugraph Jaccard core functionality.</p>
<p>Wrapper functions for Spectral Clustering.</p>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md1"></a>
@file katz_centrality.cu</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md3"></a>
@file spectral_clustering.cu</h2>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md4"></a>
@brief wrapper calling gunrock's HITS analytic</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md5"></a>
@file jaccard.cu</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md6"></a>
@file jaccard.cu</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md8"></a>
@file two_hop_neighbors.cu</h2>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md10"></a>
@file mst.cu</h2>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a365647c6c8b681e9af24661537ee6e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365647c6c8b681e9af24661537ee6e27">&nbsp;</a></span>cugraph_cc_t</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">enum <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph::cugraph_cc_t</a></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a365647c6c8b681e9af24661537ee6e27a5882369885616cc6ba190202b140ee02"></a>CUGRAPH_STRONG&nbsp;</td><td class="fielddoc"><blockquote class="doxtable">
<p>Weakly Connected Components </p>
</blockquote>
</td></tr>
<tr><td class="fieldname"><a id="a365647c6c8b681e9af24661537ee6e27a436bdad1238dd6b8309bdbd0150c0e65"></a>NUM_CONNECTIVITY_TYPES&nbsp;</td><td class="fielddoc"><blockquote class="doxtable">
<p>Strongly Connected Components </p>
</blockquote>
</td></tr>
</tbody></table>
</div>
</div>
<a id="a31902d040f48ca34b65c041847c3cd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31902d040f48ca34b65c041847c3cd98">&nbsp;</a></span>DegreeDirection</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">enum <a class="el" href="namespacecugraph.html#a31902d040f48ca34b65c041847c3cd98">cugraph::DegreeDirection</a></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a31902d040f48ca34b65c041847c3cd98ac86ee0d9d7ed3e7b4fdbf486fa6c0ebb"></a>IN&nbsp;</td><td class="fielddoc"><blockquote class="doxtable">
<p>Compute sum of in and out degree </p>
</blockquote>
</td></tr>
<tr><td class="fieldname"><a id="a31902d040f48ca34b65c041847c3cd98aef373774188a51f80463f37b6bd9e83a"></a>OUT&nbsp;</td><td class="fielddoc"><blockquote class="doxtable">
<p>Compute in degree </p>
</blockquote>
</td></tr>
<tr><td class="fieldname"><a id="a31902d040f48ca34b65c041847c3cd98afa48476d9be3504d991897f564b32427"></a>DEGREE_DIRECTION_COUNT&nbsp;</td><td class="fielddoc"><blockquote class="doxtable">
<p>Compute out degree </p>
</blockquote>
</td></tr>
</tbody></table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afa8eadf92af49adf18fe1403b7c5d62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8eadf92af49adf18fe1403b7c5d62e">&nbsp;</a></span>betweenness_centrality()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::betweenness_centrality </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">result_t *&nbsp;</td>
<td class="paramname"><em>result</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>normalized</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>endpoints</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t const *&nbsp;</td>
<td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>k</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const *&nbsp;</td>
<td class="paramname"><em>vertices</em> = <code>nullptr</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute betweenness centrality for a graph. </p>
<p>Betweenness centrality for a vertex is the sum of the fraction of all pairs shortest paths that pass through the vertex.</p>
<p>The current implementation does not support a weighted graph.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>if <code>result == nullptr</code> or <code>number_of_sources &lt; 0</code> or <code>number_of_sources !=0 and sources == nullptr</code>. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double. </td></tr>
<tr><td class="paramname">result_t</td><td>Type of computed result. Supported values : float or double </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a CSR </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device array of centrality scores </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalized</td><td>If true, return normalized scores, if false return unnormalized scores. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">endpoints</td><td>If true, include endpoints of paths in score, if false do not </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>If specified, device array of weights for each edge </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>If specified, number of vertex samples defined in the vertices array. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>If specified, host array of vertex ids to estimate betweenness these vertices will serve as sources for the traversal algorihtm to obtain shortest path counters. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">total_number_of_source_used</td><td>If specified use this number to normalize results when using subsampling, it allows accumulation of results across multiple calls. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a007a963984961523802b2b66a6dd33db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007a963984961523802b2b66a6dd33db">&nbsp;</a></span>bfs()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::bfs </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT *&nbsp;</td>
<td class="paramname"><em>distances</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT *&nbsp;</td>
<td class="paramname"><em>predecessors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double *&nbsp;</td>
<td class="paramname"><em>sp_counters</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const VT&nbsp;</td>
<td class="paramname"><em>start_vertex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>directed</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>mg_batch</em> = <code>false</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>@Synopsis Performs a breadth first search traversal of a graph starting from a vertex.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : int (signed, 32-bit)</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>If set to a valid pointer, this is populated by distance of every vertex in the graph from the starting vertex</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">predecessors</td><td>If set to a valid pointer, this is populated by bfs traversal predecessor of every vertex</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">sp_counters</td><td>If set to a valid pointer, this is populated by bfs traversal shortest_path counter of every vertex</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">start_vertex</td><td>The starting vertex for breadth first search traversal</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">directed</td><td>Treat the input graph as directed</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mg_batch</td><td>If set to true use SG BFS path when comms are initialized. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a3da3282a0c1ee7afc2cb91f6e17a8835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da3282a0c1ee7afc2cb91f6e17a8835">&nbsp;</a></span>combine_edgelists()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt; cugraph::combine_edgelists </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;&nbsp;</td>
<td class="paramname"><em>d_sources</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; rmm::device_uvector&lt; vertex_t &gt;&gt; &amp;&amp;&nbsp;</td>
<td class="paramname"><em>d_dests</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::optional&lt; std::vector&lt; rmm::device_uvector&lt; weight_t &gt;&gt;&gt; &amp;&amp;&nbsp;</td>
<td class="paramname"><em>optional_d_weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>remove_multi_edges</em> = <code>true</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Combine edgelists from multiple sources into a single edgelist. </p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will operate only on its subset of data. Any shuffling to get edges onto the same GPU should be done prior to calling this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">sources</td><td>The source vertex ids to combine </td></tr>
<tr><td class="paramname">dests</td><td>The destination vertex ids to combine </td></tr>
<tr><td class="paramname">weights</td><td>Optional vector of weights to combine </td></tr>
<tr><td class="paramname">remove_multi_edges</td><td>If true (the default) then remove multi edges, if false leave them in </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;weight_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs and edge weights. </dd></dl>
</div>
</div>
<a id="a3ea68fa26fc144e25e2bb392903c4ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea68fa26fc144e25e2bb392903c4ec4">&nbsp;</a></span>comms_bcast()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::comms_bcast </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">value_t *&nbsp;</td>
<td class="paramname"><em>value</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>count</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Broadcast using handle communicator. </p>
<p>Use handle's communicator to operate broadcasting.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">value_t</td><td>Type of the data to broadcast</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Point to the data </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to broadcast </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a6c61241ace7da8b4f3b3f35a8a3f3980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c61241ace7da8b4f3b3f35a8a3f3980">&nbsp;</a></span>connected_components()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::connected_components </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a>&nbsp;</td>
<td class="paramname"><em>connectivity_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT *&nbsp;</td>
<td class="paramname"><em>labels</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute connected components. </p>
<p>The weak version (for undirected graphs, only) was imported from cuML. This implementation comes from [1] and solves component labeling problem in parallel on CSR-indexes based upon the vertex degree and adjacency graph.</p>
<p>[1] Hawick, K.A et al, 2010. "Parallel graph component labelling with GPUs and CUDA"</p>
<p>The strong version (for directed or undirected graphs) is based on: [2] Gilbert, J. et al, 2011. "Graph Algorithms in the Language of Linear Algebra"</p>
<p>C = I | A | A^2 |...| A^k where matrix multiplication is via semi-ring: (combine, reduce) == (&amp;, |) (bitwise ops) Then: X = C &amp; transpose(C); and finally, apply get_labels(X);</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">connectivity_type</td><td>STRONG or WEAK </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">labels</td><td>Device array of component labels (labels[i] indicates the label associated with vertex id i. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a4ddfbabee24b22217e4bbfdecb55980e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddfbabee24b22217e4bbfdecb55980e">&nbsp;</a></span>coo_to_csr()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCSR.html">GraphCSR</a>&lt; VT, ET, WT &gt; &gt; cugraph::coo_to_csr </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Convert COO to CSR. </p>
<p>Takes a list of edges in COOrdinate format and generates a CSR format.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>type of vertex index </td></tr>
<tr><td class="paramname">ET</td><td>type of edge index </td></tr>
<tr><td class="paramname">WT</td><td>type of the edge weight</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph in coordinate format </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to generate Compressed Sparse Row graph </dd></dl>
</div>
</div>
<a id="aa9d5c8e792f3082f524d07e0f8e489b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d5c8e792f3082f524d07e0f8e489b2">&nbsp;</a></span>core_number()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::core_number </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT *&nbsp;</td>
<td class="paramname"><em>core_number</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute the Core Number for the nodes of the graph G. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor with a valid edgeList or adjList </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">core_number</td><td>Populated by the core number of every vertex in the graph</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="afb3648213e150cbe1c0e7a3a9fd40915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3648213e150cbe1c0e7a3a9fd40915">&nbsp;</a></span>ecg()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::ecg </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t&nbsp;</td>
<td class="paramname"><em>min_weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>ensemble_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t *&nbsp;</td>
<td class="paramname"><em>clustering</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Computes the ecg clustering of the given graph. </p>
<p>ECG runs truncated <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> on an ensemble of permutations of the input graph, then uses the ensemble partitions to determine weights for the input graph. The final result is found by running full <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> on the input graph using the determined weights. See <a href="https://arxiv.org/abs/1809.05578">https://arxiv.org/abs/1809.05578</a> for further information.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph_coo</td><td>input graph object (COO) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph_csr</td><td>input graph object (CSR) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_weight</td><td>The minimum weight parameter </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ensemble_size</td><td>The ensemble size parameter </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>A device pointer to array where the partitioning should be written </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a74ceda7a5e01d0d2b31ebc128fd4dfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ceda7a5e01d0d2b31ebc128fd4dfa0">&nbsp;</a></span>edge_betweenness_centrality()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t , typename result_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::edge_betweenness_centrality </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">result_t *&nbsp;</td>
<td class="paramname"><em>result</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>normalized</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t const *&nbsp;</td>
<td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>k</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const *&nbsp;</td>
<td class="paramname"><em>vertices</em> = <code>nullptr</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute edge betweenness centrality for a graph. </p>
<p>Betweenness centrality of an edge is the sum of the fraction of all-pairs shortest paths that pass through this edge. The weight parameter is currenlty not supported</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>if <code>result == nullptr</code> or <code>number_of_sources &lt; 0</code> or <code>number_of_sources !=0 and sources == nullptr</code> or <code>endpoints == true</code>. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double. </td></tr>
<tr><td class="paramname">result_t</td><td>Type of computed result. Supported values : float or double </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device array of centrality scores </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalized</td><td>If true, return normalized scores, if false return unnormalized scores. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>If specified, device array of weights for each edge </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>If specified, number of vertex samples defined in the vertices array. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>If specified, host array of vertex ids to estimate betweenness these vertices will serve as sources for the traversal algorihtm to obtain shortest path counters. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">total_number_of_source_used</td><td>If specified use this number to normalize results when using subsampling, it allows accumulation of results across multiple calls. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a14ff99325a9b1360a3ae2a3b3ff30c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ff99325a9b1360a3ae2a3b3ff30c58">&nbsp;</a></span>flatten_dendrogram()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graph_view_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::flatten_dendrogram </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">graph_view_t const &amp;&nbsp;</td>
<td class="paramname"><em>graph_view</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; typename graph_view_t::vertex_type &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>dendrogram</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">typename graph_view_t::vertex_type *&nbsp;</td>
<td class="paramname"><em>clustering</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Flatten a <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a> at a particular level. </p>
<p>A <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a> represents a hierarchical clustering/partitioning of a graph. This function will flatten the hierarchical clustering into a label for each vertex representing the final cluster/partition to which it is assigned</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">graph_view_t</td><td>Type of graph</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dendrogram</td><td>input dendrogram object </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>Pointer to device array where the clustering should be stored </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="aba1813aba5fc057cdbf5bcd62ea2ec84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1813aba5fc057cdbf5bcd62ea2ec84">&nbsp;</a></span>force_atlas2()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::force_atlas2 </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float *&nbsp;</td>
<td class="paramname"><em>pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int&nbsp;</td>
<td class="paramname"><em>max_iter</em> = <code>500</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float *&nbsp;</td>
<td class="paramname"><em>x_start</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float *&nbsp;</td>
<td class="paramname"><em>y_start</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>outbound_attraction_distribution</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>lin_log_mode</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>prevent_overlapping</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float&nbsp;</td>
<td class="paramname"><em>edge_weight_influence</em> = <code>1.0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float&nbsp;</td>
<td class="paramname"><em>jitter_tolerance</em> = <code>1.0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>barnes_hut_optimize</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float&nbsp;</td>
<td class="paramname"><em>barnes_hut_theta</em> = <code>0.5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float&nbsp;</td>
<td class="paramname"><em>scaling_ratio</em> = <code>2.0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>strong_gravity_mode</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float&nbsp;</td>
<td class="paramname"><em>gravity</em> = <code>1.0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>verbose</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *&nbsp;</td>
<td class="paramname"><em>callback</em> = <code>nullptr</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>ForceAtlas2 is a continuous graph layout algorithm for handy network visualization. </p>
<pre class="fragment">                                         NOTE: Peak memory allocation occurs at 17*V.
</pre><dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a COO. Graph is considered undirected. Edge weights are used for this algorithm and set to 1 by default. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Device array (2, n) containing x-axis and y-axis positions; </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations Force Atlas 2 should run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">x_start</td><td>Device array containing starting x-axis positions; </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y_start</td><td>Device array containing starting y-axis positions; </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">outbound_attraction_distribution</td><td>Distributes attraction along outbound edges. Hubs attract less and thus are pushed to the borders. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">lin_log_mode</td><td>Switch ForceAtlas&rsquo; model from lin-lin to lin-log (tribute to Andreas Noack). Makes clusters more tight. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">prevent_overlapping</td><td>Prevent nodes from overlapping. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">edge_weight_influence</td><td>How much influence you give to the edges weight. 0 is &ldquo;no influence&rdquo; and 1 is &ldquo;normal&rdquo;. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">jitter_tolerance</td><td>How much swinging you allow. Above 1 discouraged. Lower gives less speed and more precision. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut_optimize</td><td>Whether to use the Barnes Hut approximation or the slower exact version. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut_theta</td><td>Float between 0 and 1. Tradeoff for speed (1) vs accuracy (0) for Barnes Hut only. @params[in] scaling_ratio Float strictly positive. How much repulsion you want. More makes a more sparse graph. Switching from regular mode to LinLog mode needs a readjustment of the scaling parameter. @params[in] strong_gravity_mode Sets a force that attracts the nodes that are distant from the center more. It is so strong that it can sometimes dominate other forces. @params[in] gravity Attracts nodes to the center. Prevents islands from drifting away. @params[in] verbose Output convergence info at each interation. @params[in] callback An instance of GraphBasedDimRedCallback class to intercept the internal state of positions while they are being trained. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="adc635cbe97462344e74adf1ed7a44a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc635cbe97462344e74adf1ed7a44a72">&nbsp;</a></span>generate_2d_mesh_graph_edgelist()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_2d_mesh_graph_edgelist </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; std::tuple&lt; vertex_t, vertex_t, vertex_t &gt;&gt; const &amp;&nbsp;</td>
<td class="paramname"><em>component_parameters_v</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>generate an edge list for a 2D Mesh Graph </p>
<p>A sequence of 2D mesh graphs will be constructed according to the component specifications. Each 2D mesh graph is configured with a tuple containing (x, y, base_vertex_id). <code>component_parameters_v</code> will contain a tuple for each component.</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate disjoint 2D mesh constructs of equal size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">component_parameters_v</td><td>Vector containing tuple defining the configuration of each component </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="a16c815a628f002265faa58797bfeab3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c815a628f002265faa58797bfeab3b">&nbsp;</a></span>generate_3d_mesh_graph_edgelist()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_3d_mesh_graph_edgelist </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; std::tuple&lt; vertex_t, vertex_t, vertex_t, vertex_t &gt;&gt; const &amp;&nbsp;</td>
<td class="paramname"><em>component_parameters_v</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>generate an edge list for a 3D Mesh Graph </p>
<p>A sequence of 3D mesh graphs will be constructed according to the component specifications. Each 3D mesh graph is configured with a tuple containing (x, y, z, base_vertex_id). <code>component_parameters_v</code> will contain a tuple for each component.</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate disjoint 3D mesh constructs of equal size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">component_parameters_v</td><td>Vector containing tuple defining the configuration of each component </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="a35c787db93f9ec4165a8430f965254c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c787db93f9ec4165a8430f965254c7">&nbsp;</a></span>generate_complete_graph_edgelist()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_complete_graph_edgelist </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; std::tuple&lt; vertex_t, vertex_t &gt;&gt; const &amp;&nbsp;</td>
<td class="paramname"><em>component_parameters_v</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>generate an edge lists for some complete graphs </p>
<p>A sequence of complete graphs will be constructed according to the component specifications. Each complete graph is configured with a tuple containing (n, base_vertex_id). <code>component_parameters_v</code> will contain a tuple for each component.</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate disjoint complete graph constructs of equal size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">component_parameters_v</td><td>Vector containing tuple defining the configuration of each component </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="a72ced6246f6172491c08ee1719e0afe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ced6246f6172491c08ee1719e0afe1">&nbsp;</a></span>generate_erdos_renyi_graph_edgelist_gnm()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_erdos_renyi_graph_edgelist_gnm </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>num_vertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>m</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>base_vertex_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t&nbsp;</td>
<td class="paramname"><em>seed</em> = <code>0</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>generate an edge lists for an Erdos-Renyi graph </p>
<p>This API supports the G(n,m) model</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate Erdos-Renyi edges for its portion of the 2D partitioning of the adjacency matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">num_vertices</td><td>Number of vertices to use in each complete graph </td></tr>
<tr><td class="paramname">m</td><td>Number of edges to generate </td></tr>
<tr><td class="paramname">base_vertex_id</td><td>Starting vertex id for the generated graph </td></tr>
<tr><td class="paramname">seed</td><td>Seed value for the random number generator. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="aa0a5f26d9d1f8e7f5be618b169afab13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a5f26d9d1f8e7f5be618b169afab13">&nbsp;</a></span>generate_erdos_renyi_graph_edgelist_gnp()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_erdos_renyi_graph_edgelist_gnp </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>num_vertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float&nbsp;</td>
<td class="paramname"><em>p</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>base_vertex_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t&nbsp;</td>
<td class="paramname"><em>seed</em> = <code>0</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>generate an edge lists for an Erdos-Renyi graph </p>
<p>This API supports the G(n,p) model which requires O(n^2) work.</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) each GPU will generate Erdos-Renyi edges for its portion of the 2D partitioning of the adjacency matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">num_vertices</td><td>Number of vertices to use in the generated graph </td></tr>
<tr><td class="paramname">p</td><td>Probability for edge creation </td></tr>
<tr><td class="paramname">base_vertex_id</td><td>Starting vertex id for the generated graph </td></tr>
<tr><td class="paramname">seed</td><td>Seed value for the random number generator. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="a22e8e5b35a3e17bcb609162b38d681a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e8e5b35a3e17bcb609162b38d681a7">&nbsp;</a></span>generate_path_graph_edgelist()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_path_graph_edgelist </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; std::tuple&lt; vertex_t, vertex_t &gt;&gt; const &amp;&nbsp;</td>
<td class="paramname"><em>component_parameters_v</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>generate an edge list for path graph </p>
<p>A path graph of size n connects the vertices from 0 to (n - 1) in a single long path: ((0,1), (1,2), ..., (n - 2, n - 1)</p>
<p>If executed in a multi-gpu context (handle comms has been initialized) the path will span all GPUs including an edge from the last vertex on GPU i to the first vertex on GPU (i+1)</p>
<p>This function will generate a collection of path graphs. <code>component_parameters_v</code> defines the parameters for generating each component. Each element of <code>component_parameters_v</code> defines a tuple consisting of the number of vertices and the base vertex id for the component.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">component_parameters_v</td><td>A vector containing tuples consisting of the number of vertices and base vertex id for each component to generate. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="a868438c616436c2e2f2017d46479c3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868438c616436c2e2f2017d46479c3f7">&nbsp;</a></span>generate_rmat_edgelist()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; cugraph::generate_rmat_edgelist </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>scale</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>num_edges</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double&nbsp;</td>
<td class="paramname"><em>a</em> = <code>0.57</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double&nbsp;</td>
<td class="paramname"><em>b</em> = <code>0.19</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double&nbsp;</td>
<td class="paramname"><em>c</em> = <code>0.19</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t&nbsp;</td>
<td class="paramname"><em>seed</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>clip_and_flip</em> = <code>false</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>generate an edge list for an R-mat graph. </p>
<p>This function allows multi-edges and self-loops similar to the Graph 500 reference implementation.</p>
<p>NOTE: The scramble_vertex_ids function needs to be called in order to generate a graph conforming to the Graph 500 specification (note that scrambling does not affect cuGraph's graph construction performance, so this is generally unnecessary). If <code>edge_factor</code> is given (e.g. Graph 500), set <code>num_edges</code> to (size_t{1} &lt;&lt; <code>scale</code>) * <code>edge_factor</code>. To generate an undirected graph, set <code>b</code> == <code>c</code> and <code>clip_and_flip</code> = true. All the resulting edges will be placed in the lower triangular part (including the diagonal) of the graph adjacency matrix.</p>
<p>For multi-GPU generation with <code>P</code> GPUs, <code>seed</code> should be set to different values in different GPUs to avoid every GPU generating the same set of edges. <code>num_edges</code> should be adjusted as well; e.g. assuming <code>edge_factor</code> is given, set <code>num_edges</code> = (size_t{1} &lt;&lt; <code>scale</code>) * <code>edge_factor</code> / <code>P</code> + (rank &lt; (((size_t{1} &lt;&lt; <code>scale</code>) * <code>edge_factor</code>) % P) ? 1 : 0).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">scale</td><td>Scale factor to set the number of verties in the graph. Vertex IDs have values in [0, V), where V = 1 &lt;&lt; <code>scale</code>. </td></tr>
<tr><td class="paramname">num_edges</td><td>Number of edges to generate. </td></tr>
<tr><td class="paramname">a</td><td>a, b, c, d (= 1.0 - (a + b + c)) in the R-mat graph generator (vist <a href="https://graph500.org">https://graph500.org</a> for additional details). a, b, c, d should be non-negative and a + b + c should be no larger than 1.0. </td></tr>
<tr><td class="paramname">b</td><td>a, b, c, d (= 1.0 - (a + b + c)) in the R-mat graph generator (vist <a href="https://graph500.org">https://graph500.org</a> for additional details). a, b, c, d should be non-negative and a + b + c should be no larger than 1.0. </td></tr>
<tr><td class="paramname">c</td><td>a, b, c, d (= 1.0 - (a + b + c)) in the R-mat graph generator (vist <a href="https://graph500.org">https://graph500.org</a> for additional details). a, b, c, d should be non-negative and a + b + c should be no larger than 1.0. </td></tr>
<tr><td class="paramname">seed</td><td>Seed value for the random number generator. </td></tr>
<tr><td class="paramname">clip_and_flip</td><td>Flag controlling whether to generate edges only in the lower triangular part (including the diagonal) of the graph adjacency matrix (if set to <code>true</code>) or not (if set to <code>false</code>). </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="aefc59061788cff241d12089e0162b3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc59061788cff241d12089e0162b3bb">&nbsp;</a></span>generate_rmat_edgelists()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::vector&lt; std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt; &gt; &gt; cugraph::generate_rmat_edgelists </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>n_edgelists</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>min_scale</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>max_scale</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>edge_factor</em> = <code>16</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">generator_distribution_t&nbsp;</td>
<td class="paramname"><em>size_distribution</em> = <code>generator_distribution_t::POWER_LAW</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">generator_distribution_t&nbsp;</td>
<td class="paramname"><em>edge_distribution</em> = <code>generator_distribution_t::POWER_LAW</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t&nbsp;</td>
<td class="paramname"><em>seed</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>clip_and_flip</em> = <code>false</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>generate multiple edge lists using the R-mat graph generator. </p>
<p>This function allows multi-edges and self-loops similar to the Graph 500 reference implementation.</p>
<p>NOTE: The scramble_vertex_ids function needs to be called in order to generate a graph conforming to the Graph 500 specification (note that scrambling does not affect cuGraph's graph construction performance, so this is generally unnecessary). If <code>edge_factor</code> is given (e.g. Graph 500), set <code>num_edges</code> to (size_t{1} &lt;&lt; <code>scale</code>) * <code>edge_factor</code>. To generate an undirected graph, set <code>b</code> == <code>c</code> and <code>clip_and_flip</code> = true. All the resulting edges will be placed in the lower triangular part (including the diagonal) of the graph adjacency matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">n_edgelists</td><td>Number of edge lists (graphs) to generate </td></tr>
<tr><td class="paramname">min_scale</td><td>Scale factor to set the minimum number of verties in the graph. </td></tr>
<tr><td class="paramname">max_scale</td><td>Scale factor to set the maximum number of verties in the graph. </td></tr>
<tr><td class="paramname">edge_factor</td><td>Average number of edges per vertex to generate. </td></tr>
<tr><td class="paramname">size_distribution</td><td>Distribution of the graph sizes, impacts the scale parameter of the R-MAT generator </td></tr>
<tr><td class="paramname">edge_distribution</td><td>Edges distribution for each graph, impacts how R-MAT parameters a,b,c,d, are set. </td></tr>
<tr><td class="paramname">seed</td><td>Seed value for the random number generator. </td></tr>
<tr><td class="paramname">clip_and_flip</td><td>Flag controlling whether to generate edges only in the lower triangular part (including the diagonal) of the graph adjacency matrix (if set to <code>true</code>) or not (if set to <code>false</code>). </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; of size <code>n_edgelists</code>, each vector element being a tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="a08fb902125ff27b1bd3b386c09450436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fb902125ff27b1bd3b386c09450436">&nbsp;</a></span>get_traversed_cost()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::get_traversed_cost </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const *&nbsp;</td>
<td class="paramname"><em>vertices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const *&nbsp;</td>
<td class="paramname"><em>preds</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t const *&nbsp;</td>
<td class="paramname"><em>info_weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t *&nbsp;</td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>stop_vertex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>num_vertices</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Takes the results of BFS or SSSP function call and sums the given weights along the path to the starting vertex. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Needs to be a floating point type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. Must have at least one worker stream. </td></tr>
<tr><td class="paramname">vertices</td><td>Pointer to vertex ids. </td></tr>
<tr><td class="paramname">preds</td><td>Pointer to predecessors. </td></tr>
<tr><td class="paramname">info_weights</td><td>Secondary weights along the edge from predecessor to vertex. </td></tr>
<tr><td class="paramname">out</td><td>Contains for each index the sum of weights along the path unfolding. </td></tr>
<tr><td class="paramname">num_vertices</td><td>Number of vertices. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a0a543daa87bfbef69b255ea2d5441877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a543daa87bfbef69b255ea2d5441877">&nbsp;</a></span>get_two_hop_neighbors()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::get_two_hop_neighbors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em></td><td>)</td>
<td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Find all 2-hop neighbors in the graph. </p>
<p>Find pairs of vertices in the input graph such that each pair is connected by a path that is two hops in length.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph in COO format </dd></dl>
</div>
</div>
<a id="a6709c56fbbb108b4d54b5f3d8b542bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6709c56fbbb108b4d54b5f3d8b542bdf">&nbsp;</a></span>hungarian() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">weight_t cugraph::hungarian </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>num_workers</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const *&nbsp;</td>
<td class="paramname"><em>workers</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t *&nbsp;</td>
<td class="paramname"><em>assignments</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute Hungarian algorithm on a weighted bipartite graph. </p>
<p>The Hungarian algorithm computes an assigment of "jobs" to "workers". This function accepts a weighted graph and a vertex list identifying the "workers". The weights in the weighted graph identify the cost of assigning a particular job to a worker. The algorithm computes a minimum cost assignment and returns the cost as well as a vector identifying the assignment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH COO graph </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">num_workers</td><td>number of vertices in the worker set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">workers</td><td>device pointer to an array of worker vertex ids </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">assignments</td><td>device pointer to an array to which the assignment will be written. The array should be num_workers long, and will identify which vertex id (job) is assigned to that worker </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="aeaae3689f14f2c3a41e59ce326b08116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaae3689f14f2c3a41e59ce326b08116">&nbsp;</a></span>hungarian() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">weight_t cugraph::hungarian </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>num_workers</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const *&nbsp;</td>
<td class="paramname"><em>workers</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t *&nbsp;</td>
<td class="paramname"><em>assignments</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t&nbsp;</td>
<td class="paramname"><em>epsilon</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute Hungarian algorithm on a weighted bipartite graph. </p>
<p>The Hungarian algorithm computes an assigment of "jobs" to "workers". This function accepts a weighted graph and a vertex list identifying the "workers". The weights in the weighted graph identify the cost of assigning a particular job to a worker. The algorithm computes a minimum cost assignment and returns the cost as well as a vector identifying the assignment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH COO graph </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">num_workers</td><td>number of vertices in the worker set </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">workers</td><td>device pointer to an array of worker vertex ids </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">assignments</td><td>device pointer to an array to which the assignment will be written. The array should be num_workers long, and will identify which vertex id (job) is assigned to that worker </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>parameter to define precision of comparisons in reducing weights to zero. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="aa581ef3206fc57bc0bfaaaf87a1e7428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa581ef3206fc57bc0bfaaaf87a1e7428">&nbsp;</a></span>jaccard()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::jaccard </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const *&nbsp;</td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT *&nbsp;</td>
<td class="paramname"><em>result</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute jaccard similarity coefficient for all vertices. </p>
<p>Computes the Jaccard similarity coefficient for every pair of vertices in the graph which are connected by an edge.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted Jaccard, may be NULL for unweighted Jaccard. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="aada0a5fdbdfb025445745dd6dcc15436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada0a5fdbdfb025445745dd6dcc15436">&nbsp;</a></span>jaccard_list()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::jaccard_list </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const *&nbsp;</td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ET&nbsp;</td>
<td class="paramname"><em>num_pairs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const *&nbsp;</td>
<td class="paramname"><em>first</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const *&nbsp;</td>
<td class="paramname"><em>second</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT *&nbsp;</td>
<td class="paramname"><em>result</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute jaccard similarity coefficient for selected vertex pairs. </p>
<p>Computes the Jaccard similarity coefficient for each pair of specified vertices. Vertices are specified as pairs where pair[n] = (first[n], second[n])</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The input vertex weights for weighted Jaccard, may be NULL for unweighted Jaccard. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">num_pairs</td><td>The number of vertex ID pairs specified </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Device pointer to first vertex ID of each pair </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Device pointer to second vertex ID of each pair </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="ad2abd72fff71904ed9def45a89b3eee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2abd72fff71904ed9def45a89b3eee7">&nbsp;</a></span>k_core()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::k_core </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const *&nbsp;</td>
<td class="paramname"><em>vertex_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const *&nbsp;</td>
<td class="paramname"><em>core_number</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT&nbsp;</td>
<td class="paramname"><em>num_vertex_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute K Core of the graph G. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph in coordinate format </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Order of the core. This value must not be negative. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertex_id</td><td>User specified vertex identifiers for which core number values are supplied </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">core_number</td><td>User supplied core number values corresponding to vertex_id </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">num_vertex_ids</td><td>Number of elements in vertex_id/core_number arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out_graph</td><td>Unique pointer to K Core subgraph in COO format </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="aae82739c377ed2fa66944475a901434b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae82739c377ed2fa66944475a901434b">&nbsp;</a></span>k_truss_subgraph()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::k_truss_subgraph </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCOOView.html">GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute k truss for a graph. </p>
<p>K Truss is the maximal subgraph of a graph which contains at least three vertices where every edge is incident to at least k-2 triangles.</p>
<p>Note that current implementation does not support a weighted graph.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a COO </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The order of the truss </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to K Truss subgraph in COO format </dd></dl>
</div>
</div>
<a id="aaba8880b35e0a04f7e216a43ea180fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba8880b35e0a04f7e216a43ea180fa9">&nbsp;</a></span>katz_centrality()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT , typename result_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::katz_centrality </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">result_t *&nbsp;</td>
<td class="paramname"><em>result</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double&nbsp;</td>
<td class="paramname"><em>alpha</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>max_iter</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double&nbsp;</td>
<td class="paramname"><em>tol</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>has_guess</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>normalized</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute the Katz centrality for the nodes of the graph G. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double. </td></tr>
<tr><td class="paramname">result_t</td><td>Type of computed result. Supported values : float</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device array of centrality scores </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Attenuation factor with a default value of 0.1. Alpha is set to 1/(lambda_max) if it is greater where lambda_max is the maximum degree of the graph. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations before an answer is returned. This can be used to limit the execution time and do an early exit before the solver reaches the convergence tolerance. If this value is lower or equal to 0 cuGraph will use the default value, which is 100. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Set the tolerance the approximation, this parameter should be a small magnitude value. The lower the tolerance the better the approximation. If this value is 0.0f, cuGraph will use the default value which is 1.0E-5. Setting too small a tolerance can lead to non-convergence due to numerical roundoff. Usually values between 0.01 and 0.00001 are acceptable. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">has_guess</td><td>Flag to determine whether <code>katz_centrality</code> contains an initial guess for katz centrality values </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalized</td><td>If True normalize the resulting katz centrality values </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="af87fd2140039558d0764aecbf58ccfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87fd2140039558d0764aecbf58ccfc5">&nbsp;</a></span>leiden()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::pair&lt; size_t, weight_t &gt; cugraph::leiden </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t *&nbsp;</td>
<td class="paramname"><em>clustering</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>max_iter</em> = <code>100</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t&nbsp;</td>
<td class="paramname"><em>resolution</em> = <code>weight_t{1}</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p><a class="el" href="classcugraph_1_1Leiden.html">Leiden</a> implementation. </p>
<p>Compute a clustering of the graph by maximizing modularity using the <a class="el" href="classcugraph_1_1Leiden.html">Leiden</a> improvements to the <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> method.</p>
<p>Computed using the <a class="el" href="classcugraph_1_1Leiden.html">Leiden</a> method described in:</p>
<p>Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> to <a class="el" href="classcugraph_1_1Leiden.html">Leiden</a>: guaranteeing well-connected communities. Scientific reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>input graph object (CSR) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>Pointer to device array where the clustering should be stored </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>(optional) maximum number of iterations to run (default 100) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>(optional) The value of the resolution parameter to use. Called gamma in the modularity formula, this changes the size of the communities. Higher resolutions lead to more smaller communities, lower resolutions lead to fewer larger communities. (default 1)</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing: 1) number of levels of the returned clustering 2) modularity of the returned clustering </dd></dl>
</div>
</div>
<a id="a467270ee534ba7cc7fcdd597dc582c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467270ee534ba7cc7fcdd597dc582c0a">&nbsp;</a></span>louvain() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graph_view_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcugraph_1_1Dendrogram.html">Dendrogram</a>&lt; typename graph_view_t::vertex_type &gt; &gt;, typename graph_view_t::weight_type &gt; cugraph::louvain </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">graph_view_t const &amp;&nbsp;</td>
<td class="paramname"><em>graph_view</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>max_level</em> = <code>100</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">typename graph_view_t::weight_type&nbsp;</td>
<td class="paramname"><em>resolution</em> = <code>typename&nbsp;graph_view_t::weight_type{1}</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> implementation, returning dendrogram. </p>
<p>Compute a clustering of the graph by maximizing modularity</p>
<p>Computed using the <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> method described in:</p>
<p>VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008), <a href="http://arxiv.org/abs/0803.0476">http://arxiv.org/abs/0803.0476</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">graph_view_t</td><td>Type of graph</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph_view</td><td>Input graph view object (CSR) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_level</td><td>(optional) maximum number of levels to run (default 100) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>(optional) The value of the resolution parameter to use. Called gamma in the modularity formula, this changes the size of the communities. Higher resolutions lead to more smaller communities, lower resolutions lead to fewer larger communities. (default 1)</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing: 1) unique pointer to dendrogram 2) modularity of the returned clustering </dd></dl>
</div>
</div>
<a id="a07626b2e51010662d12ad4d5d85e6b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07626b2e51010662d12ad4d5d85e6b1d">&nbsp;</a></span>louvain() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graph_view_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::pair&lt; size_t, typename graph_view_t::weight_type &gt; cugraph::louvain </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">graph_view_t const &amp;&nbsp;</td>
<td class="paramname"><em>graph_view</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">typename graph_view_t::vertex_type *&nbsp;</td>
<td class="paramname"><em>clustering</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t&nbsp;</td>
<td class="paramname"><em>max_level</em> = <code>100</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">typename graph_view_t::weight_type&nbsp;</td>
<td class="paramname"><em>resolution</em> = <code>typename&nbsp;graph_view_t::weight_type{1}</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p><a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> implementation. </p>
<p>Compute a clustering of the graph by maximizing modularity</p>
<p>Computed using the <a class="el" href="classcugraph_1_1Louvain.html">Louvain</a> method described in:</p>
<p>VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008), <a href="http://arxiv.org/abs/0803.0476">http://arxiv.org/abs/0803.0476</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">graph_view_t</td><td>Type of graph</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>input graph object (CSR) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>Pointer to device array where the clustering should be stored </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_level</td><td>(optional) maximum number of levels to run (default 100) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">resolution</td><td>(optional) The value of the resolution parameter to use. Called gamma in the modularity formula, this changes the size of the communities. Higher resolutions lead to more smaller communities, lower resolutions lead to fewer larger communities. (default 1)</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing: 1) number of levels of the returned clustering 2) modularity of the returned clustering </dd></dl>
</div>
</div>
<a id="a5454f11df761214623aba6c416adadf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5454f11df761214623aba6c416adadf1">&nbsp;</a></span>minimum_spanning_tree()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1GraphCOO.html">GraphCOO</a>&lt; vertex_t, edge_t, weight_t &gt; &gt; cugraph::minimum_spanning_tree </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; vertex_t, edge_t, weight_t &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Generate edges in a minimum spanning forest of an undirected weighted graph. </p>
<p>A minimum spanning tree is a subgraph of the graph (a tree) with the minimum sum of edge weights. A spanning forest is a union of the spanning trees for each connected component of the graph. If the graph is connected it returns the minimum spanning tree.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">edge_t</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph_csr</td><td>input graph object (CSR) expected to be symmetric </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>out_graph Unique pointer to MSF subgraph in COO format </dd></dl>
</div>
</div>
<a id="aeaa48eeaac66fa304ce189d280c93579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa48eeaac66fa304ce189d280c93579">&nbsp;</a></span>overlap()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::overlap </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const *&nbsp;</td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT *&nbsp;</td>
<td class="paramname"><em>result</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute overlap coefficient for all vertices in the graph. </p>
<p>Computes the Overlap Coefficient for every pair of vertices in the graph which are connected by an edge.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted overlap, may be NULL for unweighted overlap. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a08982e910178f088d24bd943769131d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08982e910178f088d24bd943769131d1">&nbsp;</a></span>overlap_list()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::overlap_list </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const *&nbsp;</td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ET&nbsp;</td>
<td class="paramname"><em>num_pairs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const *&nbsp;</td>
<td class="paramname"><em>first</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const *&nbsp;</td>
<td class="paramname"><em>second</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT *&nbsp;</td>
<td class="paramname"><em>result</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Compute overlap coefficient for select pairs of vertices. </p>
<p>Computes the overlap coefficient for each pair of specified vertices. Vertices are specified as pairs where pair[n] = (first[n], second[n])</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted overlap, may be NULL for unweighted overlap. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">num_pairs</td><td>The number of vertex ID pairs specified </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Device pointer to first vertex ID of each pair </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Device pointer to second vertex ID of each pair </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="ae0e49dce7b1e20902d940e8156a83ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e49dce7b1e20902d940e8156a83ea9">&nbsp;</a></span>renumber_vertices()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT_IN , typename VT_OUT , typename ET &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::unique_ptr&lt; rmm::device_buffer &gt; cugraph::renumber_vertices </td>
<td>(</td>
<td class="paramtype">ET&nbsp;</td>
<td class="paramname"><em>number_of_edges</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT_IN const *&nbsp;</td>
<td class="paramname"><em>src</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT_IN const *&nbsp;</td>
<td class="paramname"><em>dst</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT_OUT *&nbsp;</td>
<td class="paramname"><em>src_renumbered</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT_OUT *&nbsp;</td>
<td class="paramname"><em>dst_renumbered</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ET *&nbsp;</td>
<td class="paramname"><em>map_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource *&nbsp;</td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Renumber source and destination indices. </p>
<p>Renumber source and destination indexes to be a dense numbering, using contiguous values between 0 and number of vertices minus 1.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT_IN</td><td>type of vertex index input </td></tr>
<tr><td class="paramname">VT_OUT</td><td>type of vertex index output </td></tr>
<tr><td class="paramname">ET</td><td>type of edge index</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">number_of_edges</td><td>number of edges in the graph </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Pointer to device memory containing source vertex ids </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Pointer to device memory containing destination vertex ids </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">src_renumbered</td><td>Pointer to device memory containing the output source vertices. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">dst_renumbered</td><td>Pointer to device memory containing the output destination vertices. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">map_size</td><td>Pointer to local memory containing the number of elements in the renumbering map </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to renumbering map </dd></dl>
</div>
</div>
<a id="af8f46f02fbf60659c432be4882f89be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f46f02fbf60659c432be4882f89be1">&nbsp;</a></span>scramble_vertex_ids()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::scramble_vertex_ids </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&nbsp;</td>
<td class="paramname"><em>d_src_v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&nbsp;</td>
<td class="paramname"><em>d_dst_v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t&nbsp;</td>
<td class="paramname"><em>vertex_id_offset</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t&nbsp;</td>
<td class="paramname"><em>seed</em> = <code>0</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>scramble vertex ids in a graph </p>
<p>Given an edgelist for a graph, scramble all vertex ids by the given offset. This translation is done in place.</p>
<p>The scramble code here follows the algorithm in the Graph 500 reference implementation version 3.0.0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">d_src_v</td><td>Vector of source vertices </td></tr>
<tr><td class="paramname">d_dst_v</td><td>Vector of destination vertices </td></tr>
<tr><td class="paramname">vertex_id_offset</td><td>Offset to add to each vertex id </td></tr>
<tr><td class="paramname">seed</td><td>Used to initialize random number generator </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="afbcb939cffaf811289ba6a5edc7f6b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcb939cffaf811289ba6a5edc7f6b04">&nbsp;</a></span>sssp()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">void cugraph::sssp </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1GraphCSRView.html">GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT *&nbsp;</td>
<td class="paramname"><em>distances</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT *&nbsp;</td>
<td class="paramname"><em>predecessors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const VT&nbsp;</td>
<td class="paramname"><em>source_vertex</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Native sssp with predecessors. </p>
<p>------------------------------------------------------------------------&mdash;*</p>
<h2><a class="anchor" id="autotoc_md7"></a>
@file sssp.cu</h2>
<p>@Synopsis Performs a single source shortest path traversal of a graph starting from a vertex.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGraph graph descriptor, should contain the connectivity information as a CSR</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>If set to a valid pointer, array of size V populated by distance of every vertex in the graph from the starting vertex. Memory is provided and owned by the caller.</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">predecessors</td><td>If set to a valid pointer, array of size V populated by the SSSP predecessor of every vertex. Memory is provided and owned by the caller.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">start_vertex</td><td>The starting vertex for SSSP </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a533136dac7270bcd27fe8655c17730fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533136dac7270bcd27fe8655c17730fa">&nbsp;</a></span>symmetrize_edgelist()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename weight_t &gt; </div>
<table class="memname">
<tbody><tr>
<td class="memname">std::tuple&lt; rmm::device_uvector&lt; vertex_t &gt;, rmm::device_uvector&lt; vertex_t &gt;, std::optional&lt; rmm::device_uvector&lt; weight_t &gt; &gt; &gt; cugraph::symmetrize_edgelist </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;&nbsp;</td>
<td class="paramname"><em>d_src_v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::device_uvector&lt; vertex_t &gt; &amp;&amp;&nbsp;</td>
<td class="paramname"><em>d_dst_v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::optional&lt; rmm::device_uvector&lt; weight_t &gt;&gt; &amp;&amp;&nbsp;</td>
<td class="paramname"><em>optional_d_weights_v</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>symmetrize an edgelist </p>
<p>Given an edgelist for a graph, symmetrize and deduplicate edges.</p>
<p>If a duplicate edge exists in a weighted graph, one of the weights is arbitrarily returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">vertex_t</td><td>Type of vertex identifiers. Needs to be an integral type. </td></tr>
<tr><td class="paramname">weight_t</td><td>Type of weights. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">handle</td><td>RAFT handle object to encapsulate resources (e.g. CUDA stream, communicator, and handles to various CUDA libraries) to run graph algorithms. </td></tr>
<tr><td class="paramname">d_src_v</td><td>Vector of source vertices </td></tr>
<tr><td class="paramname">d_dst_v</td><td>Vector of destination vertices </td></tr>
<tr><td class="paramname">d_weights_v</td><td>Optional vector of edge weights </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;rmm::device_uvector&lt;vertex_t&gt;, rmm::device_uvector&lt;vertex_t&gt;&gt; A tuple of rmm::device_uvector objects for edge source vertex IDs and edge destination vertex IDs. </dd></dl>
</div>
</div>
<a id="a75cae03f49d08c9257d7eb1e81e19530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cae03f49d08c9257d7eb1e81e19530">&nbsp;</a></span>traveling_salesperson()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tbody><tr>
<td class="memname">float cugraph::traveling_salesperson </td>
<td>(</td>
<td class="paramtype">raft::handle_t const &amp;&nbsp;</td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int const *&nbsp;</td>
<td class="paramname"><em>vtx_ptr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float const *&nbsp;</td>
<td class="paramname"><em>x_pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float const *&nbsp;</td>
<td class="paramname"><em>y_pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>nodes</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>restarts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>beam_search</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>nstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>verbose</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int *&nbsp;</td>
<td class="paramname"><em>route</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Finds an approximate solution to the traveling salesperson problem (TSP). cuGraph computes an approximation of the TSP problem using hill climbing optimization. </p>
<p>The current implementation does not support a weighted graph.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Library handle (RAFT). If a communicator is set in the handle, the multi GPU version will be selected. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vtx_ptr</td><td>Device array containing the vertex identifiers used to initialize the route. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">x_pos</td><td>Device array containing starting x-axis positions. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y_pos</td><td>Device array containing starting y-axis positions. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>Number of cities. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">restarts</td><td>Number of starts to try. The more restarts, the better the solution will be approximated. The number of restarts depends on the problem size and should be kept low for instances above 2k cities. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">beam_search</td><td>Specify if the initial solution should use KNN for an approximation solution. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Beam width to use in the search. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nstart</td><td>Start from a specific position. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>Logs configuration and iterative improvement. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">route</td><td>Device array containing the returned route. </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body></html>