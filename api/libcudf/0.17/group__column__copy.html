<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.20" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>libcudf: Copying</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="rapids.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (0.17)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (0.19)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (0.18)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/legacy/namespacecudf.html">legacy (0.17)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
<div class="summary">
<a href="#groups">Modules</a> |
<a href="#files">Files</a> |
<a href="#nested-classes">Classes</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">Copying<div class="ingroups"><a class="el" href="group__column__apis.html">Column and Table</a></div></div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__copy__concatenate"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__concatenate.html">Concatenating</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:group__copy__gather"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__gather.html">Gathering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:group__copy__scatter"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__scatter.html">Scattering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:group__copy__slice"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__slice.html">Slicing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:group__copy__split"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__split.html">Splitting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:group__copy__shift"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__shift.html">Shifting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:copying_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="copying_8hpp.html">copying.hpp</a></td></tr>
<tr class="memdesc:copying_8hpp"><td class="mdescLeft"> </td><td class="mdescRight">Column APIs for gather, scatter, split, slice, etc. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1contiguous__split__result.html">cudf::contiguous_split_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The result(s) of a <code>contiguous_split</code> <a href="structcudf_1_1contiguous__split__result.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae3ba74951558bc7966aae86abc6af5df"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">cudf::out_of_bounds_policy</a> : bool { <b>NULLIFY</b>, 
<a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d">cudf::out_of_bounds_policy::DONT_CHECK</a>
 }</td></tr>
<tr class="memdesc:gae3ba74951558bc7966aae86abc6af5df"><td class="mdescLeft"> </td><td class="mdescRight">Policy to account for possible out-of-bounds indices.  <a href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">More...</a><br/></td></tr>
<tr class="separator:gae3ba74951558bc7966aae86abc6af5df"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga267e03474dcfd85242d2fdc6e5846ec6"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">cudf::mask_allocation_policy</a> { <a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a443475558f0168dff92ecde26b98ae5a">cudf::mask_allocation_policy::NEVER</a>, 
<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">cudf::mask_allocation_policy::RETAIN</a>, 
<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6af3fc827ade4b968e50406496907ef962">cudf::mask_allocation_policy::ALWAYS</a>
 }</td></tr>
<tr class="memdesc:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="mdescLeft"> </td><td class="mdescRight">Indicates when to allocate a mask, based on an existing mask.  <a href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">More...</a><br/></td></tr>
<tr class="separator:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae7607cde56cb602ab1b198b5bebf7cba"><td align="right" class="memItemLeft" valign="top"><a id="gae7607cde56cb602ab1b198b5bebf7cba"></a>enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">cudf::sample_with_replacement</a> : bool { <b>FALSE</b>, 
<b>TRUE</b>
 }</td></tr>
<tr class="memdesc:gae7607cde56cb602ab1b198b5bebf7cba"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether a row can be sampled more than once. <br/></td></tr>
<tr class="separator:gae7607cde56cb602ab1b198b5bebf7cba"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0e09ded998662935b453cf161c752e5c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga0e09ded998662935b453cf161c752e5c">cudf::empty_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga0e09ded998662935b453cf161c752e5c"><td class="mdescLeft"> </td><td class="mdescRight">Initializes and returns an empty column of the same type as the <code>input</code>.  <a href="group__column__copy.html#ga0e09ded998662935b453cf161c752e5c">More...</a><br/></td></tr>
<tr class="separator:ga0e09ded998662935b453cf161c752e5c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga11bdde9e4782a83845ff97a0da5d6894"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga11bdde9e4782a83845ff97a0da5d6894">cudf::allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=mask_allocation_policy::RETAIN, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga11bdde9e4782a83845ff97a0da5d6894"><td class="mdescLeft"> </td><td class="mdescRight">Creates an uninitialized new column of the same size and type as the <code>input</code>. Supports only fixed-width types.  <a href="group__column__copy.html#ga11bdde9e4782a83845ff97a0da5d6894">More...</a><br/></td></tr>
<tr class="separator:ga11bdde9e4782a83845ff97a0da5d6894"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga735c8dd32ebfbf05638095afa51eba9d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga735c8dd32ebfbf05638095afa51eba9d">cudf::allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, size_type size, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=mask_allocation_policy::RETAIN, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga735c8dd32ebfbf05638095afa51eba9d"><td class="mdescLeft"> </td><td class="mdescRight">Creates an uninitialized new column of the specified size and same type as the <code>input</code>. Supports only fixed-width types.  <a href="group__column__copy.html#ga735c8dd32ebfbf05638095afa51eba9d">More...</a><br/></td></tr>
<tr class="separator:ga735c8dd32ebfbf05638095afa51eba9d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf882e46ff3f8447ec3cf315d74fe180f"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf882e46ff3f8447ec3cf315d74fe180f">cudf::empty_like</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table)</td></tr>
<tr class="memdesc:gaf882e46ff3f8447ec3cf315d74fe180f"><td class="mdescLeft"> </td><td class="mdescRight">Creates a table of empty columns with the same types as the <code>input_table</code> <a href="group__column__copy.html#gaf882e46ff3f8447ec3cf315d74fe180f">More...</a><br/></td></tr>
<tr class="separator:gaf882e46ff3f8447ec3cf315d74fe180f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf7453a32aa49fd9a55287a776f2b4b2f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf7453a32aa49fd9a55287a776f2b4b2f">cudf::copy_range_in_place</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source, <a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;target, size_type source_begin, size_type source_end, size_type target_begin)</td></tr>
<tr class="memdesc:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="mdescLeft"> </td><td class="mdescRight">Copies a range of elements in-place from one column to another.  <a href="group__column__copy.html#gaf7453a32aa49fd9a55287a776f2b4b2f">More...</a><br/></td></tr>
<tr class="separator:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaac8fd5edd4c310f32b455244eb3a69e4"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaac8fd5edd4c310f32b455244eb3a69e4">cudf::copy_range</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;target, size_type source_begin, size_type source_end, size_type target_begin, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaac8fd5edd4c310f32b455244eb3a69e4"><td class="mdescLeft"> </td><td class="mdescRight">Copies a range of elements out-of-place from one column to another.  <a href="group__column__copy.html#gaac8fd5edd4c310f32b455244eb3a69e4">More...</a><br/></td></tr>
<tr class="separator:gaac8fd5edd4c310f32b455244eb3a69e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab08aeaceb95ca962b4ddb5b4a471da4c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab08aeaceb95ca962b4ddb5b4a471da4c">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab08aeaceb95ca962b4ddb5b4a471da4c"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="group__column__copy.html#gab08aeaceb95ca962b4ddb5b4a471da4c">More...</a><br/></td></tr>
<tr class="separator:gab08aeaceb95ca962b4ddb5b4a471da4c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3e0d11f978be0b2e9a95b0252fe8fd17"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga3e0d11f978be0b2e9a95b0252fe8fd17">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga3e0d11f978be0b2e9a95b0252fe8fd17"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="group__column__copy.html#ga3e0d11f978be0b2e9a95b0252fe8fd17">More...</a><br/></td></tr>
<tr class="separator:ga3e0d11f978be0b2e9a95b0252fe8fd17"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa1787664ecc9439c5a8b963d334491ab"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaa1787664ecc9439c5a8b963d334491ab">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaa1787664ecc9439c5a8b963d334491ab"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="group__column__copy.html#gaa1787664ecc9439c5a8b963d334491ab">More...</a><br/></td></tr>
<tr class="separator:gaa1787664ecc9439c5a8b963d334491ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gafc7251a332092ac4506b1da4448e686d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gafc7251a332092ac4506b1da4448e686d">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gafc7251a332092ac4506b1da4448e686d"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="group__column__copy.html#gafc7251a332092ac4506b1da4448e686d">More...</a><br/></td></tr>
<tr class="separator:gafc7251a332092ac4506b1da4448e686d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gafdb8ce94112a0353af61119497c1b6ee"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gafdb8ce94112a0353af61119497c1b6ee">cudf::get_element</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, size_type index, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gafdb8ce94112a0353af61119497c1b6ee"><td class="mdescLeft"> </td><td class="mdescRight">Get the element at specified index from a column.  <a href="group__column__copy.html#gafdb8ce94112a0353af61119497c1b6ee">More...</a><br/></td></tr>
<tr class="separator:gafdb8ce94112a0353af61119497c1b6ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf2c879c97a852fdf113781d63a303aa7"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf2c879c97a852fdf113781d63a303aa7">cudf::sample</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, size_type const n, <a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a> replacement=sample_with_replacement::FALSE, int64_t const seed=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaf2c879c97a852fdf113781d63a303aa7"><td class="mdescLeft"> </td><td class="mdescRight">Gather <code>n</code> samples from given <code>input</code> randomly.  <a href="group__column__copy.html#gaf2c879c97a852fdf113781d63a303aa7">More...</a><br/></td></tr>
<tr class="separator:gaf2c879c97a852fdf113781d63a303aa7"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga267e03474dcfd85242d2fdc6e5846ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267e03474dcfd85242d2fdc6e5846ec6">◆ </a></span>mask_allocation_policy</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">cudf::mask_allocation_policy</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates when to allocate a mask, based on an existing mask. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6a443475558f0168dff92ecde26b98ae5a"></a>NEVER </td><td class="fielddoc"><p>Do not allocate a null mask, regardless of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4"></a>RETAIN </td><td class="fielddoc"><p>Allocate a null mask if the input contains one. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6af3fc827ade4b968e50406496907ef962"></a>ALWAYS </td><td class="fielddoc"><p>Allocate a null mask, regardless of input. </p>
</td></tr>
</table>
<p class="definition">Definition at line <a class="el" href="copying_8hpp_source.html#l00171">171</a> of file <a class="el" href="copying_8hpp_source.html">copying.hpp</a>.</p>
</div>
</div>
<a id="gae3ba74951558bc7966aae86abc6af5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ba74951558bc7966aae86abc6af5df">◆ </a></span>out_of_bounds_policy</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">cudf::out_of_bounds_policy</a> : bool</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Policy to account for possible out-of-bounds indices. </p>
<p><code>NULLIFY</code> means to nullify output values corresponding to out-of-bounds gather_map values. <code>DONT_CHECK</code> means do not check whether the indices are out-of-bounds, for better performance. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d"></a>DONT_CHECK </td><td class="fielddoc"><p>Output values corresponding to out-of-bounds indices are null. </p>
<p>No bounds checking is performed, better performance </p>
</td></tr>
</table>
<p class="definition">Definition at line <a class="el" href="copying_8hpp_source.html#l00043">43</a> of file <a class="el" href="copying_8hpp_source.html">copying.hpp</a>.</p>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga11bdde9e4782a83845ff97a0da5d6894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11bdde9e4782a83845ff97a0da5d6894">◆ </a></span>allocate_like() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::allocate_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> </td>
<td class="paramname"><em>mask_alloc</em> = <code>mask_allocation_policy::RETAIN</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates an uninitialized new column of the same size and type as the <code>input</code>. Supports only fixed-width types. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A column with sufficient uninitialized capacity to hold the same number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>
</div>
</div>
<a id="ga735c8dd32ebfbf05638095afa51eba9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga735c8dd32ebfbf05638095afa51eba9d">◆ </a></span>allocate_like() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::allocate_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> </td>
<td class="paramname"><em>mask_alloc</em> = <code>mask_allocation_policy::RETAIN</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates an uninitialized new column of the specified size and same type as the <code>input</code>. Supports only fixed-width types. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The desired number of elements that the new column should have capacity for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A column with sufficient uninitialized capacity to hold the specified number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>
</div>
</div>
<a id="gab08aeaceb95ca962b4ddb5b4a471da4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab08aeaceb95ca962b4ddb5b4a471da4c">◆ </a></span>copy_if_else() <span class="overload">[1/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_if_else </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>rhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>boolean_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs[i] : rhs[i]</code></p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same length </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs and rhs </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code>type_id::BOOL8</code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>
</div>
</div>
<a id="gaa1787664ecc9439c5a8b963d334491ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1787664ecc9439c5a8b963d334491ab">◆ </a></span>copy_if_else() <span class="overload">[2/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_if_else </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp; </td>
<td class="paramname"><em>rhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>boolean_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs[i] : rhs</code></p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand scalar </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code>type_id::BOOL8</code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>
</div>
</div>
<a id="ga3e0d11f978be0b2e9a95b0252fe8fd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e0d11f978be0b2e9a95b0252fe8fd17">◆ </a></span>copy_if_else() <span class="overload">[3/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_if_else </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>rhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>boolean_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs : rhs[i]</code></p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as rhs </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand scalar </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code>type_id::BOOL8</code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>
</div>
</div>
<a id="gafc7251a332092ac4506b1da4448e686d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7251a332092ac4506b1da4448e686d">◆ </a></span>copy_if_else() <span class="overload">[4/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_if_else </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp; </td>
<td class="paramname"><em>rhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>boolean_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs : rhs</code></p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand scalar </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand scalar </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code>type_id::BOOL8</code> representing "left (true) / right (false)" boolean for each element. null element represents false. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>
</div>
</div>
<a id="gaac8fd5edd4c310f32b455244eb3a69e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac8fd5edd4c310f32b455244eb3a69e4">◆ </a></span>copy_range()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_range </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>source</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>target</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>source_begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>source_end</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>target_begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies a range of elements out-of-place from one column to another. </p>
<p>Creates a new column as if an in-place copy was performed into <code>target</code>. A copy of <code>target</code> is created first and then the elements indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) were copied from the elements indicated by the indices [<code>source_begin</code>, <code>source_end</code>) of <code>source</code> (where N = (<code>source_end</code> - <code>source_begin</code>)). Elements outside the range are copied from <code>target</code> into the returned new column target.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>target</code> and <code>source</code> have different types.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">source</td><td>The column to copy from inside the range. </td></tr>
<tr><td class="paramname">target</td><td>The column to copy from outside the range. </td></tr>
<tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
<tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
<tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; The result target column </dd></dl>
</div>
</div>
<a id="gaf7453a32aa49fd9a55287a776f2b4b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7453a32aa49fd9a55287a776f2b4b2f">◆ </a></span>copy_range_in_place()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void cudf::copy_range_in_place </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>source</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp; </td>
<td class="paramname"><em>target</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>source_begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>source_end</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>target_begin</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies a range of elements in-place from one column to another. </p>
<p>Overwrites the range of elements in <code>target</code> indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) with the elements from <code>source</code> indicated by the indices [<code>source_begin</code>, <code>source_end</code>) (where N = (<code>source_end</code> - <code>source_begin</code>)). Use the out-of-place copy function returning std::unique_ptr&lt;column&gt; for uses cases requiring memory reallocation. For example for strings columns and other variable-width types.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if memory reallocation is required (e.g. for variable width types). </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>target</code> and <code>source</code> have different types. </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>source</code> has null values and <code>target</code> is not nullable.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">source</td><td>The column to copy from </td></tr>
<tr><td class="paramname">target</td><td>The preallocated column to copy into </td></tr>
<tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
<tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
<tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga0e09ded998662935b453cf161c752e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e09ded998662935b453cf161c752e5c">◆ </a></span>empty_like() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::empty_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Initializes and returns an empty column of the same type as the <code>input</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; An empty column of same type as <code>input</code> </dd></dl>
</div>
</div>
<a id="gaf882e46ff3f8447ec3cf315d74fe180f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf882e46ff3f8447ec3cf315d74fe180f">◆ </a></span>empty_like() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1table.html">table</a>&gt; cudf::empty_like </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp; </td>
<td class="paramname"><em>input_table</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a table of empty columns with the same types as the <code>input_table</code> </p>
<p>Creates the <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">input_table</td><td>Immutable view of input table to emulate </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;table&gt; A table of empty columns with the same types as the columns in <code>input_table</code> </dd></dl>
</div>
</div>
<a id="gafdb8ce94112a0353af61119497c1b6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb8ce94112a0353af61119497c1b6ee">◆ </a></span>get_element()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1scalar.html">scalar</a>&gt; cudf::get_element </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the element at specified index from a column. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is expensive (invokes a kernel launch). So, it is not recommended to be used in performance sensitive code or inside a loop.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>index</code> is not within the range <code>[0, input.size())</code></td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">input</td><td>Column view to get the element from </td></tr>
<tr><td class="paramname">index</td><td>Index into <code>input</code> to get the element at </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned scalar's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;scalar&gt; Scalar containing the single value </dd></dl>
</div>
</div>
<a id="gaf2c879c97a852fdf113781d63a303aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2c879c97a852fdf113781d63a303aa7">◆ </a></span>sample()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1table.html">table</a>&gt; cudf::sample </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type const </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a> </td>
<td class="paramname"><em>replacement</em> = <code>sample_with_replacement::FALSE</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t const </td>
<td class="paramname"><em>seed</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Gather <code>n</code> samples from given <code>input</code> randomly. </p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input: {col1: {1, 2, 3, 4, 5}, col2: {6, 7, 8, 9, 10}}</div>
<div class="line">n: 3</div>
<div class="line">replacement: false</div>
<div class="line"> </div>
<div class="line">output:       {col1: {3, 1, 4}, col2: {8, 6, 9}}</div>
<div class="line"> </div>
<div class="line">replacement: true</div>
<div class="line"> </div>
<div class="line">output:       {col1: {3, 1, 1}, col2: {8, 6, 6}}</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>n</code> &gt; <code>input.num_rows()</code> and <code>replacement</code> == FALSE. </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>n</code> &lt; 0.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">input</td><td>View of a table to sample. </td></tr>
<tr><td class="paramname">n</td><td>non-negative number of samples expected from <code>input</code>. </td></tr>
<tr><td class="paramname">replacement</td><td>Allow or disallow sampling of the same row more than once. </td></tr>
<tr><td class="paramname">seed</td><td>Seed value to initiate random number generator. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;table&gt; Table containing samples from <code>input</code> </dd></dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"/></a> 1.8.20
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
