<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.20" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>libcudf: Converting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="rapids.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (0.17)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (0.19)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (0.18)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/legacy/namespacecudf.html">legacy (0.17)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
<div class="summary">
<a href="#files">Files</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">Converting<div class="ingroups"><a class="el" href="group__strings__apis.html">Strings</a></div></div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:convert__booleans_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="convert__booleans_8hpp.html">convert_booleans.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:convert__datetime_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="convert__datetime_8hpp.html">convert_datetime.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:convert__durations_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="convert__durations_8hpp.html">convert_durations.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:convert__floats_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="convert__floats_8hpp.html">convert_floats.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:convert__integers_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="convert__integers_8hpp.html">convert_integers.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:convert__ipv4_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="convert__ipv4_8hpp.html">convert_ipv4.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:convert__urls_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="convert__urls_8hpp.html">convert_urls.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadabfd784d248d6d6a7bfcf0d1674013d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gadabfd784d248d6d6a7bfcf0d1674013d">cudf::strings::to_booleans</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;true_string=<a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>("true"), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gadabfd784d248d6d6a7bfcf0d1674013d"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new BOOL8 column by parsing boolean values from the strings in the provided strings column.  <a href="group__strings__convert.html#gadabfd784d248d6d6a7bfcf0d1674013d">More...</a><br/></td></tr>
<tr class="separator:gadabfd784d248d6d6a7bfcf0d1674013d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga53c34963a030e7f16d8da9aadea257d7"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga53c34963a030e7f16d8da9aadea257d7">cudf::strings::from_booleans</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;booleans, <a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;true_string=<a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>("true"), string_scalar const &amp;false_string=<a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>("false"), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga53c34963a030e7f16d8da9aadea257d7"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new strings column converting the boolean values from the provided column into strings.  <a href="group__strings__convert.html#ga53c34963a030e7f16d8da9aadea257d7">More...</a><br/></td></tr>
<tr class="separator:ga53c34963a030e7f16d8da9aadea257d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac020f0fada9c6c59cf3f2ad8dd2774e3"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gac020f0fada9c6c59cf3f2ad8dd2774e3">cudf::strings::to_timestamps</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> timestamp_type, std::string const &amp;format, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac020f0fada9c6c59cf3f2ad8dd2774e3"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new timestamp column converting a strings column into timestamps using the provided format pattern.  <a href="group__strings__convert.html#gac020f0fada9c6c59cf3f2ad8dd2774e3">More...</a><br/></td></tr>
<tr class="separator:gac020f0fada9c6c59cf3f2ad8dd2774e3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga97c8a7085ac3d47545a1e5af31543364"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga97c8a7085ac3d47545a1e5af31543364">cudf::strings::is_timestamp</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, std::string const &amp;format, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga97c8a7085ac3d47545a1e5af31543364"><td class="mdescLeft"> </td><td class="mdescRight">Verifies the given strings column can be parsed to timestamps using the provided format pattern.  <a href="group__strings__convert.html#ga97c8a7085ac3d47545a1e5af31543364">More...</a><br/></td></tr>
<tr class="separator:ga97c8a7085ac3d47545a1e5af31543364"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga030d41440ce2c1724fe55364750a011e"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga030d41440ce2c1724fe55364750a011e">cudf::strings::from_timestamps</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamps, std::string const &amp;format="%Y-%m-%dT%H:%M:%SZ", rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga030d41440ce2c1724fe55364750a011e"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new strings column converting a timestamp column into strings using the provided format pattern.  <a href="group__strings__convert.html#ga030d41440ce2c1724fe55364750a011e">More...</a><br/></td></tr>
<tr class="separator:ga030d41440ce2c1724fe55364750a011e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad65d2a45664839b1c7dc02f1b328e46d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gad65d2a45664839b1c7dc02f1b328e46d">cudf::strings::to_durations</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> duration_type, std::string const &amp;format, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gad65d2a45664839b1c7dc02f1b328e46d"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new duration column converting a strings column into durations using the provided format pattern.  <a href="group__strings__convert.html#gad65d2a45664839b1c7dc02f1b328e46d">More...</a><br/></td></tr>
<tr class="separator:gad65d2a45664839b1c7dc02f1b328e46d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaee5146f9e157d8886c4621d1c04f0b05"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gaee5146f9e157d8886c4621d1c04f0b05">cudf::strings::from_durations</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;durations, std::string const &amp;format="%D days %H:%M:%S", rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaee5146f9e157d8886c4621d1c04f0b05"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new strings column converting a duration column into strings using the provided format pattern.  <a href="group__strings__convert.html#gaee5146f9e157d8886c4621d1c04f0b05">More...</a><br/></td></tr>
<tr class="separator:gaee5146f9e157d8886c4621d1c04f0b05"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad7d9050edfe6fcbe58bbe0abb1fee52f"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gad7d9050edfe6fcbe58bbe0abb1fee52f">cudf::strings::to_floats</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gad7d9050edfe6fcbe58bbe0abb1fee52f"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new numeric column by parsing float values from each string in the provided strings column.  <a href="group__strings__convert.html#gad7d9050edfe6fcbe58bbe0abb1fee52f">More...</a><br/></td></tr>
<tr class="separator:gad7d9050edfe6fcbe58bbe0abb1fee52f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2eefe45dd81f4c3f30b8bd9da5e433d9"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga2eefe45dd81f4c3f30b8bd9da5e433d9">cudf::strings::from_floats</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;floats, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2eefe45dd81f4c3f30b8bd9da5e433d9"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new strings column converting the float values from the provided column into strings.  <a href="group__strings__convert.html#ga2eefe45dd81f4c3f30b8bd9da5e433d9">More...</a><br/></td></tr>
<tr class="separator:ga2eefe45dd81f4c3f30b8bd9da5e433d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacf9de3f89a71d9c2a24a905a66d68c4c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gacf9de3f89a71d9c2a24a905a66d68c4c">cudf::strings::to_integers</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gacf9de3f89a71d9c2a24a905a66d68c4c"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new integer numeric column parsing integer values from the provided strings column.  <a href="group__strings__convert.html#gacf9de3f89a71d9c2a24a905a66d68c4c">More...</a><br/></td></tr>
<tr class="separator:gacf9de3f89a71d9c2a24a905a66d68c4c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3cd7ba1e7633829ddc53837b7c6127ad"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga3cd7ba1e7633829ddc53837b7c6127ad">cudf::strings::from_integers</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;integers, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga3cd7ba1e7633829ddc53837b7c6127ad"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new strings column converting the integer values from the provided column into strings.  <a href="group__strings__convert.html#ga3cd7ba1e7633829ddc53837b7c6127ad">More...</a><br/></td></tr>
<tr class="separator:ga3cd7ba1e7633829ddc53837b7c6127ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga31c8d3b529c9a7d00a1b00dd55e537c6"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga31c8d3b529c9a7d00a1b00dd55e537c6">cudf::strings::hex_to_integers</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga31c8d3b529c9a7d00a1b00dd55e537c6"><td class="mdescLeft"> </td><td class="mdescRight">Returns a new integer numeric column parsing hexadecimal values from the provided strings column.  <a href="group__strings__convert.html#ga31c8d3b529c9a7d00a1b00dd55e537c6">More...</a><br/></td></tr>
<tr class="separator:ga31c8d3b529c9a7d00a1b00dd55e537c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac6baadd079106a66af126e5bb318db8d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gac6baadd079106a66af126e5bb318db8d">cudf::strings::is_hex</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac6baadd079106a66af126e5bb318db8d"><td class="mdescLeft"> </td><td class="mdescRight">Returns a boolean column identifying strings in which all characters are valid for conversion to integers from hex.  <a href="group__strings__convert.html#gac6baadd079106a66af126e5bb318db8d">More...</a><br/></td></tr>
<tr class="separator:gac6baadd079106a66af126e5bb318db8d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6bbfa8b6908f90126869c956a62bdfd0"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga6bbfa8b6908f90126869c956a62bdfd0">cudf::strings::ipv4_to_integers</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6bbfa8b6908f90126869c956a62bdfd0"><td class="mdescLeft"> </td><td class="mdescRight">Converts IPv4 addresses into integers.  <a href="group__strings__convert.html#ga6bbfa8b6908f90126869c956a62bdfd0">More...</a><br/></td></tr>
<tr class="separator:ga6bbfa8b6908f90126869c956a62bdfd0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac4188900570205f772372ea931277d27"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gac4188900570205f772372ea931277d27">cudf::strings::integers_to_ipv4</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;integers, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac4188900570205f772372ea931277d27"><td class="mdescLeft"> </td><td class="mdescRight">Converts integers into IPv4 addresses as strings.  <a href="group__strings__convert.html#gac4188900570205f772372ea931277d27">More...</a><br/></td></tr>
<tr class="separator:gac4188900570205f772372ea931277d27"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7adb04c1c0b59cb5869e573531654fdc"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga7adb04c1c0b59cb5869e573531654fdc">cudf::strings::is_ipv4</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7adb04c1c0b59cb5869e573531654fdc"><td class="mdescLeft"> </td><td class="mdescRight">Returns a boolean column identifying strings in which all characters are valid for conversion to integers from IPv4 format.  <a href="group__strings__convert.html#ga7adb04c1c0b59cb5869e573531654fdc">More...</a><br/></td></tr>
<tr class="separator:ga7adb04c1c0b59cb5869e573531654fdc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaca75cf8110d40289c7e90e6d84640ecc"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gaca75cf8110d40289c7e90e6d84640ecc">cudf::strings::url_encode</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaca75cf8110d40289c7e90e6d84640ecc"><td class="mdescLeft"> </td><td class="mdescRight">Decodes each string using URL encoding.  <a href="group__strings__convert.html#gaca75cf8110d40289c7e90e6d84640ecc">More...</a><br/></td></tr>
<tr class="separator:gaca75cf8110d40289c7e90e6d84640ecc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga4369d2892844667ddda5da6d68dcfb8c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga4369d2892844667ddda5da6d68dcfb8c">cudf::strings::url_decode</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga4369d2892844667ddda5da6d68dcfb8c"><td class="mdescLeft"> </td><td class="mdescRight">Encodes each string using URL encoding.  <a href="group__strings__convert.html#ga4369d2892844667ddda5da6d68dcfb8c">More...</a><br/></td></tr>
<tr class="separator:ga4369d2892844667ddda5da6d68dcfb8c"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga53c34963a030e7f16d8da9aadea257d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c34963a030e7f16d8da9aadea257d7">◆ </a></span>from_booleans()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::from_booleans </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>booleans</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp; </td>
<td class="paramname"><em>true_string</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>("true")</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp; </td>
<td class="paramname"><em>false_string</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>("false")</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new strings column converting the boolean values from the provided column into strings. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the input column is not BOOL8 type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">booleans</td><td>Boolean column to convert. </td></tr>
<tr><td class="paramname">true_string</td><td>String to use for true in the output column. </td></tr>
<tr><td class="paramname">false_string</td><td>String to use for false in the output column. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings column. </dd></dl>
</div>
</div>
<a id="gaee5146f9e157d8886c4621d1c04f0b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee5146f9e157d8886c4621d1c04f0b05">◆ </a></span>from_durations()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::from_durations </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>durations</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::string const &amp; </td>
<td class="paramname"><em>format</em> = <code>"%D days %H:%M:%S"</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new strings column converting a duration column into strings using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%%,%n,%t,%D,%H,%I,%M,%S,%p,%R,%T,%r,%OH,%OI,%OM,%OS"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Range   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%%  </td><td class="markdownTableBodyNone">A literal % character  </td><td class="markdownTableBodyNone">%   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%n  </td><td class="markdownTableBodyNone">A newline character  </td><td class="markdownTableBodyNone">\n   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%t  </td><td class="markdownTableBodyNone">A horizontal tab character  </td><td class="markdownTableBodyNone">\t   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%D  </td><td class="markdownTableBodyNone">Days  </td><td class="markdownTableBodyNone">-2,147,483,648 to 2,147,483,647   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H  </td><td class="markdownTableBodyNone">24-hour of the day  </td><td class="markdownTableBodyNone">00 to 23   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I  </td><td class="markdownTableBodyNone">12-hour of the day  </td><td class="markdownTableBodyNone">00 to 11   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M  </td><td class="markdownTableBodyNone">Minute of the hour  </td><td class="markdownTableBodyNone">00 to 59   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S  </td><td class="markdownTableBodyNone">Second of the minute  </td><td class="markdownTableBodyNone">00 to 59.999999999   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%OH  </td><td class="markdownTableBodyNone">same as H but without sign  </td><td class="markdownTableBodyNone">00 to 23   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%OI  </td><td class="markdownTableBodyNone">same as I but without sign  </td><td class="markdownTableBodyNone">00 to 11   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%OM  </td><td class="markdownTableBodyNone">same as M but without sign  </td><td class="markdownTableBodyNone">00 to 59   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%OS  </td><td class="markdownTableBodyNone">same as S but without sign  </td><td class="markdownTableBodyNone">00 to 59   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%p  </td><td class="markdownTableBodyNone">AM/PM designations associated with a 12-hour clock  </td><td class="markdownTableBodyNone">'AM' or 'PM'   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%R  </td><td class="markdownTableBodyNone">Equivalent to "%H:%M"  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%T  </td><td class="markdownTableBodyNone">Equivalent to "%H:%M:%S"  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%r  </td><td class="markdownTableBodyNone">Equivalent to "%OI:%OM:%OS %p"  </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>No checking is done for invalid formats or invalid duration values. Formatting sticks to specifications of <code>std::formatter&lt;std::chrono::duration&gt;</code> as much as possible.</p>
<p>Any null input entry will result in a corresponding null entry in the output column.</p>
<p>The time units of the input column influence the number of digits in decimal of seconds. It uses 3 digits for milliseconds, 6 digits for microseconds and 9 digits for nanoseconds. If duration value is negative, only one negative sign is written to output string. The specifiers with signs are "%H,%I,%M,%S,%R,%T".</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>durations</code> column parameter is not a duration type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">durations</td><td>Duration values to convert. </td></tr>
<tr><td class="paramname">format</td><td>The string specifying output format. Default format is ""d days H:M:S". </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings column with formatted durations. </dd></dl>
</div>
</div>
<a id="ga2eefe45dd81f4c3f30b8bd9da5e433d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eefe45dd81f4c3f30b8bd9da5e433d9">◆ </a></span>from_floats()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::from_floats </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>floats</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new strings column converting the float values from the provided column into strings. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>For each float, a string is created in base-10 decimal. Negative numbers will include a '-' prefix. Numbers producing more than 10 significant digits will produce a string that includes scientific notation (e.g. "-1.78e+15").</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if floats column is not float type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">floats</td><td>Numeric column to convert. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings column with floats as strings. </dd></dl>
</div>
</div>
<a id="ga3cd7ba1e7633829ddc53837b7c6127ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd7ba1e7633829ddc53837b7c6127ad">◆ </a></span>from_integers()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::from_integers </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>integers</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new strings column converting the integer values from the provided column into strings. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>For each integer, a string is created in base-10 decimal. Negative numbers will include a '-' prefix.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if integers column is not integral type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">integers</td><td>Numeric column to convert. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings column with integers as strings. </dd></dl>
</div>
</div>
<a id="ga030d41440ce2c1724fe55364750a011e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga030d41440ce2c1724fe55364750a011e">◆ </a></span>from_timestamps()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::from_timestamps </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>timestamps</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::string const &amp; </td>
<td class="paramname"><em>format</em> = <code>"%Y-%m-%dT%H:%M:%SZ"</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new strings column converting a timestamp column into strings using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%Y,%y,%m,%d,%H,%I,%p,%M,%S,%f,%z,%Z"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%d  </td><td class="markdownTableBodyNone">Day of the month: 01-31   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%m  </td><td class="markdownTableBodyNone">Month of the year: 01-12   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%y  </td><td class="markdownTableBodyNone">Year without century: 00-99   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%Y  </td><td class="markdownTableBodyNone">Year with century: 0001-9999   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H  </td><td class="markdownTableBodyNone">24-hour of the day: 00-23   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I  </td><td class="markdownTableBodyNone">12-hour of the day: 01-12   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M  </td><td class="markdownTableBodyNone">Minute of the hour: 00-59   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S  </td><td class="markdownTableBodyNone">Second of the minute: 00-59   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%f  </td><td class="markdownTableBodyNone">6-digit microsecond: 000000-999999   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%z  </td><td class="markdownTableBodyNone">Always outputs "+0000"   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%Z  </td><td class="markdownTableBodyNone">Always outputs "UTC"   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%j  </td><td class="markdownTableBodyNone">Day of the year: 001-366   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%p  </td><td class="markdownTableBodyNone">Only 'AM' or 'PM'   </td></tr>
</table>
<p>No checking is done for invalid formats or invalid timestamp values. All timestamps values are formatted to UTC.</p>
<p>Any null input entry will result in a corresponding null entry in the output column.</p>
<p>The time units of the input column do not influence the number of digits written by the "%f" specifier. The "%f" supports a precision value to write out numeric digits for the subsecond value. Specify the precision with a single integer value (1-9) between the "%" and the "f" as follows: use "%3f" for milliseconds, "%6f" for microseconds and "%9f" for nanoseconds. If the precision is higher than the units, then zeroes are padded to the right of the subsecond value. If the precision is lower than the units, the subsecond value may be truncated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>timestamps</code> column parameter is not a timestamp type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">timestamps</td><td>Timestamp values to convert. </td></tr>
<tr><td class="paramname">format</td><td>The string specifying output format. Default format is "%Y-%m-%dT%H:%M:%SZ". </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings column with formatted timestamps. </dd></dl>
</div>
</div>
<a id="ga31c8d3b529c9a7d00a1b00dd55e537c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31c8d3b529c9a7d00a1b00dd55e537c6">◆ </a></span>hex_to_integers()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::hex_to_integers </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>output_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new integer numeric column parsing hexadecimal values from the provided strings column. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>Only characters [0-9] and [A-F] are recognized. When any other character is encountered, the parsing ends for that string. No interpretation is made on the sign of the integer.</p>
<p>Overflow of the resulting integer type is not checked. Each string is converted using an int64 type and then cast to the target integer type before storing it into the output column. If the resulting integer type is too small to hold the value, the stored value will be undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if output_type is not integral type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">output_type</td><td>Type of integer numeric column to return. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New column with integers converted from strings. </dd></dl>
</div>
</div>
<a id="gac4188900570205f772372ea931277d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4188900570205f772372ea931277d27">◆ </a></span>integers_to_ipv4()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::integers_to_ipv4 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>integers</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Converts integers into IPv4 addresses as strings. </p>
<p>The IPv4 format is 1-3 character digits [0-9] between 3 dots (e.g. 123.45.67.890). Each section can have a value between [0-255].</p>
<p>Each input integer is dissected into four integers by dividing the input into 8-bit sections. These sub-integers are then converted into [0-9] characters and placed between '.' characters.</p>
<p>No checking is done on the input integer value. Only the lower 32-bits are used.</p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the input column is not INT64 type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">integers</td><td>Integer (INT64) column to convert. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings column. </dd></dl>
</div>
</div>
<a id="ga6bbfa8b6908f90126869c956a62bdfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bbfa8b6908f90126869c956a62bdfd0">◆ </a></span>ipv4_to_integers()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::ipv4_to_integers </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Converts IPv4 addresses into integers. </p>
<p>The IPv4 format is 1-3 character digits [0-9] between 3 dots (e.g. 123.45.67.890). Each section can have a value between [0-255].</p>
<p>The four sets of digits are converted to integers and placed in 8-bit fields inside the resulting integer. </p><div class="fragment"><div class="line">i0.i1.i2.i3 -&gt; (i0 &lt;&lt; 24) | (i1 &lt;&lt; 16) | (i2 &lt;&lt; 8) | (i3)</div>
</div><!-- fragment --><p>No checking is done on the format. If a string is not in IPv4 format, the resulting integer is undefined.</p>
<p>The resulting 32-bit integer is placed in an int64_t to avoid setting the sign-bit in an int32_t type. This could be changed if cudf supported a UINT32 type in the future.</p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New INT64 column converted from strings. </dd></dl>
</div>
</div>
<a id="gac6baadd079106a66af126e5bb318db8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6baadd079106a66af126e5bb318db8d">◆ </a></span>is_hex()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::is_hex </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a boolean column identifying strings in which all characters are valid for conversion to integers from hex. </p>
<p>The output row entry will be set to <code>true</code> if the corresponding string element has at least one character in [0-9A-Za-z]. Also, the string may start with '0x'.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ['123', '-456', '', 'AGE', '+17EA', '0x9EF' '123ABC']</div>
<div class="line">b = s.is_hex(s)</div>
<div class="line">b is [true, false, false, false, false, true, true]</div>
</div><!-- fragment --><p>Any null row results in a null entry for that row in the output column.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New column of boolean results for each string. </dd></dl>
</div>
</div>
<a id="ga7adb04c1c0b59cb5869e573531654fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7adb04c1c0b59cb5869e573531654fdc">◆ </a></span>is_ipv4()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::is_ipv4 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a boolean column identifying strings in which all characters are valid for conversion to integers from IPv4 format. </p>
<p>The output row entry will be set to <code>true</code> if the corresponding string element has the following format <code>xxx.xxx.xxx.xxx</code> where <code>xxx</code> is integer digits between 0-255.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ['123.255.0.7', '127.0.0.1', '', '1.2.34' '123.456.789.10']</div>
<div class="line">b = s.is_ipv4(s)</div>
<div class="line">b is [true, true, false, false, true]</div>
</div><!-- fragment --><p>Any null row results in a null entry for that row in the output column.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New column of boolean results for each string. </dd></dl>
</div>
</div>
<a id="ga97c8a7085ac3d47545a1e5af31543364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97c8a7085ac3d47545a1e5af31543364">◆ </a></span>is_timestamp()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::is_timestamp </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::string const &amp; </td>
<td class="paramname"><em>format</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Verifies the given strings column can be parsed to timestamps using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%Y,%y,%m,%d,%H,%I,%p,%M,%S,%f,%z"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%d  </td><td class="markdownTableBodyNone">Day of the month: 01-31   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%m  </td><td class="markdownTableBodyNone">Month of the year: 01-12   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%y  </td><td class="markdownTableBodyNone">Year without century: 00-99   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%Y  </td><td class="markdownTableBodyNone">Year with century: 0001-9999   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H  </td><td class="markdownTableBodyNone">24-hour of the day: 00-23   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I  </td><td class="markdownTableBodyNone">12-hour of the day: 01-12   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M  </td><td class="markdownTableBodyNone">Minute of the hour: 00-59   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S  </td><td class="markdownTableBodyNone">Second of the minute: 00-59   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%f  </td><td class="markdownTableBodyNone">6-digit microsecond: 000000-999999   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%z  </td><td class="markdownTableBodyNone">UTC offset with format ±HHMM Example +0500   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%j  </td><td class="markdownTableBodyNone">Day of the year: 001-366   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%p  </td><td class="markdownTableBodyNone">Only 'AM', 'PM' or 'am', 'pm' are recognized   </td></tr>
</table>
<p>Other specifiers are not currently supported. The "%f" supports a precision value to read the numeric digits. Specify the precision with a single integer value (1-9) as follows: use "%3f" for milliseconds, "%6f" for microseconds and "%9f" for nanoseconds.</p>
<p>Any null string entry will result in a corresponding null row in the output column.</p>
<p>This will return a column of type BOOL8 where a <code>true</code> row indicates the corresponding input string can be parsed correctly with the given format.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">format</td><td>String specifying the timestamp format in strings. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New BOOL8 column. </dd></dl>
</div>
</div>
<a id="gadabfd784d248d6d6a7bfcf0d1674013d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadabfd784d248d6d6a7bfcf0d1674013d">◆ </a></span>to_booleans()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::to_booleans </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp; </td>
<td class="paramname"><em>true_string</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>("true")</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new BOOL8 column by parsing boolean values from the strings in the provided strings column. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">true_string</td><td>String to expect for true. Non-matching strings are false. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New BOOL8 column converted from strings. </dd></dl>
</div>
</div>
<a id="gad65d2a45664839b1c7dc02f1b328e46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65d2a45664839b1c7dc02f1b328e46d">◆ </a></span>to_durations()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::to_durations </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>duration_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::string const &amp; </td>
<td class="paramname"><em>format</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new duration column converting a strings column into durations using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%%,%n,%t,%D,%H,%I,%M,%S,%p,%R,%T,%r,%OH,%OI,%OM,%OS"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Range   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%%  </td><td class="markdownTableBodyNone">A literal % character  </td><td class="markdownTableBodyNone">%   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%n  </td><td class="markdownTableBodyNone">A newline character  </td><td class="markdownTableBodyNone">\n   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%t  </td><td class="markdownTableBodyNone">A horizontal tab character  </td><td class="markdownTableBodyNone">\t   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%D  </td><td class="markdownTableBodyNone">Days  </td><td class="markdownTableBodyNone">-2,147,483,648 to 2,147,483,647   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H  </td><td class="markdownTableBodyNone">24-hour of the day  </td><td class="markdownTableBodyNone">00 to 23   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I  </td><td class="markdownTableBodyNone">12-hour of the day  </td><td class="markdownTableBodyNone">00 to 11   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M  </td><td class="markdownTableBodyNone">Minute of the hour  </td><td class="markdownTableBodyNone">00 to 59   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S  </td><td class="markdownTableBodyNone">Second of the minute  </td><td class="markdownTableBodyNone">00 to 59.999999999   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%OH  </td><td class="markdownTableBodyNone">same as H but without sign  </td><td class="markdownTableBodyNone">00 to 23   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%OI  </td><td class="markdownTableBodyNone">same as I but without sign  </td><td class="markdownTableBodyNone">00 to 11   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%OM  </td><td class="markdownTableBodyNone">same as M but without sign  </td><td class="markdownTableBodyNone">00 to 59   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%OS  </td><td class="markdownTableBodyNone">same as S but without sign  </td><td class="markdownTableBodyNone">00 to 59   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%p  </td><td class="markdownTableBodyNone">AM/PM designations associated with a 12-hour clock  </td><td class="markdownTableBodyNone">'AM' or 'PM'   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%R  </td><td class="markdownTableBodyNone">Equivalent to "%H:%M"  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%T  </td><td class="markdownTableBodyNone">Equivalent to "%H:%M:%S"  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%r  </td><td class="markdownTableBodyNone">Equivalent to "%OI:%OM:%OS %p"  </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Other specifiers are not currently supported.</p>
<p>Invalid formats are not checked. If the string contains unexpected or insufficient characters, that output row entry's duration value is undefined.</p>
<p>Any null string entry will result in a corresponding null row in the output column.</p>
<p>The resulting time units are specified by the <code>duration_type</code> parameter.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if duration_type is not a duration type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">duration_type</td><td>The duration type used for creating the output column. </td></tr>
<tr><td class="paramname">format</td><td>String specifying the duration format in strings. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New duration column. </dd></dl>
</div>
</div>
<a id="gad7d9050edfe6fcbe58bbe0abb1fee52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7d9050edfe6fcbe58bbe0abb1fee52f">◆ </a></span>to_floats()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::to_floats </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>output_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new numeric column by parsing float values from each string in the provided strings column. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>Only characters [0-9] plus a prefix '-' and '+' and decimal '.' are recognized. Additionally, scientific notation is also supported (e.g. "-1.78e+5").</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if output_type is not float type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">output_type</td><td>Type of float numeric column to return. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New column with floats converted from strings. </dd></dl>
</div>
</div>
<a id="gacf9de3f89a71d9c2a24a905a66d68c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9de3f89a71d9c2a24a905a66d68c4c">◆ </a></span>to_integers()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::to_integers </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>output_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new integer numeric column parsing integer values from the provided strings column. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>Only characters [0-9] plus a prefix '-' and '+' are recognized. When any other character is encountered, the parsing ends for that string and the current digits are converted into an integer.</p>
<p>Overflow of the resulting integer type is not checked. Each string is converted using an int64 type and then cast to the target integer type before storing it into the output column. If the resulting integer type is too small to hold the value, the stored value will be undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if output_type is not integral type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">output_type</td><td>Type of integer numeric column to return. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New column with integers converted from strings. </dd></dl>
</div>
</div>
<a id="gac020f0fada9c6c59cf3f2ad8dd2774e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac020f0fada9c6c59cf3f2ad8dd2774e3">◆ </a></span>to_timestamps()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::to_timestamps </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>timestamp_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::string const &amp; </td>
<td class="paramname"><em>format</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a new timestamp column converting a strings column into timestamps using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%Y,%y,%m,%d,%H,%I,%p,%M,%S,%f,%z"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%d  </td><td class="markdownTableBodyNone">Day of the month: 01-31   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%m  </td><td class="markdownTableBodyNone">Month of the year: 01-12   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%y  </td><td class="markdownTableBodyNone">Year without century: 00-99   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%Y  </td><td class="markdownTableBodyNone">Year with century: 0001-9999   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H  </td><td class="markdownTableBodyNone">24-hour of the day: 00-23   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I  </td><td class="markdownTableBodyNone">12-hour of the day: 01-12   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M  </td><td class="markdownTableBodyNone">Minute of the hour: 00-59   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S  </td><td class="markdownTableBodyNone">Second of the minute: 00-59   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%f  </td><td class="markdownTableBodyNone">6-digit microsecond: 000000-999999   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%z  </td><td class="markdownTableBodyNone">UTC offset with format ±HHMM Example +0500   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%j  </td><td class="markdownTableBodyNone">Day of the year: 001-366   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%p  </td><td class="markdownTableBodyNone">Only 'AM', 'PM' or 'am', 'pm' are recognized   </td></tr>
</table>
<p>Other specifiers are not currently supported.</p>
<p>Invalid formats are not checked. If the string contains unexpected or insufficient characters, that output row entry's timestamp value is undefined.</p>
<p>Any null string entry will result in a corresponding null row in the output column.</p>
<p>The resulting time units are specified by the <code>timestamp_type</code> parameter. The time units are independent of the number of digits parsed by the "%f" specifier. The "%f" supports a precision value to read the numeric digits. Specify the precision with a single integer value (1-9) as follows: use "%3f" for milliseconds, "%6f" for microseconds and "%9f" for nanoseconds.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if timestamp_type is not a timestamp type.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">timestamp_type</td><td>The timestamp type used for creating the output column. </td></tr>
<tr><td class="paramname">format</td><td>String specifying the timestamp format in strings. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New datetime column. </dd></dl>
</div>
</div>
<a id="ga4369d2892844667ddda5da6d68dcfb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4369d2892844667ddda5da6d68dcfb8c">◆ </a></span>url_decode()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::url_decode </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Encodes each string using URL encoding. </p>
<p>Converts all character sequences starting with '' into character code-points interpreting the 2 following characters as hex values to create the code-point. For example, the sequence '%20' is converted into byte (0x20) which is a single space character. Another example converts 'C3A9' into 2 sequential bytes (0xc3 and 0xa9 respectively) which is the é character. Overall, 3 characters are converted into one char byte whenever a '%' (single percent) character is encountered in the string.</p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings column. </dd></dl>
</div>
</div>
<a id="gaca75cf8110d40289c7e90e6d84640ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca75cf8110d40289c7e90e6d84640ecc">◆ </a></span>url_encode()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::strings::url_encode </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Decodes each string using URL encoding. </p>
<p>Converts mostly non-ascii characters and control characters into UTF-8 hex code-points prefixed with ''. For example, the space character must be converted to characters '%20' where the '20' indicates the hex value for space in UTF-8. Likewise, multi-byte characters are converted to multiple hex characters. For example, the é character is converted to characters 'C3A9' where 'C3A9' is the UTF-8 bytes 0xC3A9 for this character.</p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings column. </dd></dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"/></a> 1.8.20
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
