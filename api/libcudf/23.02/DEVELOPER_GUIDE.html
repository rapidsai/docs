<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcudf: libcudf C++ Developer Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer="" src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/nightly">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (23.02)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/nightly/namespacecudf.html">nightly (23.02)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (22.12)</a><a class="rapids-selector__menu-item" href="/api/libcudf/legacy/namespacecudf.html">legacy (22.10)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libcudf C++ Developer Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_developer_guide_DEVELOPER_GUIDE"></a> This document serves as a guide for contributors to libcudf C++ code. Developers should also refer to these additional files for further documentation of libcudf best practices.</p>
<ul>
<li><a class="el" href="md_developer_guide_DOCUMENTATION.html">Documentation Guide</a> for guidelines on documenting libcudf code.</li>
<li><a class="el" href="md_developer_guide_TESTING.html">Testing Guide</a> for guidelines on writing unit tests.</li>
<li><a class="el" href="md_developer_guide_BENCHMARKING.html">Benchmarking Guide</a> for guidelines on writing unit benchmarks.</li>
</ul>
<h1><a class="anchor" id="autotoc_md38"></a>
Overview</h1>
<p>libcudf is a C++ library that provides GPU-accelerated data-parallel algorithms for processing column-oriented tabular data. libcudf provides algorithms including slicing, filtering, sorting, various types of aggregations, and database-type operations such as grouping and joins. libcudf serves a number of clients via multiple language interfaces, including Python and Java. Users may also use libcudf directly from C++ code.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Lexicon</h2>
<p>This section defines terminology used within libcudf.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
Column</h3>
<p>A column is an array of data of a single type. Along with Tables, columns are the fundamental data structures used in libcudf. Most libcudf algorithms operate on columns. Columns may have a validity mask representing whether each element is valid or null (invalid). Columns of nested types are supported, meaning that a column may have child columns. A column is the C++ equivalent to a cuDF Python <a href="https://docs.rapids.ai/api/cudf/stable/api_docs/series.html">Series</a>.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
Element</h3>
<p>An individual data item within a column. Also known as a row.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
Scalar</h3>
<p>A type representing a single element of a data type.</p>
<h3><a class="anchor" id="autotoc_md43"></a>
Table</h3>
<p>A table is a collection of columns with equal number of elements. A table is the C++ equivalent to a cuDF Python <a href="https://docs.rapids.ai/api/cudf/stable/api_docs/dataframe.html">DataFrame</a>.</p>
<h3><a class="anchor" id="autotoc_md44"></a>
View</h3>
<p>A view is a non-owning object that provides zero-copy access (possibly with slicing or offsets) to data owned by another object. Examples are column views and table views.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
Directory Structure and File Naming</h1>
<p>External/public libcudf APIs are grouped based on functionality into an appropriately titled header file in <code>cudf/cpp/include/cudf/</code>. For example, <code><a class="el" href="copying_8hpp.html" title="Column APIs for gather, scatter, split, slice, etc.">cudf/cpp/include/cudf/copying.hpp</a></code> contains the APIs for functions related to copying from one column to another. Note the <code>.hpp</code> file extension used to indicate a C++ header file.</p>
<p>Header files should use the <code>#pragma once</code> include guard.</p>
<p>The naming of external API headers should be consistent with the name of the folder that contains the source files that implement the API. For example, the implementation of the APIs found in <code><a class="el" href="copying_8hpp.html" title="Column APIs for gather, scatter, split, slice, etc.">cudf/cpp/include/cudf/copying.hpp</a></code> are located in <code>cudf/src/copying</code>. Likewise, the unit tests for the APIs reside in <code>cudf/tests/copying/</code>.</p>
<p>Internal API headers containing <code>detail</code> namespace definitions that are used across translation units inside libcudf should be placed in <code>include/cudf/detail</code>.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
File extensions</h2>
<ul>
<li><code>.hpp</code> : C++ header files</li>
<li><code>.cpp</code> : C++ source files</li>
<li><code>.cu</code> : CUDA C++ source files</li>
<li><code>.cuh</code> : Headers containing CUDA device code</li>
</ul>
<p>Only use <code>.cu</code> and <code>.cuh</code> if necessary. A good indicator is the inclusion of <code>__device__</code> and other symbols that are only recognized by <code>nvcc</code>. Another indicator is Thrust algorithm APIs with a device execution policy (always <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1exec__policy.html">rmm::exec_policy</a></code> in libcudf).</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Code and Documentation Style and Formatting</h2>
<p>libcudf code uses <a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> for all names except in a few cases: template parameters, unit tests and test case names may use Pascal case, aka <a href="https://en.wikipedia.org/wiki/Camel_case">UpperCamelCase</a>. We do not use <a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation</a>, except sometimes when naming device data variables and their corresponding host copies. Private member variables are typically prefixed with an underscore.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IteratorType&gt;</div>
<div class="line"><span class="keywordtype">void</span> algorithm_function(<span class="keywordtype">int</span> x, <a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html">rmm::cuda_stream_view</a> s, rmm::device_memory_resource* mr)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>utility_class</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">private:</div>
<div class="line">  <span class="keywordtype">int</span> _rating{};</div>
<div class="line">  std::unique_ptr&lt;cudf::column&gt; _column{};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TYPED_TEST_SUITE(RepeatTypedTestFixture, <a class="code" href="type__lists_8hpp.html#a801e7f5ab035e59f7560ce97cd47ed5f">cudf::test::FixedWidthTypes</a>);</div>
<div class="line"> </div>
<div class="line">TYPED_TEST(RepeatTypedTestFixture, RepeatScalarCount)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>C++ formatting is enforced using <code>clang-format</code>. You should configure <code>clang-format</code> on your machine to use the <code>cudf/cpp/.clang-format</code> configuration file, and run <code>clang-format</code> on all changed code before committing it. The easiest way to do this is to configure your editor to "format on save."</p>
<p>Aspects of code style not discussed in this document and not automatically enforceable are typically caught during code review, or not enforced.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
C++ Guidelines</h3>
<p>In general, we recommend following <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines</a>. We also recommend watching Sean Parent's <a href="https://www.youtube.com/watch?v=W2tWOdzgXHA">C++ Seasoning talk</a>, and we try to follow his rules: "No raw loops. No raw pointers. No raw synchronization primitives."</p>
<ul>
<li>Prefer algorithms from STL and Thrust to raw loops.</li>
<li>Prefer libcudf and RMM <a href="#libcudf-data-structures">owning data structures and views</a> to raw pointers and raw memory allocation.</li>
<li>libcudf doesn't have a lot of CPU-thread concurrency, but there is some. And currently libcudf does use raw synchronization primitives. So we should revisit Parent's third rule and improve here.</li>
</ul>
<p>Additional style guidelines for libcudf code include:</p>
<ul>
<li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#nl11-make-literals-readable">NL.11: Make Literals Readable</a>: Decimal values should use integer separators every thousands place, like <code>1'234'567</code>. Hexadecimal values should use separators every 4 characters, like <code>0x0123'ABCD</code>.</li>
</ul>
<p>Documentation is discussed in the <a class="el" href="md_developer_guide_DOCUMENTATION.html">Documentation Guide</a>.</p>
<h3><a class="anchor" id="autotoc_md49"></a>
Includes</h3>
<p>The following guidelines apply to organizing <code>#include</code> lines.</p>
<ul>
<li>Group includes by library (e.g. cuDF, RMM, Thrust, STL). <code>clang-format</code> will respect the groupings and sort the individual includes within a group lexicographically.</li>
<li>Separate groups by a blank line.</li>
<li>Order the groups from "nearest" to "farthest". In other words, local includes, then includes from other RAPIDS libraries, then includes from related libraries, like <code>&lt;thrust/...&gt;</code>, then includes from dependencies installed with cuDF, and then standard headers (for example <code>&lt;string&gt;</code>, <code>&lt;iostream&gt;</code>).</li>
<li>Use <code>&lt;&gt;</code> instead of <code>""</code> unless the header is in the same directory as the source file.</li>
<li>Tools like <code>clangd</code> often auto-insert includes when they can, but they usually get the grouping and brackets wrong.</li>
<li>Always check that includes are only necessary for the file in which they are included. Try to avoid excessive including especially in header files. Double check this when you remove code.</li>
<li>Use quotes <code>"</code> to include local headers from the same relative source directory. This should only occur in source files and non-public header files. Otherwise use angle brackets <code>&lt;&gt;</code> around included header filenames.</li>
<li>Avoid relative paths with <code>..</code> when possible. Paths with <code>..</code> are necessary when including (internal) headers from source paths not in the same directory as the including file, because source paths are not passed with <code>-I</code>.</li>
<li>Avoid including library internal headers from non-internal files. For example, try not to include headers from libcudf <code>src</code> directories in tests or in libcudf public headers. If you find yourself doing this, start a discussion about moving (parts of) the included internal header to a public header.</li>
</ul>
<h1><a class="anchor" id="autotoc_md50"></a>
libcudf Data Structures</h1>
<p>Application data in libcudf is contained in Columns and Tables, but there are a variety of other data structures you will use when developing libcudf code.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Views and Ownership</h2>
<p>Resource ownership is an essential concept in libcudf. In short, an "owning" object owns a resource (such as device memory). It acquires that resource during construction and releases the resource in destruction (<a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>). A "non-owning" object does not own resources. Any class in libcudf with the <code>*_view</code> suffix is non-owning. For more detail see the <a href="https://docs.google.com/presentation/d/1zKzAtc1AWFKfMhiUlV5yRZxSiPLwsObxMlWRWz_f5hA/edit?usp=sharing"><code>libcudf</code> presentation.</a></p>
<p>libcudf functions typically take views as input (<code>column_view</code> or <code>table_view</code>) and produce <code>unique_ptr</code>s to owning objects as output. For example,</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;table&gt; <a class="code" href="group__column__sort.html#ga63ae5bdac795a9829eda093339cf5a6d">sort</a>(table_view <span class="keyword">const</span>&amp; input);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
rmm::device_memory_resource</h2>
<p>libcudf allocates all device memory via RMM memory resources (MR). See the <a href="https://github.com/rapidsai/rmm/blob/main/README.md">RMM documentation</a> for details.</p>
<h3><a class="anchor" id="autotoc_md53"></a>
Current Device Memory Resource</h3>
<p>RMM provides a "default" memory resource for each device that can be accessed and updated via the <code>rmm::mr::get_current_device_resource()</code> and <code>rmm::mr::set_current_device_resource(...)</code> functions, respectively. All memory resource parameters should be defaulted to use the return value of <code>rmm::mr::get_current_device_resource()</code>.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
cudf::column</h2>
<p><code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> is a core owning data structure in libcudf. Most libcudf public APIs produce either a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> or a <code><a class="el" href="classcudf_1_1table.html" title="A set of cudf::column's of the same size.">cudf::table</a></code> as output. A <code>column</code> contains <code>device_buffer</code>s which own the device memory for the elements of a column and an optional null indicator bitmask.</p>
<p>Implicitly convertible to <code>column_view</code> and <code>mutable_column_view</code>.</p>
<p>Movable and copyable. A copy performs a deep copy of the column's contents, whereas a move moves the contents from one column to another.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classcudf_1_1column.html">cudf::column</a> col{...};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classcudf_1_1column.html">cudf::column</a> copy{col}; <span class="comment">// Copies the contents of `col`</span></div>
<div class="line"><a class="code" href="classcudf_1_1column.html">cudf::column</a> <span class="keyword">const</span> moved_to{std::move(col)}; <span class="comment">// Moves contents from `col`</span></div>
<div class="line"> </div>
<div class="line">column_view v = moved_to; <span class="comment">// Implicit conversion to non-owning column_view</span></div>
<div class="line"><span class="comment">// mutable_column_view m = moved_to; // Cannot create mutable view to const column</span></div>
</div><!-- fragment --><p>A <code>column</code> may have nested (child) columns, depending on the data type of the column. For example, <code>LIST</code>, <code>STRUCT</code>, and <code>STRING</code> type columns.</p>
<h3><a class="anchor" id="autotoc_md55"></a>
cudf::column_view</h3>
<p><code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">cudf::column_view</a></code> is a core non-owning data structure in libcudf. It is an immutable, non-owning view of device memory as a column. Most libcudf public APIs take views as inputs.</p>
<p>A <code>column_view</code> may be a view of a "slice" of a column. For example, it might view rows 75-150 of a column with 1000 rows. The <code>size()</code> of this <code>column_view</code> would be <code>75</code>, and accessing index <code>0</code> of the view would return the element at index <code>75</code> of the owning <code>column</code>. Internally, this is implemented by storing in the view a pointer, an offset, and a size. <code>column_view::data&lt;T&gt;()</code> returns a pointer iterator to <code>column_view::head&lt;T&gt;() + offset</code>.</p>
<h3><a class="anchor" id="autotoc_md56"></a>
cudf::mutable_column_view</h3>
<p>A <em>mutable</em>, non-owning view of device memory as a column. Used for detail APIs and (rare) public APIs that modify columns in place.</p>
<h3><a class="anchor" id="autotoc_md57"></a>
cudf::column_device_view</h3>
<p>An immutable, non-owning view of device data as a column of elements that is trivially copyable and usable in CUDA device code. Used to pass <code>column_view</code> data as input to CUDA kernels and device functions (including Thrust algorithms)</p>
<h3><a class="anchor" id="autotoc_md58"></a>
cudf::mutable_column_device_view</h3>
<p>A mutable, non-owning view of device data as a column of elements that is trivially copyable and usable in CUDA device code. Used to pass <code>column_view</code> data to be modified on the device by CUDA kernels and device functions (including Thrust algorithms).</p>
<h2><a class="anchor" id="autotoc_md59"></a>
cudf::table</h2>
<p>Owning class for a set of <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code>s all with equal number of elements. This is the C++ equivalent to a data frame.</p>
<p>Implicitly convertible to <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">cudf::table_view</a></code> and <code><a class="el" href="classcudf_1_1mutable__table__view.html" title="A set of mutable_column_views of the same size.">cudf::mutable_table_view</a></code></p>
<p>Movable and copyable. A copy performs a deep copy of all columns, whereas a move moves all columns from one table to another.</p>
<h3><a class="anchor" id="autotoc_md60"></a>
cudf::table_view</h3>
<p>An <em>immutable</em>, non-owning view of a table.</p>
<h3><a class="anchor" id="autotoc_md61"></a>
cudf::mutable_table_view</h3>
<p>A <em>mutable</em>, non-owning view of a table.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
Spans</h2>
<p>libcudf provides <code>span</code> classes that mimic C++20 <code>std::span</code>, which is a lightweight view of a contiguous sequence of objects. libcudf provides two classes, <code>host_span</code> and <code>device_span</code>, which can be constructed from multiple container types, or from a pointer (host or device, respectively) and size, or from iterators. <code>span</code> types are useful for defining generic (internal) interfaces which work with multiple input container types. <code>device_span</code> can be constructed from <code>thrust::device_vector</code>, <code>rmm::device_vector</code>, or <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__uvector.html">rmm::device_uvector</a></code>. <code>host_span</code> can be constructed from <code>thrust::host_vector</code>, <code>std::vector</code>, or <code>std::basic_string</code>.</p>
<p>If you are defining internal (detail) functions that operate on vectors, use spans for the input vector parameters rather than a specific vector type, to make your functions more widely applicable.</p>
<p>When a <code>span</code> refers to immutable elements, use <code>span&lt;T const&gt;</code>, not <code>span&lt;T&gt; const</code>. Since a span is lightweight view, it does not propagate <code>const</code>-ness. Therefore, <code>const</code> should be applied to the template type parameter, not to the <code>span</code> itself. Also, <code>span</code> should be passed by value because it is a lightweight view. APIS in libcudf that take spans as input will look like the following function that copies device data to a host <code>std::vector</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::vector&lt;T&gt; make_std_vector_async(device_span&lt;T const&gt; v, <a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html">rmm::cuda_stream_view</a> stream)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md63"></a>
cudf::scalar</h2>
<p>A <code><a class="el" href="classcudf_1_1scalar.html" title="An owning class to represent a singular value.">cudf::scalar</a></code> is an object that can represent a singular, nullable value of any of the types currently supported by cudf. Each type of value is represented by a separate type of scalar class which are all derived from <code><a class="el" href="classcudf_1_1scalar.html" title="An owning class to represent a singular value.">cudf::scalar</a></code>. e.g. A <code>numeric_scalar</code> holds a single numerical value, a <code>string_scalar</code> holds a single string. The data for the stored value resides in device memory.</p>
<p>A <code>list_scalar</code> holds the underlying data of a single list. This means the underlying data can be any type that cudf supports. For example, a <code>list_scalar</code> representing a list of integers stores a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> of type <code>INT32</code>. A <code>list_scalar</code> representing a list of lists of integers stores a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> of type <code>LIST</code>, which in turn stores a column of type <code>INT32</code>.</p>
<table class="markdownTable">
<tbody><tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value type  </th><th class="markdownTableHeadNone">Scalar class  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fixed-width  </td><td class="markdownTableBodyNone"><code>fixed_width_scalar&lt;T&gt;</code>  </td><td class="markdownTableBodyNone"><code>T</code> can be any fixed-width type   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">numeric  </td><td class="markdownTableBodyNone"><code>numeric_scalar&lt;T&gt;</code>  </td><td class="markdownTableBodyNone"><code>T</code> can be <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int_64_t</code>, <code>float</code> or <code>double</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fixed-point  </td><td class="markdownTableBodyNone"><code>fixed_point_scalar&lt;T&gt;</code>  </td><td class="markdownTableBodyNone"><code>T</code> can be <code><a class="el" href="group__fixed__point__classes.html#ga74f28c0e58f5105d5a67b658d839ffa0" title="32-bit decimal fixed point">numeric::decimal32</a></code> or <code><a class="el" href="group__fixed__point__classes.html#ga85be3b2e76e27778378832af34cf88a5" title="64-bit decimal fixed point">numeric::decimal64</a></code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">timestamp  </td><td class="markdownTableBodyNone"><code>timestamp_scalar&lt;T&gt;</code>  </td><td class="markdownTableBodyNone"><code>T</code> can be <code>timestamp_D</code>, <code>timestamp_s</code>, etc.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">duration  </td><td class="markdownTableBodyNone"><code>duration_scalar&lt;T&gt;</code>  </td><td class="markdownTableBodyNone"><code>T</code> can be <code>duration_D</code>, <code>duration_s</code>, etc.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">string  </td><td class="markdownTableBodyNone"><code>string_scalar</code>  </td><td class="markdownTableBodyNone">This class object is immutable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">list  </td><td class="markdownTableBodyNone"><code>list_scalar</code>  </td><td class="markdownTableBodyNone">Underlying data can be any type supported by cudf   </td></tr>
</tbody></table>
<h3><a class="anchor" id="autotoc_md64"></a>
Construction</h3>
<p><code>scalar</code>s can be created using either their respective constructors or using factory functions like <code><a class="el" href="group__scalar__factories.html#gaa76f2f5b1cab4f43ec997d77f1a3851e" title="Construct scalar with uninitialized storage to hold a value of the specified numeric data_type.">make_numeric_scalar()</a></code>, <code><a class="el" href="group__scalar__factories.html#gacdd7c294fe02eed61bec156f3c960b59" title="Construct scalar with uninitialized storage to hold a value of the specified timestamp data_type.">make_timestamp_scalar()</a></code> or <code><a class="el" href="group__scalar__factories.html#ga910858190bf158fce6adfba4cd0cfb43" title="Construct STRING type scalar given a std::string. The size of the std::string must not exceed the max...">make_string_scalar()</a></code>.</p>
<h3><a class="anchor" id="autotoc_md65"></a>
Casting</h3>
<p>All the factory methods return a <code>unique_ptr&lt;scalar&gt;</code> which needs to be statically downcasted to its respective scalar class type before accessing its value. Their validity (nullness) can be accessed without casting. Generally, the value needs to be accessed from a function that is aware of the value type e.g. a functor that is dispatched from <code>type_dispatcher</code>. To cast to the requisite scalar class type given the value type, use the mapping utility <code>scalar_type_t</code> provided in <code><a class="el" href="type__dispatcher_8hpp.html" title="Defines the mapping between cudf::type_id runtime type information and concrete C++ types.">type_dispatcher.hpp</a></code> :</p>
<div class="fragment"><div class="line"><span class="comment">//unique_ptr&lt;scalar&gt; s = make_numeric_scalar(...);</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> ScalarType = <a class="code" href="group__utility__dispatcher.html#ga9446c2558fd01c19f5fb5fa33927586f">cudf::scalar_type_t&lt;T&gt;</a>;</div>
<div class="line"><span class="comment">// ScalarType is now numeric_scalar&lt;T&gt;</span></div>
<div class="line"><span class="keyword">auto</span> s1 = <span class="keyword">static_cast&lt;</span>ScalarType *<span class="keyword">&gt;</span>(s.get());</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md66"></a>
Passing to device</h3>
<p>Each scalar type, except <code>list_scalar</code>, has a corresponding non-owning device view class which allows access to the value and its validity from the device. This can be obtained using the function <code>get_scalar_device_view(ScalarType s)</code>. Note that a device view is not provided for a base scalar object, only for the derived typed scalar class objects.</p>
<p>The underlying data for <code>list_scalar</code> can be accessed via <code>view()</code> method. For non-nested data, the device view can be obtained via function <code>column_device_view::create(column_view)</code>. For nested data, a specialized device view for list columns can be constructed via <code>lists_column_device_view(column_device_view)</code>.</p>
<h1><a class="anchor" id="autotoc_md67"></a>
libcudf Policies and Design Principles</h1>
<p><code>libcudf</code> is designed to provide thread-safe, single-GPU accelerated algorithm primitives for solving a wide variety of problems that arise in data science. APIs are written to execute on the default GPU, which can be controlled by the caller through standard CUDA device APIs or environment variables like <code>CUDA_VISIBLE_DEVICES</code>. Our goal is to enable diverse use cases like Spark or Pandas to benefit from the performance of GPUs, and libcudf relies on these higher-level layers like Spark or Dask to orchestrate multi-GPU tasks.</p>
<p>To best satisfy these use-cases, libcudf prioritizes performance and flexibility, which sometimes may come at the cost of convenience. While we welcome users to use libcudf directly, we design with the expectation that most users will be consuming libcudf through higher-level layers like Spark or cuDF Python that handle some of details that direct users of libcudf must handle on their own. We document these policies and the reasons behind them here.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
libcudf does not introspect data</h2>
<p>libcudf APIs generally do not perform deep introspection and validation of input data. There are numerous reasons for this:</p><ol type="1">
<li>It violates the single responsibility principle: validation is separate from execution.</li>
<li>Since libcudf data structures store data on the GPU, any validation incurs <em>at minimum</em> the overhead of a kernel launch, and may in general be prohibitively expensive.</li>
<li>API promises around data introspection often significantly complicate implementation.</li>
</ol>
<p>Users are therefore responsible for passing valid data into such APIs. <em>Note that this policy does not mean that libcudf performs no validation whatsoever</em>. libcudf APIs should still perform any validation that does not require introspection. To give some idea of what should or should not be validated, here are (non-exhaustive) lists of examples.</p>
<p><b>Things that libcudf should validate</b>:</p><ul>
<li>Input column/table sizes or dtypes</li>
</ul>
<p><b>Things that libcudf should not validate</b>:</p><ul>
<li>Integer overflow</li>
<li>Ensuring that outputs will not exceed the 2GB size limit for a given set of inputs</li>
</ul>
<h2><a class="anchor" id="autotoc_md69"></a>
libcudf expects nested types to have sanitized null masks</h2>
<p>Various libcudf APIs accepting columns of nested dtypes (such as <code>LIST</code> or <code>STRUCT</code>) may assume that these columns have been sanitized. In this context, sanitization refers to ensuring that the null elements in a column with a nested dtype are compatible with the elements of nested columns. Specifically:</p><ul>
<li>Null elements of list columns should also be empty. The starting offset of a null element should be equal to the ending offset.</li>
<li>Null elements of struct columns should also be null elements in the underlying structs.</li>
<li>For compound columns, nulls should only be present at the level of the parent column. Child columns should not contain nulls.</li>
<li>Slice operations on nested columns do not propagate offsets to child columns.</li>
</ul>
<p>libcudf APIs <em>should</em> promise to never return "dirty" columns, i.e. columns containing unsanitized data. Therefore, the only problem is if users construct input columns that are not correctly sanitized and then pass those into libcudf APIs.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
Treat libcudf APIs as if they were asynchronous</h2>
<p>libcudf APIs called on the host do not guarantee that the stream is synchronized before returning. Work in libcudf occurs on <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa" title="Get the current default stream.">cudf::get_default_stream()</a>.value</code>, which defaults to the CUDA default stream (stream 0). Note that the stream 0 behavior differs if <a href="https://docs.nvidia.com/cuda/cuda-runtime-api/stream-sync-behavior.html">per-thread default stream is enabled</a> via <code>CUDF_USE_PER_THREAD_DEFAULT_STREAM</code>. Any data provided to or returned by libcudf that uses a separate non-blocking stream requires synchronization with the default libcudf stream to ensure stream safety.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
libcudf generally does not make ordering guarantees</h2>
<p>Functions like merge or groupby in libcudf make no guarantees about the order of entries in the output. Promising deterministic ordering is not, in general, conducive to fast parallel algorithms. Calling code is responsible for performing sorts after the fact if sorted outputs are needed.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
libcudf does not promise specific exception messages</h2>
<p>libcudf documents the exceptions that will be thrown by an API for different kinds of invalid inputs. The types of those exceptions (e.g. <code><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></code>) are part of the public API. However, the explanatory string returned by the <code>what</code> method of those exceptions is not part of the API and is subject to change. Calling code should not rely on the contents of libcudf error messages to determine the nature of the error. For information on the types of exceptions that libcudf throws under different circumstances, see the <a href="#errors">section on error handling</a>.</p>
<h1><a class="anchor" id="autotoc_md73"></a>
libcudf API and Implementation</h1>
<h2><a class="anchor" id="autotoc_md74"></a>
Streams</h2>
<p>CUDA streams are not yet exposed in external libcudf APIs. However, in order to ease the transition to future use of streams, all libcudf APIs that allocate device memory or execute a kernel should be implemented using asynchronous APIs on the default stream (e.g., stream 0).</p>
<p>The recommended pattern for doing this is to make the definition of the external API invoke an internal API in the <code>detail</code> namespace. The internal <code>detail</code> API has the same parameters as the public API, plus a <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html">rmm::cuda_stream_view</a></code> parameter at the end with no default value. If the detail API also accepts a memory resource parameter, the stream parameter should be ideally placed just <em>before</em> the memory resource. The public API will call the detail API and provide <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa" title="Get the current default stream.">cudf::get_default_stream()</a></code>. The implementation should be wholly contained in the <code>detail</code> API definition and use only asynchronous versions of CUDA APIs with the stream parameter.</p>
<p>In order to make the <code>detail</code> API callable from other libcudf functions, it should be exposed in a header placed in the <code>cudf/cpp/include/detail/</code> directory.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="comment">// cpp/include/cudf/header.hpp</span></div>
<div class="line"><span class="keywordtype">void</span> external_function(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// cpp/include/cudf/detail/header.hpp</span></div>
<div class="line"><span class="keyword">namespace </span>detail{</div>
<div class="line"><span class="keywordtype">void</span> external_function(..., <a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html">rmm::cuda_stream_view</a> stream)</div>
<div class="line">} <span class="comment">// namespace detail</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// cudf/src/implementation.cpp</span></div>
<div class="line"><span class="keyword">namespace </span>detail{</div>
<div class="line">    <span class="comment">// Use the stream parameter in the detail implementation.</span></div>
<div class="line">    <span class="keywordtype">void</span> external_function(..., <a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html">rmm::cuda_stream_view</a> stream){</div>
<div class="line">        <span class="comment">// Implementation uses the stream with async APIs.</span></div>
<div class="line">        <a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a> buff(...,stream);</div>
<div class="line">        <a class="code" href="group__utility__error.html#gaeb308ca6145fb2250acd4e7651dec984">CUDF_CUDA_TRY</a>(cudaMemcpyAsync(...,stream.<a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html#a17aac270b340f8d9f73ad88c9636954f">value</a>()));</div>
<div class="line">        kernel&lt;&lt;&lt;..., stream&gt;&gt;&gt;(...);</div>
<div class="line">        thrust::algorithm(<a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1exec__policy.html">rmm::exec_policy</a>(stream), ...);</div>
<div class="line">    }</div>
<div class="line">} <span class="comment">// namespace detail</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> external_function(...){</div>
<div class="line">    CUDF_FUNC_RANGE(); <span class="comment">// Generates an NVTX range for the lifetime of this function.</span></div>
<div class="line">    detail::external_function(..., <a class="code" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Note:</b> It is important to synchronize the stream if <em>and only if</em> it is necessary. For example, when a non-pointer value is returned from the API that is the result of an asynchronous device-to-host copy, the stream used for the copy should be synchronized before returning. However, when a column is returned, the stream should not be synchronized because doing so will break asynchrony if and when we add an asynchronous API to libcudf.</p>
<p><b>Note:</b> <code>cudaDeviceSynchronize()</code> should <em>never</em> be used. This limits the ability to do any multi-stream/multi-threaded work with libcudf APIs.</p>
<h3><a class="anchor" id="autotoc_md75"></a>
NVTX Ranges</h3>
<p>In order to aid in performance optimization and debugging, all compute intensive libcudf functions should have a corresponding NVTX range. In libcudf, we have a convenience macro <code>CUDF_FUNC_RANGE()</code> that will automatically annotate the lifetime of the enclosing function and use the function's name as the name of the NVTX range. For more information about NVTX, see <a href="https://github.com/NVIDIA/NVTX/tree/dev/cpp">here</a>.</p>
<h3><a class="anchor" id="autotoc_md76"></a>
Stream Creation</h3>
<p>There may be times in implementing libcudf features where it would be advantageous to use streams <em>internally</em>, i.e., to accomplish overlap in implementing an algorithm. However, dynamically creating a stream can be expensive. RMM has a stream pool class to help avoid dynamic stream creation. However, this is not yet exposed in libcudf, so for the time being, libcudf features should avoid creating streams (even if it is slightly less efficient). It is a good idea to leave a <code>// TODO:</code> note indicating where using a stream would be beneficial.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
Memory Allocation</h2>
<p>Device <a href="#rmmdevice_memory_resource">memory resources</a> are used in libcudf to abstract and control how device memory is allocated.</p>
<h3><a class="anchor" id="autotoc_md78"></a>
Output Memory</h3>
<p>Any libcudf API that allocates memory that is <em>returned</em> to a user must accept a pointer to a <code>device_memory_resource</code> as the last parameter. Inside the API, this memory resource must be used to allocate any memory for returned objects. It should therefore be passed into functions whose outputs will be returned. Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Returned `column` contains newly allocated memory,</span></div>
<div class="line"><span class="comment">// therefore the API must accept a memory resource pointer</span></div>
<div class="line">std::unique_ptr&lt;column&gt; returns_output_memory(</div>
<div class="line">  ..., rmm::device_memory_resource * mr = rmm::mr::get_current_device_resource());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This API does not allocate any new *output* memory, therefore</span></div>
<div class="line"><span class="comment">// a memory resource is unnecessary</span></div>
<div class="line"><span class="keywordtype">void</span> does_not_allocate_output_memory(...);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md79"></a>
Temporary Memory</h3>
<p>Not all memory allocated within a libcudf API is returned to the caller. Often algorithms must allocate temporary, scratch memory for intermediate results. Always use the default resource obtained from <code>rmm::mr::get_current_device_resource()</code> for temporary memory allocations. Example:</p>
<div class="fragment"><div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a> some_function(</div>
<div class="line">  ..., <a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> mr * = rmm::mr::get_current_device_resource()) {</div>
<div class="line">    <a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a> returned_buffer(..., mr); <span class="comment">// Returned buffer uses the passed in MR</span></div>
<div class="line">    ...</div>
<div class="line">    <a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a> temporary_buffer(...); <span class="comment">// Temporary buffer uses default MR</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">return</span> returned_buffer;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md80"></a>
Memory Management</h3>
<p>libcudf code generally eschews raw pointers and direct memory allocation. Use RMM classes built to use <code>device_memory_resource</code>(*)s for device memory allocation with automated lifetime management.</p>
<h4><a class="anchor" id="autotoc_md81"></a>
rmm::device_buffer</h4>
<p>Allocates a specified number of bytes of untyped, uninitialized device memory using a <code>device_memory_resource</code>. If no resource is explicitly provided, uses <code>rmm::mr::get_current_device_resource()</code>.</p>
<p><code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a></code> is movable and copyable on a stream. A copy performs a deep copy of the <code>device_buffer</code>'s device memory on the specified stream, whereas a move moves ownership of the device memory from one <code>device_buffer</code> to another.</p>
<div class="fragment"><div class="line"><span class="comment">// Allocates at least 100 bytes of uninitialized device memory</span></div>
<div class="line"><span class="comment">// using the specified resource and stream</span></div>
<div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a> buff(100, stream, mr);</div>
<div class="line"><span class="keywordtype">void</span> * raw_data = buff.data(); <span class="comment">// Raw pointer to underlying device memory</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deep copies `buff` into `copy` on `stream`</span></div>
<div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a> copy(buff, stream);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Moves contents of `buff` into `moved_to`</span></div>
<div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a> moved_to(std::move(buff));</div>
<div class="line"> </div>
<div class="line">custom_memory_resource *mr...;</div>
<div class="line"><span class="comment">// Allocates 100 bytes from the custom_memory_resource</span></div>
<div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a> custom_buff(100, mr, stream);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md82"></a>
rmm::device_scalar&lt;T&gt;</h4>
<p>Allocates a single element of the specified type initialized to the specified value. Use this for scalar input/outputs into device kernels, e.g., reduction results, null count, etc. This is effectively a convenience wrapper around a <code>rmm::device_vector&lt;T&gt;</code> of length 1.</p>
<div class="fragment"><div class="line"><span class="comment">// Allocates device memory for a single int using the specified resource and stream</span></div>
<div class="line"><span class="comment">// and initializes the value to 42</span></div>
<div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__scalar.html">rmm::device_scalar&lt;int&gt;</a> int_scalar{42, stream, mr};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// scalar.data() returns pointer to value in device memory</span></div>
<div class="line">kernel&lt;&lt;&lt;...&gt;&gt;&gt;(int_scalar.data(),...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// scalar.value() synchronizes the scalar's stream and copies the</span></div>
<div class="line"><span class="comment">// value from device to host and returns the value</span></div>
<div class="line"><span class="keywordtype">int</span> host_value = int_scalar.<a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html#a17aac270b340f8d9f73ad88c9636954f">value</a>();</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md83"></a>
rmm::device_vector&lt;T&gt;</h4>
<p>Allocates a specified number of elements of the specified type. If no initialization value is provided, all elements are default initialized (this incurs a kernel launch).</p>
<p><b>Note</b>: We have removed all usage of <code>rmm::device_vector</code> and <code>thrust::device_vector</code> from libcudf, and you should not use it in new code in libcudf without careful consideration. Instead, use <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__uvector.html">rmm::device_uvector</a></code> along with the utility factories in <code>device_factories.hpp</code>. These utilities enable creation of <code>uvector</code>s from host-side vectors, or creating zero-initialized <code>uvector</code>s, so that they are as convenient to use as <code>device_vector</code>. Avoiding <code>device_vector</code> has a number of benefits, as described in the following section on <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__uvector.html">rmm::device_uvector</a></code>.</p>
<h4><a class="anchor" id="autotoc_md84"></a>
rmm::device_uvector&lt;T&gt;</h4>
<p>Similar to a <code>device_vector</code>, allocates a contiguous set of elements in device memory but with key differences:</p><ul>
<li>As an optimization, elements are uninitialized and no synchronization occurs at construction. This limits the types <code>T</code> to trivially copyable types.</li>
<li>All operations are stream ordered (i.e., they accept a <code>cuda_stream_view</code> specifying the stream on which the operation is performed). This improves safety when using non-default streams.</li>
<li><code>device_uvector.hpp</code> does not include any <code>__device__</code> code, unlike <code>thrust/device_vector.hpp</code>, which means <code>device_uvector</code>s can be used in <code>.cpp</code> files, rather than just in <code>.cu</code> files.</li>
</ul>
<div class="fragment"><div class="line">cuda_stream s;</div>
<div class="line"><span class="comment">// Allocates uninitialized storage for 100 `int32_t` elements on stream `s` using the</span></div>
<div class="line"><span class="comment">// default resource</span></div>
<div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__uvector.html">rmm::device_uvector&lt;int32_t&gt;</a> v(100, s);</div>
<div class="line"><span class="comment">// Initializes the elements to 0</span></div>
<div class="line">thrust::uninitialized_fill(thrust::cuda::par.on(s.value()), v.begin(), v.end(), int32_t{0});</div>
<div class="line"> </div>
<div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> * mr = <span class="keyword">new</span> my_custom_resource{...};</div>
<div class="line"><span class="comment">// Allocates uninitialized storage for 100 `int32_t` elements on stream `s` using the resource `mr`</span></div>
<div class="line"><a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__uvector.html">rmm::device_uvector&lt;int32_t&gt;</a> v2{100, s, mr};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md85"></a>
Input/Output Style</h2>
<p>The preferred style for how inputs are passed in and outputs are returned is the following:</p><ul>
<li>Inputs<ul>
<li>Columns:<ul>
<li><code>column_view const&amp;</code></li>
</ul>
</li>
<li>Tables:<ul>
<li><code>table_view const&amp;</code></li>
<li>Scalar:<ul>
<li><code>scalar const&amp;</code></li>
</ul>
</li>
<li>Everything else:<ul>
<li>Trivial or inexpensively copied types<ul>
<li>Pass by value</li>
</ul>
</li>
<li>Non-trivial or expensive to copy types<ul>
<li>Pass by <code>const&amp;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>In/Outs<ul>
<li>Columns:<ul>
<li><code>mutable_column_view&amp;</code></li>
</ul>
</li>
<li>Tables:<ul>
<li><code>mutable_table_view&amp;</code></li>
<li>Everything else:<ul>
<li>Pass by via raw pointer</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Outputs<ul>
<li>Outputs should be <em>returned</em>, i.e., no output parameters</li>
<li>Columns:<ul>
<li><code>std::unique_ptr&lt;column&gt;</code></li>
</ul>
</li>
<li>Tables:<ul>
<li><code>std::unique_ptr&lt;table&gt;</code></li>
<li>Scalars:<ul>
<li><code>std::unique_ptr&lt;scalar&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md86"></a>
Multiple Return Values</h3>
<p>Sometimes it is necessary for functions to have multiple outputs. There are a few ways this can be done in C++ (including creating a <code>struct</code> for the output). One convenient way to do this is using <code>std::tie</code> and <code>std::pair</code>. Note that objects passed to <code>std::pair</code> will invoke either the copy constructor or the move constructor of the object, and it may be preferable to move non-trivially copyable objects (and required for types with deleted copy constructors, like <code>std::unique_ptr</code>).</p>
<div class="fragment"><div class="line">std::pair&lt;table, table&gt; return_two_tables(<span class="keywordtype">void</span>){</div>
<div class="line">  <a class="code" href="classcudf_1_1table.html">cudf::table</a> out0;</div>
<div class="line">  <a class="code" href="classcudf_1_1table.html">cudf::table</a> out1;</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Do stuff with out0, out1</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Return a std::pair of the two outputs</span></div>
<div class="line">  <span class="keywordflow">return</span> std::pair(std::move(out0), std::move(out1));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classcudf_1_1table.html">cudf::table</a> out0;</div>
<div class="line"><a class="code" href="classcudf_1_1table.html">cudf::table</a> out1;</div>
<div class="line">std::tie(out0, out1) = cudf::return_two_outputs();</div>
</div><!-- fragment --><p>Note: <code>std::tuple</code> <em>could</em> be used if not for the fact that Cython does not support <code>std::tuple</code>. Therefore, libcudf APIs must use <code>std::pair</code>, and are therefore limited to return only two objects of different types. Multiple objects of the same type may be returned via a <code>std::vector&lt;T&gt;</code>.</p>
<p>Alternatively, with C++17 (supported from cudf v0.20), <a href="https://en.cppreference.com/w/cpp/language/structured_binding">structured binding</a> may be used to disaggregate multiple return values:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [out0, out1] = cudf::return_two_outputs();</div>
</div><!-- fragment --><p>Note that the compiler might not support capturing aliases defined in a structured binding in a lambda. One may work around this by using a capture with an initializer instead:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [out0, out1] = cudf::return_two_outputs();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Direct capture of alias from structured binding might fail with:</span></div>
<div class="line"><span class="comment">// "error: structured binding cannot be captured"</span></div>
<div class="line"><span class="comment">// auto foo = [out0]() {...};</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use an initializing capture:</span></div>
<div class="line"><span class="keyword">auto</span> foo = [&amp;out0 = out0] {</div>
<div class="line">  <span class="comment">// Use out0 to compute something.</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md87"></a>
Iterator-based interfaces</h2>
<p>Increasingly, libcudf is moving toward internal (<code>detail</code>) APIs with iterator parameters rather than explicit <code>column</code>/<code>table</code>/<code>scalar</code> parameters. As with STL, iterators enable generic algorithms to be applied to arbitrary containers. A good example of this is <code><a class="el" href="group__column__copy.html#gab08aeaceb95ca962b4ddb5b4a471da4c" title="Returns a new column, where each element is selected from either lhs or rhs based on the value of the...">cudf::copy_if_else</a></code>. This function takes two inputs, and a Boolean mask. It copies the corresponding element from the first or second input depending on whether the mask at that index is <code>true</code> or <code>false</code>. Implementing <code>copy_if_else</code> for all combinations of <code>column</code> and <code>scalar</code> parameters is simplified by using iterators in the <code>detail</code> API.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FilterFn, <span class="keyword">typename</span> LeftIter, <span class="keyword">typename</span> RightIter&gt;</div>
<div class="line">std::unique_ptr&lt;column&gt; <a class="code" href="group__column__copy.html#gab08aeaceb95ca962b4ddb5b4a471da4c">copy_if_else</a>(</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code" href="namespacecudf.html#a025670a619591e80fdf972c36e625005">nullable</a>,</div>
<div class="line">  LeftIter lhs_begin,</div>
<div class="line">  LeftIter lhs_end,</div>
<div class="line">  RightIter rhs,</div>
<div class="line">  FilterFn filter,</div>
<div class="line">  ...);</div>
</div><!-- fragment --><p><code>LeftIter</code> and <code>RightIter</code> need only implement the necessary interface for an iterator. libcudf provides a number of iterator types and utilities that are useful with iterator-based APIs from libcudf as well as Thrust algorithms. Most are defined in <code>include/detail/iterator.cuh</code>.</p>
<h3><a class="anchor" id="autotoc_md88"></a>
Pair iterator</h3>
<p>The pair iterator is used to access elements of nullable columns as a pair containing an element's value and validity. <code>cudf::detail::make_pair_iterator</code> can be used to create a pair iterator from a <code>column_device_view</code> or a <code><a class="el" href="classcudf_1_1scalar.html" title="An owning class to represent a singular value.">cudf::scalar</a></code>. <code>make_pair_iterator</code> is not available for <code>mutable_column_device_view</code>.</p>
<h3><a class="anchor" id="autotoc_md89"></a>
Null-replacement iterator</h3>
<p>This iterator replaces the null/validity value for each element with a specified constant (<code>true</code> or <code>false</code>). Created using <code>cudf::detail::make_null_replacement_iterator</code>.</p>
<h3><a class="anchor" id="autotoc_md90"></a>
Validity iterator</h3>
<p>This iterator returns the validity of the underlying element (<code>true</code> or <code>false</code>). Created using <code>cudf::detail::make_validity_iterator</code>.</p>
<h3><a class="anchor" id="autotoc_md91"></a>
Index-normalizing iterators</h3>
<p>The proliferation of data types supported by libcudf can result in long compile times. One area where compile time was a problem is in types used to store indices, which can be any integer type. The "Indexalator", or index-normalizing iterator (<code>include/cudf/detail/indexalator.cuh</code>), can be used for index types (integers) without requiring a type-specific instance. It can be used for any iterator interface for reading an array of integer values of type <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, or <code>uint64</code>. Reading specific elements always return a <code><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9" title="Row index type for columns and tables.">cudf::size_type</a></code> integer.</p>
<p>Use the <code>indexalator_factory</code> to create an appropriate input iterator from a column_view. Example input iterator usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> begin = indexalator_factory::create_input_iterator(gather_map);</div>
<div class="line"><span class="keyword">auto</span> end   = begin + gather_map.size();</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code" href="group__copy__gather.html#ga4702ca8eeac8134c395e9f0868134869">detail::gather</a>( source, begin, end, IGNORE, stream, mr );</div>
</div><!-- fragment --><p>Example output iterator usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result_itr = indexalator_factory::create_output_iterator(indices-&gt;mutable_view());</div>
<div class="line"><a class="code" href="group__column__search.html#ga3afcd339444c399c3a258c3f78b9354c">thrust::lower_bound</a>(<a class="codeRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1exec__policy.html">rmm::exec_policy</a>(stream),</div>
<div class="line">                    input-&gt;begin&lt;Element&gt;(),</div>
<div class="line">                    input-&gt;end&lt;Element&gt;(),</div>
<div class="line">                    values-&gt;begin&lt;Element&gt;(),</div>
<div class="line">                    values-&gt;end&lt;Element&gt;(),</div>
<div class="line">                    result_itr,</div>
<div class="line">                    thrust::less&lt;Element&gt;());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md92"></a>
Namespaces</h2>
<h3><a class="anchor" id="autotoc_md93"></a>
External</h3>
<p>All public libcudf APIs should be placed in the <code>cudf</code> namespace. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacecudf.html">cudf</a>{</div>
<div class="line">   <span class="keywordtype">void</span> public_function(...);</div>
<div class="line">} <span class="comment">// namespace cudf</span></div>
</div><!-- fragment --><p>The top-level <code>cudf</code> namespace is sufficient for most of the public API. However, to logically group a broad set of functions, further namespaces may be used. For example, there are numerous functions that are specific to columns of Strings. These functions reside in the <code><a class="el" href="namespacecudf_1_1strings.html" title="Strings column APIs.">cudf::strings</a>::</code> namespace. Similarly, functionality used exclusively for unit testing is in the <code>cudf::test::</code> namespace.</p>
<h3><a class="anchor" id="autotoc_md94"></a>
Internal</h3>
<p>Many functions are not meant for public use, so place them in either the <code>detail</code> or an <em>anonymous</em> namespace, depending on the situation.</p>
<h4><a class="anchor" id="autotoc_md95"></a>
detail namespace</h4>
<p>Functions or objects that will be used across <em>multiple</em> translation units (i.e., source files), should be exposed in an internal header file and placed in the <code>detail</code> namespace. Example:</p>
<div class="fragment"><div class="line"><span class="comment">// some_utilities.hpp</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacecudf.html">cudf</a>{</div>
<div class="line"><span class="keyword">namespace </span>detail{</div>
<div class="line"><span class="keywordtype">void</span> reusable_helper_function(...);</div>
<div class="line">} <span class="comment">// namespace detail</span></div>
<div class="line">} <span class="comment">// namespace cudf</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md96"></a>
Anonymous namespace</h4>
<p>Functions or objects that will only be used in a <em>single</em> translation unit should be defined in an <em>anonymous</em> namespace in the source file where it is used. Example:</p>
<div class="fragment"><div class="line"><span class="comment">// some_file.cpp</span></div>
<div class="line"><span class="keyword">namespace</span>{</div>
<div class="line"><span class="keywordtype">void</span> isolated_helper_function(...);</div>
<div class="line">} <span class="comment">// anonymous namespace</span></div>
</div><!-- fragment --><p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL59-CPP.+Do+not+define+an+unnamed+namespace+in+a+header+file"><b>Anonymous namespaces should <em>never</em> be used in a header file.</b></a></p>
<h1><a class="anchor" id="autotoc_md97"></a>
Deprecating and Removing Code</h1>
<p>libcudf is constantly evolving to improve performance and better meet our users' needs. As a result, we occasionally need to break or entirely remove APIs to respond to new and improved understanding of the functionality we provide. Remaining free to do this is essential to making libcudf an agile library that can rapidly accommodate our users needs. As a result, we do not always provide a warning or any lead time prior to releasing breaking changes. On a best effort basis, the libcudf team will notify users of changes that we expect to have significant or widespread effects.</p>
<p>Where possible, indicate pending API removals using the <a href="https://en.cppreference.com/w/cpp/language/attributes/deprecated">deprecated</a> attribute and document them using Doxygen's <a href="https://www.doxygen.nl/manual/commands.html#cmddeprecated">deprecated</a> command prior to removal. When a replacement API is available for a deprecated API, mention the replacement in both the deprecation message and the deprecation documentation. Pull requests that introduce deprecations should be labeled "deprecation" to facilitate discovery and removal in the subsequent release.</p>
<p>Advertise breaking changes by labeling any pull request that breaks or removes an existing API with the "breaking" tag. This ensures that the "Breaking" section of the release notes includes a description of what has broken from the past release. Label pull requests that contain deprecations with the "non-breaking" tag.</p>
<h1><a class="anchor" id="errors"></a>
Error Handling</h1>
<p>libcudf follows conventions (and provides utilities) enforcing compile-time and run-time conditions and detecting and handling CUDA errors. Communication of errors is always via C++ exceptions.</p>
<h2><a class="anchor" id="autotoc_md98"></a>
Runtime Conditions</h2>
<p>Use the <code>CUDF_EXPECTS</code> macro to enforce runtime conditions necessary for correct execution.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"><a class="code" href="group__utility__error.html#gadbdd4370b0eb1fc42ca81494b18f2bc6">CUDF_EXPECTS</a>(lhs.type() == rhs.type(), <span class="stringliteral">"Column type mismatch"</span>);</div>
</div><!-- fragment --><p>The first argument is the conditional expression expected to resolve to <code>true</code> under normal conditions. If the conditional evaluates to <code>false</code>, then an error has occurred and an instance of <code><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></code> is thrown. The second argument to <code>CUDF_EXPECTS</code> is a short description of the error that has occurred and is used for the exception's <code>what()</code> message.</p>
<p>There are times where a particular code path, if reached, should indicate an error no matter what. For example, often the <code>default</code> case of a <code>switch</code> statement represents an invalid alternative. Use the <code>CUDF_FAIL</code> macro for such errors. This is effectively the same as calling <code><a class="el" href="group__utility__error.html#gadbdd4370b0eb1fc42ca81494b18f2bc6" title="Macro for checking (pre-)conditions that throws an exception when a condition is violated.">CUDF_EXPECTS(false, reason)</a></code>.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="group__utility__error.html#gaec9dde7c80632a629125cde816c55faf">CUDF_FAIL</a>(<span class="stringliteral">"This code path should not be reached."</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md99"></a>
CUDA Error Checking</h3>
<p>Use the <code>CUDF_CUDA_TRY</code> macro to check for the successful completion of CUDA runtime API functions. This macro throws a <code><a class="el" href="structcudf_1_1cuda__error.html" title="Exception thrown when a CUDA error is encountered.">cudf::cuda_error</a></code> exception if the CUDA API return value is not <code>cudaSuccess</code>. The thrown exception includes a description of the CUDA error code in its <code>what()</code> message.</p>
<p>Example:</p>
<div class="fragment"><div class="line">CUDA_TRY( cudaMemcpy(&amp;dst, &amp;src, num_bytes) );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md100"></a>
Compile-Time Conditions</h2>
<p>Use <code>static_assert</code> to enforce compile-time conditions. For example,</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> trivial_types_only(T t){</div>
<div class="line">  static_assert(std::is_trivial&lt;T&gt;::value, <span class="stringliteral">"This function requires a trivial type."</span>);</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md101"></a>
Data Types</h1>
<p>Columns may contain data of a number of types (see <code>enum class type_id</code> in <code><a class="el" href="types_8hpp.html" title="Type declarations for libcudf.">include/cudf/types.hpp</a></code>)</p>
<ul>
<li>Numeric data: signed and unsigned integers (8-, 16-, 32-, or 64-bit), floats (32- or 64-bit), and Booleans (8-bit).</li>
<li>Timestamp data with resolution of days, seconds, milliseconds, microseconds, or nanoseconds.</li>
<li>Duration data with resolution of days, seconds, milliseconds, microseconds, or nanoseconds.</li>
<li>Decimal fixed-point data (32- or 64-bit).</li>
<li>Strings</li>
<li>Dictionaries</li>
<li>Lists of any type</li>
<li>Structs of columns of any type</li>
</ul>
<p>Most algorithms must support columns of any data type. This leads to complexity in the code, and is one of the primary challenges a libcudf developer faces. Sometimes we develop new algorithms with gradual support for more data types to make this easier. Typically we start with fixed-width data types such as numeric types and timestamps/durations, adding support for nested types later.</p>
<p>Enabling an algorithm differently for different types uses either template specialization or SFINAE, as discussed in <a href="#specializing-type-dispatched-code-paths">Specializing Type-Dispatched Code Paths</a>.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
Type Dispatcher</h1>
<p>libcudf stores data (for columns and scalars) "type erased" in <code>void*</code> device memory. This <em>type-erasure</em> enables interoperability with other languages and type systems, such as Python and Java. In order to determine the type, libcudf algorithms must use the run-time information stored in the column <code>type()</code> to reconstruct the data type <code>T</code> by casting the <code>void*</code> to the appropriate <code>T*</code>.</p>
<p>This so-called <em>type dispatch</em> is pervasive throughout libcudf. The <code>type_dispatcher</code> is a central utility that automates the process of mapping the runtime type information in <code>data_type</code> to a concrete C++ type.</p>
<p>At a high level, you call the <code>type_dispatcher</code> with a <code>data_type</code> and a function object (also known as a <em>functor</em>) with an <code>operator()</code> template. Based on the value of <code>data_type::id()</code>, the type dispatcher invokes the corresponding instantiation of the <code>operator()</code> template.</p>
<p>This simplified example shows how the value of <code>data_type::id()</code> determines which instantiation of the <code>F::operator()</code> template is invoked.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__utility__dispatcher.html#ga61f3520c09e5a9959ba405dd6ba1df9a">type_dispatcher</a>(data_type t, F f){</div>
<div class="line">    <span class="keywordflow">switch</span>(t.id())</div>
<div class="line">       <span class="keywordflow">case</span> type_id::INT32: f.template operator()&lt;int32_t&gt;()</div>
<div class="line">       <span class="keywordflow">case</span> type_id::INT64: f.template <span class="keyword">operator</span>()&lt;int64_t&gt;()</div>
<div class="line">       <span class="keywordflow">case</span> type_id::FLOAT: f.template <span class="keyword">operator</span>()&lt;<span class="keywordtype">float</span>&gt;()</div>
<div class="line">       ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following example shows a function object called <code>size_of_functor</code> that returns the size of the dispatched type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>size_of_functor{</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">int</span> operator()(){ <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(T); }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__utility__dispatcher.html#ga61f3520c09e5a9959ba405dd6ba1df9a">cudf::type_dispatcher</a>(data_type{type_id::INT8}, size_of_functor{});  <span class="comment">// returns 1</span></div>
<div class="line"><a class="code" href="group__utility__dispatcher.html#ga61f3520c09e5a9959ba405dd6ba1df9a">cudf::type_dispatcher</a>(data_type{type_id::INT32}, size_of_functor{});  <span class="comment">// returns 4</span></div>
<div class="line"><a class="code" href="group__utility__dispatcher.html#ga61f3520c09e5a9959ba405dd6ba1df9a">cudf::type_dispatcher</a>(data_type{type_id::FLOAT64}, size_of_functor{});  <span class="comment">// returns 8</span></div>
</div><!-- fragment --><p>By default, <code>type_dispatcher</code> uses <code><a class="el" href="group__utility__dispatcher.html#ga9ba5eea729f54e486b228ab4d4fbb8bc" title="Maps a C++ type to it's corresponding cudf::type_id">cudf::type_to_id</a>&lt;t&gt;</code> to provide the mapping of <code><a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539" title="Identifies a column's logical element type.">cudf::type_id</a></code> to dispatched C++ types. However, this mapping may be customized by explicitly specifying a user-defined trait for the <code>IdTypeMap</code>. For example, to always dispatch <code>int32_t</code> for all values of <code><a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539" title="Identifies a column's logical element type.">cudf::type_id</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;cudf::type_<span class="keywordtype">id</span> t&gt; <span class="keyword">struct </span>always_int{ <span class="keyword">using</span> type = int32_t; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This will always invoke `operator()&lt;int32_t&gt;`</span></div>
<div class="line">cudf::type_dispatcher&lt;always_int&gt;(data_type, f);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
Avoid Multiple Type Dispatch</h2>
<p>Avoid multiple type-dispatch if possible. The compiler creates a code path for every type dispatched, so a second-level type dispatch results in quadratic growth in compilation time and object code size. As a large library with many types and functions, we are constantly working to reduce compilation time and code size.</p>
<h2><a class="anchor" id="autotoc_md104"></a>
Specializing Type-Dispatched Code Paths</h2>
<p>It is often necessary to customize the dispatched <code>operator()</code> for different types. This can be done in several ways.</p>
<p>The first method is to use explicit, full template specialization. This is useful for specializing behavior for single types. The following example function object prints <code>"int32_t"</code> or <code>"double"</code> when invoked with either of those types, or <code>"unhandled type"</code> otherwise.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>type_printer {</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType&gt;</div>
<div class="line"><span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">"unhandled type\n"</span>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Due to a bug in g++, explicit member function specializations need to be</span></div>
<div class="line"><span class="comment">// defined outside of the class definition</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> type_printer::operator()&lt;int32_t&gt;() { std::cout &lt;&lt; <span class="stringliteral">"int32_t\n"</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> type_printer::operator()&lt;<span class="keywordtype">double</span>&gt;() { std::cout &lt;&lt; <span class="stringliteral">"double\n"</span>; }</div>
</div><!-- fragment --><p>The second method is to use <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> with <code>std::enable_if_t</code>. This is useful to partially specialize for a set of types with a common trait. The following example functor prints <code>integral</code> or <code>floating point</code> for integral or floating point types, respectively.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>integral_or_floating_point {</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType,</div>
<div class="line">          std::enable_if_t&lt;not std::is_integral&lt;ColumnType&gt;::value and</div>
<div class="line">                           not std::is_floating_point&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">"neither integral nor floating point\n"</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType,</div>
<div class="line">          std::enable_if_t&lt;std::is_integral&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">"integral\n"</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> ColumnType,</div>
<div class="line">           std::enable_if_t&lt;std::is_floating_point&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">"floating point\n"</span>; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>For more info on SFINAE with <code>std::enable_if</code>, <a href="https://eli.thegreenplace.net/2014/sfinae-and-enable_if">see this post</a>.</p>
<p>There are a number of traits defined in <code><a class="el" href="traits_8hpp.html">include/cudf/utilities/traits.hpp</a></code> that are useful for partial specialization of dispatched function objects. For example <code>is_numeric&lt;T&gt;()</code> can be used to specialize for any numeric type.</p>
<h1><a class="anchor" id="autotoc_md105"></a>
Variable-Size and Nested Data Types</h1>
<p>libcudf supports a number of variable-size and nested data types, including strings, lists, and structs.</p>
<ul>
<li><code>string</code>: Simply a character string, but a column of strings may have a different-length string in each row.</li>
<li><code>list</code>: A list of elements of any type, so a column of lists of integers has rows with a list of integers, possibly of a different length, in each row.</li>
<li><code>struct</code>: In a column of structs, each row is a structure comprising one or more fields. These fields are stored in structure-of-arrays format, so that the column of structs has a nested column for each field of the structure.</li>
</ul>
<p>As the heading implies, list and struct columns may be nested arbitrarily. One may create a column of lists of structs, where the fields of the struct may be of any type, including strings, lists and structs. Thinking about deeply nested data types can be confusing for column-based data, even with experience. Therefore it is important to carefully write algorithms, and to test and document them well.</p>
<h2><a class="anchor" id="autotoc_md106"></a>
List columns</h2>
<p>In order to represent variable-width elements, libcudf columns contain a vector of child columns. For list columns, the parent column's type is <code>LIST</code> and contains no data, but its size represents the number of lists in the column, and its null mask represents the validity of each list element. The parent has two children.</p>
<ol type="1">
<li>A non-nullable column of <code>INT32</code> elements that indicates the offset to the beginning of each list in a dense column of elements.</li>
<li>A column containing the actual data and optional null mask for all elements of all the lists packed together.</li>
</ol>
<p>With this representation, <code>data[offsets[i]]</code> is the first element of list <code>i</code>, and the size of list <code>i</code> is given by <code>offsets[i+1] - offsets[i]</code>.</p>
<p>Note that the data may be of any type, and therefore the data column may itself be a nested column of any type. Note also that not only is each list nullable (using the null mask of the parent), but each list element may be nullable. So you may have a lists column with null row 3, and also null element 2 of row 4.</p>
<p>The underlying data for a lists column is always bundled into a single leaf column at the very bottom of the hierarchy (ignoring structs, which conceptually "reset" the root of the hierarchy), regardless of the level of nesting. So a <code>List&lt;List&lt;List&lt;List&lt;int&gt;&gt;&gt;&gt;</code> column has a single <code>int</code> column at the very bottom. The following is a visual representation of this.</p>
<div class="fragment"><div class="line">lists_column = { {{{1, 2}, {3, 4}}, NULL}, {{{10, 20}, {30, 40}}, {{50, 60, 70}, {0}}} }</div>
<div class="line"> </div>
<div class="line">   List&lt;List&lt;List&lt;int&gt;&gt;&gt;  (2 rows):</div>
<div class="line">   Length : 2</div>
<div class="line">   Offsets : 0, 2, 4</div>
<div class="line">   Children :</div>
<div class="line">      List&lt;List&lt;int&gt;&gt;:</div>
<div class="line">      Length : 4</div>
<div class="line">      Offsets : 0, 2, 2, 4, 6</div>
<div class="line">      Null count: 1</div>
<div class="line">        1101</div>
<div class="line">      Children :</div>
<div class="line">        List&lt;int&gt;:</div>
<div class="line">        Length : 6</div>
<div class="line">        Offsets : 0, 2, 4, 6, 8, 11, 12</div>
<div class="line">        Children :</div>
<div class="line">          Column of ints</div>
<div class="line">          1, 2, 3, 4, 10, 20, 30, 40, 50, 60, 70, 0</div>
</div><!-- fragment --><p>This is related to <a href="https://arrow.apache.org/docs/format/Columnar.html?highlight=nested%20types#physical-memory-layout">Arrow's "Variable-Size List" memory layout</a>.</p>
<h2><a class="anchor" id="autotoc_md107"></a>
Strings columns</h2>
<p>Strings are represented in much the same way as lists, except that the data child column is always a non-nullable column of <code>INT8</code> data. The parent column's type is <code>STRING</code> and contains no data, but its size represents the number of strings in the column, and its null mask represents the validity of each string. To summarize, the strings column children are:</p>
<ol type="1">
<li>A non-nullable column of <code>INT32</code> elements that indicates the offset to the beginning of each string in a dense column of all characters.</li>
<li>A non-nullable column of <code>INT8</code> elements of all the characters across all the strings packed together.</li>
</ol>
<p>With this representation, <code>characters[offsets[i]]</code> is the first character of string <code>i</code>, and the size of string <code>i</code> is given by <code>offsets[i+1] - offsets[i]</code>. The following image shows an example of this compound column representation of strings.</p>
<p><img alt="strings" class="inline" src="strings.png"></p>
<h2><a class="anchor" id="autotoc_md108"></a>
Structs columns</h2>
<p>A struct is a nested data type with a set of child columns each representing an individual field of a logical struct. Field names are not represented.</p>
<p>A structs column with <code>N</code> fields has <code>N</code> children. Each child is a column storing all the data of a single field packed column-wise, with an optional null mask. The parent column's type is <code>STRUCT</code> and contains no data, its size represents the number of struct rows in the column, and its null mask represents the validity of each struct element.</p>
<p>With this representation, <code>child[0][10]</code> is row 10 of the first field of the struct, <code>child[1][42]</code> is row 42 of the second field of the struct.</p>
<p>Notice that in addition to the struct column's null mask, each struct field column has its own optional null mask. A struct field's validity can vary independently from the corresponding struct row. For instance, a non-null struct row might have a null field. However, the fields of a null struct row are deemed to be null as well. For example, consider a struct column of type <code>STRUCT&lt;FLOAT32, INT32&gt;</code>. If the contents are <code>[ {1.0, 2}, {4.0, 5}, null, {8.0, null} ]</code>, the struct column's layout is as follows. (Note that null masks should be read from right to left.)</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type = STRUCT</div>
<div class="line">  null_mask = [1, 1, 0, 1]</div>
<div class="line">  null_count = 1</div>
<div class="line">  children = {</div>
<div class="line">    {</div>
<div class="line">      type = FLOAT32</div>
<div class="line">      data =       [1.0, 4.0, X, 8.0]</div>
<div class="line">      null_mask  = [  1,   1, 0,   1]</div>
<div class="line">      null_count = 1</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      type = INT32</div>
<div class="line">      data =       [2, 5, X, X]</div>
<div class="line">      null_mask  = [1, 1, 0, 0]</div>
<div class="line">      null_count = 2</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The last struct row (index 3) is not null, but has a null value in the INT32 field. Also, row 2 of the struct column is null, making its corresponding fields also null. Therefore, bit 2 is unset in the null masks of both struct fields.</p>
<h2><a class="anchor" id="autotoc_md109"></a>
Dictionary columns</h2>
<p>Dictionaries provide an efficient way to represent low-cardinality data by storing a single copy of each value. A dictionary comprises a column of sorted keys and a column containing an index into the keys column for each row of the parent column. The keys column may have any libcudf data type, such as a numerical type or strings. The indices represent the corresponding positions of each element's value in the keys. The indices child column can have any unsigned integer type (<code>UINT8</code>, <code>UINT16</code>, <code>UINT32</code>, or <code>UINT64</code>).</p>
<h2><a class="anchor" id="autotoc_md110"></a>
Nested column challenges</h2>
<p>The first challenge with nested columns is that it is effectively impossible to do any operation that modifies the length of any string or list in place. For example, consider trying to append the character &lsquo;'a&rsquo;<code>to the end of each string. This requires dynamically resizing the characters column to allow inserting</code>'a'` at the end of each string, and then modifying the offsets column to indicate the new size of each element. As a result, every operation that can modify the strings or lists in a column must be done out-of-place.</p>
<p>The second challenge is that in an out-of-place operation on a strings column, unlike with fixed- width elements, the size of the output cannot be known <em>a priori</em>. For example, consider scattering into a column of strings: </p><pre class="fragment">destination:    {"this", "is", "a", "column", "of", "strings"}
scatter_map:    {1, 3, 5}
scatter_values: {"red", "green", "blue"}

result:         {"this", "red", "a", "green", "of", "blue"}
</pre><p>In this example, the strings "red", "green", and "blue" will respectively be scattered into positions <code>1</code>, <code>3</code>, and <code>5</code> of <code>destination</code>. Recall from above that this operation cannot be done in place, therefore <code>result</code> will be generated by selectively copying strings from <code>destination</code> and <code>scatter_values</code>. Notice that <code>result</code>'s child column of characters requires storage for <code>19</code> characters. However, there is no way to know ahead of time that <code>result</code> will require <code>19</code> characters. Therefore, most operations that produce a new output column of strings use a two-phase approach:</p>
<ol type="1">
<li>Determine the number and size of each string in the result. This amounts to materializing the output offsets column.</li>
<li>Allocate sufficient storage for all of the output characters and materialize each output string.</li>
</ol>
<p>In scatter, the first phase consists of using the <code>scatter_map</code> to determine whether string <code>i</code> in the output will come from <code>destination</code> or from <code>scatter_values</code> and use the corresponding size(s) to materialize the offsets column and determine the size of the output. Then, in the second phase, sufficient storage is allocated for the output's characters, and then the characters are filled with the corresponding strings from either <code>destination</code> or <code>scatter_values</code>.</p>
<h2><a class="anchor" id="autotoc_md111"></a>
Nested Type Views</h2>
<p>libcudf provides view types for nested column types as well as for the data elements within them.</p>
<h3><a class="anchor" id="autotoc_md112"></a>
cudf::strings_column_view and cudf::string_view</h3>
<p><code><a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">cudf::strings_column_view</a></code> is a view of a strings column, like <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">cudf::column_view</a></code> is a view of any <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code>. <code><a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">cudf::string_view</a></code> is a view of a single string, and therefore <code><a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">cudf::string_view</a></code> is the data type of a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> of type <code>STRING</code> just like <code>int32_t</code> is the data type for a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> of type <code>INT32</code>. As it's name implies, this is a read-only object instance that points to device memory inside the strings column. It's lifespan is the same (or less) as the column it views.</p>
<p>Use the <code>column_device_view::element</code> method to access an individual row element. Like any other column, do not call <code>element()</code> on a row that is null.</p>
<div class="fragment"><div class="line"><a class="code" href="classcudf_1_1column__device__view.html">cudf::column_device_view</a> d_strings;</div>
<div class="line">...</div>
<div class="line">if( d_strings.<a class="code" href="classcudf_1_1detail_1_1column__device__view__base.html#aea4f26330357db25fadd3f6784645898">is_valid</a>(row_index) ) {</div>
<div class="line">   string_view d_str = d_strings.<a class="code" href="classcudf_1_1column__device__view.html#a4ed558f8cf0821214bef8479f06b0e00">element</a>&lt;string_view&gt;(row_index);</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>A null string is not the same as an empty string. Use the <code>string_scalar</code> class if you need an instance of a class object to represent a null string.</p>
<p>The <code>string_view</code> contains comparison operators <code>&lt;,&gt;,==,&lt;=,&gt;=</code> that can be used in many cudf functions like <code>sort</code> without string-specific code. The data for a <code>string_view</code> instance is required to be <a href="#utf-8">UTF-8</a> and all operators and methods expect this encoding. Unless documented otherwise, position and length parameters are specified in characters and not bytes. The class also includes a <code>string_view::const_iterator</code> which can be used to navigate through individual characters within the string.</p>
<p><code><a class="el" href="group__utility__dispatcher.html#ga61f3520c09e5a9959ba405dd6ba1df9a" title="Invokes an operator() template with the type instantiation based on the specified cudf::data_type's i...">cudf::type_dispatcher</a></code> dispatches to the <code>string_view</code> data type when invoked on a <code>STRING</code> column.</p>
<h4><a class="anchor" id="autotoc_md113"></a>
UTF-8</h4>
<p>The libcudf strings column only supports UTF-8 encoding for strings data. <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> is a variable-length character encoding wherein each character can be 1-4 bytes. This means the length of a string is not the same as its size in bytes. For this reason, it is recommended to use the <code>string_view</code> class to access these characters for most operations.</p>
<p>The <code><a class="el" href="string__view_8cuh_source.html">string_view.cuh</a></code> header also includes some utility methods for reading and writing (<code>to_char_utf8/from_char_utf8</code>) individual UTF-8 characters to/from byte arrays.</p>
<h3><a class="anchor" id="autotoc_md114"></a>
cudf::lists_column_view and cudf::lists_view</h3>
<p><code><a class="el" href="classcudf_1_1lists__column__view.html" title="Given a column-view of lists type, an instance of this class provides a wrapper on this compound colu...">cudf::lists_column_view</a></code> is a view of a lists column. <code><a class="el" href="classcudf_1_1list__view.html" title="A non-owning, immutable view of device data that represents a list of elements of arbitrary type (inc...">cudf::list_view</a></code> is a view of a single list, and therefore <code><a class="el" href="classcudf_1_1list__view.html" title="A non-owning, immutable view of device data that represents a list of elements of arbitrary type (inc...">cudf::list_view</a></code> is the data type of a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> of type <code>LIST</code>.</p>
<p><code><a class="el" href="group__utility__dispatcher.html#ga61f3520c09e5a9959ba405dd6ba1df9a" title="Invokes an operator() template with the type instantiation based on the specified cudf::data_type's i...">cudf::type_dispatcher</a></code> dispatches to the <code>list_view</code> data type when invoked on a <code>LIST</code> column.</p>
<h3><a class="anchor" id="autotoc_md115"></a>
cudf::structs_column_view and cudf::struct_view</h3>
<p><code><a class="el" href="classcudf_1_1structs__column__view.html" title="Given a column view of struct type, an instance of this class provides a wrapper on this compound col...">cudf::structs_column_view</a></code> is a view of a structs column. <code><a class="el" href="classcudf_1_1struct__view.html" title="A non-owning, immutable view of device data that represents a struct with fields of arbitrary types (...">cudf::struct_view</a></code> is a view of a single struct, and therefore <code><a class="el" href="classcudf_1_1struct__view.html" title="A non-owning, immutable view of device data that represents a struct with fields of arbitrary types (...">cudf::struct_view</a></code> is the data type of a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> of type <code>STRUCT</code>.</p>
<p><code><a class="el" href="group__utility__dispatcher.html#ga61f3520c09e5a9959ba405dd6ba1df9a" title="Invokes an operator() template with the type instantiation based on the specified cudf::data_type's i...">cudf::type_dispatcher</a></code> dispatches to the <code>struct_view</code> data type when invoked on a <code>STRUCT</code> column.</p>
<h1><a class="anchor" id="autotoc_md116"></a>
cuIO: file reading and writing</h1>
<p>cuIO is a component of libcudf that provides GPU-accelerated reading and writing of data file formats commonly used in data analytics, including CSV, Parquet, ORC, Avro, and JSON_Lines.</p>
<p>// TODO: add more detail and move to a separate file. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclasscudf_1_1column_html"><div class="ttname"><a href="classcudf_1_1column.html">cudf::column</a></div><div class="ttdoc">A container of nullable device data as a column of elements.</div><div class="ttdef"><b>Definition:</b> <a href="column_8hpp_source.html#l00048">column.hpp:48</a></div></div>
<div class="ttc" id="aclasscudf_1_1column__device__view_html"><div class="ttname"><a href="classcudf_1_1column__device__view.html">cudf::column_device_view</a></div><div class="ttdoc">An immutable, non-owning view of device data as a column of elements that is trivially copyable and u...</div><div class="ttdef"><b>Definition:</b> <a href="column__device__view_8cuh_source.html#l00353">column_device_view.cuh:353</a></div></div>
<div class="ttc" id="aclasscudf_1_1detail_1_1column__device__view__base_html_aea4f26330357db25fadd3f6784645898"><div class="ttname"><a href="classcudf_1_1detail_1_1column__device__view__base.html#aea4f26330357db25fadd3f6784645898">cudf::detail::column_device_view_base::is_valid</a></div><div class="ttdeci">bool is_valid(size_type element_index) const noexcept</div><div class="ttdoc">Returns whether the specified element holds a valid value (i.e., not null).</div><div class="ttdef"><b>Definition:</b> <a href="column__device__view_8cuh_source.html#l00223">column_device_view.cuh:223</a></div></div>
<div class="ttc" id="aclassrmm_1_1cuda__stream__view_html"><div class="ttname"><a href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html">rmm::cuda_stream_view</a></div></div>
<div class="ttc" id="agroup__utility__error_html_gaec9dde7c80632a629125cde816c55faf"><div class="ttname"><a href="group__utility__error.html#gaec9dde7c80632a629125cde816c55faf">CUDF_FAIL</a></div><div class="ttdeci">#define CUDF_FAIL(...)</div><div class="ttdoc">Indicates that an erroneous code path has been taken.</div><div class="ttdef"><b>Definition:</b> <a href="error_8hpp_source.html#l00162">error.hpp:162</a></div></div>
<div class="ttc" id="aclasscudf_1_1table_html"><div class="ttname"><a href="classcudf_1_1table.html">cudf::table</a></div><div class="ttdoc">A set of cudf::column's of the same size.</div><div class="ttdef"><b>Definition:</b> <a href="table_8hpp_source.html#l00040">table.hpp:40</a></div></div>
<div class="ttc" id="anamespacecudf_html_a025670a619591e80fdf972c36e625005"><div class="ttname"><a href="namespacecudf.html#a025670a619591e80fdf972c36e625005">cudf::nullable</a></div><div class="ttdeci">bool nullable(table_view const &amp;view)</div><div class="ttdoc">Returns True if any of the columns in the table is nullable. (not entire hierarchy)</div><div class="ttdef"><b>Definition:</b> <a href="table__view_8hpp_source.html#l00305">table_view.hpp:305</a></div></div>
<div class="ttc" id="aclassrmm_1_1device__uvector_html"><div class="ttname"><a href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__uvector.html">rmm::device_uvector</a></div></div>
<div class="ttc" id="agroup__copy__gather_html_ga4702ca8eeac8134c395e9f0868134869"><div class="ttname"><a href="group__copy__gather.html#ga4702ca8eeac8134c395e9f0868134869">cudf::gather</a></div><div class="ttdeci">std::unique_ptr&lt; table &gt; gather(table_view const &amp;source_table, column_view const &amp;gather_map, out_of_bounds_policy bounds_policy=out_of_bounds_policy::DONT_CHECK, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Gathers the specified rows (including null values) of a set of columns.</div></div>
<div class="ttc" id="aclassrmm_1_1device__buffer_html"><div class="ttname"><a href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__buffer.html">rmm::device_buffer</a></div></div>
<div class="ttc" id="agroup__utility__dispatcher_html_ga61f3520c09e5a9959ba405dd6ba1df9a"><div class="ttname"><a href="group__utility__dispatcher.html#ga61f3520c09e5a9959ba405dd6ba1df9a">cudf::type_dispatcher</a></div><div class="ttdeci">CUDF_HOST_DEVICE constexpr decltype(auto) __forceinline__ type_dispatcher(cudf::data_type dtype, Functor f, Ts &amp;&amp;... args)</div><div class="ttdoc">Invokes an operator() template with the type instantiation based on the specified cudf::data_type's i...</div><div class="ttdef"><b>Definition:</b> <a href="type__dispatcher_8hpp_source.html#l00440">type_dispatcher.hpp:440</a></div></div>
<div class="ttc" id="atype__lists_8hpp_html_a801e7f5ab035e59f7560ce97cd47ed5f"><div class="ttname"><a href="type__lists_8hpp.html#a801e7f5ab035e59f7560ce97cd47ed5f">cudf::test::FixedWidthTypes</a></div><div class="ttdeci">Concat&lt; NumericTypes, ChronoTypes, FixedPointTypes &gt; FixedWidthTypes</div><div class="ttdoc">Provides a list of all fixed-width element types for use in GTest typed tests.</div><div class="ttdef"><b>Definition:</b> <a href="type__lists_8hpp_source.html#l00301">type_lists.hpp:301</a></div></div>
<div class="ttc" id="agroup__column__copy_html_gab08aeaceb95ca962b4ddb5b4a471da4c"><div class="ttname"><a href="group__column__copy.html#gab08aeaceb95ca962b4ddb5b4a471da4c">cudf::copy_if_else</a></div><div class="ttdeci">std::unique_ptr&lt; column &gt; copy_if_else(column_view const &amp;lhs, column_view const &amp;rhs, column_view const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Returns a new column, where each element is selected from either lhs or rhs based on the value of the...</div></div>
<div class="ttc" id="agroup__utility__dispatcher_html_ga9446c2558fd01c19f5fb5fa33927586f"><div class="ttname"><a href="group__utility__dispatcher.html#ga9446c2558fd01c19f5fb5fa33927586f">cudf::scalar_type_t</a></div><div class="ttdeci">typename type_to_scalar_type_impl&lt; T &gt;::ScalarType scalar_type_t</div><div class="ttdoc">Maps a C++ type to the scalar type required to hold its value.</div><div class="ttdef"><b>Definition:</b> <a href="type__dispatcher_8hpp_source.html#l00332">type_dispatcher.hpp:332</a></div></div>
<div class="ttc" id="anamespacecudf_html"><div class="ttname"><a href="namespacecudf.html">cudf</a></div><div class="ttdoc">cuDF interfaces</div><div class="ttdef"><b>Definition:</b> <a href="aggregation_8hpp_source.html#l00034">aggregation.hpp:34</a></div></div>
<div class="ttc" id="aclassrmm_1_1device__scalar_html"><div class="ttname"><a href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1device__scalar.html">rmm::device_scalar</a></div></div>
<div class="ttc" id="agroup__column__search_html_ga3afcd339444c399c3a258c3f78b9354c"><div class="ttname"><a href="group__column__search.html#ga3afcd339444c399c3a258c3f78b9354c">cudf::lower_bound</a></div><div class="ttdeci">std::unique_ptr&lt; column &gt; lower_bound(table_view const &amp;haystack, table_view const &amp;needles, std::vector&lt; order &gt; const &amp;column_order, std::vector&lt; null_order &gt; const &amp;null_precedence, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Find smallest indices in a sorted table where values should be inserted to maintain order.</div></div>
<div class="ttc" id="anamespacecudf_html_a001ed29e71e759518cae31e52312befa"><div class="ttname"><a href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a></div><div class="ttdeci">rmm::cuda_stream_view const get_default_stream()</div><div class="ttdoc">Get the current default stream.</div></div>
<div class="ttc" id="aclassrmm_1_1cuda__stream__view_html_a17aac270b340f8d9f73ad88c9636954f"><div class="ttname"><a href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1cuda__stream__view.html#a17aac270b340f8d9f73ad88c9636954f">rmm::cuda_stream_view::value</a></div><div class="ttdeci">constexpr cudaStream_t value() const noexcept</div></div>
<div class="ttc" id="aclassrmm_1_1mr_1_1device__memory__resource_html"><div class="ttname"><a href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a></div></div>
<div class="ttc" id="agroup__column__sort_html_ga63ae5bdac795a9829eda093339cf5a6d"><div class="ttname"><a href="group__column__sort.html#ga63ae5bdac795a9829eda093339cf5a6d">cudf::sort</a></div><div class="ttdeci">std::unique_ptr&lt; table &gt; sort(table_view const &amp;input, std::vector&lt; order &gt; const &amp;column_order={}, std::vector&lt; null_order &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Performs a lexicographic sort of the rows of a table.</div></div>
<div class="ttc" id="agroup__utility__error_html_gaeb308ca6145fb2250acd4e7651dec984"><div class="ttname"><a href="group__utility__error.html#gaeb308ca6145fb2250acd4e7651dec984">CUDF_CUDA_TRY</a></div><div class="ttdeci">#define CUDF_CUDA_TRY(call)</div><div class="ttdoc">Error checking macro for CUDA runtime API functions.</div><div class="ttdef"><b>Definition:</b> <a href="error_8hpp_source.html#l00209">error.hpp:209</a></div></div>
<div class="ttc" id="aclassrmm_1_1exec__policy_html"><div class="ttname"><a href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1exec__policy.html">rmm::exec_policy</a></div></div>
<div class="ttc" id="agroup__utility__error_html_gadbdd4370b0eb1fc42ca81494b18f2bc6"><div class="ttname"><a href="group__utility__error.html#gadbdd4370b0eb1fc42ca81494b18f2bc6">CUDF_EXPECTS</a></div><div class="ttdeci">#define CUDF_EXPECTS(...)</div><div class="ttdoc">Macro for checking (pre-)conditions that throws an exception when a condition is violated.</div><div class="ttdef"><b>Definition:</b> <a href="error_8hpp_source.html#l00123">error.hpp:123</a></div></div>
<div class="ttc" id="aclasscudf_1_1column__device__view_html_a4ed558f8cf0821214bef8479f06b0e00"><div class="ttname"><a href="classcudf_1_1column__device__view.html#a4ed558f8cf0821214bef8479f06b0e00">cudf::column_device_view::element</a></div><div class="ttdeci">T element(size_type element_index) const noexcept</div><div class="ttdoc">Returns reference to element at the specified index.</div><div class="ttdef"><b>Definition:</b> <a href="column__device__view_8cuh_source.html#l00429">column_device_view.cuh:429</a></div></div>
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>