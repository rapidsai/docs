<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcudf: Rolling Window</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">stable (23.02)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (23.04)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">stable (23.02)</a><a class="rapids-selector__menu-item" href="/api/libcudf/legacy/namespacecudf.html">legacy (22.12)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> |
<a href="#nested-classes">Classes</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Rolling Window<div class="ingroups"><a class="el" href="group__column__apis.html">Column and Table</a> &raquo; <a class="el" href="group__column__aggregation.html">Aggregation</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:rolling_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rolling_8hpp.html">rolling.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1window__bounds.html">cudf::window_bounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstraction for window boundary sizes.  <a href="structcudf_1_1window__bounds.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6baaee875d5de07b2839df49c8bec5cb"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga6baaee875d5de07b2839df49c8bec5cb"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb">More...</a><br></td></tr>
<tr class="separator:ga6baaee875d5de07b2839df49c8bec5cb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga664a38d6ccbfcfd4b27353af23556b31"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga664a38d6ccbfcfd4b27353af23556b31">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga664a38d6ccbfcfd4b27353af23556b31"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#ga664a38d6ccbfcfd4b27353af23556b31">More...</a><br></td></tr>
<tr class="separator:ga664a38d6ccbfcfd4b27353af23556b31"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga9fab5fd6ba625c6335c6aed8b2fce260"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga9fab5fd6ba625c6335c6aed8b2fce260">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga9fab5fd6ba625c6335c6aed8b2fce260"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#ga9fab5fd6ba625c6335c6aed8b2fce260">More...</a><br></td></tr>
<tr class="separator:ga9fab5fd6ba625c6335c6aed8b2fce260"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3cd9eea88c929c32416e743ee162af5c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga3cd9eea88c929c32416e743ee162af5c">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga3cd9eea88c929c32416e743ee162af5c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#ga3cd9eea88c929c32416e743ee162af5c">More...</a><br></td></tr>
<tr class="separator:ga3cd9eea88c929c32416e743ee162af5c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf4707fe74dc49ba72edd6bc176d41ef2"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gaf4707fe74dc49ba72edd6bc176d41ef2">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gaf4707fe74dc49ba72edd6bc176d41ef2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#gaf4707fe74dc49ba72edd6bc176d41ef2">More...</a><br></td></tr>
<tr class="separator:gaf4707fe74dc49ba72edd6bc176d41ef2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga0427f1cd656e16fbf914f14722cb6511"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga0427f1cd656e16fbf914f14722cb6511">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga0427f1cd656e16fbf914f14722cb6511"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#ga0427f1cd656e16fbf914f14722cb6511">More...</a><br></td></tr>
<tr class="separator:ga0427f1cd656e16fbf914f14722cb6511"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaec2dcb215c454925dd0819bded3c4931"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gaec2dcb215c454925dd0819bded3c4931">cudf::grouped_time_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamp_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;timestamp_order, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gaec2dcb215c454925dd0819bded3c4931"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a grouping-aware, timestamp-based rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#gaec2dcb215c454925dd0819bded3c4931">More...</a><br></td></tr>
<tr class="separator:gaec2dcb215c454925dd0819bded3c4931"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga5133f03c74dec6adc6bff241acc00fbe"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga5133f03c74dec6adc6bff241acc00fbe">cudf::grouped_time_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamp_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;timestamp_order, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window_in_days, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga5133f03c74dec6adc6bff241acc00fbe"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a grouping-aware, timestamp-based rolling window function to the values in a column,.  <a href="group__aggregation__rolling.html#ga5133f03c74dec6adc6bff241acc00fbe">More...</a><br></td></tr>
<tr class="separator:ga5133f03c74dec6adc6bff241acc00fbe"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gacc5049a6216e0c2a6a1a2b2d290b89db"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gacc5049a6216e0c2a6a1a2b2d290b89db">cudf::grouped_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;orderby_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;<a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a>, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;preceding, <a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;following, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gacc5049a6216e0c2a6a1a2b2d290b89db"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a grouping-aware, value range-based rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#gacc5049a6216e0c2a6a1a2b2d290b89db">More...</a><br></td></tr>
<tr class="separator:gacc5049a6216e0c2a6a1a2b2d290b89db"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga55831ecba2d0ee5196b28bbcab2e6965"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga55831ecba2d0ee5196b28bbcab2e6965">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;preceding_window, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, <a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga55831ecba2d0ee5196b28bbcab2e6965"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a variable-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#ga55831ecba2d0ee5196b28bbcab2e6965">More...</a><br></td></tr>
<tr class="separator:ga55831ecba2d0ee5196b28bbcab2e6965"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacc5049a6216e0c2a6a1a2b2d290b89db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc5049a6216e0c2a6a1a2b2d290b89db">◆&nbsp;</a></span>grouped_range_rolling_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_range_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>orderby_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>preceding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>following</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a grouping-aware, value range-based rolling window function to the values in a column. </p>
<p>This function aggregates rows in a window around each element of a specified <code>input</code> column. The window is determined based on the values of an ordered <code>orderby</code> column, and on the values of a <code>preceding</code> and <code>following</code> scalar representing an inclusive range of orderby column values.</p>
<ol type="1">
<li>The elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby), determined by the corresponding values of the columns under <code>group_keys</code>. The window-aggregation cannot cross the group boundaries.</li>
<li>Within a group, with all rows sorted by the <code>orderby</code> column, the aggregation window for a row at index <code>i</code> is determined as follows: a) If <code>orderby</code> is ASCENDING, aggregation window for row <code>i</code> includes all <code>input</code> rows at index <code>j</code> such that: <div class="fragment"><div class="line">(orderby[i] - preceding) &lt;= orderby[j] &lt;= orderby[i] + following</div>
</div><!-- fragment --> b) If <code>orderby</code> is DESCENDING, aggregation window for row <code>i</code> includes all <code>input</code> rows at index <code>j</code> such that: <div class="fragment"><div class="line">(orderby[i] + preceding) &gt;= orderby[j] &gt;= orderby[i] - following</div>
</div><!-- fragment --></li>
</ol>
<p>Note: This method requires that the rows are presorted by the group keys and orderby column values.</p>
<p>The window intervals are specified as scalar values appropriate for the orderby column. Currently, only the following combinations of <code>orderby</code> column type and range types are supported:</p><ol type="1">
<li>If <code>orderby</code> column is a TIMESTAMP, the <code>preceding</code>/<code>following</code> windows are specified in terms of <code>DURATION</code> scalars of the same resolution. E.g. For <code>orderby</code> column of type <code>TIMESTAMP_SECONDS</code>, the intervals may only be <code>DURATION_SECONDS</code>. Durations of higher resolution (e.g. <code>DURATION_NANOSECONDS</code>) or lower (e.g. <code>DURATION_DAYS</code>) cannot be used.</li>
<li>If the <code>orderby</code> column is an integral type (e.g. <code>INT32</code>), the <code>preceding</code>/<code>following</code> should be the exact same type (<code>INT32</code>).</li>
</ol>
<div class="fragment"><div class="line">Example: Consider a motor-racing statistics dataset, containing the following columns:</div>
<div class="line">  1. driver_name:   (STRING) Name of the car driver</div>
<div class="line">  2. num_overtakes: (INT32)  Number of times the driver overtook another car in a lap</div>
<div class="line">  3. lap_number:    (INT32)  The number of the lap</div>
<div class="line"> </div>
<div class="line">The `group_range_rolling_window()` function allows one to calculate the total number of overtakes</div>
<div class="line">each driver made within any 3 lap window of each entry:</div>
<div class="line">  1. Group/partition the dataset by `driver_id` (This is the group_keys argument.)</div>
<div class="line">  2. Sort each group by the `lap_number` (i.e. This is the orderby_column.)</div>
<div class="line">  3. Calculate the SUM(num_overtakes) over a window (preceding=1, following=1)</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // driver_name,  num_overtakes,  lap_number</div>
<div class="line">   {   "bottas",        1,            1        },</div>
<div class="line">   {   "hamilton",      2,            1        },</div>
<div class="line">   {   "bottas",        2,            2        },</div>
<div class="line">   {   "bottas",        1,            3        },</div>
<div class="line">   {   "hamilton",      3,            1        },</div>
<div class="line">   {   "hamilton",      8,            2        },</div>
<div class="line">   {   "bottas",        5,            7        },</div>
<div class="line">   {   "bottas",        6,            8        },</div>
<div class="line">   {   "hamilton",      4,            4        }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `driver_name`, and ordering by `lap_number` yields the following</div>
<div class="line">`num_overtakes` vector (with 2 groups, one for each distinct `driver_name`):</div>
<div class="line"> </div>
<div class="line">lap_number:      [ 1,  2,  3,  7,  8,   1,  1,   2,  4 ]</div>
<div class="line">num_overtakes:   [ 1,  2,  1,  5,  6,   2,  3,   8,  4 ]</div>
<div class="line">                   &lt;-----bottas------&gt;|&lt;----hamilton---&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied, with 1 preceding, and 1 following, with a minimum of 1</div>
<div class="line">period. The aggregation window is thus 3 (laps) wide, yielding the following output column:</div>
<div class="line"> </div>
<div class="line"> Results:        [ 3,  4,  3,  11, 11,  13, 13,  13,  4 ]</div>
</div><!-- fragment --><p>Note: The number of rows participating in each window might vary, based on the index within the group, datestamp, and <code>min_periods</code>. Apropos:</p><ol type="1">
<li>results[0] considers 2 values, because it is at the beginning of its group, and has no preceding values.</li>
<li>results[5] considers 3 values, despite being at the beginning of its group. It must include 2 following values, based on its orderby_column value.</li>
</ol>
<p>Each aggregation operation cannot cross group boundaries.</p>
<p>The type of the returned column depends on the input column type <code>T</code>, and the aggregation:</p><ol type="1">
<li>COUNT returns <code>INT32</code> columns</li>
<li>MIN/MAX returns <code>T</code> columns</li>
<li>SUM returns the promoted type for T. Sum on <code>INT32</code> yields <code>INT64</code>.</li>
<li>MEAN returns FLOAT64 columns</li>
<li>COLLECT returns columns of type <code>LIST&lt;T&gt;</code>.</li>
</ol>
<p>LEAD/LAG/ROW_NUMBER are undefined for range queries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderby_column</td><td>The (pre-sorted) order-by column, for range comparisons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order (ASCENDING/DESCENDING) in which the order-by column is sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding</td><td>The interval value in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following</td><td>The interval value in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="gaf4707fe74dc49ba72edd6bc176d41ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4707fe74dc49ba72edd6bc176d41ef2">◆&nbsp;</a></span>grouped_rolling_window() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>default_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ "user_id", sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   20      },</div>
<div class="line">   { "user1",   20      },</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   30      },</div>
<div class="line">   { "user2",   80      },</div>
<div class="line">   { "user1",   50      },</div>
<div class="line">   { "user1",   60      },</div>
<div class="line">   { "user2",   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">default_outputs</td><td>A column of per-row default values to be returned instead of nulls. Used for LEAD()/LAG(), if the row offset crosses the boundaries of the column or group. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga0427f1cd656e16fbf914f14722cb6511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0427f1cd656e16fbf914f14722cb6511">◆&nbsp;</a></span>grouped_rolling_window() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>default_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&nbsp;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&nbsp;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ "user_id", sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   20      },</div>
<div class="line">   { "user1",   20      },</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   30      },</div>
<div class="line">   { "user2",   80      },</div>
<div class="line">   { "user1",   50      },</div>
<div class="line">   { "user1",   60      },</div>
<div class="line">   { "user2",   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">default_outputs</td><td>A column of per-row default values to be returned instead of nulls. Used for LEAD()/LAG(), if the row offset crosses the boundaries of the column or group. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fab5fd6ba625c6335c6aed8b2fce260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fab5fd6ba625c6335c6aed8b2fce260">◆&nbsp;</a></span>grouped_rolling_window() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ "user_id", sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   20      },</div>
<div class="line">   { "user1",   20      },</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   30      },</div>
<div class="line">   { "user2",   80      },</div>
<div class="line">   { "user1",   50      },</div>
<div class="line">   { "user1",   60      },</div>
<div class="line">   { "user2",   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="ga3cd9eea88c929c32416e743ee162af5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd9eea88c929c32416e743ee162af5c">◆&nbsp;</a></span>grouped_rolling_window() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&nbsp;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&nbsp;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ "user_id", sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   20      },</div>
<div class="line">   { "user1",   20      },</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   30      },</div>
<div class="line">   { "user2",   80      },</div>
<div class="line">   { "user1",   50      },</div>
<div class="line">   { "user1",   60      },</div>
<div class="line">   { "user2",   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="gaec2dcb215c454925dd0819bded3c4931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec2dcb215c454925dd0819bded3c4931">◆&nbsp;</a></span>grouped_time_range_rolling_window() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_time_range_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>timestamp_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>timestamp_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>preceding_window_in_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>following_window_in_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a grouping-aware, timestamp-based rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in two respects:</p><ol type="1">
<li>The elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby), determined by the corresponding values of the columns under <code>group_keys</code>. The window-aggregation cannot cross the group boundaries.</li>
<li>Within a group, the aggregation window is calculated based on a time interval (e.g. number of days preceding/following the current row). The timestamps for the input data are specified by the <code>timestamp_column</code> argument.</li>
</ol>
<p>Note: This method requires that the rows are presorted by the group keys and timestamp values.</p>
<div class="fragment"><div class="line">  Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">   { "user_id", sales_amt, date }</div>
<div class="line"> </div>
<div class="line">  This method enables windowing queries such as grouping a dataset by `user_id`, sorting by</div>
<div class="line">  increasing `date`, and summing up the `sales_amt` column over a window of 3 days (1 preceding</div>
<div class="line">*day, the current day, and 1 following day).</div>
<div class="line"> </div>
<div class="line">  In this example,</div>
<div class="line">     1. `group_keys == [ user_id ]`</div>
<div class="line">     2. `timestamp_column == date`</div>
<div class="line">     3. `input == sales_amt`</div>
<div class="line">  The data are grouped by `user_id`, and ordered by `date`. The aggregation</div>
<div class="line">  (SUM) is then calculated for a window of 3 days around (and including) each row.</div>
<div class="line"> </div>
<div class="line">  For the following input:</div>
<div class="line"> </div>
<div class="line">   [ // user,  sales_amt,  YYYYMMDD (date)</div>
<div class="line">     { "user1",   10,      20200101    },</div>
<div class="line">     { "user2",   20,      20200101    },</div>
<div class="line">     { "user1",   20,      20200102    },</div>
<div class="line">     { "user1",   10,      20200103    },</div>
<div class="line">     { "user2",   30,      20200101    },</div>
<div class="line">     { "user2",   80,      20200102    },</div>
<div class="line">     { "user1",   50,      20200107    },</div>
<div class="line">     { "user1",   60,      20200107    },</div>
<div class="line">     { "user2",   40,      20200104    }</div>
<div class="line">   ]</div>
<div class="line"> </div>
<div class="line">  Partitioning (grouping) by `user_id`, and ordering by `date` yields the following `sales_amt`</div>
<div class="line">  vector (with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">  Date :(202001-)  [ 01,  02,  03,  07,  07,    01,   01,   02,  04 ]</div>
<div class="line">  Input:           [ 10,  20,  10,  50,  60,    20,   30,   80,  40 ]</div>
<div class="line">                     &lt;-------user1--------&gt;|&lt;---------user2---------&gt;</div>
<div class="line"> </div>
<div class="line">  The SUM aggregation is applied, with 1 day preceding, and 1 day following, with a minimum of 1</div>
<div class="line">  period. The aggregation window is thus 3 *days* wide, yielding the following output column:</div>
<div class="line"> </div>
<div class="line">   Results:        [ 30,  40,  30,  110, 110,  130,  130,  130,  40 ]</div>
</div><!-- fragment --><p>Note: The number of rows participating in each window might vary, based on the index within the group, datestamp, and <code>min_periods</code>. Apropos:</p><ol type="1">
<li>results[0] considers 2 values, because it is at the beginning of its group, and has no preceding values.</li>
<li>results[5] considers 3 values, despite being at the beginning of its group. It must include 2 following values, based on its datestamp.</li>
</ol>
<p>Each aggregation operation cannot cross group boundaries.</p>
<p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_column</td><td>The (pre-sorted) timestamps for each row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_order</td><td>The order (ASCENDING/DESCENDING) in which the timestamps are sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window_in_days</td><td>The rolling window time-interval in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window_in_days</td><td>The rolling window time-interval in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="ga5133f03c74dec6adc6bff241acc00fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5133f03c74dec6adc6bff241acc00fbe">◆&nbsp;</a></span>grouped_time_range_rolling_window() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_time_range_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>timestamp_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>timestamp_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&nbsp;</td>
          <td class="paramname"><em>preceding_window_in_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&nbsp;</td>
          <td class="paramname"><em>following_window_in_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a grouping-aware, timestamp-based rolling window function to the values in a column,. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga6baaee875d5de07b2839df49c8bec5cb" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in two respects:</p><ol type="1">
<li>The elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby), determined by the corresponding values of the columns under <code>group_keys</code>. The window-aggregation cannot cross the group boundaries.</li>
<li>Within a group, the aggregation window is calculated based on a time interval (e.g. number of days preceding/following the current row). The timestamps for the input data are specified by the <code>timestamp_column</code> argument.</li>
</ol>
<p>Note: This method requires that the rows are presorted by the group keys and timestamp values.</p>
<div class="fragment"><div class="line">  Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">   { "user_id", sales_amt, date }</div>
<div class="line"> </div>
<div class="line">  This method enables windowing queries such as grouping a dataset by `user_id`, sorting by</div>
<div class="line">  increasing `date`, and summing up the `sales_amt` column over a window of 3 days (1 preceding</div>
<div class="line">*day, the current day, and 1 following day).</div>
<div class="line"> </div>
<div class="line">  In this example,</div>
<div class="line">     1. `group_keys == [ user_id ]`</div>
<div class="line">     2. `timestamp_column == date`</div>
<div class="line">     3. `input == sales_amt`</div>
<div class="line">  The data are grouped by `user_id`, and ordered by `date`. The aggregation</div>
<div class="line">  (SUM) is then calculated for a window of 3 days around (and including) each row.</div>
<div class="line"> </div>
<div class="line">  For the following input:</div>
<div class="line"> </div>
<div class="line">   [ // user,  sales_amt,  YYYYMMDD (date)</div>
<div class="line">     { "user1",   10,      20200101    },</div>
<div class="line">     { "user2",   20,      20200101    },</div>
<div class="line">     { "user1",   20,      20200102    },</div>
<div class="line">     { "user1",   10,      20200103    },</div>
<div class="line">     { "user2",   30,      20200101    },</div>
<div class="line">     { "user2",   80,      20200102    },</div>
<div class="line">     { "user1",   50,      20200107    },</div>
<div class="line">     { "user1",   60,      20200107    },</div>
<div class="line">     { "user2",   40,      20200104    }</div>
<div class="line">   ]</div>
<div class="line"> </div>
<div class="line">  Partitioning (grouping) by `user_id`, and ordering by `date` yields the following `sales_amt`</div>
<div class="line">  vector (with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">  Date :(202001-)  [ 01,  02,  03,  07,  07,    01,   01,   02,  04 ]</div>
<div class="line">  Input:           [ 10,  20,  10,  50,  60,    20,   30,   80,  40 ]</div>
<div class="line">                     &lt;-------user1--------&gt;|&lt;---------user2---------&gt;</div>
<div class="line"> </div>
<div class="line">  The SUM aggregation is applied, with 1 day preceding, and 1 day following, with a minimum of 1</div>
<div class="line">  period. The aggregation window is thus 3 *days* wide, yielding the following output column:</div>
<div class="line"> </div>
<div class="line">   Results:        [ 30,  40,  30,  110, 110,  130,  130,  130,  40 ]</div>
</div><!-- fragment --><p>Note: The number of rows participating in each window might vary, based on the index within the group, datestamp, and <code>min_periods</code>. Apropos:</p><ol type="1">
<li>results[0] considers 2 values, because it is at the beginning of its group, and has no preceding values.</li>
<li>results[5] considers 3 values, despite being at the beginning of its group. It must include 2 following values, based on its datestamp.</li>
</ol>
<p>Each aggregation operation cannot cross group boundaries.</p>
<p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_column</td><td>The (pre-sorted) timestamps for each row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_order</td><td>The order (ASCENDING/DESCENDING) in which the timestamps are sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window_in_days</td><td>The rolling window time-interval in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window_in_days</td><td>The rolling window time-interval in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results</dd></dl>
<p>The <code>preceding_window_in_days</code> and <code>following_window_in_days</code> are specified as a <code><a class="el" href="structcudf_1_1window__bounds.html" title="Abstraction for window boundary sizes.">window_bounds</a></code> and supports "unbounded" windows, if set to <code><a class="el" href="structcudf_1_1window__bounds.html#a2e188fd2bd683e913dd86f082ee1ffa0" title="Construct unbounded window boundary.">window_bounds::unbounded()</a></code>. </p>

</div>
</div>
<a id="ga664a38d6ccbfcfd4b27353af23556b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga664a38d6ccbfcfd4b27353af23556b31">◆&nbsp;</a></span>rolling_window() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>default_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a fixed-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is static (the same for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window</code>. Element <code>i</code> uses elements <code>[i-preceding_window+1, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>Notes on return column types:</p><ul>
<li>The returned column for count aggregation always has <code>INT32</code> type.</li>
<li>The returned column for VARIANCE/STD aggregations always has <code>FLOAT64</code> type.</li>
<li>All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agg</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">default_outputs</td><td>A column of per-row default values to be returned instead of nulls. Used for LEAD()/LAG(), if the row offset crosses the boundaries of the column. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga55831ecba2d0ee5196b28bbcab2e6965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55831ecba2d0ee5196b28bbcab2e6965">◆&nbsp;</a></span>rolling_window() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a variable-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is dynamic (varying for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window</code>. Element <code>i</code> uses elements <code>[i-preceding_window+1, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
<li>support for dynamic rolling windows, i.e. window size can be specified for each element using an additional array.</li>
</ul>
<p>The returned column for count aggregation always has INT32 type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if window column type is not INT32</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>A non-nullable column of INT32 window sizes in the forward direction. <code>preceding_window[i]</code> specifies preceding window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>A non-nullable column of INT32 window sizes in the backward direction. <code>following_window[i]</code> specifies following window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agg</td><td>The rolling window aggregation type (sum, max, min, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="ga6baaee875d5de07b2839df49c8bec5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6baaee875d5de07b2839df49c8bec5cb">◆&nbsp;</a></span>rolling_window() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/23.02/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Applies a fixed-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is static (the same for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window</code>. Element <code>i</code> uses elements <code>[i-preceding_window+1, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>Notes on return column types:</p><ul>
<li>The returned column for count aggregation always has <code>INT32</code> type.</li>
<li>The returned column for VARIANCE/STD aggregations always has <code>FLOAT64</code> type.</li>
<li>All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agg</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>