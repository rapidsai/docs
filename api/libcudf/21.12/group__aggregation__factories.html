<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcudf: Aggregation Factories</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="rapids.css" rel="stylesheet" type="text/css">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (21.12)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (22.04)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (22.02)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/legacy/namespacecudf.html">legacy (21.12)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> |
<a href="#nested-classes">Classes</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Aggregation Factories<div class="ingroups"><a class="el" href="group__column__apis.html">Column and Table</a> &raquo; <a class="el" href="group__column__aggregation.html">Aggregation</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:aggregation_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8hpp.html">aggregation.hpp</a></td></tr>
<tr class="memdesc:aggregation_8hpp"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representation for specifying desired aggregations from aggregation-based APIs, e.g., groupby, reductions, rolling, etc. <br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1aggregation.html">cudf::aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for specifying the desired aggregation in an <code>aggregation_request</code>.  <a href="classcudf_1_1aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1rolling__aggregation.html">cudf::rolling_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for rolling_window specific aggregation usage.  <a href="classcudf_1_1rolling__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1groupby__aggregation.html">cudf::groupby_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for groupby specific aggregation usage.  <a href="classcudf_1_1groupby__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1groupby__scan__aggregation.html">cudf::groupby_scan_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for groupby specific scan usage.  <a href="classcudf_1_1groupby__scan__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad2e43a487f20c968b2474a5cb980527e"><td align="right" class="memItemLeft" valign="top"><a id="gad2e43a487f20c968b2474a5cb980527e"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>udf_type</b> : bool { <b>CUDA</b>, 
<b>PTX</b>
 }</td></tr>
<tr class="separator:gad2e43a487f20c968b2474a5cb980527e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga1dc83597d5b1e9cf752fc20fcdd77d40"><td align="right" class="memItemLeft" valign="top"><a id="ga1dc83597d5b1e9cf752fc20fcdd77d40"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>correlation_type</b> : int32_t { <b>PEARSON</b>, 
<b>KENDALL</b>, 
<b>SPEARMAN</b>
 }</td></tr>
<tr class="separator:ga1dc83597d5b1e9cf752fc20fcdd77d40"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaac155324eba255d69d0d9888008d407"><td class="memTemplParams" colspan="2"><a id="gaaac155324eba255d69d0d9888008d407"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaaac155324eba255d69d0d9888008d407"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaaac155324eba255d69d0d9888008d407">cudf::make_sum_aggregation</a> ()</td></tr>
<tr class="memdesc:gaaac155324eba255d69d0d9888008d407"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a SUM aggregation. <br></td></tr>
<tr class="separator:gaaac155324eba255d69d0d9888008d407"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gac2e8435b8778492ebc67779dfa294506"><td class="memTemplParams" colspan="2"><a id="gac2e8435b8778492ebc67779dfa294506"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gac2e8435b8778492ebc67779dfa294506"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gac2e8435b8778492ebc67779dfa294506">cudf::make_product_aggregation</a> ()</td></tr>
<tr class="memdesc:gac2e8435b8778492ebc67779dfa294506"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a PRODUCT aggregation. <br></td></tr>
<tr class="separator:gac2e8435b8778492ebc67779dfa294506"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gabe538c8907ab48981e1e9602993db74c"><td class="memTemplParams" colspan="2"><a id="gabe538c8907ab48981e1e9602993db74c"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gabe538c8907ab48981e1e9602993db74c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gabe538c8907ab48981e1e9602993db74c">cudf::make_min_aggregation</a> ()</td></tr>
<tr class="memdesc:gabe538c8907ab48981e1e9602993db74c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MIN aggregation. <br></td></tr>
<tr class="separator:gabe538c8907ab48981e1e9602993db74c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga5d2b6d7b0c5261dfc4e797f904bb5dd7"><td class="memTemplParams" colspan="2"><a id="ga5d2b6d7b0c5261dfc4e797f904bb5dd7"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga5d2b6d7b0c5261dfc4e797f904bb5dd7"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga5d2b6d7b0c5261dfc4e797f904bb5dd7">cudf::make_max_aggregation</a> ()</td></tr>
<tr class="memdesc:ga5d2b6d7b0c5261dfc4e797f904bb5dd7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MAX aggregation. <br></td></tr>
<tr class="separator:ga5d2b6d7b0c5261dfc4e797f904bb5dd7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga7e70bc7722fe1626802cf8441fbf9fa5"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga7e70bc7722fe1626802cf8441fbf9fa5"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga7e70bc7722fe1626802cf8441fbf9fa5">cudf::make_count_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=null_policy::EXCLUDE)</td></tr>
<tr class="memdesc:ga7e70bc7722fe1626802cf8441fbf9fa5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a COUNT aggregation.  <a href="group__aggregation__factories.html#ga7e70bc7722fe1626802cf8441fbf9fa5">More...</a><br></td></tr>
<tr class="separator:ga7e70bc7722fe1626802cf8441fbf9fa5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga55cfff4e36496925b0eaa46c0fae9fae"><td class="memTemplParams" colspan="2"><a id="ga55cfff4e36496925b0eaa46c0fae9fae"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga55cfff4e36496925b0eaa46c0fae9fae"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga55cfff4e36496925b0eaa46c0fae9fae">cudf::make_any_aggregation</a> ()</td></tr>
<tr class="memdesc:ga55cfff4e36496925b0eaa46c0fae9fae"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create an ANY aggregation. <br></td></tr>
<tr class="separator:ga55cfff4e36496925b0eaa46c0fae9fae"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gab05157b9f041bfc674dd11c719d628a2"><td class="memTemplParams" colspan="2"><a id="gab05157b9f041bfc674dd11c719d628a2"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gab05157b9f041bfc674dd11c719d628a2"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gab05157b9f041bfc674dd11c719d628a2">cudf::make_all_aggregation</a> ()</td></tr>
<tr class="memdesc:gab05157b9f041bfc674dd11c719d628a2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a ALL aggregation. <br></td></tr>
<tr class="separator:gab05157b9f041bfc674dd11c719d628a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gabd9ccbdfe6ffcb13401bf2357e711119"><td class="memTemplParams" colspan="2"><a id="gabd9ccbdfe6ffcb13401bf2357e711119"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gabd9ccbdfe6ffcb13401bf2357e711119"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gabd9ccbdfe6ffcb13401bf2357e711119">cudf::make_sum_of_squares_aggregation</a> ()</td></tr>
<tr class="memdesc:gabd9ccbdfe6ffcb13401bf2357e711119"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a SUM_OF_SQUARES aggregation. <br></td></tr>
<tr class="separator:gabd9ccbdfe6ffcb13401bf2357e711119"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gafc5553cfc6e762346951a049d0664a8c"><td class="memTemplParams" colspan="2"><a id="gafc5553cfc6e762346951a049d0664a8c"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gafc5553cfc6e762346951a049d0664a8c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gafc5553cfc6e762346951a049d0664a8c">cudf::make_mean_aggregation</a> ()</td></tr>
<tr class="memdesc:gafc5553cfc6e762346951a049d0664a8c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MEAN aggregation. <br></td></tr>
<tr class="separator:gafc5553cfc6e762346951a049d0664a8c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gab600cbeb5a9fe9f6d2a7c6b5a769308a"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gab600cbeb5a9fe9f6d2a7c6b5a769308a"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gab600cbeb5a9fe9f6d2a7c6b5a769308a">cudf::make_m2_aggregation</a> ()</td></tr>
<tr class="memdesc:gab600cbeb5a9fe9f6d2a7c6b5a769308a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a M2 aggregation.  <a href="group__aggregation__factories.html#gab600cbeb5a9fe9f6d2a7c6b5a769308a">More...</a><br></td></tr>
<tr class="separator:gab600cbeb5a9fe9f6d2a7c6b5a769308a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga4f3a4efc7e531724b51b4ed2f11367d1"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga4f3a4efc7e531724b51b4ed2f11367d1"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga4f3a4efc7e531724b51b4ed2f11367d1">cudf::make_variance_aggregation</a> (size_type ddof=1)</td></tr>
<tr class="memdesc:ga4f3a4efc7e531724b51b4ed2f11367d1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a VARIANCE aggregation.  <a href="group__aggregation__factories.html#ga4f3a4efc7e531724b51b4ed2f11367d1">More...</a><br></td></tr>
<tr class="separator:ga4f3a4efc7e531724b51b4ed2f11367d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3d0f22ac076169ad064357f3a62ee40c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga3d0f22ac076169ad064357f3a62ee40c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3d0f22ac076169ad064357f3a62ee40c">cudf::make_std_aggregation</a> (size_type ddof=1)</td></tr>
<tr class="memdesc:ga3d0f22ac076169ad064357f3a62ee40c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a STD aggregation.  <a href="group__aggregation__factories.html#ga3d0f22ac076169ad064357f3a62ee40c">More...</a><br></td></tr>
<tr class="separator:ga3d0f22ac076169ad064357f3a62ee40c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga1a1568d94242ece1768494349930e367"><td class="memTemplParams" colspan="2"><a id="ga1a1568d94242ece1768494349930e367"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga1a1568d94242ece1768494349930e367"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga1a1568d94242ece1768494349930e367">cudf::make_median_aggregation</a> ()</td></tr>
<tr class="memdesc:ga1a1568d94242ece1768494349930e367"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MEDIAN aggregation. <br></td></tr>
<tr class="separator:ga1a1568d94242ece1768494349930e367"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf27931287bb704b589369ea856f24f97"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaf27931287bb704b589369ea856f24f97"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaf27931287bb704b589369ea856f24f97">cudf::make_quantile_aggregation</a> (std::vector&lt; double &gt; const &amp;<a class="el" href="group__column__quantiles.html#ga3da34be52bf8791d27731bd9c330be11">quantiles</a>, <a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a> interp=interpolation::LINEAR)</td></tr>
<tr class="memdesc:gaf27931287bb704b589369ea856f24f97"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a QUANTILE aggregation.  <a href="group__aggregation__factories.html#gaf27931287bb704b589369ea856f24f97">More...</a><br></td></tr>
<tr class="separator:gaf27931287bb704b589369ea856f24f97"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaa0a7a442ff8e3f87e5b7dea812bf0b2f"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaa0a7a442ff8e3f87e5b7dea812bf0b2f"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaa0a7a442ff8e3f87e5b7dea812bf0b2f">cudf::make_argmax_aggregation</a> ()</td></tr>
<tr class="memdesc:gaa0a7a442ff8e3f87e5b7dea812bf0b2f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create an <code>argmax</code> aggregation.  <a href="group__aggregation__factories.html#gaa0a7a442ff8e3f87e5b7dea812bf0b2f">More...</a><br></td></tr>
<tr class="separator:gaa0a7a442ff8e3f87e5b7dea812bf0b2f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaefdbbe152b032284220429403a41875c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaefdbbe152b032284220429403a41875c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaefdbbe152b032284220429403a41875c">cudf::make_argmin_aggregation</a> ()</td></tr>
<tr class="memdesc:gaefdbbe152b032284220429403a41875c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create an <code>argmin</code> aggregation.  <a href="group__aggregation__factories.html#gaefdbbe152b032284220429403a41875c">More...</a><br></td></tr>
<tr class="separator:gaefdbbe152b032284220429403a41875c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga575d3a90787d6af802850a1573025282"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga575d3a90787d6af802850a1573025282"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga575d3a90787d6af802850a1573025282">cudf::make_nunique_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=null_policy::EXCLUDE)</td></tr>
<tr class="memdesc:ga575d3a90787d6af802850a1573025282"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a <code>nunique</code> aggregation.  <a href="group__aggregation__factories.html#ga575d3a90787d6af802850a1573025282">More...</a><br></td></tr>
<tr class="separator:ga575d3a90787d6af802850a1573025282"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gacbd7e79be437c234f47ad8b623741703"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gacbd7e79be437c234f47ad8b623741703"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gacbd7e79be437c234f47ad8b623741703">cudf::make_nth_element_aggregation</a> (size_type n, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a>)</td></tr>
<tr class="memdesc:gacbd7e79be437c234f47ad8b623741703"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a <code>nth_element</code> aggregation.  <a href="group__aggregation__factories.html#gacbd7e79be437c234f47ad8b623741703">More...</a><br></td></tr>
<tr class="separator:gacbd7e79be437c234f47ad8b623741703"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga6e3aaa3f354d1774753c5870ae40b92f"><td class="memTemplParams" colspan="2"><a id="ga6e3aaa3f354d1774753c5870ae40b92f"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga6e3aaa3f354d1774753c5870ae40b92f"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga6e3aaa3f354d1774753c5870ae40b92f">cudf::make_row_number_aggregation</a> ()</td></tr>
<tr class="memdesc:ga6e3aaa3f354d1774753c5870ae40b92f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a ROW_NUMBER aggregation. <br></td></tr>
<tr class="separator:ga6e3aaa3f354d1774753c5870ae40b92f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gadfb305a70d1c71fc300c801e0a2b60ff"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gadfb305a70d1c71fc300c801e0a2b60ff"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gadfb305a70d1c71fc300c801e0a2b60ff">cudf::make_rank_aggregation</a> ()</td></tr>
<tr class="memdesc:gadfb305a70d1c71fc300c801e0a2b60ff"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a RANK aggregation.  <a href="group__aggregation__factories.html#gadfb305a70d1c71fc300c801e0a2b60ff">More...</a><br></td></tr>
<tr class="separator:gadfb305a70d1c71fc300c801e0a2b60ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf0158607150632061d226eadb387b9bd"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaf0158607150632061d226eadb387b9bd"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaf0158607150632061d226eadb387b9bd">cudf::make_dense_rank_aggregation</a> ()</td></tr>
<tr class="memdesc:gaf0158607150632061d226eadb387b9bd"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a DENSE_RANK aggregation.  <a href="group__aggregation__factories.html#gaf0158607150632061d226eadb387b9bd">More...</a><br></td></tr>
<tr class="separator:gaf0158607150632061d226eadb387b9bd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga97444ec376ca739cd16256f2fcc90b07"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga97444ec376ca739cd16256f2fcc90b07"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga97444ec376ca739cd16256f2fcc90b07">cudf::make_collect_list_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a>)</td></tr>
<tr class="memdesc:ga97444ec376ca739cd16256f2fcc90b07"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a COLLECT_LIST aggregation.  <a href="group__aggregation__factories.html#ga97444ec376ca739cd16256f2fcc90b07">More...</a><br></td></tr>
<tr class="separator:ga97444ec376ca739cd16256f2fcc90b07"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gae02625d427793418d9d1a854c81265d2"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gae02625d427793418d9d1a854c81265d2"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gae02625d427793418d9d1a854c81265d2">cudf::make_collect_set_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a>, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=null_equality::EQUAL, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::UNEQUAL</a>)</td></tr>
<tr class="memdesc:gae02625d427793418d9d1a854c81265d2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a COLLECT_SET aggregation.  <a href="group__aggregation__factories.html#gae02625d427793418d9d1a854c81265d2">More...</a><br></td></tr>
<tr class="separator:gae02625d427793418d9d1a854c81265d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga27d18f71d8ac70c0fce6e1dbccdffdc4"><td class="memTemplParams" colspan="2"><a id="ga27d18f71d8ac70c0fce6e1dbccdffdc4"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga27d18f71d8ac70c0fce6e1dbccdffdc4"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga27d18f71d8ac70c0fce6e1dbccdffdc4">cudf::make_lag_aggregation</a> (size_type offset)</td></tr>
<tr class="memdesc:ga27d18f71d8ac70c0fce6e1dbccdffdc4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a LAG aggregation. <br></td></tr>
<tr class="separator:ga27d18f71d8ac70c0fce6e1dbccdffdc4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga556fa221c5ba2a73e87b7a17ad23da2c"><td class="memTemplParams" colspan="2"><a id="ga556fa221c5ba2a73e87b7a17ad23da2c"></a>
template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga556fa221c5ba2a73e87b7a17ad23da2c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga556fa221c5ba2a73e87b7a17ad23da2c">cudf::make_lead_aggregation</a> (size_type offset)</td></tr>
<tr class="memdesc:ga556fa221c5ba2a73e87b7a17ad23da2c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a LEAD aggregation. <br></td></tr>
<tr class="separator:ga556fa221c5ba2a73e87b7a17ad23da2c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga6cdfbd69c4ab83b73f1930d1ec1060b9"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga6cdfbd69c4ab83b73f1930d1ec1060b9"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga6cdfbd69c4ab83b73f1930d1ec1060b9">cudf::make_udf_aggregation</a> (udf_type type, std::string const &amp;user_defined_aggregator, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type)</td></tr>
<tr class="memdesc:ga6cdfbd69c4ab83b73f1930d1ec1060b9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create an aggregation base on UDF for PTX or CUDA.  <a href="group__aggregation__factories.html#ga6cdfbd69c4ab83b73f1930d1ec1060b9">More...</a><br></td></tr>
<tr class="separator:ga6cdfbd69c4ab83b73f1930d1ec1060b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaebc1969a9d59183e804545cfc342e763"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaebc1969a9d59183e804545cfc342e763"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaebc1969a9d59183e804545cfc342e763">cudf::make_merge_lists_aggregation</a> ()</td></tr>
<tr class="memdesc:gaebc1969a9d59183e804545cfc342e763"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MERGE_LISTS aggregation.  <a href="group__aggregation__factories.html#gaebc1969a9d59183e804545cfc342e763">More...</a><br></td></tr>
<tr class="separator:gaebc1969a9d59183e804545cfc342e763"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf05edd87facfdb3c0300892e9ba2a215"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaf05edd87facfdb3c0300892e9ba2a215"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaf05edd87facfdb3c0300892e9ba2a215">cudf::make_merge_sets_aggregation</a> (<a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=null_equality::EQUAL, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::UNEQUAL</a>)</td></tr>
<tr class="memdesc:gaf05edd87facfdb3c0300892e9ba2a215"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MERGE_SETS aggregation.  <a href="group__aggregation__factories.html#gaf05edd87facfdb3c0300892e9ba2a215">More...</a><br></td></tr>
<tr class="separator:gaf05edd87facfdb3c0300892e9ba2a215"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gabcf59a102adff7e4ef0144fa9949388d"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gabcf59a102adff7e4ef0144fa9949388d"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gabcf59a102adff7e4ef0144fa9949388d">cudf::make_merge_m2_aggregation</a> ()</td></tr>
<tr class="memdesc:gabcf59a102adff7e4ef0144fa9949388d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MERGE_M2 aggregation.  <a href="group__aggregation__factories.html#gabcf59a102adff7e4ef0144fa9949388d">More...</a><br></td></tr>
<tr class="separator:gabcf59a102adff7e4ef0144fa9949388d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3b4973811f9179de79d580cbdf3503eb"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga3b4973811f9179de79d580cbdf3503eb"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3b4973811f9179de79d580cbdf3503eb">cudf::make_covariance_aggregation</a> (size_type min_periods=1, size_type ddof=1)</td></tr>
<tr class="memdesc:ga3b4973811f9179de79d580cbdf3503eb"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a COVARIANCE aggregation.  <a href="group__aggregation__factories.html#ga3b4973811f9179de79d580cbdf3503eb">More...</a><br></td></tr>
<tr class="separator:ga3b4973811f9179de79d580cbdf3503eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3f4ba4b1b699a74da1dc905701ce48f7"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga3f4ba4b1b699a74da1dc905701ce48f7"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3f4ba4b1b699a74da1dc905701ce48f7">cudf::make_correlation_aggregation</a> (correlation_type type, size_type min_periods=1)</td></tr>
<tr class="memdesc:ga3f4ba4b1b699a74da1dc905701ce48f7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a CORRELATION aggregation.  <a href="group__aggregation__factories.html#ga3f4ba4b1b699a74da1dc905701ce48f7">More...</a><br></td></tr>
<tr class="separator:ga3f4ba4b1b699a74da1dc905701ce48f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga2a176f20e52206e2a8197d100f8a4ca0"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:ga2a176f20e52206e2a8197d100f8a4ca0"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga2a176f20e52206e2a8197d100f8a4ca0">cudf::make_tdigest_aggregation</a> (int max_centroids=1000)</td></tr>
<tr class="memdesc:ga2a176f20e52206e2a8197d100f8a4ca0"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a TDIGEST aggregation.  <a href="group__aggregation__factories.html#ga2a176f20e52206e2a8197d100f8a4ca0">More...</a><br></td></tr>
<tr class="separator:ga2a176f20e52206e2a8197d100f8a4ca0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gafe7a1b8ffd3e7890fe6bad0d13752492"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:gafe7a1b8ffd3e7890fe6bad0d13752492"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gafe7a1b8ffd3e7890fe6bad0d13752492">cudf::make_merge_tdigest_aggregation</a> (int max_centroids=1000)</td></tr>
<tr class="memdesc:gafe7a1b8ffd3e7890fe6bad0d13752492"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MERGE_TDIGEST aggregation.  <a href="group__aggregation__factories.html#gafe7a1b8ffd3e7890fe6bad0d13752492">More...</a><br></td></tr>
<tr class="separator:gafe7a1b8ffd3e7890fe6bad0d13752492"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa0a7a442ff8e3f87e5b7dea812bf0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a7a442ff8e3f87e5b7dea812bf0b2f">◆&nbsp;</a></span>make_argmax_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_argmax_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create an <code>argmax</code> aggregation. </p>
<p><code>argmax</code> returns the index of the maximum element. </p>

</div>
</div>
<a id="gaefdbbe152b032284220429403a41875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefdbbe152b032284220429403a41875c">◆&nbsp;</a></span>make_argmin_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_argmin_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create an <code>argmin</code> aggregation. </p>
<p><code>argmin</code> returns the index of the minimum element. </p>

</div>
</div>
<a id="ga97444ec376ca739cd16256f2fcc90b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97444ec376ca739cd16256f2fcc90b07">◆&nbsp;</a></span>make_collect_list_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_collect_list_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code><a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a COLLECT_LIST aggregation. </p>
<p><code>COLLECT_LIST</code> returns a list column of all included elements in the group/series.</p>
<p>If <code>null_handling</code> is set to <code>EXCLUDE</code>, null elements are dropped from each of the list rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">null_handling</td><td>Indicates whether to include/exclude nulls in list elements. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="gae02625d427793418d9d1a854c81265d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae02625d427793418d9d1a854c81265d2">◆&nbsp;</a></span>make_collect_set_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_collect_set_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code><a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&nbsp;</td>
          <td class="paramname"><em>nulls_equal</em> = <code>null_equality::EQUAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a>&nbsp;</td>
          <td class="paramname"><em>nans_equal</em> = <code><a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::UNEQUAL</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a COLLECT_SET aggregation. </p>
<p><code>COLLECT_SET</code> returns a lists column of all included elements in the group/series. Within each list, the duplicated entries are dropped out such that each entry appears only once.</p>
<p>If <code>null_handling</code> is set to <code>EXCLUDE</code>, null elements are dropped from each of the list rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">null_handling</td><td>Indicates whether to include/exclude nulls during collection </td></tr>
    <tr><td class="paramname">nulls_equal</td><td>Flag to specify whether null entries within each list should be considered equal. </td></tr>
    <tr><td class="paramname">nans_equal</td><td>Flag to specify whether NaN values in floating point column should be considered equal. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f4ba4b1b699a74da1dc905701ce48f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f4ba4b1b699a74da1dc905701ce48f7">◆&nbsp;</a></span>make_correlation_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_correlation_aggregation </td>
          <td>(</td>
          <td class="paramtype">correlation_type&nbsp;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"><em>min_periods</em> = <code>1</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a CORRELATION aggregation. </p>
<p>Compute correlation coefficient between two columns. The input columns are child columns of a non-nullable struct columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">type</td><td>correlation_type </td></tr>
    <tr><td class="paramname">min_periods</td><td>Minimum number of non-null observations required to produce a result. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e70bc7722fe1626802cf8441fbf9fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e70bc7722fe1626802cf8441fbf9fa5">◆&nbsp;</a></span>make_count_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_count_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code>null_policy::EXCLUDE</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a COUNT aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">null_handling</td><td>Indicates if null values will be counted. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b4973811f9179de79d580cbdf3503eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4973811f9179de79d580cbdf3503eb">◆&nbsp;</a></span>make_covariance_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_covariance_aggregation </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"><em>min_periods</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a COVARIANCE aggregation. </p>
<p>Compute covariance between two columns. The input columns are child columns of a non-nullable struct columns. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">min_periods</td><td>Minimum number of non-null observations required to produce a result. </td></tr>
    <tr><td class="paramname">ddof</td><td>Delta Degrees of Freedom. The divisor used in calculations is N - ddof, where N is the number of non-null observations. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0158607150632061d226eadb387b9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0158607150632061d226eadb387b9bd">◆&nbsp;</a></span>make_dense_rank_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_dense_rank_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a DENSE_RANK aggregation. </p>
<p><code>DENSE_RANK</code> returns a non-nullable column of size_type "dense ranks": the preceding unique value's rank plus one. As a result, ranks are not unique but there are no gaps in the ranking sequence (unlike RANK aggregations).</p>
<p>This aggregation only works with "scan" algorithms. The input column into the group or ungrouped scan is an orderby column that orders the rows that the aggregate function ranks. If rows are ordered by more than one column, the orderby input column should be a struct column containing the ordering columns.</p>
<p>Note:</p><ol type="1">
<li>This method requires that the rows are presorted by the group keys and order_by columns.</li>
<li><code>DENSE_RANK</code> aggregations will return a fully valid column regardless of null_handling policy specified in the scan.</li>
<li><code>DENSE_RANK</code> aggregations are not compatible with exclusive scans.</li>
</ol>
<div class="fragment"><div class="line">Example: Consider an motor-racing statistics dataset, containing the following columns:</div>
<div class="line">  1. driver_name:   (STRING) Name of the car driver</div>
<div class="line">  2. num_overtakes: (INT32)  Number of times the driver overtook another car in a lap</div>
<div class="line">  3. lap_number:    (INT32)  The number of the lap</div>
<div class="line"> </div>
<div class="line">For the following presorted data:</div>
<div class="line"> </div>
<div class="line"> [ // driver_name,  num_overtakes,  lap_number</div>
<div class="line">   {   "bottas",        2,            3        },</div>
<div class="line">   {   "bottas",        2,            7        },</div>
<div class="line">   {   "bottas",        2,            7        },</div>
<div class="line">   {   "bottas",        1,            1        },</div>
<div class="line">   {   "bottas",        1,            2        },</div>
<div class="line">   {   "hamilton",      4,            1        },</div>
<div class="line">   {   "hamilton",      4,            1        },</div>
<div class="line">   {   "hamilton",      3,            4        },</div>
<div class="line">   {   "hamilton",      2,            4        }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">A grouped dense rank aggregation scan with:</div>
<div class="line">  groupby column      : driver_name</div>
<div class="line">  input orderby column: struct_column{num_overtakes, lap_number}</div>
<div class="line"> result: column&lt;size_type&gt;{1, 2, 2, 3, 4, 1, 1, 2, 3}</div>
<div class="line"> </div>
<div class="line">A grouped dense rank aggregation scan with:</div>
<div class="line">  groupby column      : driver_name</div>
<div class="line">  input orderby column: num_overtakes</div>
<div class="line"> result: column&lt;size_type&gt;{1, 1, 1, 2, 2, 1, 1, 2, 3}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gab600cbeb5a9fe9f6d2a7c6b5a769308a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab600cbeb5a9fe9f6d2a7c6b5a769308a">◆&nbsp;</a></span>make_m2_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_m2_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a M2 aggregation. </p>
<p>A M2 aggregation is sum of squares of differences from the mean. That is: <code>M2 = SUM((x - MEAN) * (x - MEAN))</code>.</p>
<p>This aggregation produces the intermediate values that are used to compute variance and standard deviation across multiple discrete sets. See <code><a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</a>#Parallel_algorithm</code> for more detail. </p>

</div>
</div>
<a id="gaebc1969a9d59183e804545cfc342e763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebc1969a9d59183e804545cfc342e763">◆&nbsp;</a></span>make_merge_lists_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_merge_lists_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a MERGE_LISTS aggregation. </p>
<p>Given a lists column, this aggregation merges all the lists corresponding to the same key value into one list. It is designed specifically to merge the partial results of multiple (distributed) groupby <code>COLLECT_LIST</code> aggregations into a final <code>COLLECT_LIST</code> result. As such, it requires the input lists column to be non-nullable (the child column containing list entries is not subjected to this requirement). </p>

</div>
</div>
<a id="gabcf59a102adff7e4ef0144fa9949388d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcf59a102adff7e4ef0144fa9949388d">◆&nbsp;</a></span>make_merge_m2_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_merge_m2_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a MERGE_M2 aggregation. </p>
<p>Merges the results of <code>M2</code> aggregations on independent sets into a new <code>M2</code> value equivalent to if a single <code>M2</code> aggregation was done across all of the sets at once. This aggregation is only valid on structs whose members are the result of the <code>COUNT_VALID</code>, <code>MEAN</code>, and <code>M2</code> aggregations on the same sets. The output of this aggregation is a struct containing the merged <code>COUNT_VALID</code>, <code>MEAN</code>, and <code>M2</code> aggregations.</p>
<p>The input <code>M2</code> aggregation values are expected to be all non-negative numbers, since they were output from <code>M2</code> aggregation. </p>

</div>
</div>
<a id="gaf05edd87facfdb3c0300892e9ba2a215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf05edd87facfdb3c0300892e9ba2a215">◆&nbsp;</a></span>make_merge_sets_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_merge_sets_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&nbsp;</td>
          <td class="paramname"><em>nulls_equal</em> = <code>null_equality::EQUAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a>&nbsp;</td>
          <td class="paramname"><em>nans_equal</em> = <code><a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::UNEQUAL</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a MERGE_SETS aggregation. </p>
<p>Given a lists column, this aggregation firstly merges all the lists corresponding to the same key value into one list, then it drops all the duplicate entries in each lists, producing a lists column containing non-repeated entries.</p>
<p>This aggregation is designed specifically to merge the partial results of multiple (distributed) groupby <code>COLLECT_LIST</code> or <code>COLLECT_SET</code> aggregations into a final <code>COLLECT_SET</code> result. As such, it requires the input lists column to be non-nullable (the child column containing list entries is not subjected to this requirement).</p>
<p>In practice, the input (partial results) to this aggregation should be generated by (distributed) <code>COLLECT_LIST</code> aggregations, not <code>COLLECT_SET</code>, to avoid unnecessarily removing duplicate entries for the partial results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">nulls_equal</td><td>Flag to specify whether nulls within each list should be considered equal during dropping duplicate list entries. </td></tr>
    <tr><td class="paramname">nans_equal</td><td>Flag to specify whether NaN values in floating point column should be considered equal during dropping duplicate list entries. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="gafe7a1b8ffd3e7890fe6bad0d13752492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe7a1b8ffd3e7890fe6bad0d13752492">◆&nbsp;</a></span>make_merge_tdigest_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_merge_tdigest_aggregation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_centroids</em> = <code>1000</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a MERGE_TDIGEST aggregation. </p>
<p>Merges the results from a previous aggregation resulting from a <code>make_tdigest_aggregation</code> or <code>make_merge_tdigest_aggregation</code> to produce a new a tdigest (<a href="https://arxiv.org/pdf/1902.04023.pdf">https://arxiv.org/pdf/1902.04023.pdf</a>) column.</p>
<p>The tdigest column produced is of the following structure:</p>
<p>struct { // centroids for the digest list { struct { double // mean double // weight }, ... } // these are from the input stream, not the centroids. they are used // during the percentile_approx computation near the beginning or // end of the quantiles double // min double // max }</p>
<p>Each output row is a single tdigest. The length of the row is the "size" of the tdigest, each element of which represents a weighted centroid (mean, weight).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">max_centroids</td><td>Parameter controlling compression level and accuracy on subsequent queries on the output tdigest data. <code>max_centroids</code> places an upper bound on the size of the computed tdigests: A value of 1000 will result in a tdigest containing no more than 1000 centroids (32 bytes each). Higher result in more accurate tdigest information.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A MERGE_TDIGEST aggregation object. </dd></dl>

</div>
</div>
<a id="gacbd7e79be437c234f47ad8b623741703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbd7e79be437c234f47ad8b623741703">◆&nbsp;</a></span>make_nth_element_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_nth_element_aggregation </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code><a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a <code>nth_element</code> aggregation. </p>
<p><code>nth_element</code> returns the n'th element of the group/series.</p>
<p>If <code>n</code> is not within the range <code>[-group_size, group_size)</code>, the result of the respective group will be null. Negative indices <code>[-group_size, -1]</code> corresponds to <code>[0, group_size-1]</code> indices respectively where <code>group_size</code> is the size of each group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">n</td><td>index of nth element in each group. </td></tr>
    <tr><td class="paramname">null_handling</td><td>Indicates to include/exclude nulls during indexing. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga575d3a90787d6af802850a1573025282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575d3a90787d6af802850a1573025282">◆&nbsp;</a></span>make_nunique_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_nunique_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code>null_policy::EXCLUDE</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a <code>nunique</code> aggregation. </p>
<p><code>nunique</code> returns the number of unique elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">null_handling</td><td>Indicates if null values will be counted. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="gaf27931287bb704b589369ea856f24f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27931287bb704b589369ea856f24f97">◆&nbsp;</a></span>make_quantile_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_quantile_aggregation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>quantiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a>&nbsp;</td>
          <td class="paramname"><em>interp</em> = <code>interpolation::LINEAR</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a QUANTILE aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">quantiles</td><td>The desired quantiles </td></tr>
    <tr><td class="paramname">interp</td><td>The desired interpolation </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="gadfb305a70d1c71fc300c801e0a2b60ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb305a70d1c71fc300c801e0a2b60ff">◆&nbsp;</a></span>make_rank_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_rank_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a RANK aggregation. </p>
<p><code>RANK</code> returns a non-nullable column of size_type "ranks": the number of rows preceding or equal to the current row plus one. As a result, ranks are not unique and gaps will appear in the ranking sequence.</p>
<p>This aggregation only works with "scan" algorithms. The input column into the group or ungrouped scan is an orderby column that orders the rows that the aggregate function ranks. If rows are ordered by more than one column, the orderby input column should be a struct column containing the ordering columns.</p>
<p>Note:</p><ol type="1">
<li>This method requires that the rows are presorted by the group keys and order_by columns.</li>
<li><code>RANK</code> aggregations will return a fully valid column regardless of null_handling policy specified in the scan.</li>
<li><code>RANK</code> aggregations are not compatible with exclusive scans.</li>
</ol>
<div class="fragment"><div class="line">Example: Consider an motor-racing statistics dataset, containing the following columns:</div>
<div class="line">  1. driver_name:   (STRING) Name of the car driver</div>
<div class="line">  2. num_overtakes: (INT32)  Number of times the driver overtook another car in a lap</div>
<div class="line">  3. lap_number:    (INT32)  The number of the lap</div>
<div class="line"> </div>
<div class="line">For the following presorted data:</div>
<div class="line"> </div>
<div class="line"> [ // driver_name,  num_overtakes,  lap_number</div>
<div class="line">   {   "bottas",        2,            3        },</div>
<div class="line">   {   "bottas",        2,            7        },</div>
<div class="line">   {   "bottas",        2,            7        },</div>
<div class="line">   {   "bottas",        1,            1        },</div>
<div class="line">   {   "bottas",        1,            2        },</div>
<div class="line">   {   "hamilton",      4,            1        },</div>
<div class="line">   {   "hamilton",      4,            1        },</div>
<div class="line">   {   "hamilton",      3,            4        },</div>
<div class="line">   {   "hamilton",      2,            4        }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">A grouped rank aggregation scan with:</div>
<div class="line">  groupby column      : driver_name</div>
<div class="line">  input orderby column: struct_column{num_overtakes, lap_number}</div>
<div class="line"> result: column&lt;size_type&gt;{1, 2, 2, 4, 5, 1, 1, 3, 4}</div>
<div class="line"> </div>
<div class="line">A grouped rank aggregation scan with:</div>
<div class="line">  groupby column      : driver_name</div>
<div class="line">  input orderby column: num_overtakes</div>
<div class="line"> result: column&lt;size_type&gt;{1, 1, 1, 4, 4, 1, 1, 3, 4}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3d0f22ac076169ad064357f3a62ee40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d0f22ac076169ad064357f3a62ee40c">◆&nbsp;</a></span>make_std_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_std_aggregation </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a STD aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ddof</td><td>Delta degrees of freedom. The divisor used in calculation of <code>std</code> is <code>N - ddof</code>, where <code>N</code> is the population size.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input type is chrono or compound types. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a176f20e52206e2a8197d100f8a4ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a176f20e52206e2a8197d100f8a4ca0">◆&nbsp;</a></span>make_tdigest_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_tdigest_aggregation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_centroids</em> = <code>1000</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a TDIGEST aggregation. </p>
<p>Produces a tdigest (<a href="https://arxiv.org/pdf/1902.04023.pdf">https://arxiv.org/pdf/1902.04023.pdf</a>) column from input values. The input aggregation values are expected to be fixed-width numeric types.</p>
<p>The tdigest column produced is of the following structure:</p>
<p>struct { // centroids for the digest list { struct { double // mean double // weight }, ... } // these are from the input stream, not the centroids. they are used // during the percentile_approx computation near the beginning or // end of the quantiles double // min double // max }</p>
<p>Each output row is a single tdigest. The length of the row is the "size" of the tdigest, each element of which represents a weighted centroid (mean, weight).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">max_centroids</td><td>Parameter controlling compression level and accuracy on subsequent queries on the output tdigest data. <code>max_centroids</code> places an upper bound on the size of the computed tdigests: A value of 1000 will result in a tdigest containing no more than 1000 centroids (32 bytes each). Higher result in more accurate tdigest information.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A TDIGEST aggregation object. </dd></dl>

</div>
</div>
<a id="ga6cdfbd69c4ab83b73f1930d1ec1060b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cdfbd69c4ab83b73f1930d1ec1060b9">◆&nbsp;</a></span>make_udf_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_udf_aggregation </td>
          <td>(</td>
          <td class="paramtype">udf_type&nbsp;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"><em>user_defined_aggregator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&nbsp;</td>
          <td class="paramname"><em>output_type</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create an aggregation base on UDF for PTX or CUDA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>either udf_type::PTX or udf_type::CUDA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_defined_aggregator</td><td>A string containing the aggregator code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_type</td><td>expected output type</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>aggregation unique pointer housing user_defined_aggregator string. </dd></dl>

</div>
</div>
<a id="ga4f3a4efc7e531724b51b4ed2f11367d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f3a4efc7e531724b51b4ed2f11367d1">◆&nbsp;</a></span>make_variance_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_variance_aggregation </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a VARIANCE aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ddof</td><td>Delta degrees of freedom. The divisor used in calculation of <code>variance</code> is <code>N - ddof</code>, where <code>N</code> is the population size.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input type is chrono or compound types. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body></html>