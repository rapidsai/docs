<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.20" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>libcudf: Rolling Window</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="rapids.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf-java/legacy">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">stable (0.16)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (0.17)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">stable (0.16)</a><a class="rapids-selector__menu-item" href="/api/libcudf/legacy/namespacecudf.html">legacy (0.15)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
<div class="summary">
<a href="#files">Files</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">Rolling Window<div class="ingroups"><a class="el" href="group__column__apis.html">Column and Table</a> » <a class="el" href="group__column__aggregation.html">Aggregation</a></div></div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:rolling_8hpp"><td align="right" class="memItemLeft" valign="top">file  </td><td class="memItemRight" valign="bottom"><a class="el" href="rolling_8hpp.html">rolling.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9ad56592cda94d409088c6f98b74a3d7"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga9ad56592cda94d409088c6f98b74a3d7">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, size_type preceding_window, size_type following_window, size_type min_periods, std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9ad56592cda94d409088c6f98b74a3d7"><td class="mdescLeft"> </td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#ga9ad56592cda94d409088c6f98b74a3d7">More...</a><br/></td></tr>
<tr class="separator:ga9ad56592cda94d409088c6f98b74a3d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga862e5ebb4270897d37dae542d5d9d5d1"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga862e5ebb4270897d37dae542d5d9d5d1">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, size_type preceding_window, size_type following_window, size_type min_periods, std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga862e5ebb4270897d37dae542d5d9d5d1"><td class="mdescLeft"> </td><td class="mdescRight">rolling_window(  <a href="group__aggregation__rolling.html#ga862e5ebb4270897d37dae542d5d9d5d1">More...</a><br/></td></tr>
<tr class="separator:ga862e5ebb4270897d37dae542d5d9d5d1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga878076b3d2988d1c8b91796ad9120a5c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga878076b3d2988d1c8b91796ad9120a5c">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, size_type preceding_window, size_type following_window, size_type min_periods, std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga878076b3d2988d1c8b91796ad9120a5c"><td class="mdescLeft"> </td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#ga878076b3d2988d1c8b91796ad9120a5c">More...</a><br/></td></tr>
<tr class="separator:ga878076b3d2988d1c8b91796ad9120a5c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf4c506bbb0824d54ad8fb2b5486d5459"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gaf4c506bbb0824d54ad8fb2b5486d5459">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, size_type preceding_window, size_type following_window, size_type min_periods, std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaf4c506bbb0824d54ad8fb2b5486d5459"><td class="mdescLeft"> </td><td class="mdescRight">grouped_rolling_window(  <a href="group__aggregation__rolling.html#gaf4c506bbb0824d54ad8fb2b5486d5459">More...</a><br/></td></tr>
<tr class="separator:gaf4c506bbb0824d54ad8fb2b5486d5459"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae390ff584cc095f8c6d68cf9341c6097"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gae390ff584cc095f8c6d68cf9341c6097">cudf::grouped_time_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamp_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;timestamp_order, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, size_type preceding_window_in_days, size_type following_window_in_days, size_type min_periods, std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae390ff584cc095f8c6d68cf9341c6097"><td class="mdescLeft"> </td><td class="mdescRight">Applies a grouping-aware, timestamp-based rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#gae390ff584cc095f8c6d68cf9341c6097">More...</a><br/></td></tr>
<tr class="separator:gae390ff584cc095f8c6d68cf9341c6097"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac4364402ab766f5e115be1c81d0b5099"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gac4364402ab766f5e115be1c81d0b5099">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;preceding_window, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;following_window, size_type min_periods, std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac4364402ab766f5e115be1c81d0b5099"><td class="mdescLeft"> </td><td class="mdescRight">Applies a variable-size rolling window function to the values in a column.  <a href="group__aggregation__rolling.html#gac4364402ab766f5e115be1c81d0b5099">More...</a><br/></td></tr>
<tr class="separator:gac4364402ab766f5e115be1c81d0b5099"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf4c506bbb0824d54ad8fb2b5486d5459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4c506bbb0824d54ad8fb2b5486d5459">◆ </a></span>grouped_rolling_window() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_rolling_window </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp; </td>
<td class="paramname"><em>group_keys</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>default_outputs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>preceding_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>following_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>min_periods</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp; </td>
<td class="paramname"><em>aggr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>grouped_rolling_window( </p>
<p>grouped_rolling_window( <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a> const&amp; group_keys, <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> const&amp; input, size_type preceding_window, size_type following_window, size_type min_periods, std::unique_ptr&lt;aggregation&gt; const&amp; aggr, rmm::mr::device_memory_resource* mr)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">default_outputs</td><td>A column of per-row default values to be returned instead of nulls. Used for LEAD()/LAG(), if the row offset crosses the boundaries of the column or group. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga878076b3d2988d1c8b91796ad9120a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga878076b3d2988d1c8b91796ad9120a5c">◆ </a></span>grouped_rolling_window() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_rolling_window </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp; </td>
<td class="paramname"><em>group_keys</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>preceding_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>following_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>min_periods</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp; </td>
<td class="paramname"><em>aggr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga9ad56592cda94d409088c6f98b74a3d7" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga9ad56592cda94d409088c6f98b74a3d7" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ "user_id", sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   20      },</div>
<div class="line">   { "user1",   20      },</div>
<div class="line">   { "user1",   10      },</div>
<div class="line">   { "user2",   30      },</div>
<div class="line">   { "user2",   80      },</div>
<div class="line">   { "user1",   50      },</div>
<div class="line">   { "user1",   60      },</div>
<div class="line">   { "user2",   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.)</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>
</div>
</div>
<a id="gae390ff584cc095f8c6d68cf9341c6097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae390ff584cc095f8c6d68cf9341c6097">◆ </a></span>grouped_time_range_rolling_window()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::grouped_time_range_rolling_window </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp; </td>
<td class="paramname"><em>group_keys</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>timestamp_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp; </td>
<td class="paramname"><em>timestamp_order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>preceding_window_in_days</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>following_window_in_days</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>min_periods</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp; </td>
<td class="paramname"><em>aggr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a grouping-aware, timestamp-based rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga9ad56592cda94d409088c6f98b74a3d7" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga9ad56592cda94d409088c6f98b74a3d7" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in two respects:</p><ol type="1">
<li>The elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby), determined by the corresponding values of the columns under <code>group_keys</code>. The window-aggregation cannot cross the group boundaries.</li>
<li>Within a group, the aggregation window is calculated based on a time interval (e.g. number of days preceding/following the current row). The timestamps for the input data are specified by the <code>timestamp_column</code> argument.</li>
</ol>
<p>Note: This method requires that the rows are presorted by the group keys and timestamp values.</p>
<div class="fragment"><div class="line">  Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">   { "user_id", sales_amt, date }</div>
<div class="line"> </div>
<div class="line">  This method enables windowing queries such as grouping a dataset by `user_id`, sorting by</div>
<div class="line">  increasing `date`, and summing up the `sales_amt` column over a window of 3 days (1 preceding</div>
<div class="line">*day, the current day, and 1 following day).</div>
<div class="line"> </div>
<div class="line">  In this example,</div>
<div class="line">     1. `group_keys == [ user_id ]`</div>
<div class="line">     2. `timestamp_column == date`</div>
<div class="line">     3. `input == sales_amt`</div>
<div class="line">  The data are grouped by `user_id`, and ordered by `date`. The aggregation</div>
<div class="line">  (SUM) is then calculated for a window of 3 days around (and including) each row.</div>
<div class="line"> </div>
<div class="line">  For the following input:</div>
<div class="line"> </div>
<div class="line">   [ // user,  sales_amt,  YYYYMMDD (date)</div>
<div class="line">     { "user1",   10,      20200101    },</div>
<div class="line">     { "user2",   20,      20200101    },</div>
<div class="line">     { "user1",   20,      20200102    },</div>
<div class="line">     { "user1",   10,      20200103    },</div>
<div class="line">     { "user2",   30,      20200101    },</div>
<div class="line">     { "user2",   80,      20200102    },</div>
<div class="line">     { "user1",   50,      20200107    },</div>
<div class="line">     { "user1",   60,      20200107    },</div>
<div class="line">     { "user2",   40,      20200104    }</div>
<div class="line">   ]</div>
<div class="line"> </div>
<div class="line">  Partitioning (grouping) by `user_id`, and ordering by `date` yields the following `sales_amt`</div>
<div class="line">  vector (with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">  Date :(202001-)  [ 01,  02,  03,  07,  07,    01,   01,   02,  04 ]</div>
<div class="line">  Input:           [ 10,  20,  10,  50,  60,    20,   30,   80,  40 ]</div>
<div class="line">                     &lt;-------user1--------&gt;|&lt;---------user2---------&gt;</div>
<div class="line"> </div>
<div class="line">  The SUM aggregation is applied, with 1 day preceding, and 1 day following, with a minimum of 1</div>
<div class="line">  period. The aggregation window is thus 3 *days* wide, yielding the following output column:</div>
<div class="line"> </div>
<div class="line">   Results:        [ 30,  40,  30,  110, 110,  130,  130,  130,  40 ]</div>
</div><!-- fragment --><p>Note: The number of rows participating in each window might vary, based on the index within the group, datestamp, and <code>min_periods</code>. Apropos:</p><ol type="1">
<li>results[0] considers 2 values, because it is at the beginning of its group, and has no preceding values.</li>
<li>results[5] considers 3 values, despite being at the beginning of its group. It must include 2 following values, based on its datestamp.</li>
</ol>
<p>Each aggregation operation cannot cross group boundaries.</p>
<p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">timestamp_column</td><td>The (pre-sorted) timestamps for each row </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">timestamp_order</td><td>The order (ASCENDING/DESCENDING) in which the timestamps are sorted </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">preceding_window_in_days</td><td>The rolling window time-interval in the backward direction. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">following_window_in_days</td><td>The rolling window time-interval in the forward direction. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.)</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>
</div>
</div>
<a id="ga862e5ebb4270897d37dae542d5d9d5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga862e5ebb4270897d37dae542d5d9d5d1">◆ </a></span>rolling_window() <span class="overload">[1/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::rolling_window </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>default_outputs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>preceding_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>following_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>min_periods</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp; </td>
<td class="paramname"><em>agg</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>rolling_window( </p>
<p>rolling_window( <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> const&amp; input, size_type preceding_window, size_type following_window, size_type min_periods, std::unique_ptr&lt;aggregation&gt; const&amp; agg, rmm::mr::device_memory_resource* mr)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">default_outputs</td><td>A column of per-row default values to be returned instead of nulls. Used for LEAD()/LAG(), if the row offset crosses the boundaries of the column. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gac4364402ab766f5e115be1c81d0b5099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4364402ab766f5e115be1c81d0b5099">◆ </a></span>rolling_window() <span class="overload">[2/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::rolling_window </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>preceding_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>following_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>min_periods</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp; </td>
<td class="paramname"><em>agg</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a variable-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is dynamic (varying for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window</code>. Element <code>i</code> uses elements <code>[i-preceding_window+1, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
<li>support for dynamic rolling windows, i.e. window size can be specified for each element using an additional array.</li>
</ul>
<p>The returned column for count aggregation always has INT32 type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if window column type is not INT32</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">input_col</td><td>The input column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>A non-nullable column of INT32 window sizes in the forward direction. <code>preceding_window[i]</code> specifies preceding window size for element <code>i</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>A non-nullable column of INT32 window sizes in the backward direction. <code>following_window[i]</code> specifies following window size for element <code>i</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">agg</td><td>The rolling window aggregation type (sum, max, min, etc.)</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>
</div>
</div>
<a id="ga9ad56592cda94d409088c6f98b74a3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ad56592cda94d409088c6f98b74a3d7">◆ </a></span>rolling_window() <span class="overload">[3/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::rolling_window </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>preceding_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>following_window</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>min_periods</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1aggregation.html">aggregation</a> &gt; const &amp; </td>
<td class="paramname"><em>agg</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Applies a fixed-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is static (the same for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window</code>. Element <code>i</code> uses elements <code>[i-preceding_window+1, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>The returned column for count aggregation always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">input_col</td><td>The input column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">agg</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.)</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"/></a> 1.8.20
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
