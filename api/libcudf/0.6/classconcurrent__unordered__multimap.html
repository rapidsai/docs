<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: concurrent_unordered_multimap&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classconcurrent__unordered__multimap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">concurrent_unordered_multimap&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for concurrent_unordered_multimap&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classconcurrent__unordered__multimap__inherit__graph.png" border="0" usemap="#concurrent__unordered__multimap_3_01Key_00_01Element_00_01size__type_00_01unused__key_00_01unused__element_00_01Hasher_00_01Equality_00_01Allocator_00_01count__collisions_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="concurrent__unordered__multimap_3_01Key_00_01Element_00_01size__type_00_01unused__key_00_01unused__element_00_01Hasher_00_01Equality_00_01Allocator_00_01count__collisions_01_4_inherit__map" id="concurrent__unordered__multimap_3_01Key_00_01Element_00_01size__type_00_01unused__key_00_01unused__element_00_01Hasher_00_01Equality_00_01Allocator_00_01count__collisions_01_4_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for concurrent_unordered_multimap&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classconcurrent__unordered__multimap__coll__graph.png" border="0" usemap="#concurrent__unordered__multimap_3_01Key_00_01Element_00_01size__type_00_01unused__key_00_01unused__element_00_01Hasher_00_01Equality_00_01Allocator_00_01count__collisions_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="concurrent__unordered__multimap_3_01Key_00_01Element_00_01size__type_00_01unused__key_00_01unused__element_00_01Hasher_00_01Equality_00_01Allocator_00_01count__collisions_01_4_coll__map" id="concurrent__unordered__multimap_3_01Key_00_01Element_00_01size__type_00_01unused__key_00_01unused__element_00_01Hasher_00_01Equality_00_01Allocator_00_01count__collisions_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a723373330847c9774e9259fc971fca45"><td class="memItemLeft" align="right" valign="top"><a id="a723373330847c9774e9259fc971fca45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = Hasher</td></tr>
<tr class="separator:a723373330847c9774e9259fc971fca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bc2892a0f1a5e7aec89e8a773c413b"><td class="memItemLeft" align="right" valign="top"><a id="a40bc2892a0f1a5e7aec89e8a773c413b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = Equality</td></tr>
<tr class="separator:a40bc2892a0f1a5e7aec89e8a773c413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af851b424d413f899edf79da7c7837"><td class="memItemLeft" align="right" valign="top"><a id="ae9af851b424d413f899edf79da7c7837"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:ae9af851b424d413f899edf79da7c7837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabc9a28a0c0ac2de884e0efd8c156f1"><td class="memItemLeft" align="right" valign="top"><a id="aaabc9a28a0c0ac2de884e0efd8c156f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="separator:aaabc9a28a0c0ac2de884e0efd8c156f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05647c49f8467267971ce669398d1a5b"><td class="memItemLeft" align="right" valign="top"><a id="a05647c49f8467267971ce669398d1a5b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = thrust::pair&lt; Key, Element &gt;</td></tr>
<tr class="separator:a05647c49f8467267971ce669398d1a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0d2f3190f37fa86e842418ab3110e8"><td class="memItemLeft" align="right" valign="top"><a id="a9e0d2f3190f37fa86e842418ab3110e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = Element</td></tr>
<tr class="separator:a9e0d2f3190f37fa86e842418ab3110e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7aa7349ee626f718f633ed6007e3f81"><td class="memItemLeft" align="right" valign="top"><a id="ac7aa7349ee626f718f633ed6007e3f81"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classcycle__iterator__adapter.html">cycle_iterator_adapter</a>&lt; value_type * &gt;</td></tr>
<tr class="separator:ac7aa7349ee626f718f633ed6007e3f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3168b68163a91a04abd8199cc718f6e"><td class="memItemLeft" align="right" valign="top"><a id="ad3168b68163a91a04abd8199cc718f6e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = const <a class="el" href="classcycle__iterator__adapter.html">cycle_iterator_adapter</a>&lt; value_type * &gt;</td></tr>
<tr class="separator:ad3168b68163a91a04abd8199cc718f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a64bb89fd2300aeffcca835008c5e2a2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a64bb89fd2300aeffcca835008c5e2a2f">concurrent_unordered_multimap</a> (size_type n, const bool init=true, const Hasher &amp;hf=hasher(), const Equality &amp;eql=key_equal(), const allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:a64bb89fd2300aeffcca835008c5e2a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory and optionally fills the hash map with unused keys/values.  <a href="#a64bb89fd2300aeffcca835008c5e2a2f">More...</a><br /></td></tr>
<tr class="separator:a64bb89fd2300aeffcca835008c5e2a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177b8d37df923061a61db75030d7aeea"><td class="memItemLeft" align="right" valign="top"><a id="a177b8d37df923061a61db75030d7aeea"></a>
__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a177b8d37df923061a61db75030d7aeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d5ac9ffbe49eb07b4f963f4845e0db"><td class="memItemLeft" align="right" valign="top"><a id="a50d5ac9ffbe49eb07b4f963f4845e0db"></a>
__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a50d5ac9ffbe49eb07b4f963f4845e0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b335134ce4d8d50b487b91b2c466140"><td class="memItemLeft" align="right" valign="top"><a id="a6b335134ce4d8d50b487b91b2c466140"></a>
__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a6b335134ce4d8d50b487b91b2c466140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990de374c2c5e857b0caca696062abf3"><td class="memItemLeft" align="right" valign="top"><a id="a990de374c2c5e857b0caca696062abf3"></a>
__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:a990de374c2c5e857b0caca696062abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7febd400b3cde90ea74581da354aa6"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type&gt; </td></tr>
<tr class="memitem:a9b7febd400b3cde90ea74581da354aa6"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __host__ __device__ hash_value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a9b7febd400b3cde90ea74581da354aa6">get_hash</a> (const key_type &amp;the_key) const</td></tr>
<tr class="memdesc:a9b7febd400b3cde90ea74581da354aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a hash value for a key.  <a href="#a9b7febd400b3cde90ea74581da354aa6">More...</a><br /></td></tr>
<tr class="separator:a9b7febd400b3cde90ea74581da354aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392b7f4bfeccc4d9565f15db2a648b8a"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type&gt; </td></tr>
<tr class="memitem:a392b7f4bfeccc4d9565f15db2a648b8a"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __host__ __device__ int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a392b7f4bfeccc4d9565f15db2a648b8a">get_partition</a> (const key_type &amp;the_key, const int num_parts=1, bool precomputed_hash=false, hash_value_type precomputed_hash_value=0) const</td></tr>
<tr class="memdesc:a392b7f4bfeccc4d9565f15db2a648b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the destination hash map partition for a key.  <a href="#a392b7f4bfeccc4d9565f15db2a648b8a">More...</a><br /></td></tr>
<tr class="separator:a392b7f4bfeccc4d9565f15db2a648b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6851b566c937c2a85c9703e66491d9aa"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </td></tr>
<tr class="memitem:a6851b566c937c2a85c9703e66491d9aa"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a6851b566c937c2a85c9703e66491d9aa">insert</a> (const value_type &amp;x, bool precomputed_hash=false, hash_value_type precomputed_hash_value=0, comparison_type keys_are_equal=key_equal())</td></tr>
<tr class="memdesc:a6851b566c937c2a85c9703e66491d9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a (key, value) pair into the hash map.  <a href="#a6851b566c937c2a85c9703e66491d9aa">More...</a><br /></td></tr>
<tr class="separator:a6851b566c937c2a85c9703e66491d9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d67762b3f22d37e28c38ca9c29322b9"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </td></tr>
<tr class="memitem:a4d67762b3f22d37e28c38ca9c29322b9"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a4d67762b3f22d37e28c38ca9c29322b9">insert_part</a> (const value_type &amp;x, const int part=0, const int num_parts=1, bool precomputed_hash=false, hash_value_type precomputed_hash_value=0, comparison_type keys_are_equal=key_equal())</td></tr>
<tr class="memdesc:a4d67762b3f22d37e28c38ca9c29322b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a (key, value) pair into the hash map partition. This is useful when building the hash table in multiple passes, one contiguous partition at a time, or when building the hash table distributed between multiple devices.  <a href="#a4d67762b3f22d37e28c38ca9c29322b9">More...</a><br /></td></tr>
<tr class="separator:a4d67762b3f22d37e28c38ca9c29322b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83fe57fe7025326ecc6436f6f97e14f"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </td></tr>
<tr class="memitem:ad83fe57fe7025326ecc6436f6f97e14f"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#ad83fe57fe7025326ecc6436f6f97e14f">find</a> (const key_type &amp;the_key, bool precomputed_hash=false, hash_value_type precomputed_hash_value=0, comparison_type keys_are_equal=key_equal()) const</td></tr>
<tr class="memdesc:ad83fe57fe7025326ecc6436f6f97e14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a key in the hash map and returns an iterator to the first instance of the key in the map.  <a href="#ad83fe57fe7025326ecc6436f6f97e14f">More...</a><br /></td></tr>
<tr class="separator:ad83fe57fe7025326ecc6436f6f97e14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4182ad6b96e6b3fd5587673b4e6a7fe2"><td class="memItemLeft" align="right" valign="top"><a id="a4182ad6b96e6b3fd5587673b4e6a7fe2"></a>
gdf_error&#160;</td><td class="memItemRight" valign="bottom"><b>assign_async</b> (const <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> &amp;other, cudaStream_t stream=0)</td></tr>
<tr class="separator:a4182ad6b96e6b3fd5587673b4e6a7fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867ae8326ea2434fca52f10c87057b6"><td class="memItemLeft" align="right" valign="top"><a id="ae867ae8326ea2434fca52f10c87057b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_async</b> (cudaStream_t stream=0)</td></tr>
<tr class="separator:ae867ae8326ea2434fca52f10c87057b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a8424b76af290bb28fb2375cab2106"><td class="memItemLeft" align="right" valign="top"><a id="af7a8424b76af290bb28fb2375cab2106"></a>
unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_collisions</b> () const</td></tr>
<tr class="separator:af7a8424b76af290bb28fb2375cab2106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e3c3ec1a3be86c13691f3d8a574b61"><td class="memItemLeft" align="right" valign="top"><a id="a90e3c3ec1a3be86c13691f3d8a574b61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> ()</td></tr>
<tr class="separator:a90e3c3ec1a3be86c13691f3d8a574b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f1bb512172f41af6d00aabbee627ed"><td class="memItemLeft" align="right" valign="top"><a id="a40f1bb512172f41af6d00aabbee627ed"></a>
gdf_error&#160;</td><td class="memItemRight" valign="bottom"><b>prefetch</b> (const int dev_id, cudaStream_t stream=0)</td></tr>
<tr class="separator:a40f1bb512172f41af6d00aabbee627ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8de1b4615ae5990501159fb1b28f3899"><td class="memItemLeft" align="right" valign="top"><a id="a8de1b4615ae5990501159fb1b28f3899"></a>
static __forceinline__ constexpr __host__ __device__ key_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_unused_key</b> ()</td></tr>
<tr class="separator:a8de1b4615ae5990501159fb1b28f3899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_structmanaged"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_structmanaged')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="structmanaged.html">managed</a></td></tr>
<tr class="memitem:a93aaf59204935eeec16d4b1e470c0272 inherit pub_static_methods_structmanaged"><td class="memItemLeft" align="right" valign="top"><a id="a93aaf59204935eeec16d4b1e470c0272"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t n)</td></tr>
<tr class="separator:a93aaf59204935eeec16d4b1e470c0272 inherit pub_static_methods_structmanaged"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcf733d14c705f1ee4220d3efcc7bee inherit pub_static_methods_structmanaged"><td class="memItemLeft" align="right" valign="top"><a id="adbcf733d14c705f1ee4220d3efcc7bee"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr) noexcept</td></tr>
<tr class="separator:adbcf733d14c705f1ee4220d3efcc7bee inherit pub_static_methods_structmanaged"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Element, typename size_type, Key unused_key, Element unused_element, typename Hasher = default_hash&lt;Key&gt;, typename Equality = equal_to&lt;Key&gt;, typename Allocator = managed_allocator&lt;thrust::pair&lt;Key, Element&gt; &gt;, bool count_collisions = false&gt;<br />
class concurrent_unordered_multimap&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;</h3>

<p>Does support concurrent insert, but not concurrent insert and probping.</p>
<p>TODO:</p><ul>
<li>add constructor that takes pointer to hash_table to avoid allocations</li>
<li>extend interface to accept streams </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a64bb89fd2300aeffcca835008c5e2a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bb89fd2300aeffcca835008c5e2a2f">&#9670;&nbsp;</a></span>concurrent_unordered_multimap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt; &gt;, bool count_collisions = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::<a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>init</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hasher &amp;&#160;</td>
          <td class="paramname"><em>hf</em> = <code>hasher()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Equality &amp;&#160;</td>
          <td class="paramname"><em>eql</em> = <code>key_equal()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory and optionally fills the hash map with unused keys/values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The size of the hash table (the number of key-value pairs) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>Initialize the hash table with the unused keys/values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hf</td><td>An optional hashing function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eql</td><td>An optional functor for comparing if two keys are equal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>An optional functor for allocating the hash table memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad83fe57fe7025326ecc6436f6f97e14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83fe57fe7025326ecc6436f6f97e14f">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt; &gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>the_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precomputed_hash</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_value_type&#160;</td>
          <td class="paramname"><em>precomputed_hash_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparison_type&#160;</td>
          <td class="paramname"><em>keys_are_equal</em> = <code>key_equal()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a key in the hash map and returns an iterator to the first instance of the key in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the_key</td><td>The key to search for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash</td><td>A flag indicating whether or not a precomputed hash value is passed in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash_value</td><td>A precomputed hash value to use for determing the write location of the key into the hash map instead of computing the the hash value directly from the key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys_are_equal</td><td>An optional functor for comparing if two keys are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value </td></tr>
    <tr><td class="paramname">comparison_type</td><td>The type of the key comparison functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the key in the map </dd></dl>

</div>
</div>
<a id="a9b7febd400b3cde90ea74581da354aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7febd400b3cde90ea74581da354aa6">&#9670;&nbsp;</a></span>get_hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt; &gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __host__ __device__ hash_value_type <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::get_hash </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>the_key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a hash value for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the_key</td><td>The key to compute a hash for </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash value for the key </dd></dl>

</div>
</div>
<a id="a392b7f4bfeccc4d9565f15db2a648b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392b7f4bfeccc4d9565f15db2a648b8a">&#9670;&nbsp;</a></span>get_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt; &gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __host__ __device__ int <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::get_partition </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>the_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_parts</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precomputed_hash</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_value_type&#160;</td>
          <td class="paramname"><em>precomputed_hash_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the destination hash map partition for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the_key</td><td>The key to search for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_parts</td><td>The total number of partitions in the partitioned hash table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash</td><td>A flag indicating whether or not a precomputed hash value is passed in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash_value</td><td>A precomputed hash value to use for determing the write location of the key into the hash map instead of computing the the hash value directly from the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The destination hash table partition for the specified key </dd></dl>

</div>
</div>
<a id="a6851b566c937c2a85c9703e66491d9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6851b566c937c2a85c9703e66491d9aa">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt; &gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precomputed_hash</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_value_type&#160;</td>
          <td class="paramname"><em>precomputed_hash_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparison_type&#160;</td>
          <td class="paramname"><em>keys_are_equal</em> = <code>key_equal()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a (key, value) pair into the hash map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The (key, value) pair to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash</td><td>A flag indicating whether or not a precomputed hash value is passed in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash_value</td><td>A precomputed hash value to use for determing the write location of the key into the hash map instead of computing the the hash value directly from the key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys_are_equal</td><td>An optional functor for comparing if two keys are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value </td></tr>
    <tr><td class="paramname">comparison_type</td><td>The type of the key comparison functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the newly inserted (key, value) pair </dd></dl>

</div>
</div>
<a id="a4d67762b3f22d37e28c38ca9c29322b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d67762b3f22d37e28c38ca9c29322b9">&#9670;&nbsp;</a></span>insert_part()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt; &gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::insert_part </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_parts</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precomputed_hash</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_value_type&#160;</td>
          <td class="paramname"><em>precomputed_hash_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparison_type&#160;</td>
          <td class="paramname"><em>keys_are_equal</em> = <code>key_equal()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a (key, value) pair into the hash map partition. This is useful when building the hash table in multiple passes, one contiguous partition at a time, or when building the hash table distributed between multiple devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The (key, value) pair to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">part</td><td>The partition number for the partitioned hash table build </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_parts</td><td>The total number of partitions in the partitioned hash table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash</td><td>A flag indicating whether or not a precomputed hash value is passed in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash_value</td><td>A precomputed hash value to use for determing the write location of the key into the hash map instead of computing the the hash value directly from the key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys_are_equal</td><td>An optional functor for comparing if two keys are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value </td></tr>
    <tr><td class="paramname">comparison_type</td><td>The type of the key comparison functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the newly inserted (key, value) pair </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>concurrent_unordered_multimap.cuh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
