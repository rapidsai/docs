<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: cudf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cudf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parse and Transform a piece of PTX code that contains the implementation of a <code>__device__</code> function into a CUDA <code>__device__</code> <code>__inline__</code> function.  
<a href="namespacecudf.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1avro__read__arg.html">avro_read_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1column.html">column</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1column__device__view.html">column_device_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable, non-owning view of device data as a column of elements.  <a href="classcudf_1_1column__device__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1column__view.html">column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data as a column of elements, some of which may be null as indicated by a bitmask.  <a href="classcudf_1_1column__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1csv__read__arg.html">csv_read_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input arguments to the <code>read_csv</code> interface.  <a href="structcudf_1_1csv__read__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1cuda__error.html">cuda_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a CUDA error is encountered.  <a href="structcudf_1_1cuda__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1data__type.html">data_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator for the logical data type of an element in a column.  <a href="classcudf_1_1data__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceAnd.html">DeviceAnd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceCount.html">DeviceCount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceMax.html">DeviceMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceMin.html">DeviceMin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceOr.html">DeviceOr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceProduct.html">DeviceProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceSum.html">DeviceSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceXor.html">DeviceXor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__compound__impl.html">is_compound_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__fixed__width__impl.html">is_fixed_width_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__numeric__impl.html">is_numeric_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__relationally__comparable__impl.html">is_relationally_comparable_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__relationally__comparable__impl_3_01L_00_01R_00_01void__t_3_01less__comparable_e55590d6a511f5004b91a7c1dc07c638.html">is_relationally_comparable_impl&lt; L, R, void_t&lt; less_comparable&lt; L, R &gt;, greater_comparable&lt; L, R &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__simple__impl.html">is_simple_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1json__read__arg.html">json_read_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input arguments to the <code>read_json</code> interface.  <a href="structcudf_1_1json__read__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when logical precondition is violated.  <a href="structcudf_1_1logic__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1meanvar.html">meanvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">intermediate struct to calculate mean and variance This is an example case to output a struct from column input.  <a href="structcudf_1_1meanvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__column__device__view.html">mutable_column_device_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable, non-owning view of device data as a column of elements.  <a href="classcudf_1_1mutable__column__device__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, mutable view of device data as a column of elements, some of which may be null as indicated by a bitmask.  <a href="classcudf_1_1mutable__column__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__table__device__view.html">mutable_table_device_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__table__view.html">mutable_table_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <code><a class="el" href="classcudf_1_1mutable__column__view.html" title="A non-owning, mutable view of device data as a column of elements, some of which may be null as indic...">mutable_column_view</a></code>s of the same size.  <a href="classcudf_1_1mutable__table__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1orc__read__arg.html">orc_read_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1orc__write__arg.html">orc_write_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor.html">pair_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pair accessor with/without null bitmask A unary function returns <code>thrust::pair&lt;ResultType, bool&gt;</code>. If the element at index <code>i</code> is valid, returns <code>ResultType{data[i]}</code> and <code>true</code> indicating the value was valid. If the element at <code>i</code> is null, returns <code>ResultType{identity}</code> and <code>false</code> indicating the element was null.  <a href="structcudf_1_1pair__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor_3_01ElementType_00_01ResultType_00_01false_01_4.html">pair_accessor&lt; ElementType, ResultType, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor_3_01ElementType_00_01ResultType_00_01true_01_4.html">pair_accessor&lt; ElementType, ResultType, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1parquet__read__arg.html">parquet_read_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1sink__info.html">sink_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1source__info.html">source_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1string__view.html">string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data that is a variable length char array representing a UTF-8 string. The caller must maintain the device memory for the lifetime of this instance.  <a href="classcudf_1_1string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column-view of strings type, an instance of this class.  <a href="classcudf_1_1strings__column__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1table.html">table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for a set of gdf_columns of equal number of rows.  <a href="structcudf_1_1table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1table__device__view.html">table_device_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1table__view.html">table_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s of the same size.  <a href="classcudf_1_1table__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1transformer__meanvar.html">transformer_meanvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a scalar value to construct a <code>meanvar</code> object. This transforms <code>thrust::pair&lt;ElementType, bool&gt;</code> into <code>ResultType = meanvar&lt;ElementType&gt;</code> form.  <a href="structcudf_1_1transformer__meanvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1transformer__squared.html">transformer_squared</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a scalar by first casting to another type, and then squaring the result.  <a href="structcudf_1_1transformer__squared.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor.html">value_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">value accessor with/without null bitmask A unary function returns scalar value at <code>id</code>. <code>operator() (gdf_index_type id)</code> computes <code>data</code> value and valid flag at <code>id</code>  <a href="structcudf_1_1value__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor_3_01ElementType_00_01ResultType_00_01false_01_4.html">value_accessor&lt; ElementType, ResultType, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor_3_01ElementType_00_01ResultType_00_01true_01_4.html">value_accessor&lt; ElementType, ResultType, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0b75348b715cc23b1a6f8b5cf03589cc"><td class="memItemLeft" align="right" valign="top"><a id="a0b75348b715cc23b1a6f8b5cf03589cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>char_utf8</b> = uint32_t</td></tr>
<tr class="separator:a0b75348b715cc23b1a6f8b5cf03589cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aff16b2db009d92300befaca11827e9"><td class="memItemLeft" align="right" valign="top"><a id="a0aff16b2db009d92300befaca11827e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = int32_t</td></tr>
<tr class="separator:a0aff16b2db009d92300befaca11827e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d17001baf070a639c3a5e8ed8c46d34"><td class="memItemLeft" align="right" valign="top"><a id="a1d17001baf070a639c3a5e8ed8c46d34"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bitmask_type</b> = uint32_t</td></tr>
<tr class="separator:a1d17001baf070a639c3a5e8ed8c46d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6e344a72404039eef838a8cb39295b"><td class="memItemLeft" align="right" valign="top"><a id="a8c6e344a72404039eef838a8cb39295b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>category</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_category, GDF_CATEGORY &gt;</td></tr>
<tr class="separator:a8c6e344a72404039eef838a8cb39295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64847ffcf8f0ad4069085490f9fb5c"><td class="memItemLeft" align="right" valign="top"><a id="a9b64847ffcf8f0ad4069085490f9fb5c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>nvstring_category</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_nvstring_category, GDF_STRING_CATEGORY &gt;</td></tr>
<tr class="separator:a9b64847ffcf8f0ad4069085490f9fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6916ffd2fdcad20b769afc3d4130140e"><td class="memItemLeft" align="right" valign="top"><a id="a6916ffd2fdcad20b769afc3d4130140e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_timestamp, GDF_TIMESTAMP &gt;</td></tr>
<tr class="separator:a6916ffd2fdcad20b769afc3d4130140e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788a6ac25db35f51d612644bebd86970"><td class="memItemLeft" align="right" valign="top"><a id="a788a6ac25db35f51d612644bebd86970"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>date32</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_date32, GDF_DATE32 &gt;</td></tr>
<tr class="separator:a788a6ac25db35f51d612644bebd86970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da9e96ba9d677a713403fb3704600ef"><td class="memItemLeft" align="right" valign="top"><a id="a5da9e96ba9d677a713403fb3704600ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>date64</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_date64, GDF_DATE64 &gt;</td></tr>
<tr class="separator:a5da9e96ba9d677a713403fb3704600ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2916a984683be11ca496ae1535849cb3"><td class="memItemLeft" align="right" valign="top"><a id="a2916a984683be11ca496ae1535849cb3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bool8</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_bool8, GDF_BOOL8 &gt;</td></tr>
<tr class="separator:a2916a984683be11ca496ae1535849cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9130d674f5ef432c1405fadd304a8c26"><td class="memTemplParams" colspan="2"><a id="a9130d674f5ef432c1405fadd304a8c26"></a>
template&lt;typename... &gt; </td></tr>
<tr class="memitem:a9130d674f5ef432c1405fadd304a8c26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>void_t</b> = void</td></tr>
<tr class="separator:a9130d674f5ef432c1405fadd304a8c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc1c1fe68e5031f9865b4d9114a2491"><td class="memTemplParams" colspan="2"><a id="a6cc1c1fe68e5031f9865b4d9114a2491"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a6cc1c1fe68e5031f9865b4d9114a2491"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>less_comparable</b> = decltype(std::declval&lt; L &gt;()&lt; std::declval&lt; R &gt;())</td></tr>
<tr class="separator:a6cc1c1fe68e5031f9865b4d9114a2491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a5866cc4b46bbff21bf863130d2f81"><td class="memTemplParams" colspan="2"><a id="a19a5866cc4b46bbff21bf863130d2f81"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a19a5866cc4b46bbff21bf863130d2f81"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>greater_comparable</b> = decltype(std::declval&lt; L &gt;() &gt; std::declval&lt; R &gt;())</td></tr>
<tr class="separator:a19a5866cc4b46bbff21bf863130d2f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a267e03474dcfd85242d2fdc6e5846ec6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> { <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6a615857bddd061281abf998989fb2ba8f">NEVER</a>, 
<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, 
<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6a995bafc1b2e35df60002e61e2ec0c6df">ALWAYS</a>
 }</td></tr>
<tr class="separator:a267e03474dcfd85242d2fdc6e5846ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d60cf0790fb642cce1c91f1dba63c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8ab424744b6ce548ac355f5830c0a8c5e1">LINEAR</a> =0, 
<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8a00b75d21f696dc9d435e8b4b3c3bc58d">LOWER</a>, 
<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8ae5385a7a8eb742f08471ba73ea2d77ba">HIGHER</a>, 
<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8a7b5062e7868e9d05c598ef7ad6619014">MIDPOINT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8a04fd403d483f6415e0b006bc67bd8fac">NEAREST</a>
<br />
 }</td></tr>
<tr class="memdesc:a94d60cf0790fb642cce1c91f1dba63c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolation method to use, when the desired quantile lies between two data points i and j.  <a href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">More...</a><br /></td></tr>
<tr class="separator:a94d60cf0790fb642cce1c91f1dba63c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> { <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa86ea4bfd2b3121412b0a63a3697926ec">KEEP_FIRST</a> = 0, 
<a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa1d1398f646d74e801389737f07d89d1c">KEEP_LAST</a>, 
<a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa6fb3154b77231184b596b4add407aa2a">KEEP_NONE</a>
 }</td></tr>
<tr class="memdesc:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choices for drop_duplicates API for retainment of duplicate rows.  <a href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">More...</a><br /></td></tr>
<tr class="separator:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750f02016b046079f7062d334890b4fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> : bool { <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fca83ec681a20197326c163ea3b39ef7c32">order::ASCENDING</a>, 
<a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fcacff818f0ae4cef845577e39283886a53">order::DESCENDING</a>
 }</td></tr>
<tr class="separator:a750f02016b046079f7062d334890b4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e6d6e8a21583ce0e85ee73e5abb31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> : bool { <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb">null_order::AFTER</a>, 
<a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07">null_order::BEFORE</a>
 }</td></tr>
<tr class="separator:a058e6d6e8a21583ce0e85ee73e5abb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa481249b705132999f4d082aacd21dbf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> { <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a>, 
<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa37d7c1f4781c3276729ed1678c0c0844">UNINITIALIZED</a>, 
<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfadb86173d779f7b173db120643cc1c402">ALL_VALID</a>, 
<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa042cac70175410616150fafb92f76351">ALL_NULL</a>
 }</td></tr>
<tr class="separator:aa481249b705132999f4d082aacd21dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4cd7157c4379954b5772936f89c59b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">type_id</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59bab2c14e467fcbf9a215ccc679f35bb027">EMPTY</a> = 0, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba71f4b0467efae61c1e3ac5910178940f">INT8</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba7dafa1ea3755308998ff8c972342c099">INT16</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae">INT32</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59bab9c234f82eec5cb83e3ea67aac9c1166">INT64</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba37225001c5ad4b3d1aa808620debfe7a">FLOAT32</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59baf24707a0d5537fd50bca87cd18a9a0e5">FLOAT64</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba9100ee556e5cf9b6dada6c7c506fa138">BOOL8</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59baaff82f65fddd2421f3a4567405848203">DATE32</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba1983b1e0581db578a3461827838dfb72">TIMESTAMP</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59baabcc7f7b028da5bba90f587958cc1026">CATEGORY</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59bae008ab0db4e9b28f33e1e3c9c3daf444">STRING</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba0f6b1e874ab643a0f237082cb35acad5">NUM_TYPE_IDS</a>
<br />
 }</td></tr>
<tr class="separator:acd4cd7157c4379954b5772936f89c59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15567f1034536ae6f7f14179334a19b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">unary_op</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6b585cf453d36fbb0381b38bc2c966e1">SIN</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19baf7c88ff3bee94b5c3c16c405706ef34a">COS</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19baa91cdd09214d36d756b5f13803ddd890">TAN</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba463397f416a024fb7df7d906a0436dbb">ARCSIN</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba1e17febbc6d14208d0a264562dcee2e9">ARCCOS</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19bad1c5c0c8ffe6bf038e617b0aad0f9aac">ARCTAN</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6e272b8c75625066b2c8994cec6c8f73">EXP</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba1509f8449abb15062ad85e15fb3861d7">LOG</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6ac653ea3d15f23b0f6e61b447f783ea">SQRT</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba8b0d502b44d1472a2d5fa3638f0ce945">CEIL</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba07e330cc72f454a6369d267d1bfb2d7e">FLOOR</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19bab226be3789467f51f32cf06550a4c46e">ABS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba62a7f82a72f8422f631cb550b7201667">BIT_INVERT</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba5e654d9830c09fc254d4f9f19fbdfe6e">NOT</a>
<br />
 }</td></tr>
<tr class="memdesc:ab15567f1034536ae6f7f14179334a19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of unary operations that can be performed on data.  <a href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">More...</a><br /></td></tr>
<tr class="separator:ab15567f1034536ae6f7f14179334a19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae942e9a8d320f23d61bee22ddc06df55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae942e9a8d320f23d61bee22ddc06df55">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *lhs, <a class="el" href="structgdf__column__.html">gdf_column</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:ae942e9a8d320f23d61bee22ddc06df55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> and a gdf_column.  <a href="namespacecudf.html#ae942e9a8d320f23d61bee22ddc06df55">More...</a><br /></td></tr>
<tr class="separator:ae942e9a8d320f23d61bee22ddc06df55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02af1454978d7d7f7b9f651437b3ab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa02af1454978d7d7f7b9f651437b3ab5">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__column__.html">gdf_column</a> *lhs, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:aa02af1454978d7d7f7b9f651437b3ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a gdf_column and a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a>.  <a href="namespacecudf.html#aa02af1454978d7d7f7b9f651437b3ab5">More...</a><br /></td></tr>
<tr class="separator:aa02af1454978d7d7f7b9f651437b3ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad01e2e81bc2b671dfb8963a7be22e3b0">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__column__.html">gdf_column</a> *lhs, <a class="el" href="structgdf__column__.html">gdf_column</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two gdf_columns.  <a href="namespacecudf.html#ad01e2e81bc2b671dfb8963a7be22e3b0">More...</a><br /></td></tr>
<tr class="separator:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f727c257f82efc1a7b144eb6dcbb2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a1f727c257f82efc1a7b144eb6dcbb2d8">binary_operation</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;lhs, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;rhs, const std::string &amp;ptx, gdf_dtype output_type)</td></tr>
<tr class="memdesc:a1f727c257f82efc1a7b144eb6dcbb2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two gdf_columns using a user-defined PTX function.  <a href="namespacecudf.html#a1f727c257f82efc1a7b144eb6dcbb2d8">More...</a><br /></td></tr>
<tr class="separator:a1f727c257f82efc1a7b144eb6dcbb2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="memItemLeft" align="right" valign="top">rmm::device_vector&lt; bit_mask::bit_mask_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aec006bc00092dd8ec47f2c7ca6fe01d4">row_bitmask</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a bitmask indicating the presence of NULL values in rows of a table.  <a href="namespacecudf.html#aec006bc00092dd8ec47f2c7ca6fe01d4">More...</a><br /></td></tr>
<tr class="separator:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48561f1e899da3a79132c108463840de"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a48561f1e899da3a79132c108463840de">state_null_count</a> (<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> state, size_type size)</td></tr>
<tr class="memdesc:a48561f1e899da3a79132c108463840de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the null count for a null mask of the specified <code>state</code> representing <code>size</code> elements.  <a href="namespacecudf.html#a48561f1e899da3a79132c108463840de">More...</a><br /></td></tr>
<tr class="separator:a48561f1e899da3a79132c108463840de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26b8cbca80321602bc3f39ab6cce8d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3c26b8cbca80321602bc3f39ab6cce8d">bitmask_allocation_size_bytes</a> (size_type number_of_bits, std::size_t padding_boundary=64)</td></tr>
<tr class="memdesc:a3c26b8cbca80321602bc3f39ab6cce8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the required bytes necessary to represent the specified number of bits with a given padding boundary.  <a href="namespacecudf.html#a3c26b8cbca80321602bc3f39ab6cce8d">More...</a><br /></td></tr>
<tr class="separator:a3c26b8cbca80321602bc3f39ab6cce8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5834edc8cde53fb6b23f2e95847c8066"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5834edc8cde53fb6b23f2e95847c8066">create_null_mask</a> (size_type size, <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> state, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a5834edc8cde53fb6b23f2e95847c8066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdevice__buffer.html" title="A helper class that owns a resizable device memory buffer.">device_buffer</a></code> for use as a null value indicator bitmask of a <code>column</code>.  <a href="namespacecudf.html#a5834edc8cde53fb6b23f2e95847c8066">More...</a><br /></td></tr>
<tr class="separator:a5834edc8cde53fb6b23f2e95847c8066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8405a236b985ea3d8a626f92e40658c"><td class="memItemLeft" align="right" valign="top">cudf::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae8405a236b985ea3d8a626f92e40658c">count_set_bits</a> (bitmask_type const  *bitmask, size_type start, size_type stop)</td></tr>
<tr class="memdesc:ae8405a236b985ea3d8a626f92e40658c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bitmask, counts the number of set (1) bits in the range <code>[start, stop)</code>  <a href="namespacecudf.html#ae8405a236b985ea3d8a626f92e40658c">More...</a><br /></td></tr>
<tr class="separator:ae8405a236b985ea3d8a626f92e40658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff1677d6e025ceb78e4fdc631125170"><td class="memItemLeft" align="right" valign="top">cudf::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aeff1677d6e025ceb78e4fdc631125170">count_unset_bits</a> (bitmask_type const  *bitmask, size_type start, size_type stop)</td></tr>
<tr class="memdesc:aeff1677d6e025ceb78e4fdc631125170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bitmask, counts the number of unset (0) bits in the range <code>[start, stop)</code>.  <a href="namespacecudf.html#aeff1677d6e025ceb78e4fdc631125170">More...</a><br /></td></tr>
<tr class="separator:aeff1677d6e025ceb78e4fdc631125170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084ff0262deda4407ff67857cf1660c0"><td class="memTemplParams" colspan="2">template&lt;typename bit_container , typename predicate , typename size_type &gt; </td></tr>
<tr class="memitem:a084ff0262deda4407ff67857cf1660c0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bit_container *, size_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a084ff0262deda4407ff67857cf1660c0">valid_if</a> (const bit_container *source_mask, const predicate &amp;p, size_type num_bits, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a084ff0262deda4407ff67857cf1660c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a bitmask where every bit is marked with valid if and only if predicate(bit) and source_mask(bit) are both true.  <a href="namespacecudf.html#a084ff0262deda4407ff67857cf1660c0">More...</a><br /></td></tr>
<tr class="separator:a084ff0262deda4407ff67857cf1660c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57781c8d2648ef021718b0f87aadfe1"><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa57781c8d2648ef021718b0f87aadfe1">copy_offset_bitmask</a> (bitmask_type *__restrict__ destination, bitmask_type const *__restrict__ source, size_type bit_offset, size_type number_of_bits)</td></tr>
<tr class="memdesc:aa57781c8d2648ef021718b0f87aadfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the bits starting at the specified offset from a source bitmask into the destination bitmask.  <a href="namespacecudf.html#aa57781c8d2648ef021718b0f87aadfe1">More...</a><br /></td></tr>
<tr class="separator:aa57781c8d2648ef021718b0f87aadfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b0daf2c01663d51cb3b87ad8ce93c0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a51b0daf2c01663d51cb3b87ad8ce93c0">size_of</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> t)</td></tr>
<tr class="memdesc:a51b0daf2c01663d51cb3b87ad8ce93c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of elements of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>  <a href="namespacecudf.html#a51b0daf2c01663d51cb3b87ad8ce93c0">More...</a><br /></td></tr>
<tr class="separator:a51b0daf2c01663d51cb3b87ad8ce93c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67659a0dfb8fb06d47d196b59544e9f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae67659a0dfb8fb06d47d196b59544e9f">make_numeric_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> state=<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ae67659a0dfb8fb06d47d196b59544e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <a href="namespacecudf.html#ae67659a0dfb8fb06d47d196b59544e9f">More...</a><br /></td></tr>
<tr class="separator:ae67659a0dfb8fb06d47d196b59544e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef675a9c75a848ab796ae9b2b51c4238"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aef675a9c75a848ab796ae9b2b51c4238">count_descendants</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> parent)</td></tr>
<tr class="memdesc:aef675a9c75a848ab796ae9b2b51c4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of descendants of the specified parent.  <a href="namespacecudf.html#aef675a9c75a848ab796ae9b2b51c4238">More...</a><br /></td></tr>
<tr class="separator:aef675a9c75a848ab796ae9b2b51c4238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38150f11c542f3238874911d4a30a530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a38150f11c542f3238874911d4a30a530">allocate_column</a> (gdf_dtype dtype, gdf_size_type size, bool allocate_mask=true, <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> info=<a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>{}, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a38150f11c542f3238874911d4a30a530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new column of the specified size and type.  <a href="namespacecudf.html#a38150f11c542f3238874911d4a30a530">More...</a><br /></td></tr>
<tr class="separator:a38150f11c542f3238874911d4a30a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206ad1cc4b21f7f14c5d5f7d304efbda"><td class="memItemLeft" align="right" valign="top"><a id="a206ad1cc4b21f7f14c5d5f7d304efbda"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><b>empty_like</b> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input)</td></tr>
<tr class="separator:a206ad1cc4b21f7f14c5d5f7d304efbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67e312abf9656990598ba81dfcef15c"><td class="memItemLeft" align="right" valign="top"><a id="ae67e312abf9656990598ba81dfcef15c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>should_allocate_mask</b> (<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc, bool mask_exists)</td></tr>
<tr class="separator:ae67e312abf9656990598ba81dfcef15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72ee052f776990ab9240e757d8493ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ac72ee052f776990ab9240e757d8493ad">allocate_like</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:ac72ee052f776990ab9240e757d8493ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new column of the same size and type as the input.  <a href="namespacecudf.html#ac72ee052f776990ab9240e757d8493ad">More...</a><br /></td></tr>
<tr class="separator:ac72ee052f776990ab9240e757d8493ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05145f762859aea7d4cc2fac5b7b96eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a05145f762859aea7d4cc2fac5b7b96eb">allocate_like</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, gdf_size_type size, <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a05145f762859aea7d4cc2fac5b7b96eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new column of the specified size and same type as the input.  <a href="namespacecudf.html#a05145f762859aea7d4cc2fac5b7b96eb">More...</a><br /></td></tr>
<tr class="separator:a05145f762859aea7d4cc2fac5b7b96eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa7e6bf39cb5dd5cdb370d0a562675922">copy</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column that is a copy of input.  <a href="namespacecudf.html#aa7e6bf39cb5dd5cdb370d0a562675922">More...</a><br /></td></tr>
<tr class="separator:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3588fc0b833a8f2d7213651a05f48c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3588fc0b833a8f2d7213651a05f48c80">empty_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t)</td></tr>
<tr class="memdesc:a3588fc0b833a8f2d7213651a05f48c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of empty columns with the same types as the inputs.  <a href="namespacecudf.html#a3588fc0b833a8f2d7213651a05f48c80">More...</a><br /></td></tr>
<tr class="separator:a3588fc0b833a8f2d7213651a05f48c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada80dc11907eac4cd65640233b777452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ada80dc11907eac4cd65640233b777452">allocate_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:ada80dc11907eac4cd65640233b777452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns with the same type and allocation size as the input.  <a href="namespacecudf.html#ada80dc11907eac4cd65640233b777452">More...</a><br /></td></tr>
<tr class="separator:ada80dc11907eac4cd65640233b777452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1a9329f3d83fd791f27a26a3abc48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0bb1a9329f3d83fd791f27a26a3abc48">allocate_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, gdf_size_type size, <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a0bb1a9329f3d83fd791f27a26a3abc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns with the specified size and same type as the input.  <a href="namespacecudf.html#a0bb1a9329f3d83fd791f27a26a3abc48">More...</a><br /></td></tr>
<tr class="separator:a0bb1a9329f3d83fd791f27a26a3abc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a9fae65b5e23d13aec03edef7a8aeacb0">copy</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns and deep copies the data from an input table.  <a href="namespacecudf.html#a9fae65b5e23d13aec03edef7a8aeacb0">More...</a><br /></td></tr>
<tr class="separator:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67996c2986be62de33c6685e1702755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab67996c2986be62de33c6685e1702755">copy_range</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out_column, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;in_column, gdf_index_type out_begin, gdf_index_type out_end, gdf_index_type in_begin)</td></tr>
<tr class="memdesc:ab67996c2986be62de33c6685e1702755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements from one column to another.  <a href="namespacecudf.html#ab67996c2986be62de33c6685e1702755">More...</a><br /></td></tr>
<tr class="separator:ab67996c2986be62de33c6685e1702755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3571c0c6314b622d87a18281ad08e212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3571c0c6314b622d87a18281ad08e212">gather</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, <a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;gather_map, bool check_bounds=false)</td></tr>
<tr class="memdesc:a3571c0c6314b622d87a18281ad08e212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the the specified rows (including null values) of a set of columns, returning the result as a <code>table</code>.  <a href="namespacecudf.html#a3571c0c6314b622d87a18281ad08e212">More...</a><br /></td></tr>
<tr class="separator:a3571c0c6314b622d87a18281ad08e212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89365977c2da3d50a3262a1e540d1352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a89365977c2da3d50a3262a1e540d1352">gather</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, <a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;gather_map, <a class="el" href="structcudf_1_1table.html">table</a> *destination_table, bool check_bounds=false)</td></tr>
<tr class="memdesc:a89365977c2da3d50a3262a1e540d1352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows (including null values) of a set of source columns into a set of destination columns.  <a href="namespacecudf.html#a89365977c2da3d50a3262a1e540d1352">More...</a><br /></td></tr>
<tr class="separator:a89365977c2da3d50a3262a1e540d1352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2586b61fb4ca3ccf1fb3e0eed8cc981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab2586b61fb4ca3ccf1fb3e0eed8cc981">gather</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, gdf_index_type const gather_map[], <a class="el" href="structcudf_1_1table.html">table</a> *destination_table, bool check_bounds=false)</td></tr>
<tr class="memdesc:ab2586b61fb4ca3ccf1fb3e0eed8cc981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows (including null values) of a set of source columns into a set of destination columns.  <a href="namespacecudf.html#ab2586b61fb4ca3ccf1fb3e0eed8cc981">More...</a><br /></td></tr>
<tr class="separator:ab2586b61fb4ca3ccf1fb3e0eed8cc981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ee593defbe8e2fcaa05b50fbd6612e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae9ee593defbe8e2fcaa05b50fbd6612e">scatter</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;source, <a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;scatter_map, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;target, bool check_bounds=false)</td></tr>
<tr class="memdesc:ae9ee593defbe8e2fcaa05b50fbd6612e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>table</code> as if an in-place scatter from a <code>source</code> table was performed on the <code>target</code> table.  <a href="namespacecudf.html#ae9ee593defbe8e2fcaa05b50fbd6612e">More...</a><br /></td></tr>
<tr class="separator:ae9ee593defbe8e2fcaa05b50fbd6612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65bd33669f3f37267a3b3db66a21aa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad65bd33669f3f37267a3b3db66a21aa1">scatter</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;source, gdf_index_type const scatter_map[], <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;target, bool check_bounds=false)</td></tr>
<tr class="memdesc:ad65bd33669f3f37267a3b3db66a21aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>table</code> as if an in-place scatter from a <code>source</code> table was performed on the <code>target</code> table.  <a href="namespacecudf.html#ad65bd33669f3f37267a3b3db66a21aa1">More...</a><br /></td></tr>
<tr class="separator:ad65bd33669f3f37267a3b3db66a21aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f032f6bab98db53bf7fa76259e09e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a8f032f6bab98db53bf7fa76259e09e92">scatter</a> (std::vector&lt; <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &gt; const  &amp;source, gdf_index_type const scatter_map[], gdf_size_type num_scatter_rows, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;target)</td></tr>
<tr class="memdesc:a8f032f6bab98db53bf7fa76259e09e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>table</code> as if scattering a set of <code><a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a></code> values into the rows of a <code>target</code> table in-place.  <a href="namespacecudf.html#a8f032f6bab98db53bf7fa76259e09e92">More...</a><br /></td></tr>
<tr class="separator:a8f032f6bab98db53bf7fa76259e09e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa398ba021c84cb39c9e1dcd65d81b64"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaa398ba021c84cb39c9e1dcd65d81b64">scatter_to_tables</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;input, <a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;scatter_map)</td></tr>
<tr class="memdesc:aaa398ba021c84cb39c9e1dcd65d81b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of a table to <code>n</code> tables according to a scatter map.  <a href="namespacecudf.html#aaa398ba021c84cb39c9e1dcd65d81b64">More...</a><br /></td></tr>
<tr class="separator:aaa398ba021c84cb39c9e1dcd65d81b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e5ff580a7ad1c81368264f69934d9d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a55e5ff580a7ad1c81368264f69934d9d">slice</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input, gdf_index_type const  *indices, gdf_size_type num_indices)</td></tr>
<tr class="memdesc:a55e5ff580a7ad1c81368264f69934d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a column (including null values) into a set of columns according to a set of indices.  <a href="namespacecudf.html#a55e5ff580a7ad1c81368264f69934d9d">More...</a><br /></td></tr>
<tr class="separator:a55e5ff580a7ad1c81368264f69934d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaaf55ec673b3a12f07a16182603fcb"><td class="memItemLeft" align="right" valign="top"><a id="adcaaf55ec673b3a12f07a16182603fcb"></a>
rmm::device_vector&lt; gdf_index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>splits_to_slice_indices</b> (gdf_index_type const *splits, gdf_size_type const num_splits, gdf_index_type const split_end)</td></tr>
<tr class="separator:adcaaf55ec673b3a12f07a16182603fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934a77ba7b53046d100f9c2a164be97b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a934a77ba7b53046d100f9c2a164be97b">split</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input, gdf_index_type const  *splits, gdf_size_type num_splits)</td></tr>
<tr class="memdesc:a934a77ba7b53046d100f9c2a164be97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a column (including null values) into a set of columns according to a set of indices.  <a href="namespacecudf.html#a934a77ba7b53046d100f9c2a164be97b">More...</a><br /></td></tr>
<tr class="separator:a934a77ba7b53046d100f9c2a164be97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdaf17cbac0f8976b27199b4aed31f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0fdaf17cbac0f8976b27199b4aed31f5">fill</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *<a class="el" href="classcudf_1_1column.html">column</a>, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> const  &amp;value, gdf_index_type begin, gdf_index_type end)</td></tr>
<tr class="memdesc:a0fdaf17cbac0f8976b27199b4aed31f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in a column with a scalar value.  <a href="namespacecudf.html#a0fdaf17cbac0f8976b27199b4aed31f5">More...</a><br /></td></tr>
<tr class="separator:a0fdaf17cbac0f8976b27199b4aed31f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c4ffa4dba2b1e23f4f4322f7b06408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae7c4ffa4dba2b1e23f4f4322f7b06408">repeat</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;in, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;count)</td></tr>
<tr class="memdesc:ae7c4ffa4dba2b1e23f4f4322f7b06408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <a href="namespacecudf.html#ae7c4ffa4dba2b1e23f4f4322f7b06408">More...</a><br /></td></tr>
<tr class="separator:ae7c4ffa4dba2b1e23f4f4322f7b06408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00deb58e53fc1648eb5dce3e79d0790c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a00deb58e53fc1648eb5dce3e79d0790c">repeat</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;in, const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;count)</td></tr>
<tr class="memdesc:a00deb58e53fc1648eb5dce3e79d0790c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <a href="namespacecudf.html#a00deb58e53fc1648eb5dce3e79d0790c">More...</a><br /></td></tr>
<tr class="separator:a00deb58e53fc1648eb5dce3e79d0790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c6e502e3755eefe9a720cdf0f3ed5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a30c6e502e3755eefe9a720cdf0f3ed5e">point_in_polygon</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;polygon_latitudes, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;polygon_longitudes, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;query_point_latitudes, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;query_point_longitudes)</td></tr>
<tr class="memdesc:a30c6e502e3755eefe9a720cdf0f3ed5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not coordinates (query points) are completely inside a static polygon.  <a href="namespacecudf.html#a30c6e502e3755eefe9a720cdf0f3ed5e">More...</a><br /></td></tr>
<tr class="separator:a30c6e502e3755eefe9a720cdf0f3ed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b0228c369a3729572f77dcbbe490be"><td class="memItemLeft" align="right" valign="top"><a id="a10b0228c369a3729572f77dcbbe490be"></a>
std::pair&lt; gdf_dtype, <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convertStringToDtype</b> (const std::string &amp;dtype)</td></tr>
<tr class="separator:a10b0228c369a3729572f77dcbbe490be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb570307357da1e8c28cee58d653b5cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#acb570307357da1e8c28cee58d653b5cb">inferCompressionType</a> (const std::string &amp;compression_arg, gdf_input_type source_type, const std::string &amp;source, const std::map&lt; std::string, std::string &gt; &amp;ext_to_compression)</td></tr>
<tr class="memdesc:acb570307357da1e8c28cee58d653b5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the compression type from the compression parameter and the input data.  <a href="namespacecudf.html#acb570307357da1e8c28cee58d653b5cb">More...</a><br /></td></tr>
<tr class="separator:acb570307357da1e8c28cee58d653b5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7969fa8f427959b25681e979ea2c01a"><td class="memItemLeft" align="right" valign="top"><a id="aa7969fa8f427959b25681e979ea2c01a"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_avro</b> (<a class="el" href="structcudf_1_1avro__read__arg.html">avro_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:aa7969fa8f427959b25681e979ea2c01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59a215482cdc7bc3ba850d2a0fa9f86"><td class="memItemLeft" align="right" valign="top"><a id="ab59a215482cdc7bc3ba850d2a0fa9f86"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_csv</b> (<a class="el" href="structcudf_1_1csv__read__arg.html">csv_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:ab59a215482cdc7bc3ba850d2a0fa9f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2430dcb97885610d55a2ddc34f7e8c1e"><td class="memItemLeft" align="right" valign="top"><a id="a2430dcb97885610d55a2ddc34f7e8c1e"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_json</b> (<a class="el" href="structcudf_1_1json__read__arg.html">json_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:a2430dcb97885610d55a2ddc34f7e8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ad77aef16f9ee3607c92778e14417"><td class="memItemLeft" align="right" valign="top"><a id="af36ad77aef16f9ee3607c92778e14417"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_orc</b> (<a class="el" href="structcudf_1_1orc__read__arg.html">orc_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:af36ad77aef16f9ee3607c92778e14417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67681fe72eda8509719c0ba70c1d12c"><td class="memItemLeft" align="right" valign="top"><a id="af67681fe72eda8509719c0ba70c1d12c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_orc</b> (<a class="el" href="structcudf_1_1orc__write__arg.html">orc_write_arg</a> const &amp;args)</td></tr>
<tr class="separator:af67681fe72eda8509719c0ba70c1d12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67516b133f0735f23f0024f86d8756d8"><td class="memItemLeft" align="right" valign="top"><a id="a67516b133f0735f23f0024f86d8756d8"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_parquet</b> (<a class="el" href="structcudf_1_1parquet__read__arg.html">parquet_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:a67516b133f0735f23f0024f86d8756d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5315ca38e017e2ed42a400483bba3b56"><td class="memTemplParams" colspan="2">template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a5315ca38e017e2ed42a400483bba3b56"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5315ca38e017e2ed42a400483bba3b56">make_iterator</a> (const ElementType *data, const bit_mask::bit_mask_t *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="memdesc:a5315ca38e017e2ed42a400483bba3b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an iterator over the elements of a column.  <a href="namespacecudf.html#a5315ca38e017e2ed42a400483bba3b56">More...</a><br /></td></tr>
<tr class="separator:a5315ca38e017e2ed42a400483bba3b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4644fa78d40f010ce935b4358d1a9e25"><td class="memTemplParams" colspan="2"><a id="a4644fa78d40f010ce935b4358d1a9e25"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a4644fa78d40f010ce935b4358d1a9e25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_iterator</b> (const ElementType *data, const gdf_valid_type *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a4644fa78d40f010ce935b4358d1a9e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memTemplParams" colspan="2"><a id="af06d674f7e1bd773e4166ef4d7fcf959"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_iterator</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memTemplParams" colspan="2">template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a20b11ec1348ab46ae20792ea4e2c0ca4">make_pair_iterator</a> (const ElementType *data, const bit_mask::bit_mask_t *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="memdesc:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an iterator over the elements of a column Input iterator which can be used for cub and thrust.  <a href="namespacecudf.html#a20b11ec1348ab46ae20792ea4e2c0ca4">More...</a><br /></td></tr>
<tr class="separator:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee5f476efe3d2ba71060aa0ffe202f"><td class="memTemplParams" colspan="2"><a id="a8fee5f476efe3d2ba71060aa0ffe202f"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a8fee5f476efe3d2ba71060aa0ffe202f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pair_iterator</b> (const ElementType *data, const gdf_valid_type *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a8fee5f476efe3d2ba71060aa0ffe202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f930d43783b2f9ff84a219b19d245"><td class="memTemplParams" colspan="2"><a id="a657f930d43783b2f9ff84a219b19d245"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a657f930d43783b2f9ff84a219b19d245"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pair_iterator</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a657f930d43783b2f9ff84a219b19d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec456ad746337e9471efaee3772a273"><td class="memTemplParams" colspan="2">template&lt;typename data_type &gt; </td></tr>
<tr class="memitem:a3ec456ad746337e9471efaee3772a273"><td class="memTemplItemLeft" align="right" valign="top">gdf_error&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3ec456ad746337e9471efaee3772a273">allocValueBuffer</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> **buffer, const gdf_size_type buffer_length, const <a class="el" href="classcudf_1_1data__type.html">data_type</a> value)</td></tr>
<tr class="memdesc:a3ec456ad746337e9471efaee3772a273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer and fills it with a repeated value.  <a href="namespacecudf.html#a3ec456ad746337e9471efaee3772a273">More...</a><br /></td></tr>
<tr class="separator:a3ec456ad746337e9471efaee3772a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dbfc21702c222d9d113f16cd448535"><td class="memTemplParams" colspan="2">template&lt;typename data_type &gt; </td></tr>
<tr class="memitem:a59dbfc21702c222d9d113f16cd448535"><td class="memTemplItemLeft" align="right" valign="top">gdf_error&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a59dbfc21702c222d9d113f16cd448535">allocSequenceBuffer</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> **buffer, const gdf_size_type buffer_length)</td></tr>
<tr class="memdesc:a59dbfc21702c222d9d113f16cd448535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer and fills it with a sequence.  <a href="namespacecudf.html#a59dbfc21702c222d9d113f16cd448535">More...</a><br /></td></tr>
<tr class="separator:a59dbfc21702c222d9d113f16cd448535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb548c461266cacc3b713e8007405a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#acb548c461266cacc3b713e8007405a8f">trivial_full_join</a> (const gdf_size_type left_size, const gdf_size_type right_size, <a class="el" href="structgdf__column__.html">gdf_column</a> *left_result, <a class="el" href="structgdf__column__.html">gdf_column</a> *right_result)</td></tr>
<tr class="memdesc:acb548c461266cacc3b713e8007405a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivially computes full join of two tables if one of the tables are empty.  <a href="namespacecudf.html#acb548c461266cacc3b713e8007405a8f">More...</a><br /></td></tr>
<tr class="separator:acb548c461266cacc3b713e8007405a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324e3af1901162a99c4e182255e63964"><td class="memTemplParams" colspan="2">template&lt;JoinType join_type&gt; </td></tr>
<tr class="memitem:a324e3af1901162a99c4e182255e63964"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a324e3af1901162a99c4e182255e63964">join_call</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, <a class="el" href="structgdf__column__.html">gdf_column</a> *left_result, <a class="el" href="structgdf__column__.html">gdf_column</a> *right_result, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="memdesc:a324e3af1901162a99c4e182255e63964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the join operation between two sets of columns.  <a href="namespacecudf.html#a324e3af1901162a99c4e182255e63964">More...</a><br /></td></tr>
<tr class="separator:a324e3af1901162a99c4e182255e63964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2fab609bbc1f3b044d5d5f62d37a84"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0e2fab609bbc1f3b044d5d5f62d37a84">non_common_column_indices</a> (gdf_size_type num_columns, std::vector&lt; gdf_size_type &gt; const &amp;common_column_indices)</td></tr>
<tr class="memdesc:a0e2fab609bbc1f3b044d5d5f62d37a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with non-common indices which is set difference between <code>[0, num_columns)</code> and index values in common_column_indices.  <a href="namespacecudf.html#a0e2fab609bbc1f3b044d5d5f62d37a84">More...</a><br /></td></tr>
<tr class="separator:a0e2fab609bbc1f3b044d5d5f62d37a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7345416cce5579459662d19778ab229f"><td class="memTemplParams" colspan="2">template&lt;JoinType join_type, typename index_type &gt; </td></tr>
<tr class="memitem:a7345416cce5579459662d19778ab229f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a7345416cce5579459662d19778ab229f">construct_join_output_df</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; std::pair&lt; gdf_size_type, gdf_size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structgdf__column__.html">gdf_column</a> *left_indices, <a class="el" href="structgdf__column__.html">gdf_column</a> *right_indices)</td></tr>
<tr class="memdesc:a7345416cce5579459662d19778ab229f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers rows indicated by <code>left_indices</code> and <code>right_indices</code> from tables <code>left</code> and <code>right</code>, respectively, into a single <code>table</code>.  <a href="namespacecudf.html#a7345416cce5579459662d19778ab229f">More...</a><br /></td></tr>
<tr class="separator:a7345416cce5579459662d19778ab229f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6ad074553cd2057f34df199598e8e1"><td class="memTemplParams" colspan="2">template&lt;JoinType join_type, typename index_type &gt; </td></tr>
<tr class="memitem:a0e6ad074553cd2057f34df199598e8e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0e6ad074553cd2057f34df199598e8e1">join_call_compute_df</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; gdf_size_type &gt; const &amp;left_on, std::vector&lt; gdf_size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; gdf_size_type, gdf_size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structcudf_1_1table.html">cudf::table</a> *joined_indices, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="memdesc:a0e6ad074553cd2057f34df199598e8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs join on the columns provided in <code>left</code> and <code>right</code> as per the joining indices given in <code>left_on</code> and <code>right_on</code> and creates a single table.  <a href="namespacecudf.html#a0e6ad074553cd2057f34df199598e8e1">More...</a><br /></td></tr>
<tr class="separator:a0e6ad074553cd2057f34df199598e8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07760ea9aedb894bdec9ce6c77fef69"><td class="memItemLeft" align="right" valign="top"><a id="ad07760ea9aedb894bdec9ce6c77fef69"></a>
<a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>left_join</b> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; gdf_size_type &gt; const &amp;left_on, std::vector&lt; gdf_size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; gdf_size_type, gdf_size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structcudf_1_1table.html">cudf::table</a> *joined_indices, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="separator:ad07760ea9aedb894bdec9ce6c77fef69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1bb812744126150b7dcfc8ed13cb1d"><td class="memItemLeft" align="right" valign="top"><a id="ade1bb812744126150b7dcfc8ed13cb1d"></a>
<a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inner_join</b> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; gdf_size_type &gt; const &amp;left_on, std::vector&lt; gdf_size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; gdf_size_type, gdf_size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structcudf_1_1table.html">cudf::table</a> *joined_indices, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="separator:ade1bb812744126150b7dcfc8ed13cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa115ae10ce90ce8c88f274f2355554a0"><td class="memItemLeft" align="right" valign="top"><a id="aa115ae10ce90ce8c88f274f2355554a0"></a>
<a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>full_join</b> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; gdf_size_type &gt; const &amp;left_on, std::vector&lt; gdf_size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; gdf_size_type, gdf_size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structcudf_1_1table.html">cudf::table</a> *joined_indices, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="separator:aa115ae10ce90ce8c88f274f2355554a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9b7e3e01a011595712fcaa6fb3a678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aba9b7e3e01a011595712fcaa6fb3a678">merge</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;left_table, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;right_table, std::vector&lt; gdf_size_type &gt; const  &amp;key_cols, std::vector&lt; order_by_type &gt; const  &amp;asc_desc, bool nulls_are_smallest=false)</td></tr>
<tr class="memdesc:aba9b7e3e01a011595712fcaa6fb3a678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted tables.  <a href="namespacecudf.html#aba9b7e3e01a011595712fcaa6fb3a678">More...</a><br /></td></tr>
<tr class="separator:aba9b7e3e01a011595712fcaa6fb3a678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac52a52a504d46887f1368ae13a96ffb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aac52a52a504d46887f1368ae13a96ffb">is_sorted</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>, std::vector&lt; int8_t &gt; const  &amp;descending, bool nulls_are_smallest)</td></tr>
<tr class="memdesc:aac52a52a504d46887f1368ae13a96ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the rows of a <code>table</code> are sorted in a lexicographical order.  <a href="namespacecudf.html#aac52a52a504d46887f1368ae13a96ffb">More...</a><br /></td></tr>
<tr class="separator:aac52a52a504d46887f1368ae13a96ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c828f318cb2c14c8ac0567f5084d1e7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a>, <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a6c828f318cb2c14c8ac0567f5084d1e7">group_quantiles</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;keys, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;values, std::vector&lt; double &gt; const  &amp;quantiles, <a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a> <a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a>=<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8ab424744b6ce548ac355f5830c0a8c5e1">LINEAR</a>, bool include_nulls=false)</td></tr>
<tr class="memdesc:a6c828f318cb2c14c8ac0567f5084d1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find values at given quantiles within groups.  <a href="namespacecudf.html#a6c828f318cb2c14c8ac0567f5084d1e7">More...</a><br /></td></tr>
<tr class="separator:a6c828f318cb2c14c8ac0567f5084d1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aad879c6bbd17521333c06dab5db483"><td class="memItemLeft" align="right" valign="top">gdf_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3aad879c6bbd17521333c06dab5db483">quantile_exact</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *col_in, <a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a> prec, double q, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *result, <a class="el" href="structgdf__context__.html">gdf_context</a> *ctxt)</td></tr>
<tr class="memdesc:a3aad879c6bbd17521333c06dab5db483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes exact quantile.  <a href="namespacecudf.html#a3aad879c6bbd17521333c06dab5db483">More...</a><br /></td></tr>
<tr class="separator:a3aad879c6bbd17521333c06dab5db483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecb9e39d5b5475f53260497f3a8db0a"><td class="memItemLeft" align="right" valign="top">gdf_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaecb9e39d5b5475f53260497f3a8db0a">quantile_approx</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *col_in, double q, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *result, <a class="el" href="structgdf__context__.html">gdf_context</a> *ctxt)</td></tr>
<tr class="memdesc:aaecb9e39d5b5475f53260497f3a8db0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes approximate quantile.  <a href="namespacecudf.html#aaecb9e39d5b5475f53260497f3a8db0a">More...</a><br /></td></tr>
<tr class="separator:aaecb9e39d5b5475f53260497f3a8db0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34eb2aea42d4ee97fb98cc4b38dabd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__scalar.html">gdf_scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a34eb2aea42d4ee97fb98cc4b38dabd7c">reduce</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *col, cudf::reduction::operators op, gdf_dtype output_dtype, gdf_size_type ddof=1)</td></tr>
<tr class="memdesc:a34eb2aea42d4ee97fb98cc4b38dabd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision <code>dtype</code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> will contain <code>false</code>.  <a href="namespacecudf.html#a34eb2aea42d4ee97fb98cc4b38dabd7c">More...</a><br /></td></tr>
<tr class="separator:a34eb2aea42d4ee97fb98cc4b38dabd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a65546aa9c42e87334fb5e1e3f274bc6b">scan</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *input, <a class="el" href="structgdf__column__.html">gdf_column</a> *output, gdf_scan_op op, bool inclusive)</td></tr>
<tr class="memdesc:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null.  <a href="namespacecudf.html#a65546aa9c42e87334fb5e1e3f274bc6b">More...</a><br /></td></tr>
<tr class="separator:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e93b1c814e07e108ad015d27ca2372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a68e93b1c814e07e108ad015d27ca2372">find_and_replace_all</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input_col, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;values_to_replace, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;replacement_values)</td></tr>
<tr class="memdesc:a68e93b1c814e07e108ad015d27ca2372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements from <code>input_col</code> according to the mapping <code>values_to_replace</code> to <code>replacement_values</code>, that is, replace all <code>values_to_replace[i]</code> present in <code>input_col</code> with <code>replacement_values[i]</code>.  <a href="namespacecudf.html#a68e93b1c814e07e108ad015d27ca2372">More...</a><br /></td></tr>
<tr class="separator:a68e93b1c814e07e108ad015d27ca2372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85645250c7ada0b73a61e9a691931b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a85645250c7ada0b73a61e9a691931b36">replace_nulls</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;replacement)</td></tr>
<tr class="memdesc:a85645250c7ada0b73a61e9a691931b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with corresponding values of another column.  <a href="namespacecudf.html#a85645250c7ada0b73a61e9a691931b36">More...</a><br /></td></tr>
<tr class="separator:a85645250c7ada0b73a61e9a691931b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad66cc66793473e7fc90ad3ed4cd1b450">replace_nulls</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input, const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;replacement)</td></tr>
<tr class="memdesc:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with a scalar.  <a href="namespacecudf.html#ad66cc66793473e7fc90ad3ed4cd1b450">More...</a><br /></td></tr>
<tr class="separator:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d88717a2c068bbfac0f10352296c09"><td class="memItemLeft" align="right" valign="top"><a id="aa9d88717a2c068bbfac0f10352296c09"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rolling_window</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input_col, gdf_size_type window, gdf_size_type min_periods, gdf_size_type forward_window, gdf_agg_op agg_type, const gdf_size_type *window_col, const gdf_size_type *min_periods_col, const gdf_size_type *forward_window_col)</td></tr>
<tr class="separator:aa9d88717a2c068bbfac0f10352296c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea7916598188f7011fdcfcadbb71cac"><td class="memItemLeft" align="right" valign="top"><a id="abea7916598188f7011fdcfcadbb71cac"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rolling_window</b> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input, gdf_size_type window, gdf_size_type min_periods, gdf_size_type forward_window, const std::string &amp;user_defined_aggregator, gdf_agg_op agg_op, gdf_dtype output_type, gdf_size_type const *window_col, gdf_size_type const *min_periods_col, gdf_size_type const *forward_window_col)</td></tr>
<tr class="separator:abea7916598188f7011fdcfcadbb71cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90960c52c1f1fe3ab2257bad89b18fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae90960c52c1f1fe3ab2257bad89b18fc">lower_bound</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;values, std::vector&lt; bool &gt; const  &amp;desc_flags, bool nulls_as_largest=true)</td></tr>
<tr class="memdesc:ae90960c52c1f1fe3ab2257bad89b18fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find smallest indices in a sorted table where values should be inserted to maintain order.  <a href="namespacecudf.html#ae90960c52c1f1fe3ab2257bad89b18fc">More...</a><br /></td></tr>
<tr class="separator:ae90960c52c1f1fe3ab2257bad89b18fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4423a474f1918e65aed295f0600c488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad4423a474f1918e65aed295f0600c488">upper_bound</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;values, std::vector&lt; bool &gt; const  &amp;desc_flags, bool nulls_as_largest=true)</td></tr>
<tr class="memdesc:ad4423a474f1918e65aed295f0600c488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find largest indices in a sorted table where values should be inserted to maintain order.  <a href="namespacecudf.html#ad4423a474f1918e65aed295f0600c488">More...</a><br /></td></tr>
<tr class="separator:ad4423a474f1918e65aed295f0600c488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad614fa15b385e74efb6dcf3fa663fd7c"><td class="memItemLeft" align="right" valign="top"><a id="ad614fa15b385e74efb6dcf3fa663fd7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;<a class="el" href="classcudf_1_1column.html">column</a>, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> const &amp;value)</td></tr>
<tr class="separator:ad614fa15b385e74efb6dcf3fa663fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad888a160fd5439ce10ed29232debc200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad888a160fd5439ce10ed29232debc200">apply_boolean_mask</a> (<a class="el" href="structcudf_1_1table.html">table</a> const &amp;input, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;boolean_mask)</td></tr>
<tr class="memdesc:ad888a160fd5439ce10ed29232debc200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table using a column of boolean values as a mask.  <a href="namespacecudf.html#ad888a160fd5439ce10ed29232debc200">More...</a><br /></td></tr>
<tr class="separator:ad888a160fd5439ce10ed29232debc200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e2081a7b72b9e1ee1013b7f16127fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a98e2081a7b72b9e1ee1013b7f16127fa">drop_duplicates</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;input, const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;keys, const <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep, const bool nulls_are_equal=true)</td></tr>
<tr class="memdesc:a98e2081a7b72b9e1ee1013b7f16127fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table without duplicate rows.  <a href="namespacecudf.html#a98e2081a7b72b9e1ee1013b7f16127fa">More...</a><br /></td></tr>
<tr class="separator:a98e2081a7b72b9e1ee1013b7f16127fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66263477271719b8fb6b529f1f680945"><td class="memItemLeft" align="right" valign="top">gdf_size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a66263477271719b8fb6b529f1f680945">unique_count</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, bool const ignore_nulls, bool const nan_as_null)</td></tr>
<tr class="memdesc:a66263477271719b8fb6b529f1f680945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the unique elements in the column.  <a href="namespacecudf.html#a66263477271719b8fb6b529f1f680945">More...</a><br /></td></tr>
<tr class="separator:a66263477271719b8fb6b529f1f680945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff623cffbfe93433009a4c18571ea49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a7ff623cffbfe93433009a4c18571ea49">drop_nulls</a> (<a class="el" href="structcudf_1_1table.html">table</a> const &amp;input, <a class="el" href="structcudf_1_1table.html">table</a> const &amp;keys, gdf_size_type keep_threshold)</td></tr>
<tr class="memdesc:a7ff623cffbfe93433009a4c18571ea49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table to remove null elements.  <a href="namespacecudf.html#a7ff623cffbfe93433009a4c18571ea49">More...</a><br /></td></tr>
<tr class="separator:a7ff623cffbfe93433009a4c18571ea49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c1f9dc1aaa71e250df1eed4b02f3d8"><td class="memItemLeft" align="right" valign="top"><a id="ac4c1f9dc1aaa71e250df1eed4b02f3d8"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>drop_nulls</b> (<a class="el" href="structcudf_1_1table.html">table</a> const &amp;input, <a class="el" href="structcudf_1_1table.html">table</a> const &amp;keys)</td></tr>
<tr class="separator:ac4c1f9dc1aaa71e250df1eed4b02f3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806dfe2d3033333c99fd399afeddab3d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a806dfe2d3033333c99fd399afeddab3d">make_strings_column</a> (const rmm::device_vector&lt; thrust::pair&lt; const char *, size_type &gt;&gt; &amp;strings, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a806dfe2d3033333c99fd399afeddab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct STRING type column given an array of pointer/size pairs. The total number of char bytes must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class.">strings_column_view</a> class to perform strings operations on this type of column.  <a href="namespacecudf.html#a806dfe2d3033333c99fd399afeddab3d">More...</a><br /></td></tr>
<tr class="separator:a806dfe2d3033333c99fd399afeddab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cef65bd1df1b0b2a30f9e047ad35e1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a00cef65bd1df1b0b2a30f9e047ad35e1">make_strings_column</a> (const rmm::device_vector&lt; char &gt; &amp;strings, const rmm::device_vector&lt; size_type &gt; &amp;offsets, const rmm::device_vector&lt; bitmask_type &gt; &amp;null_mask, size_type null_count, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a00cef65bd1df1b0b2a30f9e047ad35e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct STRING type column given an contiguous array of chars encoded as UTF-8, an array of byte offsets identifying individual strings within the char array, and a null bitmask. The total number of char bytes must not exceed the maximum size of size_type. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class.">strings_column_view</a> class to perform strings operations on this type of column. This function makes a deep copy of the strings, offsets, null_mask to create a new column.  <a href="namespacecudf.html#a00cef65bd1df1b0b2a30f9e047ad35e1">More...</a><br /></td></tr>
<tr class="separator:a00cef65bd1df1b0b2a30f9e047ad35e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gdf_dtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad2f973d94c67ab3dc1a183c5adb3753d">column_dtypes</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of the dtypes of the columns in a table.  <a href="namespacecudf.html#ad2f973d94c67ab3dc1a183c5adb3753d">More...</a><br /></td></tr>
<tr class="separator:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c2c74e4d88e3c0b67e7dea9f7086cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad2c2c74e4d88e3c0b67e7dea9f7086cc">column_dtype_infos</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ad2c2c74e4d88e3c0b67e7dea9f7086cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of the dtype_infos of the columns in a table.  <a href="namespacecudf.html#ad2c2c74e4d88e3c0b67e7dea9f7086cc">More...</a><br /></td></tr>
<tr class="separator:ad2c2c74e4d88e3c0b67e7dea9f7086cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada393acb565321d740f2b9950ffe2941"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ada393acb565321d740f2b9950ffe2941">has_nulls</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ada393acb565321d740f2b9950ffe2941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a table contains any null values.  <a href="namespacecudf.html#ada393acb565321d740f2b9950ffe2941">More...</a><br /></td></tr>
<tr class="separator:ada393acb565321d740f2b9950ffe2941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbd2350ad171265f45f63404ab32ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a7dbd2350ad171265f45f63404ab32ffd">concat</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;table1, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;table2)</td></tr>
<tr class="memdesc:a7dbd2350ad171265f45f63404ab32ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>table1</code> and <code>table2</code> are concatenated to return single table  <a href="namespacecudf.html#a7dbd2350ad171265f45f63404ab32ffd">More...</a><br /></td></tr>
<tr class="separator:a7dbd2350ad171265f45f63404ab32ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e3a1ed670c88771cd7e594dda2f225"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bit_mask_t *, gdf_size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a33e3a1ed670c88771cd7e594dda2f225">nans_to_nulls</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input)</td></tr>
<tr class="memdesc:a33e3a1ed670c88771cd7e594dda2f225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column with floating point values, generate a bitmask where every NaN is indicated as the corresponding null bit.  <a href="namespacecudf.html#a33e3a1ed670c88771cd7e594dda2f225">More...</a><br /></td></tr>
<tr class="separator:a33e3a1ed670c88771cd7e594dda2f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45876c5d57c0d0afb921add28b3516e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a45876c5d57c0d0afb921add28b3516e3">transform</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input, const std::string &amp;unary_udf, gdf_dtype output_type, bool is_ptx)</td></tr>
<tr class="memdesc:a45876c5d57c0d0afb921add28b3516e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by applying a unary function against every element of an input column.  <a href="namespacecudf.html#a45876c5d57c0d0afb921add28b3516e3">More...</a><br /></td></tr>
<tr class="separator:a45876c5d57c0d0afb921add28b3516e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9904c47d7ae6d33143b6441cba45d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aca9904c47d7ae6d33143b6441cba45d2">cast</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, gdf_dtype out_type, <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> out_info=<a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>{})</td></tr>
<tr class="memdesc:aca9904c47d7ae6d33143b6441cba45d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts data from dtype specified in input to dtype specified in output.  <a href="namespacecudf.html#aca9904c47d7ae6d33143b6441cba45d2">More...</a><br /></td></tr>
<tr class="separator:aca9904c47d7ae6d33143b6441cba45d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4de4905066fbb3c645b05a1fc1d31d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae4de4905066fbb3c645b05a1fc1d31d2">unary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">unary_op</a> op)</td></tr>
<tr class="memdesc:ae4de4905066fbb3c645b05a1fc1d31d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unary op on all values in column.  <a href="namespacecudf.html#ae4de4905066fbb3c645b05a1fc1d31d2">More...</a><br /></td></tr>
<tr class="separator:ae4de4905066fbb3c645b05a1fc1d31d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>)</td></tr>
<tr class="memdesc:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures a gdf_column is valid, i.e. that its fields are consistent with each other, and logical in themselves, in representing a proper column.  <a href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">More...</a><br /></td></tr>
<tr class="separator:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9985a7fc88fb9b13d429e29405e12ae"><td class="memItemLeft" align="right" valign="top"><a id="ab9985a7fc88fb9b13d429e29405e12ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *column_ptr)</td></tr>
<tr class="separator:ab9985a7fc88fb9b13d429e29405e12ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d288a83fd8de580d2274f825997cbf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0d288a83fd8de580d2274f825997cbf3">have_same_type</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;validated_column_1, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;validated_column_2, bool ignore_extra_type_info=false) noexcept</td></tr>
<tr class="memdesc:a0d288a83fd8de580d2274f825997cbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures two (valid!) columns have the same type.  <a href="namespacecudf.html#a0d288a83fd8de580d2274f825997cbf3">More...</a><br /></td></tr>
<tr class="separator:a0d288a83fd8de580d2274f825997cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11851549cdd993a7a09c280a6d015135"><td class="memItemLeft" align="right" valign="top"><a id="a11851549cdd993a7a09c280a6d015135"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>have_same_type</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *validated_column_ptr_1, const <a class="el" href="structgdf__column__.html">gdf_column</a> *validated_column_ptr_2, bool ignore_extra_type_info) noexcept</td></tr>
<tr class="separator:a11851549cdd993a7a09c280a6d015135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f193177256b121627a35887dc9f816"><td class="memTemplParams" colspan="2"><a id="a40f193177256b121627a35887dc9f816"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40f193177256b121627a35887dc9f816"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_data</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a40f193177256b121627a35887dc9f816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b3e096195676e94b7c8398747459ff"><td class="memTemplParams" colspan="2"><a id="a52b3e096195676e94b7c8398747459ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52b3e096195676e94b7c8398747459ff"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_data</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a52b3e096195676e94b7c8398747459ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571f2362be95df8c2348bcce96fc522b"><td class="memItemLeft" align="right" valign="top"><a id="a571f2362be95df8c2348bcce96fc522b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_an_integer</b> (gdf_dtype element_type) noexcept</td></tr>
<tr class="separator:a571f2362be95df8c2348bcce96fc522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1090d2083c2700bef73bb07b29f8eb"><td class="memItemLeft" align="right" valign="top"><a id="a8d1090d2083c2700bef73bb07b29f8eb"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_integral</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a8d1090d2083c2700bef73bb07b29f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a3589a60ac4e16c069ae1852d80264"><td class="memItemLeft" align="right" valign="top"><a id="a49a3589a60ac4e16c069ae1852d80264"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_integral</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a49a3589a60ac4e16c069ae1852d80264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"><td class="memItemLeft" align="right" valign="top"><a id="a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_nullable</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a4a65a257d9746a9d65f8a8a6de1a5"><td class="memItemLeft" align="right" valign="top"><a id="a83a4a65a257d9746a9d65f8a8a6de1a5"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_nulls</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a83a4a65a257d9746a9d65f8a8a6de1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="memItemLeft" align="right" valign="top"><a id="aea3dfde6d57f821aa1825a90a8cdddcb"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aea3dfde6d57f821aa1825a90a8cdddcb">size_of</a> (gdf_dtype element_type)</td></tr>
<tr class="memdesc:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of values of a column element type. <br /></td></tr>
<tr class="separator:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="memItemLeft" align="right" valign="top"><a id="aaf37d87f3ef5bb0736ad2dfeeac3e766"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaf37d87f3ef5bb0736ad2dfeeac3e766">byte_width</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;col) noexcept</td></tr>
<tr class="memdesc:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of each element of a column (a.k.a. the column's width) <br /></td></tr>
<tr class="separator:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62151c46119cd04dc146c9e4175375f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:ae62151c46119cd04dc146c9e4175375f"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae62151c46119cd04dc146c9e4175375f">genericAtomicOperation</a> (T *address, T const &amp;update_value, BinaryOp op)</td></tr>
<tr class="memdesc:ae62151c46119cd04dc146c9e4175375f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction.  <a href="namespacecudf.html#ae62151c46119cd04dc146c9e4175375f">More...</a><br /></td></tr>
<tr class="separator:ae62151c46119cd04dc146c9e4175375f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memTemplParams" colspan="2"><a id="acafbd5dbae09b26c92b964e0122d5fc9"></a>
template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genericAtomicOperation</b> (<a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a> *address, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a> const &amp;update_value, BinaryOp op)</td></tr>
<tr class="separator:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84612c5efd7a5d2c6701581308a5d3b"><td class="memItemLeft" align="right" valign="top"><a id="ae84612c5efd7a5d2c6701581308a5d3b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_nulls</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> view)</td></tr>
<tr class="separator:ae84612c5efd7a5d2c6701581308a5d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd500e54a0760773f941986e8e056b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa5bd500e54a0760773f941986e8e056b">operator==</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;lhs, <a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;rhs)</td></tr>
<tr class="memdesc:aa5bd500e54a0760773f941986e8e056b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> objects for equality.  <a href="namespacecudf.html#aa5bd500e54a0760773f941986e8e056b">More...</a><br /></td></tr>
<tr class="separator:aa5bd500e54a0760773f941986e8e056b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77959a698de64cf48519918fb2e8c8bc"><td class="memItemLeft" align="right" valign="top">constexpr __host__ __device__ size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a77959a698de64cf48519918fb2e8c8bc">word_index</a> (size_type bit_index)</td></tr>
<tr class="separator:a77959a698de64cf48519918fb2e8c8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097bed4db2f79f0e70d27f9a92329859"><td class="memItemLeft" align="right" valign="top">constexpr __host__ __device__ size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a097bed4db2f79f0e70d27f9a92329859">intra_word_index</a> (size_type bit_index)</td></tr>
<tr class="separator:a097bed4db2f79f0e70d27f9a92329859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30ec17ab379138445603a38cc476b63"><td class="memItemLeft" align="right" valign="top">__device__ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae30ec17ab379138445603a38cc476b63">bit_is_set</a> (bitmask_type const *bitmask, size_type bit_index)</td></tr>
<tr class="memdesc:ae30ec17ab379138445603a38cc476b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specified bit is set to <code>1</code>  <a href="namespacecudf.html#ae30ec17ab379138445603a38cc476b63">More...</a><br /></td></tr>
<tr class="separator:ae30ec17ab379138445603a38cc476b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b47d0e147b3ccf92e1325496f6da42"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a14b47d0e147b3ccf92e1325496f6da42">set_bit</a> (bitmask_type *bitmask, size_type bit_index)</td></tr>
<tr class="memdesc:a14b47d0e147b3ccf92e1325496f6da42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified bit to <code>1</code>  <a href="namespacecudf.html#a14b47d0e147b3ccf92e1325496f6da42">More...</a><br /></td></tr>
<tr class="separator:a14b47d0e147b3ccf92e1325496f6da42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17cc4ac1f0309603710ea5052d61d24"><td class="memItemLeft" align="right" valign="top">constexpr __device__ bitmask_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#af17cc4ac1f0309603710ea5052d61d24">set_least_significant_bits</a> (size_type n)</td></tr>
<tr class="memdesc:af17cc4ac1f0309603710ea5052d61d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask word with the <code>n</code> least significant bits set.  <a href="namespacecudf.html#af17cc4ac1f0309603710ea5052d61d24">More...</a><br /></td></tr>
<tr class="separator:af17cc4ac1f0309603710ea5052d61d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132fe860101a1ac9a4804398830ca204"><td class="memItemLeft" align="right" valign="top">constexpr __device__ bitmask_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a132fe860101a1ac9a4804398830ca204">set_most_significant_bits</a> (size_type n)</td></tr>
<tr class="memdesc:a132fe860101a1ac9a4804398830ca204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask word with the <code>n</code> most significant bits set.  <a href="namespacecudf.html#a132fe860101a1ac9a4804398830ca204">More...</a><br /></td></tr>
<tr class="separator:a132fe860101a1ac9a4804398830ca204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6c9668f427d81f2bf0f3e16d19a27b"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#afb6c9668f427d81f2bf0f3e16d19a27b">clear_bit</a> (bitmask_type *bitmask, size_type bit_index)</td></tr>
<tr class="memdesc:afb6c9668f427d81f2bf0f3e16d19a27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified bit to <code>0</code>  <a href="namespacecudf.html#afb6c9668f427d81f2bf0f3e16d19a27b">More...</a><br /></td></tr>
<tr class="separator:afb6c9668f427d81f2bf0f3e16d19a27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ced5d0e49afdda2879ae5535a03167"><td class="memTemplParams" colspan="2"><a id="a16ced5d0e49afdda2879ae5535a03167"></a>
template&lt;class functor_t , typename... Ts&gt; </td></tr>
<tr class="memitem:a16ced5d0e49afdda2879ae5535a03167"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto) CUDA_HOST_DEVICE_CALLABLE&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_dispatcher</b> (gdf_dtype dtype, functor_t f, Ts &amp;&amp;... args)</td></tr>
<tr class="separator:a16ced5d0e49afdda2879ae5535a03167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad7b0f1bc518e47eaa2cfdd0ec88e3989">gdf_dtype_of</a> ()</td></tr>
<tr class="memdesc:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to it's corresponding gdf_dtype.  <a href="namespacecudf.html#ad7b0f1bc518e47eaa2cfdd0ec88e3989">More...</a><br /></td></tr>
<tr class="separator:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memTemplParams" colspan="2"><a id="ad0a0a98fdfe7a302afb2dfcaeb536412"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int8_t &gt;</b> ()</td></tr>
<tr class="separator:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d"><td class="memTemplParams" colspan="2"><a id="ae3d9564b2dc03eee3515499cae68827d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int16_t &gt;</b> ()</td></tr>
<tr class="separator:ae3d9564b2dc03eee3515499cae68827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memTemplParams" colspan="2"><a id="ae5ac9bfed0ac9684cc5c201271d4bca5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int32_t &gt;</b> ()</td></tr>
<tr class="separator:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memTemplParams" colspan="2"><a id="a17d6aab829fdfa0a8e805693fe6d0682"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int64_t &gt;</b> ()</td></tr>
<tr class="separator:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124"><td class="memTemplParams" colspan="2"><a id="aef0bacd5dab94476140d35bd1a44c124"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; float &gt;</b> ()</td></tr>
<tr class="separator:aef0bacd5dab94476140d35bd1a44c124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac"><td class="memTemplParams" colspan="2"><a id="aa02973e71d09dc7a3636d2a836968dac"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; double &gt;</b> ()</td></tr>
<tr class="separator:aa02973e71d09dc7a3636d2a836968dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5"><td class="memTemplParams" colspan="2"><a id="ab49efe66b146dc87425669653bde18f5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::bool8 &gt;</b> ()</td></tr>
<tr class="separator:ab49efe66b146dc87425669653bde18f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memTemplParams" colspan="2"><a id="a1e1b828c8f1b2b46e015afb85902ba52"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::date32 &gt;</b> ()</td></tr>
<tr class="separator:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c"><td class="memTemplParams" colspan="2"><a id="adb20c98631c4c203372547135f13732c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::date64 &gt;</b> ()</td></tr>
<tr class="separator:adb20c98631c4c203372547135f13732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memTemplParams" colspan="2"><a id="ad2576f3b441a5f87a0d5b67b7d21b854"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::timestamp &gt;</b> ()</td></tr>
<tr class="separator:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memTemplParams" colspan="2"><a id="a4e807d272b4582ff4d2a0dd9c6b8b309"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::category &gt;</b> ()</td></tr>
<tr class="separator:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919"><td class="memTemplParams" colspan="2"><a id="a0f831e82c6b13cd54c940e74fc46b919"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::nvstring_category &gt;</b> ()</td></tr>
<tr class="separator:a0f831e82c6b13cd54c940e74fc46b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606"><td class="memTemplParams" colspan="2"><a id="a5d1e00fa2d40d07ed6114dc064582606"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; NVStrings &gt;</b> ()</td></tr>
<tr class="separator:a5d1e00fa2d40d07ed6114dc064582606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9b08b206b1340c5ac3893d17943309"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:aef9b08b206b1340c5ac3893d17943309"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aef9b08b206b1340c5ac3893d17943309">is_relationally_comparable</a> ()</td></tr>
<tr class="memdesc:aef9b08b206b1340c5ac3893d17943309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether objects of types <code>L</code> and <code>R</code> can be relationally compared.  <a href="namespacecudf.html#aef9b08b206b1340c5ac3893d17943309">More...</a><br /></td></tr>
<tr class="separator:aef9b08b206b1340c5ac3893d17943309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736c39af324b57534639bd3d8af357e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a736c39af324b57534639bd3d8af357e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a736c39af324b57534639bd3d8af357e4">is_numeric</a> ()</td></tr>
<tr class="memdesc:a736c39af324b57534639bd3d8af357e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a numeric type.  <a href="namespacecudf.html#a736c39af324b57534639bd3d8af357e4">More...</a><br /></td></tr>
<tr class="separator:a736c39af324b57534639bd3d8af357e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac193df7b5be153a88978c2e6564bf4f2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ac193df7b5be153a88978c2e6564bf4f2">is_numeric</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ac193df7b5be153a88978c2e6564bf4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <a href="namespacecudf.html#ac193df7b5be153a88978c2e6564bf4f2">More...</a><br /></td></tr>
<tr class="separator:ac193df7b5be153a88978c2e6564bf4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa937abead085ea9420b15c6473f08a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa937abead085ea9420b15c6473f08a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaa937abead085ea9420b15c6473f08a7">is_fixed_width</a> ()</td></tr>
<tr class="memdesc:aaa937abead085ea9420b15c6473f08a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of type <code>T</code> are fixed-width.  <a href="namespacecudf.html#aaa937abead085ea9420b15c6473f08a7">More...</a><br /></td></tr>
<tr class="separator:aaa937abead085ea9420b15c6473f08a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347d883100d3f7c725ad64c649f59c11"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a347d883100d3f7c725ad64c649f59c11">is_fixed_width</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:a347d883100d3f7c725ad64c649f59c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of <code>type</code> are fixed-width.  <a href="namespacecudf.html#a347d883100d3f7c725ad64c649f59c11">More...</a><br /></td></tr>
<tr class="separator:a347d883100d3f7c725ad64c649f59c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e1cea4200d1d92d7f38d596333d28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14e1cea4200d1d92d7f38d596333d28a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a14e1cea4200d1d92d7f38d596333d28a">is_compound</a> ()</td></tr>
<tr class="memdesc:a14e1cea4200d1d92d7f38d596333d28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a compound type.  <a href="namespacecudf.html#a14e1cea4200d1d92d7f38d596333d28a">More...</a><br /></td></tr>
<tr class="separator:a14e1cea4200d1d92d7f38d596333d28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f296c6fe2b6ae35ac59e41cbf1487d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad7f296c6fe2b6ae35ac59e41cbf1487d">is_compound</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ad7f296c6fe2b6ae35ac59e41cbf1487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of <code>type</code> are compound.  <a href="namespacecudf.html#ad7f296c6fe2b6ae35ac59e41cbf1487d">More...</a><br /></td></tr>
<tr class="separator:ad7f296c6fe2b6ae35ac59e41cbf1487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f075ce6421723e214c0d153fe695f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad15f075ce6421723e214c0d153fe695f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad15f075ce6421723e214c0d153fe695f">is_simple</a> ()</td></tr>
<tr class="memdesc:ad15f075ce6421723e214c0d153fe695f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a simple type.  <a href="namespacecudf.html#ad15f075ce6421723e214c0d153fe695f">More...</a><br /></td></tr>
<tr class="separator:ad15f075ce6421723e214c0d153fe695f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e62b8bc2981be767ae3f6843877956"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae6e62b8bc2981be767ae3f6843877956">is_simple</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ae6e62b8bc2981be767ae3f6843877956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of <code>type</code> are simple.  <a href="namespacecudf.html#ae6e62b8bc2981be767ae3f6843877956">More...</a><br /></td></tr>
<tr class="separator:ae6e62b8bc2981be767ae3f6843877956"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parse and Transform a piece of PTX code that contains the implementation of a <code>__device__</code> function into a CUDA <code>__device__</code> <code>__inline__</code> function. </p>
<p>Invokes an instance of a functor template with the appropriate type determined by a gdf_dtype enum value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;tt&gt;src&lt;/tt&gt;</td><td>The input PTX code.</td></tr>
    <tr><td class="paramname">&lt;tt&gt;function_name&lt;/tt&gt;</td><td>The User defined function that the output CUDA function will have.</td></tr>
    <tr><td class="paramname">&lt;tt&gt;output_arg_type&lt;/tt&gt;</td><td>The output type of the PTX function, e.g. "int", "int64_t"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output CUDA <code>__device__</code> <code>__inline__</code> function</dd></dl>
<p>This helper function accepts any object with an "operator()" template, e.g., a functor. It will invoke an instance of the template by passing in as the template argument an appropriate type determined by the value of the gdf_dtype argument.</p>
<p>The template may have 1 or more template parameters, but the first parameter must be the type dispatched from the gdf_dtype enum. The remaining template parameters must be able to be automatically deduced.</p>
<p>There is a 1-to-1 mapping of gdf_dtype enum values and dispatched types. However, different gdf_dtype values may have the same underlying type. Therefore, in order to provide the 1-to-1 mapping, a wrapper struct may be dispatched for certain gdf_dtype enum values in order to emulate a "strong
typedef".</p>
<p>A strong typedef provides a new, concrete type unlike a normal C++ typedef which is simply a type alias. These "strong typedef" structs simply wrap a single member variable of a fundamental type called 'value'.</p>
<p>The standard arithmetic operators are defined for the wrapper structs and therefore the wrapper struct types can be used as if they were fundamental types.</p>
<p>See <a class="el" href="wrapper__types_8hpp.html" title="Wrapper structs for for the non-fundamental gdf_dtype types.">wrapper_types.hpp</a> for more detail.</p>
<p>Example usage with a functor that returns the size of the dispatched type:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>example_functor{</div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"> <span class="keywordtype">int</span> operator()(){</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(T);</div>
<div class="line"> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">cudf::type_dispatcher(GDF_INT8, example_functor{});  <span class="comment">// returns 1</span></div>
<div class="line">cudf::type_dispatcher(GDF_INT64, example_functor{}); <span class="comment">// returns 8</span></div>
</div><!-- fragment --><p>Example usage of a functor for checking if element "i" in column "lhs" is equal to element "j" in column "rhs":</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>elements_are_equal{</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType&gt;</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">void</span> <span class="keyword">const</span> * lhs, <span class="keywordtype">int</span> i,</div>
<div class="line">                  <span class="keywordtype">void</span> <span class="keyword">const</span> * rhs, <span class="keywordtype">int</span> j)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Cast the void* data buffer to the dispatched type and retrieve</span></div>
<div class="line">elements</div>
<div class="line">    <span class="comment">// &quot;i&quot; and &quot;j&quot; from the respective columns</span></div>
<div class="line">    ColumnType <span class="keyword">const</span> i_elem = static_cast&lt;ColumnType const*&gt;(lhs)[i];</div>
<div class="line">    ColumnType <span class="keyword">const</span> j_elem = static_cast&lt;ColumnType const*&gt;(rhs)[j];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// operator== is defined for wrapper structs such that it performs the</span></div>
<div class="line">    <span class="comment">// operator== on the underlying values. Therefore, the wrapper structs</span></div>
<div class="line">    <span class="comment">// can be used as if they were fundamental arithmetic types</span></div>
<div class="line">    <span class="keywordflow">return</span> i_elem == j_elem;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>It is sometimes neccessary to customize the dispatched functor's <code>operator()</code> for different types. This can be done in several ways.</p>
<p>The first method is to use explicit template specialization. This is useful for specializing behavior for single types. For example, a functor that prints <code>int32_t</code> or <code>double</code> when invoked with either of those types, else it prints <code>unhandled type</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>type_printer {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">&quot;unhandled type\n&quot;</span>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Due to a bug in g++, explicit member function specializations need to be</span></div>
<div class="line"><span class="comment">// defined outside of the class definition</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> type_printer::operator()&lt;int32_t&gt;() { std::cout &lt;&lt; <span class="stringliteral">&quot;int32_t\n&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> type_printer::operator()&lt;<span class="keywordtype">double</span>&gt;() { std::cout &lt;&lt; <span class="stringliteral">&quot;double\n&quot;</span>; }</div>
</div><!-- fragment --><p>A second method is to use SFINAE with <code>std::enable_if_t</code>. This is useful for specializing for a set of types that share some property. For example, a functor that prints <code>integral</code> or <code>floating point</code> for integral or floating point types:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>integral_or_floating_point {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType,</div>
<div class="line">            std::enable_if_t&lt;not std::is_integral&lt;ColumnType&gt;::value and</div>
<div class="line">                             not std::is_floating_point&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">&quot;neither integral nor floating point\n&quot;</span>; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType,</div>
<div class="line">            std::enable_if_t&lt;std::is_integral&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">&quot;integral\n&quot;</span>; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt; <span class="keyword">typename</span> ColumnType,</div>
<div class="line">             std::enable_if_t&lt;std::is_floating_point&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">&quot;floating point\n&quot;</span>; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>For more info on SFINAE and <code>std::enable_if</code>, see <a href="https://eli.thegreenplace.net/2014/sfinae-and-enable_if/">https://eli.thegreenplace.net/2014/sfinae-and-enable_if/</a></p>
<p>The return type for all template instantiations of the functor's "operator()" lambda must be the same, else there will be a compiler error as you would be trying to return different types from the same function.</p>
<p>NOTE: It is undefined behavior if an unsupported or invalid <code>gdf_dtype</code> is supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The gdf_dtype enum that determines which type will be dispatched </td></tr>
    <tr><td class="paramname">f</td><td>The functor with a templated "operator()" that will be invoked with the dispatched type </td></tr>
    <tr><td class="paramname">args</td><td>A parameter-pack (i.e., arbitrary number of arguments) that will be perfectly-forwarded as the arguments of the functor's "operator()".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whatever is returned by the functor's "operator()". </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a69091647ea1f9c9d4cdcf7c8876bea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69091647ea1f9c9d4cdcf7c8876bea3a">&#9670;&nbsp;</a></span>duplicate_keep_option</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">cudf::duplicate_keep_option</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choices for drop_duplicates API for retainment of duplicate rows. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa86ea4bfd2b3121412b0a63a3697926ec"></a>KEEP_FIRST&#160;</td><td class="fielddoc"><p>Keeps first duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa1d1398f646d74e801389737f07d89d1c"></a>KEEP_LAST&#160;</td><td class="fielddoc"><p>Keeps last duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa6fb3154b77231184b596b4add407aa2a"></a>KEEP_NONE&#160;</td><td class="fielddoc"><p>Don't keep any duplicate rows, Keeps only unique rows. </p>
</td></tr>
</table>

</div>
</div>
<a id="a94d60cf0790fb642cce1c91f1dba63c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d60cf0790fb642cce1c91f1dba63c8">&#9670;&nbsp;</a></span>interpolation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">cudf::interpolation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolation method to use, when the desired quantile lies between two data points i and j. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8ab424744b6ce548ac355f5830c0a8c5e1"></a>LINEAR&#160;</td><td class="fielddoc"><p>Linear interpolation between i and j. </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8a00b75d21f696dc9d435e8b4b3c3bc58d"></a>LOWER&#160;</td><td class="fielddoc"><p>Lower data point (i) </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8ae5385a7a8eb742f08471ba73ea2d77ba"></a>HIGHER&#160;</td><td class="fielddoc"><p>Higher data point (j) </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8a7b5062e7868e9d05c598ef7ad6619014"></a>MIDPOINT&#160;</td><td class="fielddoc"><p>(i + j)/2 </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8a04fd403d483f6415e0b006bc67bd8fac"></a>NEAREST&#160;</td><td class="fielddoc"><p>i or j, whichever is nearest </p>
</td></tr>
</table>

</div>
</div>
<a id="a267e03474dcfd85242d2fdc6e5846ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267e03474dcfd85242d2fdc6e5846ec6">&#9670;&nbsp;</a></span>mask_allocation_policy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">cudf::mask_allocation_policy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md279"></a>
@brief Indicates when to allocate a mask, based on an existing mask.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a267e03474dcfd85242d2fdc6e5846ec6a615857bddd061281abf998989fb2ba8f"></a>NEVER&#160;</td><td class="fielddoc"><p>Do not allocate a null mask, regardless of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56"></a>RETAIN&#160;</td><td class="fielddoc"><p>Allocate a null mask if the input contains one. </p>
</td></tr>
<tr><td class="fieldname"><a id="a267e03474dcfd85242d2fdc6e5846ec6a995bafc1b2e35df60002e61e2ec0c6df"></a>ALWAYS&#160;</td><td class="fielddoc"><p>Allocate a null mask, regardless of input. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa481249b705132999f4d082aacd21dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa481249b705132999f4d082aacd21dbf">&#9670;&nbsp;</a></span>mask_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">cudf::mask_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md460"></a>
@brief Controls the allocation/initialization of a null mask.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344"></a>UNALLOCATED&#160;</td><td class="fielddoc"><p>Null mask not allocated, (all elements are valid) </p>
</td></tr>
<tr><td class="fieldname"><a id="aa481249b705132999f4d082aacd21dbfa37d7c1f4781c3276729ed1678c0c0844"></a>UNINITIALIZED&#160;</td><td class="fielddoc"><p>Null mask allocated, but not initialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa481249b705132999f4d082aacd21dbfadb86173d779f7b173db120643cc1c402"></a>ALL_VALID&#160;</td><td class="fielddoc"><p>Null mask allocated, initialized to all elements valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa481249b705132999f4d082aacd21dbfa042cac70175410616150fafb92f76351"></a>ALL_NULL&#160;</td><td class="fielddoc"><p>Null mask allocated, initialized to all elements NULL. </p>
</td></tr>
</table>

</div>
</div>
<a id="a058e6d6e8a21583ce0e85ee73e5abb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058e6d6e8a21583ce0e85ee73e5abb31">&#9670;&nbsp;</a></span>null_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md459"></a>
@brief Indicates how null values compare against all other values.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb"></a>AFTER&#160;</td><td class="fielddoc"><p>NULL values ordered <em>after</em> all other values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07"></a>BEFORE&#160;</td><td class="fielddoc"><p>NULL values ordered <em>before</em> all other values. </p>
</td></tr>
</table>

</div>
</div>
<a id="a750f02016b046079f7062d334890b4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750f02016b046079f7062d334890b4fc">&#9670;&nbsp;</a></span>order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">cudf::order</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md458"></a>
@brief Indicates the order in which elements should be sorted.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a750f02016b046079f7062d334890b4fca83ec681a20197326c163ea3b39ef7c32"></a>ASCENDING&#160;</td><td class="fielddoc"><p>Elements ordered from small to large. </p>
</td></tr>
<tr><td class="fieldname"><a id="a750f02016b046079f7062d334890b4fcacff818f0ae4cef845577e39283886a53"></a>DESCENDING&#160;</td><td class="fielddoc"><p>Elements ordered from large to small. </p>
</td></tr>
</table>

</div>
</div>
<a id="acd4cd7157c4379954b5772936f89c59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4cd7157c4379954b5772936f89c59b">&#9670;&nbsp;</a></span>type_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md461"></a>
@brief Identifies a column's logical element type</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59bab2c14e467fcbf9a215ccc679f35bb027"></a>EMPTY&#160;</td><td class="fielddoc"><p>Always null with no underlying data. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba71f4b0467efae61c1e3ac5910178940f"></a>INT8&#160;</td><td class="fielddoc"><p>1 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba7dafa1ea3755308998ff8c972342c099"></a>INT16&#160;</td><td class="fielddoc"><p>2 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae"></a>INT32&#160;</td><td class="fielddoc"><p>4 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59bab9c234f82eec5cb83e3ea67aac9c1166"></a>INT64&#160;</td><td class="fielddoc"><p>8 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba37225001c5ad4b3d1aa808620debfe7a"></a>FLOAT32&#160;</td><td class="fielddoc"><p>4 byte floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59baf24707a0d5537fd50bca87cd18a9a0e5"></a>FLOAT64&#160;</td><td class="fielddoc"><p>8 byte floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba9100ee556e5cf9b6dada6c7c506fa138"></a>BOOL8&#160;</td><td class="fielddoc"><p>Boolean using one byte per value, 0 == false, else true. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59baaff82f65fddd2421f3a4567405848203"></a>DATE32&#160;</td><td class="fielddoc"><p>days since Unix Epoch in int32 </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba1983b1e0581db578a3461827838dfb72"></a>TIMESTAMP&#160;</td><td class="fielddoc"><p>duration of specified resolution since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59baabcc7f7b028da5bba90f587958cc1026"></a>CATEGORY&#160;</td><td class="fielddoc"><p>Categorical/Dictionary type. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59bae008ab0db4e9b28f33e1e3c9c3daf444"></a>STRING&#160;</td><td class="fielddoc"><p>String elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba0f6b1e874ab643a0f237082cb35acad5"></a>NUM_TYPE_IDS&#160;</td><td class="fielddoc"><p>Total number of type ids. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab15567f1034536ae6f7f14179334a19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15567f1034536ae6f7f14179334a19b">&#9670;&nbsp;</a></span>unary_op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">cudf::unary_op</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of unary operations that can be performed on data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba6b585cf453d36fbb0381b38bc2c966e1"></a>SIN&#160;</td><td class="fielddoc"><p>Trigonometric sine. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19baf7c88ff3bee94b5c3c16c405706ef34a"></a>COS&#160;</td><td class="fielddoc"><p>Trigonometric cosine. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19baa91cdd09214d36d756b5f13803ddd890"></a>TAN&#160;</td><td class="fielddoc"><p>Trigonometric tangent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba463397f416a024fb7df7d906a0436dbb"></a>ARCSIN&#160;</td><td class="fielddoc"><p>Trigonometric sine inverse. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba1e17febbc6d14208d0a264562dcee2e9"></a>ARCCOS&#160;</td><td class="fielddoc"><p>Trigonometric cosine inverse. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19bad1c5c0c8ffe6bf038e617b0aad0f9aac"></a>ARCTAN&#160;</td><td class="fielddoc"><p>Trigonometric tangent inverse. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba6e272b8c75625066b2c8994cec6c8f73"></a>EXP&#160;</td><td class="fielddoc"><p>Exponential (base e, Euler number) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba1509f8449abb15062ad85e15fb3861d7"></a>LOG&#160;</td><td class="fielddoc"><p>Natural Logarithm (base e) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba6ac653ea3d15f23b0f6e61b447f783ea"></a>SQRT&#160;</td><td class="fielddoc"><p>Square-root (x^0.5) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba8b0d502b44d1472a2d5fa3638f0ce945"></a>CEIL&#160;</td><td class="fielddoc"><p>Smallest integer value not less than arg. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba07e330cc72f454a6369d267d1bfb2d7e"></a>FLOOR&#160;</td><td class="fielddoc"><p>largest integer value not greater than arg </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19bab226be3789467f51f32cf06550a4c46e"></a>ABS&#160;</td><td class="fielddoc"><p>Absolute value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba62a7f82a72f8422f631cb550b7201667"></a>BIT_INVERT&#160;</td><td class="fielddoc"><p>Bitwise Not (~) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba5e654d9830c09fc254d4f9f19fbdfe6e"></a>NOT&#160;</td><td class="fielddoc"><p>Logical Not (!) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a38150f11c542f3238874911d4a30a530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38150f11c542f3238874911d4a30a530">&#9670;&nbsp;</a></span>allocate_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::allocate_column </td>
          <td>(</td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocate_mask</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>&#160;</td>
          <td class="paramname"><em>info</em> = <code><a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new column of the specified size and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>Datatype of the column </td></tr>
    <tr><td class="paramname">size</td><td>Size of the column </td></tr>
    <tr><td class="paramname">allocate_mask</td><td>Optional Whether or not to allocate bitmask </td></tr>
    <tr><td class="paramname">info</td><td>Optional Extra info for the column </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column An allocated column of given size and type </dd></dl>

</div>
</div>
<a id="a05145f762859aea7d4cc2fac5b7b96eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05145f762859aea7d4cc2fac5b7b96eb">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new column of the specified size and same type as the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to emulate </td></tr>
    <tr><td class="paramname">size</td><td>The size of the column to allocate in rows </td></tr>
    <tr><td class="paramname">mask_alloc</td><td>Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column An allocated column of same size and type of input </dd></dl>

</div>
</div>
<a id="ac72ee052f776990ab9240e757d8493ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72ee052f776990ab9240e757d8493ad">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new column of the same size and type as the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to emulate </td></tr>
    <tr><td class="paramname">mask_alloc</td><td>Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column An allocated column of same size and type of input </dd></dl>

</div>
</div>
<a id="a0bb1a9329f3d83fd791f27a26a3abc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb1a9329f3d83fd791f27a26a3abc48">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns with the specified size and same type as the input. </p>
<p>Creates the <code>gdf_column</code> objects, and allocates underlying device memory for each column matching the input columns</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to emulate </td></tr>
    <tr><td class="paramname">size</td><td>The size of the columns to allocate </td></tr>
    <tr><td class="paramname">mask_alloc</td><td>Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table of columns with same type as <code>t</code> and specified <code>size</code> </dd></dl>

</div>
</div>
<a id="ada80dc11907eac4cd65640233b777452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada80dc11907eac4cd65640233b777452">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns with the same type and allocation size as the input. </p>
<p>Creates the <code>gdf_column</code> objects, and allocates underlying device memory for each column matching the input columns</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to emulate </td></tr>
    <tr><td class="paramname">mask_alloc</td><td>Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table of columns with same type and allocation size as input </dd></dl>

</div>
</div>
<a id="a59dbfc21702c222d9d113f16cd448535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dbfc21702c222d9d113f16cd448535">&#9670;&nbsp;</a></span>allocSequenceBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gdf_error cudf::allocSequenceBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gdf_size_type&#160;</td>
          <td class="paramname"><em>buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer and fills it with a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of the buffer to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_length</td><td>Amount of memory to be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></td><td>The data type to be used for the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon succesful completion </dd></dl>

</div>
</div>
<a id="a3ec456ad746337e9471efaee3772a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec456ad746337e9471efaee3772a273">&#9670;&nbsp;</a></span>allocValueBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gdf_error cudf::allocValueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gdf_size_type&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer and fills it with a repeated value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of the buffer to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_length</td><td>Amount of memory to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be filled into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></td><td>The data type to be used for the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon succesful completion </dd></dl>

</div>
</div>
<a id="ad888a160fd5439ce10ed29232debc200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad888a160fd5439ce10ed29232debc200">&#9670;&nbsp;</a></span>apply_boolean_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::apply_boolean_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a table using a column of boolean values as a mask. </p>
<p>Given an input table and a mask column, an element <code>i</code> from each column of the input table is copied to the corresponding output column if the corresponding element <code>i</code> in the mask is non-null and <code>true</code>. This operation is stable: the input order is preserved.</p>
<p>The input and mask columns must be of equal size (number of rows).</p>
<p>The output table has number of rows equal to the number of elements in boolean_mask that are both non-null and <code>true</code>. Note that the output table memory is allocated by this function but must be freed by the caller when finished.</p>
<dl class="section note"><dt>Note</dt><dd>that the <code>boolean_mask</code> may have just boolean data (no valid bitmask), or just a valid bitmask (no boolean data), or it may have both. The filter adapts to these three situations.</dd>
<dd>
if <code>input.num_rows()</code> is zero, there is no error, and an empty table is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input table to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>A column of type GDF_BOOL8 used as a mask to filter the input column corresponding index passes the filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> Table containing copy of all rows of <code>input</code> passing the filter defined by <code>boolean_mask</code>. </dd></dl>

</div>
</div>
<a id="a1f727c257f82efc1a7b144eb6dcbb2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f727c257f82efc1a7b144eb6dcbb2d8">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ptx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two gdf_columns using a user-defined PTX function. </p>
<p>Accepts a user-defined PTX function to apply between the <code>lhs</code> and <code>rhs</code>.</p>
<p>The desired output type must be specified in output_type. It is assumed that this output type is compatable with the output type in the PTX code.</p>
<p>The output column will be allocated and it is the user's reponsibility to free the device memory</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid masks of lhs and rhs gdf_columns</p>
<dl class="section return"><dt>Returns</dt><dd>A gdf_column as the output of the operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ptx</td><td>String containing the PTX of a binary function to apply between <code>lhs</code> and <code>rhs</code> </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired output type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad01e2e81bc2b671dfb8963a7be22e3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01e2e81bc2b671dfb8963a7be22e3b0">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two gdf_columns. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid masks of lhs and rhs gdf_columns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa02af1454978d7d7f7b9f651437b3ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02af1454978d7d7f7b9f651437b3ab5">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a gdf_column and a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a>. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid mask of lhs gdf_column and is_valid bool of rhs <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a>) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae942e9a8d320f23d61bee22ddc06df55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae942e9a8d320f23d61bee22ddc06df55">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> and a gdf_column. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid mask of rhs gdf_column and is_valid bool of lhs <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a>) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae30ec17ab379138445603a38cc476b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30ec17ab379138445603a38cc476b63">&#9670;&nbsp;</a></span>bit_is_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ bool cudf::bit_is_set </td>
          <td>(</td>
          <td class="paramtype">bitmask_type const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the specified bit is set to <code>1</code> </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_index</td><td>Index of the bit to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The specified bit is <code>1</code> </dd></dl>
<h2><a class="anchor" id="autotoc_md468"></a>
@return false  The specified bit is &lt;tt&gt;0&lt;/tt&gt;</h2>

</div>
</div>
<a id="a3c26b8cbca80321602bc3f39ab6cce8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c26b8cbca80321602bc3f39ab6cce8d">&#9670;&nbsp;</a></span>bitmask_allocation_size_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cudf::bitmask_allocation_size_bytes </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>number_of_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>padding_boundary</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the required bytes necessary to represent the specified number of bits with a given padding boundary. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="section note"><dt>Note</dt><dd>The Arrow specification for the null bitmask requires a 64B padding boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_bits</td><td>The number of bits that need to be represented </td></tr>
    <tr><td class="paramname">padding_boundary</td><td>The value returned will be rounded up to a multiple of this value </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md371"></a>
@return std::size_t The necessary number of bytes</h2>

</div>
</div>
<a id="aca9904c47d7ae6d33143b6441cba45d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9904c47d7ae6d33143b6441cba45d2">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>out_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>&#160;</td>
          <td class="paramname"><em>out_info</em> = <code><a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts data from dtype specified in input to dtype specified in output. </p>
<dl class="section note"><dt>Note</dt><dd>In case of conversion from GDF_DATE32/GDF_DATE64/GDF_TIMESTAMP to GDF_TIMESTAMP, the time unit for output should be set in out_info.time_unit</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gdf_column</td><td>Input column </td></tr>
    <tr><td class="paramname">out_type</td><td>Desired datatype of output column </td></tr>
    <tr><td class="paramname">out_info</td><td>Extra info for output column in case of conversion to types that require extra info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Result of the cast operation </dd></dl>

</div>
</div>
<a id="afb6c9668f427d81f2bf0f3e16d19a27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6c9668f427d81f2bf0f3e16d19a27b">&#9670;&nbsp;</a></span>clear_bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void cudf::clear_bit </td>
          <td>(</td>
          <td class="paramtype">bitmask_type *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the specified bit to <code>0</code> </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="section note"><dt>Note</dt><dd>This operation requires a global atomic operation. Therefore, it is not reccomended to use this function in performance critical regions. When possible, it is more efficient to compute and update an entire element at once using <code>set_element</code>.</dd></dl>
<p>This function is thread-safe.</p>
<h2><a class="anchor" id="autotoc_md472"></a>
@param bit_index  Index of the bit to set</h2>

</div>
</div>
<a id="ad2c2c74e4d88e3c0b67e7dea9f7086cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c2c74e4d88e3c0b67e7dea9f7086cc">&#9670;&nbsp;</a></span>column_dtype_infos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> &gt; cudf::column_dtype_infos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of the dtype_infos of the columns in a table. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to get the column dtypes_infos from </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md353"></a>
@return std::vector&lt;gdf_dtype_extra_info&gt;</h2>

</div>
</div>
<a id="ad2f973d94c67ab3dc1a183c5adb3753d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f973d94c67ab3dc1a183c5adb3753d">&#9670;&nbsp;</a></span>column_dtypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gdf_dtype &gt; cudf::column_dtypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of the dtypes of the columns in a table. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to get the column dtypes from </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md352"></a>
@return std::vector&lt;gdf_dtype&gt;</h2>

</div>
</div>
<a id="a7dbd2350ad171265f45f63404ab32ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbd2350ad171265f45f63404ab32ffd">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>table1</code> and <code>table2</code> are concatenated to return single table </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If number of rows mismatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table1</td><td>The table to be concatenated with <code>table2</code> </td></tr>
    <tr><td class="paramname">table2</td><td>The table to be concatenated with <code>table1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single table having all the columns from <code>table1</code> and <code>table2</code> </dd></dl>
<h2><a class="anchor" id="autotoc_md355"></a>
respectively in the same order.</h2>

</div>
</div>
<a id="a7345416cce5579459662d19778ab229f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7345416cce5579459662d19778ab229f">&#9670;&nbsp;</a></span>construct_join_output_df()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;JoinType join_type, typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::construct_join_output_df </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; gdf_size_type, gdf_size_type &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>columns_in_common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>left_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>right_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers rows indicated by <code>left_indices</code> and <code>right_indices</code> from tables <code>left</code> and <code>right</code>, respectively, into a single <code>table</code>. </p>
<p>The row from <code>left</code> at <code>left_indices[i]</code> will be concatenated with the row i from <code>right</code> at <code>right_indices[i]</code> to form a new row in the output <code>table</code>. If either <code>left_indices[i]</code> or <code>right_indices[i]</code> is negative, then the i contributions from <code>left</code> or <code>right</code> will be NULL.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If call to nvcategory_gather_table fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The left table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>the right table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns_in_common</td><td>is a vector of pairs of column indices from tables <code>left</code> and <code>right</code> respectively, that are "in common". For "common" columns, only a single output column will be produced. For an inner or left join, the result will be gathered from the column in <code>left</code>. For a full join, the result will be gathered from both common columns in <code>left</code> and <code>right</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_indices</td><td>Row indices from <code>left</code> to gather. If any row index is out of bounds, the contribution in the output <code>table</code> will be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_indicess</td><td>Row indices from <code>right</code> to gather. If any row index is out of bounds, the contribution in the output <code>table</code> will be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>table</code> containing the concatenation of rows from <code>left</code> and <code>right</code> specified by <code>left_indices</code> and <code>right_indices</code>, respectively. For any columns indicated by <code>columns_in_common</code>, only the corresponding column in <code>left</code> will be included in the result. Final form would look like <code>left(including common columns)+right(excluding common columns)</code>. </dd></dl>

</div>
</div>
<a id="aa7e6bf39cb5dd5cdb370d0a562675922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e6bf39cb5dd5cdb370d0a562675922">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column that is a copy of input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to copy </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column A copy of input </dd></dl>

</div>
</div>
<a id="a9fae65b5e23d13aec03edef7a8aeacb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae65b5e23d13aec03edef7a8aeacb0">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns and deep copies the data from an input table. </p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to copy </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations and copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table that is an exact copy of <code>t</code> </dd></dl>

</div>
</div>
<a id="aa57781c8d2648ef021718b0f87aadfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57781c8d2648ef021718b0f87aadfe1">&#9670;&nbsp;</a></span>copy_offset_bitmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void cudf::copy_offset_bitmask </td>
          <td>(</td>
          <td class="paramtype">bitmask_type *__restrict__&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitmask_type const *__restrict__&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>number_of_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the bits starting at the specified offset from a source bitmask into the destination bitmask. </p>
<p>------------------------------------------------------------------------&mdash;* Bit <code>i</code> in <code>destination</code> will be equal to bit <code>i + offset</code> from <code>source</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The mask to copy into </td></tr>
    <tr><td class="paramname">source</td><td>The mask to copy from </td></tr>
    <tr><td class="paramname">bit_offset</td><td>The offset into <code>source</code> from which to begin the copy </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md9"></a>
@param number_of_bits The number of bits to copy</h2>

</div>
</div>
<a id="ab67996c2986be62de33c6685e1702755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67996c2986be62de33c6685e1702755">&#9670;&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>in_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>out_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>out_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>in_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements from one column to another. </p>
<p>Copies N elements of <code>in_column</code> starting at <code>in_begin</code> to the N elements of <code>out_column</code> starting at <code>out_begin</code>, where N = (<code>out_end</code> - <code>out_begin</code>)</p>
<p>The datatypes of in_column and out_column must be the same.</p>
<p>If the input and output columns are the same and ranges overlap, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out_column</td><td>The preallocated column to copy into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_column</td><td>The column to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_begin</td><td>The starting index of the output range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_end</td><td>The index one past the end of the output range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_begin</td><td>The starting index of the input range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="aef675a9c75a848ab796ae9b2b51c4238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef675a9c75a848ab796ae9b2b51c4238">&#9670;&nbsp;</a></span>count_descendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type cudf::count_descendants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a>&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of descendants of the specified parent. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent whose descendants will be counted </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md252"></a>
@return size_type The number of descendants of the parent</h2>

</div>
</div>
<a id="ae8405a236b985ea3d8a626f92e40658c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8405a236b985ea3d8a626f92e40658c">&#9670;&nbsp;</a></span>count_set_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::size_type cudf::count_set_bits </td>
          <td>(</td>
          <td class="paramtype">bitmask_type const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bitmask, counts the number of set (1) bits in the range <code>[start, stop)</code> </p>
<p>------------------------------------------------------------------------&mdash;* Returns <code>0</code> if <code>bitmask == nullptr</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>start &gt; stop</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>start &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>Bitmask residing in device memory whose bits will be counted </td></tr>
    <tr><td class="paramname">start_bit</td><td>Index of the first bit to count (inclusive) </td></tr>
    <tr><td class="paramname">stop_bit</td><td>Index of the last bit to count (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md373"></a>
@return The number of non-zero bits in the specified range</h2>

</div>
</div>
<a id="aeff1677d6e025ceb78e4fdc631125170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff1677d6e025ceb78e4fdc631125170">&#9670;&nbsp;</a></span>count_unset_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::size_type cudf::count_unset_bits </td>
          <td>(</td>
          <td class="paramtype">bitmask_type const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bitmask, counts the number of unset (0) bits in the range <code>[start, stop)</code>. </p>
<p>------------------------------------------------------------------------&mdash;* Returns <code>0</code> if <code>bitmask == nullptr</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>start &gt; stop</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>start &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>Bitmask residing in device memory whose bits will be counted </td></tr>
    <tr><td class="paramname">start_bit</td><td>Index of the first bit to count (inclusive) </td></tr>
    <tr><td class="paramname">stop_bit</td><td>Index of the last bit to count (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md374"></a>
@return The number of zero bits in the specified range</h2>

</div>
</div>
<a id="a5834edc8cde53fb6b23f2e95847c8066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5834edc8cde53fb6b23f2e95847c8066">&#9670;&nbsp;</a></span>create_null_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::create_null_mask </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="classdevice__buffer.html" title="A helper class that owns a resizable device memory buffer.">device_buffer</a></code> for use as a null value indicator bitmask of a <code>column</code>. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements to be represented by the mask </td></tr>
    <tr><td class="paramname">state</td><td>The desired state of the mask </td></tr>
    <tr><td class="paramname">stream</td><td>Optional, stream on which all memory allocations/operations will be submitted </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to use for device memory allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmm::device_buffer A <code><a class="el" href="classdevice__buffer.html" title="A helper class that owns a resizable device memory buffer.">device_buffer</a></code> for use as a null bitmask </dd></dl>
<h2><a class="anchor" id="autotoc_md372"></a>
satisfying the desired size and state</h2>

</div>
</div>
<a id="a98e2081a7b72b9e1ee1013b7f16127fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e2081a7b72b9e1ee1013b7f16127fa">&#9670;&nbsp;</a></span>drop_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::drop_duplicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a>&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>nulls_are_equal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table without duplicate rows. </p>
<p>Given an input table, each row is copied to output table if the corresponding row of key column table is unique, where the definition of unique depends on the value of <code>keep:</code> </p><ul>
<li>KEEP_FIRST: only the first of a sequence of duplicate rows is copied</li>
<li>KEEP_LAST: only the last of a sequence of duplicate rows is copied</li>
<li>KEEP_NONE: no duplicate rows are copied</li>
</ul>
<p>The input table and key columns table should have same number of rows. Note that the memory for the output table columns is allocated by this function, so it must be freed by the caller when finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>input table to copy only unique rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>columns to consider to identify duplicate rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>keep first entry, last entry, or no entries if duplicates found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_are_equal</td><td>flag to denote nulls are equal if true, nulls are not equal if false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new table with only unique rows </dd></dl>

</div>
</div>
<a id="a7ff623cffbfe93433009a4c18571ea49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff623cffbfe93433009a4c18571ea49">&#9670;&nbsp;</a></span>drop_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::drop_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>keep_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a table to remove null elements. </p>
<p>Filters the rows of the input table considering only specified columns for validity / null values.</p>
<p>Given an input table, row <code>i</code> from the input columns is copied to the output if the same row <code>i</code> of <code>keys</code> has at leaast <code>keep_threshold</code> non-null fields.</p>
<p>This operation is stable: the input order is preserved in the output.</p>
<p>Note that the memory for the columns of the output table is allocated by this function but must be freed by the caller when finished.</p>
<p>Any non-nullable column in the input is treated as all non-null.</p>
<dl class="section note"><dt>Note</dt><dd>if <code>input.num_rows()</code> is zero, or <code>keys</code> is empty or has no nulls, there is no error, and an empty table is returned</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>keys</code> is non-empty and keys.num_rows() is less than input.num_rows()</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input table to filter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>The table of columns to check for nulls. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_threshold</td><td>The minimum number of non-null fields in a row required to keep the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> Table containing all rows of the input table with at least <code>keep_threshold</code> non-null fields in <code>keys</code>. </dd></dl>

</div>
</div>
<a id="a3588fc0b833a8f2d7213651a05f48c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3588fc0b833a8f2d7213651a05f48c80">&#9670;&nbsp;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of empty columns with the same types as the inputs. </p>
<p>Creates the <code>gdf_column</code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to delete the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input table to emulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table of empty columns of same type as input </dd></dl>

</div>
</div>
<a id="a0fdaf17cbac0f8976b27199b4aed31f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdaf17cbac0f8976b27199b4aed31f5">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in a column with a scalar value. </p>
<p>Fills N elements of <code>column</code> starting at <code>begin</code> with <code>value</code>, where N = (<code>end</code> - <code>begin</code>)</p>
<p>The datatypes of <code>column</code> and <code>value</code> must be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">column</td><td>The preallocated column to fill into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The scalar value to fill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The starting index of the fill range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The index one past the end of the fill range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a68e93b1c814e07e108ad015d27ca2372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e93b1c814e07e108ad015d27ca2372">&#9670;&nbsp;</a></span>find_and_replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::find_and_replace_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>values_to_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements from <code>input_col</code> according to the mapping <code>values_to_replace</code> to <code>replacement_values</code>, that is, replace all <code>values_to_replace[i]</code> present in <code>input_col</code> with <code>replacement_values[i]</code>. </p>
<p>Replace elements from <code>input_col</code> according to the mapping <code>old_values</code> to <code>new_values</code>, that is, replace all <code>old_values[i]</code> present in <code>col</code> with <code>new_values[i]</code> and return a new gdf_column <code>output</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>gdf_column with the data to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_to_replace</td><td>gdf_column with the old values to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement_values</td><td>gdf_column with the new values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output gdf_column with the modified data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>gdf_column with the data to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_to_replace</td><td>gdf_column with the old values to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement_values</td><td>gdf_column with the new replacement values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output gdf_column with the modified data </dd></dl>

</div>
</div>
<a id="a3571c0c6314b622d87a18281ad08e212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3571c0c6314b622d87a18281ad08e212">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the the specified rows (including null values) of a set of columns, returning the result as a <code>table</code>. </p>
<p>Gathers the rows of the source columns according to <code>gather_map</code> such that row "i" in the resulting table will contain row "gather_map[i]" from the source columns.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>A non-nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>gather_map</code> and throw an error if any of its values are out of bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> Result of the gather </dd></dl>

</div>
</div>
<a id="a89365977c2da3d50a3262a1e540d1352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89365977c2da3d50a3262a1e540d1352">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> *&#160;</td>
          <td class="paramname"><em>destination_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the specified rows (including null values) of a set of source columns into a set of destination columns. </p>
<p>The two sets of columns must have equal numbers of columns.</p>
<p>Gathers the rows of the source columns into the destination columns according to <code>gather_map</code> such that row "i" in the destination columns will contain row "gather_map[i]" from the source columns.</p>
<p>The datatypes between coresponding columns in the source and destination columns must be the same.</p>
<p>The number of elements in the <code>gather_map</code> must equal the number of rows in the destination columns.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>A non-nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>gather_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination_table</td><td>A preallocated set of columns with a number of rows equal in size to the number of elements in the gather_map that will contain the rearrangement of the source columns based on the mapping. Can be the same as <code>source_table</code> (in-place gather). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2586b61fb4ca3ccf1fb3e0eed8cc981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2586b61fb4ca3ccf1fb3e0eed8cc981">&#9670;&nbsp;</a></span>gather() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const&#160;</td>
          <td class="paramname"><em>gather_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> *&#160;</td>
          <td class="paramname"><em>destination_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the specified rows (including null values) of a set of source columns into a set of destination columns. </p>
<p>The two sets of columns must have equal numbers of columns.</p>
<p>Gathers the rows of the source columns into the destination columns according to <code>gather_map</code> such that row "i" in the destination columns will contain row "gather_map[i]" from the source columns.</p>
<p>The datatypes between coresponding columns in the source and destination columns must be the same.</p>
<p>The number of elements in the <code>gather_map</code> must equal the number of rows in the destination columns.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>An array of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>gather_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination_table</td><td>A preallocated set of columns with a number of rows equal in size to the number of elements in the gather_map that will contain the rearrangement of the source columns based on the mapping. Can be the same as <code>source_table</code> (in-place gather). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7b0f1bc518e47eaa2cfdd0ec88e3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b0f1bc518e47eaa2cfdd0ec88e3989">&#9670;&nbsp;</a></span>gdf_dtype_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr gdf_dtype cudf::gdf_dtype_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a C++ type to it's corresponding gdf_dtype. </p>
<p>------------------------------------------------------------------------&mdash;* When explicitly passed a template argument of a given type, returns the appropriate <code>gdf_dtype</code> for the specified C++ type.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> gdf_dtype_of&lt;int32_t&gt;();        <span class="comment">// Returns GDF_INT32</span></div>
<div class="line"><span class="keywordflow">return</span> gdf_dtype_of&lt;cudf::category&gt;(); <span class="comment">// Returns GDF_CATEGORY</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md473"></a>
@tparam T The type to map to a &lt;tt&gt;gdf_dtype&lt;/tt&gt;</h2>

</div>
</div>
<a id="ae62151c46119cd04dc146c9e4175375f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62151c46119cd04dc146c9e4175375f">&#9670;&nbsp;</a></span>genericAtomicOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __device__ T cudf::genericAtomicOperation </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>update_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. </p>
<p>----------------------------------------------------------------------&mdash;* The supported cudf types for <code>genericAtomicOperation</code> are: int8_t, int16_t, int32_t, int64_t, float, double, cudf::date32, cudf::date64, cudf::timestamp, cudf::category, cudf::nvstring_category, cudf::bool8</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address of old value in global or shared memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The binary operator used for compute</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md179"></a>
@returns The old value at &lt;tt&gt;address&lt;/tt&gt;</h2>

</div>
</div>
<a id="a6c828f318cb2c14c8ac0567f5084d1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c828f318cb2c14c8ac0567f5084d1e7">&#9670;&nbsp;</a></span>group_quantiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a>, <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt; cudf::group_quantiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>quantiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a>&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code><a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8ab424744b6ce548ac355f5830c0a8c5e1">LINEAR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_nulls</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find values at given quantiles within groups. </p>
<p>Computes groupby <code>keys</code> and finds values at each quantile specified in <code>quantiles</code> in each group of each column in <code>values</code>. When the quantile does not correspond to an exact index, but lies between index i and j, the result is an interpolation of values at index i and j, using the method specified in <code>interpolation</code>. Nulls are always ignored in <code>values</code>.</p>
<p>Returns the resulting quantile(s) for all groups in a single column. When more than one quantile is requested, each group's results are stored contiguously in the same order specified in <code>quantiles</code>.</p>
<p>Illustration: </p><div class="fragment"><div class="line">Let</div>
<div class="line">keys   = {[ a, c, b, c, a],}</div>
<div class="line">values = {[v1,v2,v3,v4,v5],}</div>
<div class="line">quantiles = {q1, q2}</div>
<div class="line">out_keys, out_values = <a class="code" href="namespacecudf.html#a6c828f318cb2c14c8ac0567f5084d1e7">group_quantiles</a>(keys, values, quantiles)</div>
<div class="line"> </div>
<div class="line">out_keys = {[ a,      b,     c     ],}</div>
<div class="line">out_vals = {[x1, x2, y1, y2, z1, z2],}</div>
<div class="line">where</div>
<div class="line">x1 = value at quantile q1 in group [v1,v5]</div>
<div class="line">x2 = value at quantile q2 in group [v1,v5]</div>
<div class="line">y1 = value at quantile q1 in group [v3]</div>
<div class="line">y2 = value at quantile q2 in group [v3]</div>
<div class="line">z1 = value at quantile q1 in group [v2,v4]</div>
<div class="line">z2 = value at quantile q2 in group [v2,v4]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to group by </td></tr>
    <tr><td class="paramname">values</td><td>Values to find the quantiles in </td></tr>
    <tr><td class="paramname">quantiles</td><td>List of quantiles q where q is in [0,1] </td></tr>
    <tr><td class="paramname">interpolation</td><td>Method to use for interpolating quantiles that lie between points </td></tr>
    <tr><td class="paramname">include_nulls</td><td>Whether to consider rows in <code>keys</code> that contain <code>NULL</code> values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;cudf::table, cudf::table&gt; First table contains the unique keys in <code>keys</code>. Second table contains per-group values at quantiles </dd></dl>

</div>
</div>
<a id="ada393acb565321d740f2b9950ffe2941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada393acb565321d740f2b9950ffe2941">&#9670;&nbsp;</a></span>has_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::has_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a table contains any null values. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to check for null values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the table contains one or more null values </dd></dl>
<h2><a class="anchor" id="autotoc_md354"></a>
@return false If the table contains zero null values</h2>

</div>
</div>
<a id="a0d288a83fd8de580d2274f825997cbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d288a83fd8de580d2274f825997cbf3">&#9670;&nbsp;</a></span>have_same_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::have_same_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>validated_column_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>validated_column_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_extra_type_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures two (valid!) columns have the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validated_column_1</td><td>A column which would pass <a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate()</a> . </td></tr>
    <tr><td class="paramname">validated_column_2</td><td>A column which would pass <a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate()</a> . </td></tr>
    <tr><td class="paramname">ignore_extra_type_info</td><td>For some column element types, a column carries some qualifying information which applies to all elements (and thus not repeated for each one). Generally, this information should not be ignored, so that for two columns to have the same type, they must also share it. However, for potential practical reasons (with this being a utility rather than an API function), we allow the extra information to be ignored by setting this parameter to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb570307357da1e8c28cee58d653b5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb570307357da1e8c28cee58d653b5cb">&#9670;&nbsp;</a></span>inferCompressionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cudf::inferCompressionType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compression_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_input_type&#160;</td>
          <td class="paramname"><em>source_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext_to_compression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the compression type from the compression parameter and the input data. </p>
<p>Infer the compression type from the compression parameter and the input file extension.</p>
<p>------------------------------------------------------------------------&mdash;* Returns "none" if the input is not compressed. Throws if the input is not not valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compression_arg</td><td>Input string that is potentially describing the compression type. Can also be "none" or "infer". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_type</td><td>Enum describing the type of the data source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>If source_type is FILE_PATH, contains the filepath. If source_type is HOST_BUFFER, contains the input JSON data.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md82"></a>
@return string representing the compression type.</h2>
<p>------------------------------------------------------------------------&mdash;* Returns "none" if the input is not compressed. Throws if the input is not valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compression_arg</td><td>Input string that is potentially describing the compression type. Can also be "none" or "infer". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_type</td><td>Enum describing the type of the data source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>If source_type is FILE_PATH, contains the filepath. If source_type is HOST_BUFFER, contains the input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext_to_compression</td><td>Map between file extensions and compression types.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md83"></a>
@return string representing the compression type.</h2>

</div>
</div>
<a id="a097bed4db2f79f0e70d27f9a92329859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097bed4db2f79f0e70d27f9a92329859">&#9670;&nbsp;</a></span>intra_word_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __host__ __device__ size_type cudf::intra_word_index </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md467"></a>
@brief Returns the position within a word of the specified bit.</h2>

</div>
</div>
<a id="a14e1cea4200d1d92d7f38d596333d28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e1cea4200d1d92d7f38d596333d28a">&#9670;&nbsp;</a></span>is_compound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_compound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the type <code>T</code> is a compound type. </p>
<p>------------------------------------------------------------------------&mdash;* <code>column</code>s with "compound" elements are logically a single column of elements, but may be concretely implemented with two or more <code>column</code>s. For example, a <code>STRING</code> column could contain a <code>column</code> of offsets and a child <code>column</code> of characters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a "compound" type </dd></dl>
<h2><a class="anchor" id="autotoc_md486"></a>
@return false &lt;tt&gt;T&lt;/tt&gt; corresponds to a "simple" type</h2>

</div>
</div>
<a id="ad7f296c6fe2b6ae35ac59e41cbf1487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f296c6fe2b6ae35ac59e41cbf1487d">&#9670;&nbsp;</a></span>is_compound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_compound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether elements of <code>type</code> are compound. </p>
<p>------------------------------------------------------------------------&mdash;* <code>column</code>s with "compound" elements are logically a single column of elements, but may be concretely implemented with two or more <code>column</code>s. For example, a <code>STRING</code> column could contain a <code>column</code> of offsets and a child <code>column</code> of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a compound type </dd></dl>
<h2><a class="anchor" id="autotoc_md487"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is a simple type</h2>

</div>
</div>
<a id="aaa937abead085ea9420b15c6473f08a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa937abead085ea9420b15c6473f08a7">&#9670;&nbsp;</a></span>is_fixed_width() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_fixed_width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether elements of type <code>T</code> are fixed-width. </p>
<p>------------------------------------------------------------------------&mdash;* Elements of a fixed-width type all have the same size in bytes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The C++ type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a fixed-width element type </dd></dl>
<h2><a class="anchor" id="autotoc_md484"></a>
@return false &lt;tt&gt;T&lt;/tt&gt; corresponds to a variable-width element type</h2>

</div>
</div>
<a id="a347d883100d3f7c725ad64c649f59c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347d883100d3f7c725ad64c649f59c11">&#9670;&nbsp;</a></span>is_fixed_width() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_fixed_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether elements of <code>type</code> are fixed-width. </p>
<p>------------------------------------------------------------------------&mdash;* Elements of a fixed-width type all have the same size in bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is fixed-width </dd></dl>
<h2><a class="anchor" id="autotoc_md485"></a>
@return false  &lt;tt&gt;type&lt;/tt&gt; is variable-width</h2>

</div>
</div>
<a id="a736c39af324b57534639bd3d8af357e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736c39af324b57534639bd3d8af357e4">&#9670;&nbsp;</a></span>is_numeric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_numeric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the type <code>T</code> is a numeric type. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> is numeric </dd></dl>
<h2><a class="anchor" id="autotoc_md482"></a>
@return false  &lt;tt&gt;T&lt;/tt&gt; is not numeric</h2>

</div>
</div>
<a id="ac193df7b5be153a88978c2e6564bf4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac193df7b5be153a88978c2e6564bf4f2">&#9670;&nbsp;</a></span>is_numeric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_numeric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether <code>type</code> is a numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>. </p>
<p>------------------------------------------------------------------------&mdash;* "Numeric" types are fundamental integral/floating point types such as <code>INT*</code> or <code>FLOAT*</code>. Types that wrap a numeric type are not considered numeric, e.g., <code>TIMESTAMP</code> or <code>DATE32</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is numeric </dd></dl>
<h2><a class="anchor" id="autotoc_md483"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is not numeric</h2>

</div>
</div>
<a id="aef9b08b206b1340c5ac3893d17943309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9b08b206b1340c5ac3893d17943309">&#9670;&nbsp;</a></span>is_relationally_comparable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_relationally_comparable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether objects of types <code>L</code> and <code>R</code> can be relationally compared. </p>
<p>------------------------------------------------------------------------&mdash;* Given two objects <code>L l</code>, and <code>R r</code>, returns true if <code>l &lt; r</code> and <code>l &gt; r</code> are well-formed expressions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>Type of the first object </td></tr>
    <tr><td class="paramname">R</td><td>Type of the second object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Objects of types <code>L</code> and <code>R</code> can be relationally be compared </dd></dl>
<h2><a class="anchor" id="autotoc_md481"></a>
@return false Objects of types &lt;tt&gt;L&lt;/tt&gt; and &lt;tt&gt;R&lt;/tt&gt; cannot be compared</h2>

</div>
</div>
<a id="ad15f075ce6421723e214c0d153fe695f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f075ce6421723e214c0d153fe695f">&#9670;&nbsp;</a></span>is_simple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_simple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the type <code>T</code> is a simple type. </p>
<p>------------------------------------------------------------------------&mdash;* "Simple" element types are implemented with only a single column, i.e., <code>num_children() == 0</code> for columns of "simple" elements</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a simple type </dd></dl>
<h2><a class="anchor" id="autotoc_md488"></a>
@return false &lt;tt&gt;T&lt;/tt&gt; corresponds to a compound type</h2>

</div>
</div>
<a id="ae6e62b8bc2981be767ae3f6843877956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e62b8bc2981be767ae3f6843877956">&#9670;&nbsp;</a></span>is_simple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_simple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether elements of <code>type</code> are simple. </p>
<p>------------------------------------------------------------------------&mdash;* "Simple" element types are implemented with only a single column, i.e., <code>num_children() == 0</code> for columns of "simple" elements</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a simple type </dd></dl>
<h2><a class="anchor" id="autotoc_md489"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is a compound type</h2>

</div>
</div>
<a id="aac52a52a504d46887f1368ae13a96ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac52a52a504d46887f1368ae13a96ffb">&#9670;&nbsp;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int8_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>descending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nulls_are_smallest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the rows of a <code>table</code> are sorted in a lexicographical order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>table whose rows need to be compared for ordering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descending</td><td>vector that specifies the expected ordering of each input column (0 is ascending order and 1 is descending) If this an empty vector, then it will be assumed that each column is in ascending order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_are_smallest</td><td>true indicates nulls are to be considered smaller than non-nulls ; false indicates opposite</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - if sorted , false - if not. </dd></dl>

</div>
</div>
<a id="a324e3af1901162a99c4e182255e63964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324e3af1901162a99c4e182255e63964">&#9670;&nbsp;</a></span>join_call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;JoinType join_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cudf::join_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>left_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>right_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__context__.html">gdf_context</a> *&#160;</td>
          <td class="paramname"><em>join_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the join operation between two sets of columns. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If <code>left</code>/<code>right</code> table is empty If number of rows in table is too big If it has in-valid join context If method is sort based and number of columns to join are more than <code>1</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Table of left columns to join </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Table of right columns to join </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_result</td><td>The join computed indices of the <code>left</code> table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">right_result</td><td>The join computed indices of the <code>right</code> table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">join_context</td><td>A structure that determines various run parameters, such as whether to perform a hash or sort based join </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">join_type</td><td>The type of join to be performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e6ad074553cd2057f34df199598e8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6ad074553cd2057f34df199598e8e1">&#9670;&nbsp;</a></span>join_call_compute_df()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;JoinType join_type, typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::join_call_compute_df </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gdf_size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>left_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gdf_size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; gdf_size_type, gdf_size_type &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>columns_in_common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> *&#160;</td>
          <td class="paramname"><em>joined_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__context__.html">gdf_context</a> *&#160;</td>
          <td class="paramname"><em>join_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs join on the columns provided in <code>left</code> and <code>right</code> as per the joining indices given in <code>left_on</code> and <code>right_on</code> and creates a single table. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if a sort-based join is requested and either <code>right_on</code> or <code>left_on</code> contains null values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The left table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The right table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_on</td><td>The column's indices from <code>left</code> to join on. Column <code>i</code> from <code>left_on</code> will be compared against column <code>i</code> of <code>right_on</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_on</td><td>The column's indices from <code>right</code> to join on. Column <code>i</code> from <code>right_on</code> will be compared with column <code>i</code> of <code>left_on</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns_in_common</td><td>is a vector of pairs of column indices into <code>left_on</code> and <code>right_on</code>, respectively, that are "in common". For "common" columns, only a single output column will be produced, which is gathered from <code>left_on</code> if it is left join or from intersection of <code>left_on</code> and <code>right_on</code> if it is inner join or gathered from both <code>left_on</code> and <code>right_on</code> if it is full join. Else, for every column in <code>left_on</code> and <code>right_on</code>, an output column will be produced.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>joined_indices Optional, if not <code>nullptr</code>, on return, will contain two non-nullable, <code>GDF_INT32</code> columns containing the indices of matching rows between <code>left_on</code> and <code>right_on</code>. The first column corresponds to rows in <code>left_on</code>, and the second to <code>right_on</code>. A value of <code>-1</code> in the second column indicates that the corresponding row in <code>left_on</code> has no match. And similarly <code>-1</code> in first column indicates that the corresponding row in <code>right_on</code> has no match. It is the caller's responsibility to free these columns. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">join_context</td><td>The context to use to control how the join is performed,e.g., sort vs hash based implementation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of joining <code>left</code> and <code>right</code> tables on the columns specified by <code>left_on</code> and <code>right_on</code>. The resulting table will be joined columns of <code>left(including common columns)+right(excluding common columns)</code>. </dd></dl>

</div>
</div>
<a id="ae90960c52c1f1fe3ab2257bad89b18fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90960c52c1f1fe3ab2257bad89b18fc">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&#160;</td>
          <td class="paramname"><em>desc_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nulls_as_largest</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find smallest indices in a sorted table where values should be inserted to maintain order. </p>
<p>------------------------------------------------------------------------&mdash;* For each row v in <code>values</code>, find the first index in <code>t</code> where inserting the row will maintain the sort order of <code>t</code> </p>
<p>Example:</p>
<p>Single column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 1 }</p>
<p>Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 3 }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Table to search </td></tr>
    <tr><td class="paramname">values</td><td>Find insert locations for these values </td></tr>
    <tr><td class="paramname">desc_flags</td><td>Vector of column sort order. False indicates the corresponding column is sorted ascending </td></tr>
    <tr><td class="paramname">nulls_as_largest</td><td>If true, nulls are considered larger than valid values, otherwise, nulls are considered smaller than valid values</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md377"></a>
@return gdf_column   Insertion points. Non-nullable column of type GDF_INT32 with same size as values.</h2>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2search_8hpp-example.html#a1">/rapids/cudf/cpp/include/cudf/search.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5315ca38e017e2ed42a400483bba3b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5315ca38e017e2ed42a400483bba3b56">&#9670;&nbsp;</a></span>make_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cudf::make_iterator </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_mask::bit_mask_t *&#160;</td>
          <td class="paramname"><em>valid</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>identity</em> = <code>ResultType{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator_Index const&#160;</td>
          <td class="paramname"><em>it</em> = <code>Iterator_Index(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an iterator over the elements of a column. </p>
<p>----------------------------------------------------------------------&mdash;* If the column contains no null values (indicated by <code>has_nulls == false</code>) then dereferencing an iterator <code>it</code> returned by this function as <code>*(it + n)</code> will return <code>ResultType{ static_cast&lt;ElementType*&gt;(data)[n] }</code>.</p>
<p>If the column contains null values (indicated by <code>has_nulls == true</code>) then the result of de-referencing an iterator <code>it</code> returned by this function as <code>*(it+n)</code> will depend if element is valid or null. If the element is valid, it will return <code>ResultType{ static_cast&lt;ElementType*&gt;(data)[n] }</code>. If the element is null, it will return <code>ResultType{identity}</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">has_nulls</td><td>Indicates if the column contains null values (<code>null_count &gt; 0</code>) </td></tr>
    <tr><td class="paramname">ElementType</td><td>The cudf data type of input array </td></tr>
    <tr><td class="paramname">ResultType</td><td>cudf data type of output and <code>identity</code> value which is used when null bitmaps flag is false. </td></tr>
    <tr><td class="paramname">Iterator_Index</td><td>The base iterator which gives the index of array. The default is <code>thrust::counting_iterator</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The pointer of column data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid</td><td>The pointer of null bitmask of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>The identity value used when the mask value is false </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md127"></a>
@param[in] it       The index iterator, &lt;tt&gt;thrust::counting_iterator&lt;/tt&gt; by default</h2>

</div>
</div>
<a id="ae67659a0dfb8fb06d47d196b59544e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67659a0dfb8fb06d47d196b59544e9f">&#9670;&nbsp;</a></span>make_numeric_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_numeric_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="section note"><dt>Note</dt><dd><code>null_count()</code> is determined by the requested null mask <code>state</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired numeric element type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Optional, controls allocation/initialization of the column's null mask. By default, no null mask is allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocation and device kernels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md247"></a>
allocation of the column's &lt;tt&gt;data&lt;/tt&gt; and &lt;tt&gt;null_mask&lt;/tt&gt;.</h2>

</div>
</div>
<a id="a20b11ec1348ab46ae20792ea4e2c0ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b11ec1348ab46ae20792ea4e2c0ca4">&#9670;&nbsp;</a></span>make_pair_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cudf::make_pair_iterator </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_mask::bit_mask_t *&#160;</td>
          <td class="paramname"><em>valid</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>identity</em> = <code>ResultType{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator_Index const&#160;</td>
          <td class="paramname"><em>it</em> = <code>Iterator_Index(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an iterator over the elements of a column Input iterator which can be used for cub and thrust. </p>
<p>----------------------------------------------------------------------&mdash;* The iterator returns thrust::pair&lt;ResultType, bool&gt; This is useful for more complex logic that depends on the validity. e.g. group_by.count, mean_var, sort algorism.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">has_nulls</td><td>True if the data has valid bit mask, False else </td></tr>
    <tr><td class="paramname">ElementType</td><td>The cudf data type of input array </td></tr>
    <tr><td class="paramname">ResultType</td><td>cudf data type of output and <code>identity</code> value which is used when null bitmaps flag is false. </td></tr>
    <tr><td class="paramname">Iterator_Index</td><td>The base iterator which gives the index of array. The default is <code>thrust::counting_iterator</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The pointer of column data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid</td><td>The pointer of null bitmask of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>The identity value used when the mask value is false </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md130"></a>
@param[in] it       The index iterator, &lt;tt&gt;thrust::counting_iterator&lt;/tt&gt; by default</h2>

</div>
</div>
<a id="a00cef65bd1df1b0b2a30f9e047ad35e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cef65bd1df1b0b2a30f9e047ad35e1">&#9670;&nbsp;</a></span>make_strings_column() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_strings_column </td>
          <td>(</td>
          <td class="paramtype">const rmm::device_vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmm::device_vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmm::device_vector&lt; bitmask_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>null_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct STRING type column given an contiguous array of chars encoded as UTF-8, an array of byte offsets identifying individual strings within the char array, and a null bitmask. The total number of char bytes must not exceed the maximum size of size_type. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class.">strings_column_view</a> class to perform strings operations on this type of column. This function makes a deep copy of the strings, offsets, null_mask to create a new column. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>The contiguous array of chars in device memory. This char array is expected to be UTF-8 encoded characters. </td></tr>
    <tr><td class="paramname">offsets</td><td>The array of byte offsets in device memory. The number of elements is one more than the total number of strings so the offset[last] - offset[0] is the total number of bytes in the strings array. </td></tr>
    <tr><td class="paramname">null_mask</td><td>The array of bits specifying the null strings. This array must be in device memory. Arrow format for nulls is used for interpeting this bitmask. </td></tr>
    <tr><td class="paramname">null_count</td><td>The number of null string entries. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocation and device kernels </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md249"></a>
allocation of the column's &lt;tt&gt;null_mask&lt;/tt&gt; and children.</h2>

</div>
</div>
<a id="a806dfe2d3033333c99fd399afeddab3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806dfe2d3033333c99fd399afeddab3d">&#9670;&nbsp;</a></span>make_strings_column() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_strings_column </td>
          <td>(</td>
          <td class="paramtype">const rmm::device_vector&lt; thrust::pair&lt; const char *, size_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct STRING type column given an array of pointer/size pairs. The total number of char bytes must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class.">strings_column_view</a> class to perform strings operations on this type of column. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="section note"><dt>Note</dt><dd><code>null_count()</code> and <code>null_bitmask</code> are determined if a pair contains a null string. That is, for each pair, if <code>.first</code> is null, that string is considered null. Likewise, a string is considered empty (not null) if <code>.first</code> is not null and <code>.second</code> is 0. Otherwise the <code>.first</code> member must be a valid device address pointing to <code>.second</code> consecutive bytes.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>The pointer/size pair arrays. Each pointer must be a device memory address or <code>nullptr</code> (indicating a null string). The size must be the number of bytes. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocation and device kernels </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md248"></a>
allocation of the column's &lt;tt&gt;null_mask&lt;/tt&gt; and children.</h2>

</div>
</div>
<a id="aba9b7e3e01a011595712fcaa6fb3a678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9b7e3e01a011595712fcaa6fb3a678">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>left_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>right_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gdf_size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>key_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; order_by_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>asc_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nulls_are_smallest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted tables. </p>
<p>Merges two sorted tables (including null values) into one sorted table containing data from both tables.</p>
<p>Example: input: table 1 =&gt; col 1 {0, 1, 2, 3} col 2 {4, 5, 6, 7} table 2 =&gt; col 1 {1, 2} col 2 {8, 9} output: table =&gt; col 1 {0, 1, 1, 2, 2, 3} col 2 {4, 5, 8, 6, 9, 7}</p>
<p>@Param[in] left_table A sorted table to be merged @Param[in] right_table A sorted table to be merged @Param[in] key_cols Indices of left_cols and right_cols to be used for comparison criteria @Param[in] asc_desc Sort order types of columns indexed by key_cols @Param[in] nulls_are_smallest Flag indicating is nulls are to be treated as the smallest value</p>
<p>@Returns A table containing sorted data from left_table and right_table </p>

</div>
</div>
<a id="a33e3a1ed670c88771cd7e594dda2f225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e3a1ed670c88771cd7e594dda2f225">&#9670;&nbsp;</a></span>nans_to_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bit_mask::bit_mask_t *, gdf_size_type &gt; cudf::nans_to_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a column with floating point values, generate a bitmask where every NaN is indicated as the corresponding null bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to generate bitmask from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>std::pair</code> of <code>bit_mask_t*</code>, the output bitmask, and its null count </dd></dl>

</div>
</div>
<a id="a0e2fab609bbc1f3b044d5d5f62d37a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2fab609bbc1f3b044d5d5f62d37a84">&#9670;&nbsp;</a></span>non_common_column_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto cudf::non_common_column_indices </td>
          <td>(</td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>num_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gdf_size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>common_column_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with non-common indices which is set difference between <code>[0, num_columns)</code> and index values in common_column_indices. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_columns</td><td>The number of columns , which represents column indices from <code>[0, num_columns)</code> in a table </td></tr>
    <tr><td class="paramname">common_column_indices</td><td>A vector of common indices which needs to be excluded from <code>[0, num_columns)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector A vector containing only the indices which are not present in </dd></dl>
<h2><a class="anchor" id="autotoc_md157"></a>
&lt;tt&gt;common_column_indices&lt;/tt&gt;</h2>

</div>
</div>
<a id="aa5bd500e54a0760773f941986e8e056b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bd500e54a0760773f941986e8e056b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> objects for equality. </p>
<p>------------------------------------------------------------------------&mdash;* // TODO Define exactly what it means for two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>s to be equal. e.g., are two timestamps with different resolutions equal? How about decimals with different scale/precision?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>The second <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>lhs</code> is equal to <code>rhs</code> </dd></dl>
<h2><a class="anchor" id="autotoc_md463"></a>
@return false &lt;tt&gt;lhs&lt;/tt&gt; is not equal to &lt;tt&gt;rhs&lt;/tt&gt;</h2>

</div>
</div>
<a id="a30c6e502e3755eefe9a720cdf0f3ed5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c6e502e3755eefe9a720cdf0f3ed5e">&#9670;&nbsp;</a></span>point_in_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::point_in_polygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>polygon_latitudes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>polygon_longitudes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>query_point_latitudes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>query_point_longitudes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether or not coordinates (query points) are completely inside a static polygon. </p>
<p>Note: The polygon must not have holes or intersect with itself, but it is not required to be convex.</p>
<p>The polygon is defined by a set of coordinates (latitudes and longitudes), where the first and last coordinates must have the same value (closed).</p>
<p>This function supports clockwise and counter-clockwise polygons.</p>
<p>If a query point is colinear with two contiguous polygon coordinates then this query point isn't inside.</p>
<p>polygon_latitudes and polygon_longitudes must have equal size.</p>
<p>point_latitudes and point_longitudes must have equal size.</p>
<p>All input params must have equal datatypes (for numeric operations).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon_latitudes</td><td>column with latitudes of a polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon_longitudes</td><td>column with longitudes of a polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">query_point_latitudes</td><td>column with latitudes of query points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">query_point_longitudes</td><td>column with longitudes of query points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column of type GDF_BOOL8 indicating whether the i-th query point is inside (true) or not (false) </dd></dl>

</div>
</div>
<a id="aaecb9e39d5b5475f53260497f3a8db0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecb9e39d5b5475f53260497f3a8db0a">&#9670;&nbsp;</a></span>quantile_approx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gdf_error cudf::quantile_approx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>col_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__context__.html">gdf_context</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes approximate quantile. </p>
<p>Computes quantile with the same type as <code>col_in</code>. This function works only with arithmetic columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col_in</td><td>input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>requested quantile in [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The value at the requested quantile, with the same type as <code>col_in</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon successful compute, otherwise returns appropriate error code </dd></dl>

</div>
</div>
<a id="a3aad879c6bbd17521333c06dab5db483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aad879c6bbd17521333c06dab5db483">&#9670;&nbsp;</a></span>quantile_exact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gdf_error cudf::quantile_exact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>col_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a>&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__context__.html">gdf_context</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes exact quantile. </p>
<p>Computes quantile using double precision. This function works only with arithmetic columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col_in</td><td>input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolation</td><td>Method to use for interpolating quantiles that lie between points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>requested quantile in [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The value at the requested quantile </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon successful compute, otherwise returns appropriate error code </dd></dl>

</div>
</div>
<a id="a34eb2aea42d4ee97fb98cc4b38dabd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34eb2aea42d4ee97fb98cc4b38dabd7c">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> cudf::reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::reduction::operators&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>output_dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision <code>dtype</code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> will contain <code>false</code>. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>Input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operator applied by the reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_dtype</td><td>The computation and output precision. <code>dtype</code> must be a data type that is convertible from the input dtype. If the input column has arithmetic type or cudf::bool8 type, output_dtype can be any arithmetic type or cudf::bool8 type. For <code>mean</code>, <code>var</code> and <code>std</code> ops, a floating point type must be specified. If the input column has non-arithmetic type (date32, timestamp, category...), the same type must be specified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ddof</td><td>Delta Degrees of Freedom: the divisor used in calculation of <code>std</code> and <code>var</code> is <code>N - ddof</code>, where <code>N</code> is the population size.`</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> the result value If the reduction fails, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> </dd></dl>
<h2><a class="anchor" id="autotoc_md375"></a>
will contain &lt;tt&gt;false&lt;/tt&gt;.</h2>

</div>
</div>
<a id="ae7c4ffa4dba2b1e23f4f4322f7b06408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c4ffa4dba2b1e23f4f4322f7b06408">&#9670;&nbsp;</a></span>repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::repeat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table. </p>
<p>Creates a new table by repeating the rows of <code>in</code>. The number of repetitions of each element is defined by the value at the corresponding index of <code>count</code> Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = [1,2,3]</div>
<div class="line"><span class="keywordflow">return</span> = [4,5,5,6,6,6]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input column </td></tr>
    <tr><td class="paramname">count</td><td>Non-nullable column of type <code>GDF_INT32</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> The result table containing the repetitions </dd></dl>

</div>
</div>
<a id="a00deb58e53fc1648eb5dce3e79d0790c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00deb58e53fc1648eb5dce3e79d0790c">&#9670;&nbsp;</a></span>repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::repeat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table. </p>
<p>Creates a new table by repeating <code>count</code> times the rows of <code>in</code>. Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = 2</div>
<div class="line"><span class="keywordflow">return</span> = [4,4,5,5,6,6]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input column </td></tr>
    <tr><td class="paramname">count</td><td>Non-null scalar of type <code>GDF_INT32</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> The result table containing the repetitions </dd></dl>

</div>
</div>
<a id="a85645250c7ada0b73a61e9a691931b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85645250c7ada0b73a61e9a691931b36">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::replace_nulls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with corresponding values of another column. </p>
<p>Returns a column <code>output</code> such that if <code>input[i]</code> is valid, its value will be copied to <code>output[i]</code>. Otherwise, <code>replacements[i]</code> will be copied to <code>output[i]</code>.</p>
<p>The <code>input</code> and <code>replacement</code> columns must be of same size and have the same data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A gdf_column containing null values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A gdf_column whose values will replace null values in input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column with nulls replaced </dd></dl>

</div>
</div>
<a id="ad66cc66793473e7fc90ad3ed4cd1b450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66cc66793473e7fc90ad3ed4cd1b450">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::replace_nulls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with a scalar. </p>
<p>Returns a column <code>output</code> such that if <code>input[i]</code> is valid, its value will be copied to <code>output[i]</code>. Otherise, <code>replacement</code> will be coped to <code>output[i]</code>.</p>
<p><code>replacement</code> must have the same data type as <code>input</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A gdf_column containing null values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> whose value will replace null values in input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column with nulls replaced </dd></dl>

</div>
</div>
<a id="aec006bc00092dd8ec47f2c7ca6fe01d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec006bc00092dd8ec47f2c7ca6fe01d4">&#9670;&nbsp;</a></span>row_bitmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_vector&lt; bit_mask::bit_mask_t &gt; cudf::row_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a bitmask indicating the presence of NULL values in rows of a table. </p>
<p>------------------------------------------------------------------------&mdash;* If a row <code>i</code> in <code>table</code> contains one or more NULL values, then bit <code>i</code> in the returned bitmask will be 0.</p>
<p>Otherwise, bit <code>i</code> will be 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to compute the row bitmask of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bit_mask::bit_mask_t* The bitmask indicating the presence of NULLs in </dd></dl>
<h2><a class="anchor" id="autotoc_md6"></a>
a row</h2>

</div>
</div>
<a id="a65546aa9c42e87334fb5e1e3f274bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65546aa9c42e87334fb5e1e3f274bc6b">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_scan_op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column for the san </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The pre-allocated output column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation of the scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inclusive</td><td>The flag for applying an inclusive scan if true, </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md376"></a>
an exclusive scan if false.</h2>

</div>
</div>
<a id="a8f032f6bab98db53bf7fa76259e09e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f032f6bab98db53bf7fa76259e09e92">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::scatter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const&#160;</td>
          <td class="paramname"><em>scatter_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>num_scatter_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>table</code> as if scattering a set of <code><a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a></code> values into the rows of a <code>target</code> table in-place. </p>
<p><code>data</code> and <code>valid</code> of a specific row of the target_column is kept unchanged if the <code>scatter_map</code> does not map to that row.</p>
<p>The datatypes between coresponding columns in the source and target columns must be the same.</p>
<p>A negative index <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>destination_table</code>.</p>
<p>If the same index appears more than once in <code>scatter_map</code>, the result is undefined.</p>
<p>If the scalar is null (is_valid == false) and the target column does not have a valid bitmask, the destination column will have a bitmask allocated.</p>
<p>@Param[in] source The row to be scattered @Param[in] scatter_map An array that maps to rows in the output columns. @Param[in] target The table to copy and then perform an in-place scatter into the copy. </p><dl class="section return"><dt>Returns</dt><dd>[out] The result of the scatter </dd></dl>

</div>
</div>
<a id="ae9ee593defbe8e2fcaa05b50fbd6612e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ee593defbe8e2fcaa05b50fbd6612e">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>scatter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>table</code> as if an in-place scatter from a <code>source</code> table was performed on the <code>target</code> table. </p>
<p>It is the user's reponsibility to free the device memory allocated in the returned table <code>destination_table</code>.</p>
<p>The <code>source_table</code> and the <code>target_table</code> must have equal numbers of columns.</p>
<p>The datatypes between coresponding columns in the source and target columns must be the same.</p>
<p>The number of elements in the <code>scatter_map</code> must equal the number of rows in the source columns.</p>
<p>A negative index <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>destination_table</code>.</p>
<p>If the same index appears more than once in <code>scatter_map</code>, the result is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>scatter_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the destination table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<p>A column in the output will only be nullable if:</p><ul>
<li>Its corresponding column in <code>target</code> is nullable</li>
<li>Its corresponding column in <code>source</code> has <code>null_count &gt; 0</code></li>
</ul>
<p>@Param[in] source The columns whose rows will be scattered @Param[in] scatter_map A non-nullable column of integral indices that map rows in the input columns to rows in the output columns. @Param[in] target The table to copy and then perform an in-place scatter into the copy. @Param[in] check_bounds Optionally perform bounds checking on the values of <code>scatter_map</code> and throw an error if any of its values are out of bounds. </p><dl class="section return"><dt>Returns</dt><dd>[out] The result of the scatter </dd></dl>

</div>
</div>
<a id="ad65bd33669f3f37267a3b3db66a21aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65bd33669f3f37267a3b3db66a21aa1">&#9670;&nbsp;</a></span>scatter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const&#160;</td>
          <td class="paramname"><em>scatter_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>table</code> as if an in-place scatter from a <code>source</code> table was performed on the <code>target</code> table. </p>
<p>It is the user's reponsibility to free the device memory allocated in the returned table <code>destination_table</code>.</p>
<p>The <code>source_table</code> and the <code>target_table</code> must have equal numbers of columns.</p>
<p>The datatypes between coresponding columns in the source and target columns must be the same.</p>
<p>The number of elements in the <code>scatter_map</code> must equal the number of rows in the source columns.</p>
<p>A negative index <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>destination_table</code>.</p>
<p>If the same index appears more than once in <code>scatter_map</code>, the result is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>scatter_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the destination table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<p>A column in the output will only be nullable if:</p><ul>
<li>Its corresponding column in <code>target</code> is nullable</li>
<li>Its corresponding column in <code>source</code> has <code>null_count &gt; 0</code></li>
</ul>
<p>@Param[in] source The columns whose rows will be scattered @Param[in] scatter_map An array of integral indices that map rows in the input columns to rows in the output columns. @Param[in] target The table to copy and then perform an in-place scatter into the copy. @Param[in] check_bounds Optionally perform bounds checking on the values of <code>scatter_map</code> and throw an error if any of its values are out of bounds. </p><dl class="section return"><dt>Returns</dt><dd>[out] The result of the scatter </dd></dl>

</div>
</div>
<a id="aaa398ba021c84cb39c9e1dcd65d81b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa398ba021c84cb39c9e1dcd65d81b64">&#9670;&nbsp;</a></span>scatter_to_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt; cudf::scatter_to_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>scatter_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows of a table to <code>n</code> tables according to a scatter map. </p>
<p>Copies the rows from the input table to new tables according to the table indices given by scatter map. The number of output tables is one more than the maximum value in <code>scatter_map</code>. If a value in [0,n] does not appear in scatter_map, then the corresponding output table will be empty.</p>
<p><code>scatter_map</code> is a non-nullable column of <code>GDF_INT32</code> elements whose <code>size</code> equals <code>input.num_rows()</code> and contains numbers in range of [0, n].</p>
<p>Exceptional cases for the scatter_map column are: </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>scatter_map.dtype != GDF_INT32</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>scatter_map.size != input.num_rows()</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>has_nulls(scatter_map) == true</code></td></tr>
  </table>
  </dd>
</dl>
<p>Example: input: [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28}, { 1, 2, 3, 4, null, 0, 2, 4, 6, 2}] scatter_map: { 3, 4, 3, 1, 4, 4, 0, 1, 1, 1} output: {[{22}, {2}], [{16, 24, 26, 28}, {4, 4, 6, 2}], [{}, {}], [{10, 14}, {1, 3}], [{12, 18, 20}, {2, null, 0}]}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Table whose rows will be partitioned into a set of tables according to <code>scatter_map</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scatter_map</td><td>Non-nullable column of <code>GDF_INT32</code> values that map each row in <code>input</code> table into one of the output tables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of <code>table</code>s containing the scattered rows of <code>input</code>. <code>table</code> <code>i</code> contains all rows <code>j</code> from <code>input</code> where <code>scatter_map[j] == i</code>. </dd></dl>

</div>
</div>
<a id="a14b47d0e147b3ccf92e1325496f6da42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b47d0e147b3ccf92e1325496f6da42">&#9670;&nbsp;</a></span>set_bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void cudf::set_bit </td>
          <td>(</td>
          <td class="paramtype">bitmask_type *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the specified bit to <code>1</code> </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="section note"><dt>Note</dt><dd>This operation requires a global atomic operation. Therefore, it is not recommended to use this function in performance critical regions. When possible, it is more efficient to compute and update an entire word at once using <code>set_word</code>.</dd></dl>
<p>This function is thread-safe.</p>
<h2><a class="anchor" id="autotoc_md469"></a>
@param bit_index  Index of the bit to set</h2>

</div>
</div>
<a id="af17cc4ac1f0309603710ea5052d61d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17cc4ac1f0309603710ea5052d61d24">&#9670;&nbsp;</a></span>set_least_significant_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __device__ bitmask_type cudf::set_least_significant_bits </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bitmask word with the <code>n</code> least significant bits set. </p>
<p>------------------------------------------------------------------------&mdash;* Behavior is undefined if <code>n &lt; 0</code> or if <code>n &gt;= size_in_bits&lt;bitmask_type&gt;()</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of least significant bits to set </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md470"></a>
@return A bitmask word with &lt;tt&gt;n&lt;/tt&gt; least significant bits set</h2>

</div>
</div>
<a id="a132fe860101a1ac9a4804398830ca204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132fe860101a1ac9a4804398830ca204">&#9670;&nbsp;</a></span>set_most_significant_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __device__ bitmask_type cudf::set_most_significant_bits </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bitmask word with the <code>n</code> most significant bits set. </p>
<p>------------------------------------------------------------------------&mdash;* Behavior is undefined if <code>n &lt; 0</code> or if <code>n &gt;= size_in_bits&lt;bitmask_type&gt;()</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of most significant bits to set </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md471"></a>
@return A bitmask word with &lt;tt&gt;n&lt;/tt&gt; most significant bits set</h2>

</div>
</div>
<a id="a51b0daf2c01663d51cb3b87ad8ce93c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b0daf2c01663d51cb3b87ad8ce93c0">&#9670;&nbsp;</a></span>size_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cudf::size_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size in bytes of elements of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> </p>
<dl class="section note"><dt>Note</dt><dd>Only fixed-width types are supported</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>is_fixed_width(element_type) == false</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of an element of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> </dd></dl>

</div>
</div>
<a id="a55e5ff580a7ad1c81368264f69934d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e5ff580a7ad1c81368264f69934d9d">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt; cudf::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>num_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a column (including null values) into a set of columns according to a set of indices. </p>
<p>The "slice" function divides part of the input column into multiple intervals of rows using the indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.</p>
<p>The pairs of indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.</p>
<p>Exceptional cases for the indices array are: When the values in the pair are equal, the function returns an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.</p>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} indices: {1, 3, 5, 9, 2, 4, 8, 8} output: {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column whose rows will be sliced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>An device array of indices that are used to take 'slices' of the input column. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_indices</td><td>Number of indices in the indices array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of gdf_column*, each of which may have a different number of rows. The number of rows in each column is equal to the difference of two consecutive indices in the indices array. </dd></dl>

</div>
</div>
<a id="a934a77ba7b53046d100f9c2a164be97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934a77ba7b53046d100f9c2a164be97b">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt; cudf::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const *&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>num_splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a column (including null values) into a set of columns according to a set of indices. </p>
<p>The "split" function divides the input column into multiple intervals of rows using the splits indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.</p>
<p>The indices array ('splits') is require to be a monotonic non-decreasing set. The indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.</p>
<p>The split function will take a pair of indices from the indices array ('splits') in a consecutive manner. For the first pair, the function will take the value 0 and the first element of the indices array. For the last pair, the function will take the last element of the indices array and the size of the input column.</p>
<p>Exceptional cases for the indices array are: When the values in the pair are equal, the function return an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.</p>
<p>The input columns may have different sizes. The number of columns must be equal to the number of indices in the array plus one.</p>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} splits: {2, 5, 9} output: {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column whose rows will be split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splits</td><td>An device array of indices that are used to divide the input column into multiple columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_splits</td><td>Number of splits in the splits indices array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of gdf_column*, each of which may have a different size a different number of rows. </dd></dl>

</div>
</div>
<a id="a48561f1e899da3a79132c108463840de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48561f1e899da3a79132c108463840de">&#9670;&nbsp;</a></span>state_null_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type cudf::state_null_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the null count for a null mask of the specified <code>state</code> representing <code>size</code> elements. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state of the null mask </td></tr>
    <tr><td class="paramname">size</td><td>The number of elements represented by the mask </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md370"></a>
@return size_type The count of null elements</h2>

</div>
</div>
<a id="a45876c5d57c0d0afb921add28b3516e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45876c5d57c0d0afb921add28b3516e3">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unary_udf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_ptx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column by applying a unary function against every element of an input column. </p>
<p>Computes: <code>out[i] = F(in[i])</code></p>
<p>Support all GDF data types except for GDF_CATEGORY or GDF_STRING. For GDF_STRING_CATEGORY the UDF is only applied to the indices, after which the underlying category is cleared and remapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to transform </td></tr>
    <tr><td class="paramname">unary_udf</td><td>The PTX/CUDA string of the unary function to apply </td></tr>
    <tr><td class="paramname">outout_type</td><td>The output type that is compatible with the output type in the PTX code </td></tr>
    <tr><td class="paramname">is_ptx</td><td>If true the UDF is treated as a piece of PTX code; if fasle the UDF is treated as a piece of CUDA code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column The column resulting from applying the unary function to every element of the input </dd></dl>

</div>
</div>
<a id="acb548c461266cacc3b713e8007405a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb548c461266cacc3b713e8007405a8f">&#9670;&nbsp;</a></span>trivial_full_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::trivial_full_join </td>
          <td>(</td>
          <td class="paramtype">const gdf_size_type&#160;</td>
          <td class="paramname"><em>left_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gdf_size_type&#160;</td>
          <td class="paramname"><em>right_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>left_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>right_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trivially computes full join of two tables if one of the tables are empty. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>"Dataset is empty" if both left_table and right_table are empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left_size</td><td>The size of the left table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_size</td><td>The size of the right table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rightcol</td><td>The right set of columns to join </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_result</td><td>The join computed indices of the left table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">right_result</td><td>The join computed indices of the right table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4de4905066fbb3c645b05a1fc1d31d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4de4905066fbb3c645b05a1fc1d31d2">&#9670;&nbsp;</a></span>unary_operation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::unary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">unary_op</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs unary op on all values in column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gdf_column</td><td>Input column </td></tr>
    <tr><td class="paramname">unary_op</td><td>operation to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Result of the operation </dd></dl>

</div>
</div>
<a id="a66263477271719b8fb6b529f1f680945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66263477271719b8fb6b529f1f680945">&#9670;&nbsp;</a></span>unique_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gdf_size_type cudf::unique_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>ignore_nulls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>nan_as_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the unique elements in the column. </p>
<p>Given an input column, number of unique elements in this column is returned</p>
<p>If both <code>ignore_nulls</code> and <code>nan_as_null</code> are true, both <code>NaN</code> and <code>null</code> values are ignored. If <code>ignored_nulls</code> is true and <code>nan_as_null</code> is false, only <code>null</code> is ignored, <code>NaN</code> is considered in unique count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The column whose unique elements will be counted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_nulls</td><td>flag to ignore <code>null</code> in unique count if true, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nan_as_null</td><td>flag to consider <code>NaN==null</code> if true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unique elements </dd></dl>

</div>
</div>
<a id="ad4423a474f1918e65aed295f0600c488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4423a474f1918e65aed295f0600c488">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&#160;</td>
          <td class="paramname"><em>desc_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nulls_as_largest</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find largest indices in a sorted table where values should be inserted to maintain order. </p>
<p>------------------------------------------------------------------------&mdash;* For each row v in <code>values</code>, find the last index in <code>t</code> where inserting the row will maintain the sort order of <code>t</code> </p>
<p>Example:</p>
<p>Single Column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 3 }</p>
<p>Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 5 * * </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>Table to search </td></tr>
    <tr><td class="paramname">values</td><td>Find insert locations for these values </td></tr>
    <tr><td class="paramname">desc_flags</td><td>Vector of column sort order. False indicates the corresponding column is sorted ascending </td></tr>
    <tr><td class="paramname">nulls_as_largest</td><td>If true, nulls are considered larger than valid values, otherwise, nulls are considered smaller than valid values</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md378"></a>
@return gdf_column   Insertion points. Non-nullable column of type GDF_INT32 with same size as values.</h2>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2search_8hpp-example.html#a2">/rapids/cudf/cpp/include/cudf/search.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a084ff0262deda4407ff67857cf1660c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084ff0262deda4407ff67857cf1660c0">&#9670;&nbsp;</a></span>valid_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename bit_container , typename predicate , typename size_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bit_container*, size_type&gt; cudf::valid_if </td>
          <td>(</td>
          <td class="paramtype">const bit_container *&#160;</td>
          <td class="paramname"><em>source_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a bitmask where every bit is marked with valid if and only if predicate(bit) and source_mask(bit) are both true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_mask</td><td>The source mask </td></tr>
    <tr><td class="paramname">p</td><td>The predicate that has an operator() member function </td></tr>
    <tr><td class="paramname">num_bits</td><td>Number of bits </td></tr>
    <tr><td class="paramname">stream</td><td>An optional cudaStream_t object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated bitmask as well as its null_count </dd></dl>

</div>
</div>
<a id="afa70e889e2b83eba15ed8e8e864dd3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa70e889e2b83eba15ed8e8e864dd3ff">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures a gdf_column is valid, i.e. that its fields are consistent with each other, and logical in themselves, in representing a proper column. </p>
<p>Ensure the input is in a valid state representing a proper column. Specifically, ensures all fields have valid (rather than junk, uninitialized or declared-invalid values), and that they are consistent with each other. </p>

</div>
</div>
<a id="a77959a698de64cf48519918fb2e8c8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77959a698de64cf48519918fb2e8c8bc">&#9670;&nbsp;</a></span>word_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __host__ __device__ size_type cudf::word_index </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md466"></a>
@brief Returns the index of the word containing the specified bit.</h2>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacecudf_html_a6c828f318cb2c14c8ac0567f5084d1e7"><div class="ttname"><a href="namespacecudf.html#a6c828f318cb2c14c8ac0567f5084d1e7">cudf::group_quantiles</a></div><div class="ttdeci">std::pair&lt; cudf::table, cudf::table &gt; group_quantiles(cudf::table const &amp;keys, cudf::table const &amp;values, std::vector&lt; double &gt; const &amp;quantiles, cudf::interpolation interpolation, bool include_nulls)</div><div class="ttdoc">Find values at given quantiles within groups.</div><div class="ttdef"><b>Definition:</b> group_quantiles.cu:120</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
