<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcudf: cudf::io::data_sink Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="rapids.css" rel="stylesheet" type="text/css">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/legacy">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (22.04)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/nightly/namespacecudf.html">nightly (22.04)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (22.02)</a><a class="rapids-selector__menu-item" href="/api/libcudf/legacy/namespacecudf.html">legacy (21.12)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="navpath" id="nav-path">
  <ul>
<li class="navelem"><a class="el" href="namespacecudf.html">cudf</a></li><li class="navelem"><a class="el" href="namespacecudf_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="#pub-static-methods">Static Public Member Functions</a> |
<a href="classcudf_1_1io_1_1data__sink-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cudf::io::data_sink Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface class for storing the output data from the writers.  
 <a href="classcudf_1_1io_1_1data__sink.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a778f6bad53ffc49dc6285dd8a9879f73"><td align="right" class="memItemLeft" valign="top"><a id="a778f6bad53ffc49dc6285dd8a9879f73"></a>
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a778f6bad53ffc49dc6285dd8a9879f73">~data_sink</a> ()</td></tr>
<tr class="memdesc:a778f6bad53ffc49dc6285dd8a9879f73"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class destructor. <br></td></tr>
<tr class="separator:a778f6bad53ffc49dc6285dd8a9879f73"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab68621d609bd643680481195dc07422c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#ab68621d609bd643680481195dc07422c">host_write</a> (void const *data, size_t size)=0</td></tr>
<tr class="memdesc:ab68621d609bd643680481195dc07422c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the buffer content to the sink.  <a href="classcudf_1_1io_1_1data__sink.html#ab68621d609bd643680481195dc07422c">More...</a><br></td></tr>
<tr class="separator:ab68621d609bd643680481195dc07422c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3a2904b3b6e1167676f0d88e3324a3b3"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a3a2904b3b6e1167676f0d88e3324a3b3">supports_device_write</a> () const</td></tr>
<tr class="memdesc:a3a2904b3b6e1167676f0d88e3324a3b3"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether or not this sink supports writing from gpu memory addresses.  <a href="classcudf_1_1io_1_1data__sink.html#a3a2904b3b6e1167676f0d88e3324a3b3">More...</a><br></td></tr>
<tr class="separator:a3a2904b3b6e1167676f0d88e3324a3b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a61919a2f46a62914b64cb1756058f7a3"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a61919a2f46a62914b64cb1756058f7a3">is_device_write_preferred</a> (size_t size) const</td></tr>
<tr class="memdesc:a61919a2f46a62914b64cb1756058f7a3"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimates whether a direct device write would be more optimal for the given size.  <a href="classcudf_1_1io_1_1data__sink.html#a61919a2f46a62914b64cb1756058f7a3">More...</a><br></td></tr>
<tr class="separator:a61919a2f46a62914b64cb1756058f7a3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2a1de8c173d8320ba6e65e3ca72bb54c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a2a1de8c173d8320ba6e65e3ca72bb54c">device_write</a> (void const *gpu_data, size_t size, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a2a1de8c173d8320ba6e65e3ca72bb54c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the buffer content to the sink from a gpu address.  <a href="classcudf_1_1io_1_1data__sink.html#a2a1de8c173d8320ba6e65e3ca72bb54c">More...</a><br></td></tr>
<tr class="separator:a2a1de8c173d8320ba6e65e3ca72bb54c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac0026dedc5539a8cad518e487a9007e6"><td align="right" class="memItemLeft" valign="top">virtual std::future&lt; void &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#ac0026dedc5539a8cad518e487a9007e6">device_write_async</a> (void const *gpu_data, size_t size, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:ac0026dedc5539a8cad518e487a9007e6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronously append the buffer content to the sink from a gpu address.  <a href="classcudf_1_1io_1_1data__sink.html#ac0026dedc5539a8cad518e487a9007e6">More...</a><br></td></tr>
<tr class="separator:ac0026dedc5539a8cad518e487a9007e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a059e16ef19d5901feed0098bc97babfa"><td align="right" class="memItemLeft" valign="top"><a id="a059e16ef19d5901feed0098bc97babfa"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a059e16ef19d5901feed0098bc97babfa">flush</a> ()=0</td></tr>
<tr class="memdesc:a059e16ef19d5901feed0098bc97babfa"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the data written into the sink. <br></td></tr>
<tr class="separator:a059e16ef19d5901feed0098bc97babfa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8b43b4b466aa55d96366e4fd934dd971"><td align="right" class="memItemLeft" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a8b43b4b466aa55d96366e4fd934dd971">bytes_written</a> ()=0</td></tr>
<tr class="memdesc:a8b43b4b466aa55d96366e4fd934dd971"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of bytes written into this sink.  <a href="classcudf_1_1io_1_1data__sink.html#a8b43b4b466aa55d96366e4fd934dd971">More...</a><br></td></tr>
<tr class="separator:a8b43b4b466aa55d96366e4fd934dd971"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9b068462654dcf40f8baa0ce0018ca70"><td align="right" class="memItemLeft" valign="top">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a9b068462654dcf40f8baa0ce0018ca70">create</a> (const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a9b068462654dcf40f8baa0ce0018ca70"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a sink from a file path.  <a href="classcudf_1_1io_1_1data__sink.html#a9b068462654dcf40f8baa0ce0018ca70">More...</a><br></td></tr>
<tr class="separator:a9b068462654dcf40f8baa0ce0018ca70"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acbfb0f3cb8e8ae2f8e5e46d84fad926f"><td align="right" class="memItemLeft" valign="top">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#acbfb0f3cb8e8ae2f8e5e46d84fad926f">create</a> (std::vector&lt; char &gt; *buffer)</td></tr>
<tr class="memdesc:acbfb0f3cb8e8ae2f8e5e46d84fad926f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a sink from a std::vector.  <a href="classcudf_1_1io_1_1data__sink.html#acbfb0f3cb8e8ae2f8e5e46d84fad926f">More...</a><br></td></tr>
<tr class="separator:acbfb0f3cb8e8ae2f8e5e46d84fad926f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6a89c2acee32c8a647bb7cb983fc7653"><td align="right" class="memItemLeft" valign="top">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a6a89c2acee32c8a647bb7cb983fc7653">create</a> ()</td></tr>
<tr class="memdesc:a6a89c2acee32c8a647bb7cb983fc7653"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a void sink (one that does no actual io)  <a href="classcudf_1_1io_1_1data__sink.html#a6a89c2acee32c8a647bb7cb983fc7653">More...</a><br></td></tr>
<tr class="separator:a6a89c2acee32c8a647bb7cb983fc7653"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a46308042b66357d50981d37dcd00b1b1"><td align="right" class="memItemLeft" valign="top">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a46308042b66357d50981d37dcd00b1b1">create</a> (<a class="el" href="classcudf_1_1io_1_1data__sink.html">cudf::io::data_sink</a> *const user_sink)</td></tr>
<tr class="memdesc:a46308042b66357d50981d37dcd00b1b1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a wrapped custom user data sink.  <a href="classcudf_1_1io_1_1data__sink.html#a46308042b66357d50981d37dcd00b1b1">More...</a><br></td></tr>
<tr class="separator:a46308042b66357d50981d37dcd00b1b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0f77bea84b22a7f14cb7da12754ffeb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f77bea84b22a7f14cb7da12754ffeb6"><td align="right" class="memTemplItemLeft" valign="top">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a0f77bea84b22a7f14cb7da12754ffeb6">create</a> (std::vector&lt; T &gt; const &amp;args)</td></tr>
<tr class="memdesc:a0f77bea84b22a7f14cb7da12754ffeb6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a vector of data sinks, one per element in the input vector.  <a href="classcudf_1_1io_1_1data__sink.html#a0f77bea84b22a7f14cb7da12754ffeb6">More...</a><br></td></tr>
<tr class="separator:a0f77bea84b22a7f14cb7da12754ffeb6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface class for storing the output data from the writers. </p>

<p class="definition">Definition at line <a class="el" href="data__sink_8hpp_source.html#l00035">35</a> of file <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8b43b4b466aa55d96366e4fd934dd971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b43b4b466aa55d96366e4fd934dd971">◆&nbsp;</a></span>bytes_written()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">virtual size_t cudf::io::data_sink::bytes_written </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Returns the total number of bytes written into this sink. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t Total number of bytes written into this sink </dd></dl>

</div>
</div>
<a id="a6a89c2acee32c8a647bb7cb983fc7653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a89c2acee32c8a647bb7cb983fc7653">◆&nbsp;</a></span>create() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a>&gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Create a void sink (one that does no actual io) </p>
<p>A useful code path for benchmarking, to eliminate physical hardware randomness from profiling. </p>

</div>
</div>
<a id="a9b068462654dcf40f8baa0ce0018ca70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b068462654dcf40f8baa0ce0018ca70">◆&nbsp;</a></span>create() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a>&gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Create a sink from a file path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to use </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a46308042b66357d50981d37dcd00b1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46308042b66357d50981d37dcd00b1b1">◆&nbsp;</a></span>create() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a>&gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1io_1_1data__sink.html">cudf::io::data_sink</a> *const&nbsp;</td>
          <td class="paramname"><em>user_sink</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Create a wrapped custom user data sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">user_sink</td><td>User-provided data sink (typically custom class)</td></tr>
  </tbody></table>
  </dd>
</dl>
<p>The data sink returned here is not the one passed by the user. It is an internal class that wraps the user pointer. The principle is to allow the user to declare a custom sink instance and use it across multiple write() calls. </p>

</div>
</div>
<a id="acbfb0f3cb8e8ae2f8e5e46d84fad926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfb0f3cb8e8ae2f8e5e46d84fad926f">◆&nbsp;</a></span>create() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a>&gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; *&nbsp;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Create a sink from a std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Pointer to the output vector </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a0f77bea84b22a7f14cb7da12754ffeb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f77bea84b22a7f14cb7da12754ffeb6">◆&nbsp;</a></span>create() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">static std::vector&lt;std::unique_ptr&lt;<a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a>&gt; &gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Creates a vector of data sinks, one per element in the input vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>vector of parameters </td></tr>
  </tbody></table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="data__sink_8hpp_source.html#l00078">78</a> of file <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a>.</p>

</div>
</div>
<a id="a2a1de8c173d8320ba6e65e3ca72bb54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1de8c173d8320ba6e65e3ca72bb54c">◆&nbsp;</a></span>device_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">virtual void cudf::io::data_sink::device_write </td>
          <td>(</td>
          <td class="paramtype">void const *&nbsp;</td>
          <td class="paramname"><em>gpu_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Append the buffer content to the sink from a gpu address. </p>
<p>For optimal performance, should only be called when <code>is_device_write_preferred</code> returns <code>true</code>. Data sink implementations that don't support direct device writes don't need to override this function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>the object does not support direct device writes, i.e. <code>supports_device_write</code> returns <code>false</code>.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">gpu_data</td><td>Pointer to the buffer to be written into the sink object </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream to use </td></tr>
  </tbody></table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="data__sink_8hpp_source.html#l00150">150</a> of file <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a>.</p>

</div>
</div>
<a id="ac0026dedc5539a8cad518e487a9007e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0026dedc5539a8cad518e487a9007e6">◆&nbsp;</a></span>device_write_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">virtual std::future&lt;void&gt; cudf::io::data_sink::device_write_async </td>
          <td>(</td>
          <td class="paramtype">void const *&nbsp;</td>
          <td class="paramname"><em>gpu_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Asynchronously append the buffer content to the sink from a gpu address. </p>
<p>For optimal performance, should only be called when <code>is_device_write_preferred</code> returns <code>true</code>. Data sink implementations that don't support direct device writes don't need to override this function.</p>
<p><code>gpu_data</code> must not be freed until this call is synchronized. </p><div class="fragment"><div class="line">auto result = device_write_async(gpu_data, size, stream);</div>
<div class="line">result.wait(); // OR result.get()</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>the object does not support direct device writes, i.e. <code>supports_device_write</code> returns <code>false</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">gpu_data</td><td>Pointer to the buffer to be written into the sink object </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream to use </td></tr>
  </tbody></table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="data__sink_8hpp_source.html#l00176">176</a> of file <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a>.</p>

</div>
</div>
<a id="ab68621d609bd643680481195dc07422c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68621d609bd643680481195dc07422c">◆&nbsp;</a></span>host_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">virtual void cudf::io::data_sink::host_write </td>
          <td>(</td>
          <td class="paramtype">void const *&nbsp;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>size</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Append the buffer content to the sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the buffer to be written into the sink object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to write </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a61919a2f46a62914b64cb1756058f7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61919a2f46a62914b64cb1756058f7a3">◆&nbsp;</a></span>is_device_write_preferred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">virtual bool cudf::io::data_sink::is_device_write_preferred </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Estimates whether a direct device write would be more optimal for the given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">size</td><td>Number of bytes to write </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the device write is expected to be more performant for the given size </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__sink_8hpp_source.html#l00131">131</a> of file <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a>.</p>

</div>
</div>
<a id="a3a2904b3b6e1167676f0d88e3324a3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2904b3b6e1167676f0d88e3324a3b3">◆&nbsp;</a></span>supports_device_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">virtual bool cudf::io::data_sink::supports_device_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Whether or not this sink supports writing from gpu memory addresses. </p>
<p>Internal to some of the file format writers, we have code that does things like</p>
<p>tmp_buffer = alloc_temp_buffer(); cudaMemcpy(tmp_buffer, device_buffer, size); sink-&gt;write(tmp_buffer, size);</p>
<p>In the case where the sink type is itself a memory buffered write, this ends up being effectively a second memcpy. So a useful optimization for a "smart" custom <a class="el" href="classcudf_1_1io_1_1data__sink.html" title="Interface class for storing the output data from the writers.">data_sink</a> is to do it's own internal management of the movement of data between cpu and gpu; turning the internals of the writer into simply</p>
<p>sink-&gt;device_write(device_buffer, size)</p>
<p>If this function returns true, the <a class="el" href="classcudf_1_1io_1_1data__sink.html" title="Interface class for storing the output data from the writers.">data_sink</a> will receive calls to <a class="el" href="classcudf_1_1io_1_1data__sink.html#a2a1de8c173d8320ba6e65e3ca72bb54c" title="Append the buffer content to the sink from a gpu address.">device_write()</a> instead of write() when possible. However, it is still possible to receive write() calls as well.</p>
<dl class="section return"><dt>Returns</dt><dd>bool If this writer supports <a class="el" href="classcudf_1_1io_1_1data__sink.html#a2a1de8c173d8320ba6e65e3ca72bb54c" title="Append the buffer content to the sink from a gpu address.">device_write()</a> calls. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__sink_8hpp_source.html#l00123">123</a> of file <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a>.</p>

</div>
</div>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body></html>