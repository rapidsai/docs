<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.16" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>
   libcudf: cudf Namespace Reference
  </title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript">
</script>
<script src="dynsections.js" type="text/javascript">
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript">
</script>
<script src="search/search.js" type="text/javascript">
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top">
<!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libnvstrings/stable/annotated.html">libnvstrings</a><a class="rapids-selector__menu-item" href="/api/nvstrings/stable/api.html">nvstrings</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (0.9)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (0.15)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (0.14)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/legacy/namespacecudf.html">legacy (0.9)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
   </script>
<script src="menudata.js" type="text/javascript">
</script>
<script src="menu.js" type="text/javascript">
</script>
<script type="text/javascript">
    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
   </script>
<div id="main-nav">
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
</div>
<!-- top -->
<div class="header">
<div class="summary">
<a href="#nested-classes">
     Classes
    </a>
    |
    <a href="#typedef-members">
     Typedefs
    </a>
    |
    <a href="#enum-members">
     Enumerations
    </a>
    |
    <a href="#func-members">
     Functions
    </a>
</div>
<div class="headertitle">
<div class="title">
     cudf Namespace Reference
    </div>
</div>
</div>
<!--header-->
<div class="contents">
<p>
    Parse and Transform a piece of PTX code that contains the implementation of a
    <code>
     __device__
    </code>
    function into a CUDA
    <code>
     __device__
    </code>
<code>
     __inline__
    </code>
    function.
    <a href="namespacecudf.html#details">
     More...
    </a>
</p>
<table class="memberdecls">
<tr class="heading">
<td colspan="2">
<h2 class="groupheader">
<a name="nested-classes">
</a>
       Classes
      </h2>
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1avro__read__arg.html">
       avro_read_arg
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1csv__read__arg.html">
       csv_read_arg
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Input arguments to the
      <code>
       read_csv
      </code>
      interface.
      <a href="structcudf_1_1csv__read__arg.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1cuda__error.html">
       cuda_error
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Exception thrown when a CUDA error is encountered.
      <a href="structcudf_1_1cuda__error.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1DeviceAnd.html">
       DeviceAnd
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1DeviceCount.html">
       DeviceCount
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1DeviceMax.html">
       DeviceMax
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1DeviceMin.html">
       DeviceMin
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1DeviceOr.html">
       DeviceOr
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1DeviceProduct.html">
       DeviceProduct
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1DeviceSum.html">
       DeviceSum
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1DeviceXor.html">
       DeviceXor
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1json__read__arg.html">
       json_read_arg
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Input arguments to the
      <code>
       read_json
      </code>
      interface.
      <a href="structcudf_1_1json__read__arg.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1logic__error.html">
       logic_error
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Exception thrown when logical precondition is violated.
      <a href="structcudf_1_1logic__error.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1meanvar.html">
       meanvar
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      intermediate struct to calculate mean and variance This is an example case to output a struct from column input.
      <a href="structcudf_1_1meanvar.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1orc__read__arg.html">
       orc_read_arg
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1pair__accessor.html">
       pair_accessor
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      pair accessor with/without null bitmask A unary function returns
      <code>
       thrust::pair&lt;ResultType, bool&gt;
      </code>
      . If the element at index
      <code>
       i
      </code>
      is valid, returns
      <code>
       ResultType{data[i]}
      </code>
      and
      <code>
       true
      </code>
      indicating the value was valid. If the element at
      <code>
       i
      </code>
      is null, returns
      <code>
       ResultType{identity}
      </code>
      and
      <code>
       false
      </code>
      indicating the element was null.
      <a href="structcudf_1_1pair__accessor.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1pair__accessor_3_01ElementType_00_01ResultType_00_01false_01_4.html">
       pair_accessor&lt; ElementType, ResultType, false &gt;
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1pair__accessor_3_01ElementType_00_01ResultType_00_01true_01_4.html">
       pair_accessor&lt; ElementType, ResultType, true &gt;
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1parquet__read__arg.html">
       parquet_read_arg
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1source__info.html">
       source_info
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      A wrapper for a set of gdf_columns of equal number of rows.
      <a href="structcudf_1_1table.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1transformer__meanvar.html">
       transformer_meanvar
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Uses a scalar value to construct a
      <code>
       meanvar
      </code>
      object. This transforms
      <code>
       thrust::pair&lt;ElementType, bool&gt;
      </code>
      into
      <code>
       ResultType = meanvar&lt;ElementType&gt;
      </code>
      form.
      <a href="structcudf_1_1transformer__meanvar.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1transformer__squared.html">
       transformer_squared
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Transforms a scalar by first casting to another type, and then squaring the result.
      <a href="structcudf_1_1transformer__squared.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1value__accessor.html">
       value_accessor
      </a>
</td>
</tr>
<tr class="memdesc:">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      value accessor with/without null bitmask A unary function returns scalar value at
      <code>
       id
      </code>
      .
      <code>
       operator() (gdf_index_type id)
      </code>
      computes
      <code>
       data
      </code>
      value and valid flag at
      <code>
       id
      </code>
<a href="structcudf_1_1value__accessor.html#details">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1value__accessor_3_01ElementType_00_01ResultType_00_01false_01_4.html">
       value_accessor&lt; ElementType, ResultType, false &gt;
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:">
<td align="right" class="memItemLeft" valign="top">
      struct
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="structcudf_1_1value__accessor_3_01ElementType_00_01ResultType_00_01true_01_4.html">
       value_accessor&lt; ElementType, ResultType, true &gt;
      </a>
</td>
</tr>
<tr class="separator:">
<td class="memSeparator" colspan="2">
</td>
</tr>
</table>
<table class="memberdecls">
<tr class="heading">
<td colspan="2">
<h2 class="groupheader">
<a name="typedef-members">
</a>
       Typedefs
      </h2>
</td>
</tr>
<tr class="memitem:a8c6e344a72404039eef838a8cb39295b">
<td align="right" class="memItemLeft" valign="top">
<a id="a8c6e344a72404039eef838a8cb39295b">
</a>
      using
     </td>
<td class="memItemRight" valign="bottom">
<b>
       category
      </b>
      =
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       detail::wrapper
      </a>
      &lt; gdf_category, GDF_CATEGORY &gt;
     </td>
</tr>
<tr class="separator:a8c6e344a72404039eef838a8cb39295b">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a9b64847ffcf8f0ad4069085490f9fb5c">
<td align="right" class="memItemLeft" valign="top">
<a id="a9b64847ffcf8f0ad4069085490f9fb5c">
</a>
      using
     </td>
<td class="memItemRight" valign="bottom">
<b>
       nvstring_category
      </b>
      =
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       detail::wrapper
      </a>
      &lt; gdf_nvstring_category, GDF_STRING_CATEGORY &gt;
     </td>
</tr>
<tr class="separator:a9b64847ffcf8f0ad4069085490f9fb5c">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a6916ffd2fdcad20b769afc3d4130140e">
<td align="right" class="memItemLeft" valign="top">
<a id="a6916ffd2fdcad20b769afc3d4130140e">
</a>
      using
     </td>
<td class="memItemRight" valign="bottom">
<b>
       timestamp
      </b>
      =
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       detail::wrapper
      </a>
      &lt; gdf_timestamp, GDF_TIMESTAMP &gt;
     </td>
</tr>
<tr class="separator:a6916ffd2fdcad20b769afc3d4130140e">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a788a6ac25db35f51d612644bebd86970">
<td align="right" class="memItemLeft" valign="top">
<a id="a788a6ac25db35f51d612644bebd86970">
</a>
      using
     </td>
<td class="memItemRight" valign="bottom">
<b>
       date32
      </b>
      =
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       detail::wrapper
      </a>
      &lt; gdf_date32, GDF_DATE32 &gt;
     </td>
</tr>
<tr class="separator:a788a6ac25db35f51d612644bebd86970">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a5da9e96ba9d677a713403fb3704600ef">
<td align="right" class="memItemLeft" valign="top">
<a id="a5da9e96ba9d677a713403fb3704600ef">
</a>
      using
     </td>
<td class="memItemRight" valign="bottom">
<b>
       date64
      </b>
      =
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       detail::wrapper
      </a>
      &lt; gdf_date64, GDF_DATE64 &gt;
     </td>
</tr>
<tr class="separator:a5da9e96ba9d677a713403fb3704600ef">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a2916a984683be11ca496ae1535849cb3">
<td align="right" class="memItemLeft" valign="top">
<a id="a2916a984683be11ca496ae1535849cb3">
</a>
      using
     </td>
<td class="memItemRight" valign="bottom">
<b>
       bool8
      </b>
      =
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       detail::wrapper
      </a>
      &lt; gdf_bool8, GDF_BOOL8 &gt;
     </td>
</tr>
<tr class="separator:a2916a984683be11ca496ae1535849cb3">
<td class="memSeparator" colspan="2">
</td>
</tr>
</table>
<table class="memberdecls">
<tr class="heading">
<td colspan="2">
<h2 class="groupheader">
<a name="enum-members">
</a>
       Enumerations
      </h2>
</td>
</tr>
<tr class="memitem:a69091647ea1f9c9d4cdcf7c8876bea3a">
<td align="right" class="memItemLeft" valign="top">
      enum
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">
       duplicate_keep_option
      </a>
      {
      <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa86ea4bfd2b3121412b0a63a3697926ec">
       KEEP_FIRST
      </a>
      = 0,
      <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa1d1398f646d74e801389737f07d89d1c">
       KEEP_LAST
      </a>
      ,
      <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa6fb3154b77231184b596b4add407aa2a">
       KEEP_NONE
      </a>
      }
     </td>
</tr>
<tr class="memdesc:a69091647ea1f9c9d4cdcf7c8876bea3a">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Choices for drop_duplicates API for retainment of duplicate rows.
      <a href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a69091647ea1f9c9d4cdcf7c8876bea3a">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ab15567f1034536ae6f7f14179334a19b">
<td align="right" class="memItemLeft" valign="top">
      enum
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">
       unary_op
      </a>
      {
      <br/>
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6b585cf453d36fbb0381b38bc2c966e1">
       SIN
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19baf7c88ff3bee94b5c3c16c405706ef34a">
       COS
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19baa91cdd09214d36d756b5f13803ddd890">
       TAN
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba463397f416a024fb7df7d906a0436dbb">
       ARCSIN
      </a>
      ,
      <br/>
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba1e17febbc6d14208d0a264562dcee2e9">
       ARCCOS
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19bad1c5c0c8ffe6bf038e617b0aad0f9aac">
       ARCTAN
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6e272b8c75625066b2c8994cec6c8f73">
       EXP
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba1509f8449abb15062ad85e15fb3861d7">
       LOG
      </a>
      ,
      <br/>
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6ac653ea3d15f23b0f6e61b447f783ea">
       SQRT
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba8b0d502b44d1472a2d5fa3638f0ce945">
       CEIL
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba07e330cc72f454a6369d267d1bfb2d7e">
       FLOOR
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19bab226be3789467f51f32cf06550a4c46e">
       ABS
      </a>
      ,
      <br/>
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba62a7f82a72f8422f631cb550b7201667">
       BIT_INVERT
      </a>
      ,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba5e654d9830c09fc254d4f9f19fbdfe6e">
       NOT
      </a>
<br/>
      }
     </td>
</tr>
<tr class="memdesc:ab15567f1034536ae6f7f14179334a19b">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Types of unary operations that can be performed on data.
      <a href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ab15567f1034536ae6f7f14179334a19b">
<td class="memSeparator" colspan="2">
</td>
</tr>
</table>
<table class="memberdecls">
<tr class="heading">
<td colspan="2">
<h2 class="groupheader">
<a name="func-members">
</a>
       Functions
      </h2>
</td>
</tr>
<tr class="memitem:ae942e9a8d320f23d61bee22ddc06df55">
<td align="right" class="memItemLeft" valign="top">
      void
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ae942e9a8d320f23d61bee22ddc06df55">
       binary_operation
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *out,
      <a class="el" href="structgdf__scalar.html">
       gdf_scalar
      </a>
      *lhs,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *rhs, gdf_binary_operator ope)
     </td>
</tr>
<tr class="memdesc:ae942e9a8d320f23d61bee22ddc06df55">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Performs a binary operation between a
      <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
       gdf_scalar
      </a>
      and a gdf_column.
      <a href="namespacecudf.html#ae942e9a8d320f23d61bee22ddc06df55">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ae942e9a8d320f23d61bee22ddc06df55">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aa02af1454978d7d7f7b9f651437b3ab5">
<td align="right" class="memItemLeft" valign="top">
      void
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#aa02af1454978d7d7f7b9f651437b3ab5">
       binary_operation
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *out,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *lhs,
      <a class="el" href="structgdf__scalar.html">
       gdf_scalar
      </a>
      *rhs, gdf_binary_operator ope)
     </td>
</tr>
<tr class="memdesc:aa02af1454978d7d7f7b9f651437b3ab5">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Performs a binary operation between a gdf_column and a
      <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
       gdf_scalar
      </a>
      .
      <a href="namespacecudf.html#aa02af1454978d7d7f7b9f651437b3ab5">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:aa02af1454978d7d7f7b9f651437b3ab5">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad01e2e81bc2b671dfb8963a7be22e3b0">
<td align="right" class="memItemLeft" valign="top">
      void
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ad01e2e81bc2b671dfb8963a7be22e3b0">
       binary_operation
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *out,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *lhs,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *rhs, gdf_binary_operator ope)
     </td>
</tr>
<tr class="memdesc:ad01e2e81bc2b671dfb8963a7be22e3b0">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Performs a binary operation between two gdf_columns.
      <a href="namespacecudf.html#ad01e2e81bc2b671dfb8963a7be22e3b0">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ad01e2e81bc2b671dfb8963a7be22e3b0">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a1f727c257f82efc1a7b144eb6dcbb2d8">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a1f727c257f82efc1a7b144eb6dcbb2d8">
       binary_operation
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;lhs, const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;rhs, const std::string &amp;ptx, gdf_dtype output_type)
     </td>
</tr>
<tr class="memdesc:a1f727c257f82efc1a7b144eb6dcbb2d8">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Performs a binary operation between two gdf_columns using a user-defined PTX function.
      <a href="namespacecudf.html#a1f727c257f82efc1a7b144eb6dcbb2d8">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a1f727c257f82efc1a7b144eb6dcbb2d8">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aec006bc00092dd8ec47f2c7ca6fe01d4">
<td align="right" class="memItemLeft" valign="top">
      rmm::device_vector&lt; bit_mask::bit_mask_t &gt;
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#aec006bc00092dd8ec47f2c7ca6fe01d4">
       row_bitmask
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       cudf::table
      </a>
      const  &amp;
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      , cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:aec006bc00092dd8ec47f2c7ca6fe01d4">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Computes a bitmask indicating the presence of NULL values in rows of a table.
      <a href="namespacecudf.html#aec006bc00092dd8ec47f2c7ca6fe01d4">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:aec006bc00092dd8ec47f2c7ca6fe01d4">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a084ff0262deda4407ff67857cf1660c0">
<td class="memTemplParams" colspan="2">
      template&lt;typename bit_container , typename predicate , typename size_type &gt;
     </td>
</tr>
<tr class="memitem:a084ff0262deda4407ff67857cf1660c0">
<td align="right" class="memTemplItemLeft" valign="top">
      std::pair&lt; bit_container *, size_type &gt;
     </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a084ff0262deda4407ff67857cf1660c0">
       valid_if
      </a>
      (const bit_container *source_mask, const predicate &amp;p, size_type num_bits, cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:a084ff0262deda4407ff67857cf1660c0">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Generate a bitmask where every bit is marked with valid if and only if predicate(bit) and source_mask(bit) are both true.
      <a href="namespacecudf.html#a084ff0262deda4407ff67857cf1660c0">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a084ff0262deda4407ff67857cf1660c0">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a38150f11c542f3238874911d4a30a530">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a38150f11c542f3238874911d4a30a530">
       allocate_column
      </a>
      (gdf_dtype dtype, gdf_size_type size, bool allocate_mask=true,
      <a class="el" href="structgdf__dtype__extra__info.html">
       gdf_dtype_extra_info
      </a>
      info=
      <a class="el" href="structgdf__dtype__extra__info.html">
       gdf_dtype_extra_info
      </a>
      {}, cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:a38150f11c542f3238874911d4a30a530">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Allocates a new column of the specified size and type.
      <a href="namespacecudf.html#a38150f11c542f3238874911d4a30a530">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a38150f11c542f3238874911d4a30a530">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a206ad1cc4b21f7f14c5d5f7d304efbda">
<td align="right" class="memItemLeft" valign="top">
<a id="a206ad1cc4b21f7f14c5d5f7d304efbda">
</a>
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<b>
       empty_like
      </b>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;input)
     </td>
</tr>
<tr class="separator:a206ad1cc4b21f7f14c5d5f7d304efbda">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ae08cb8501fe52a732913af1ac7b25ace">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ae08cb8501fe52a732913af1ac7b25ace">
       allocate_like
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const  &amp;input, bool allocate_mask_if_exists=true, cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:ae08cb8501fe52a732913af1ac7b25ace">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Allocates a new column of the same size and type as the input.
      <a href="namespacecudf.html#ae08cb8501fe52a732913af1ac7b25ace">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ae08cb8501fe52a732913af1ac7b25ace">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:af8183dc03a72e9c6cc1d7cd4cda37816">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#af8183dc03a72e9c6cc1d7cd4cda37816">
       allocate_like
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const  &amp;input, gdf_size_type size, bool allocate_mask_if_exists=true, cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:af8183dc03a72e9c6cc1d7cd4cda37816">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Allocates a new column of the specified size and same type as the input.
      <a href="namespacecudf.html#af8183dc03a72e9c6cc1d7cd4cda37816">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:af8183dc03a72e9c6cc1d7cd4cda37816">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aa7e6bf39cb5dd5cdb370d0a562675922">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#aa7e6bf39cb5dd5cdb370d0a562675922">
       copy
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const  &amp;input, cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:aa7e6bf39cb5dd5cdb370d0a562675922">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Creates a new column that is a copy of input.
      <a href="namespacecudf.html#aa7e6bf39cb5dd5cdb370d0a562675922">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:aa7e6bf39cb5dd5cdb370d0a562675922">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a3588fc0b833a8f2d7213651a05f48c80">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a3588fc0b833a8f2d7213651a05f48c80">
       empty_like
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;t)
     </td>
</tr>
<tr class="memdesc:a3588fc0b833a8f2d7213651a05f48c80">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Creates a table of empty columns with the same types as the inputs.
      <a href="namespacecudf.html#a3588fc0b833a8f2d7213651a05f48c80">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a3588fc0b833a8f2d7213651a05f48c80">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:af3a1a6bea8f1e1dd224f4316bbd23fbc">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#af3a1a6bea8f1e1dd224f4316bbd23fbc">
       allocate_like
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;t, bool allocate_mask_if_exists=true, cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:af3a1a6bea8f1e1dd224f4316bbd23fbc">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Creates a table of columns with the same type and allocation size as the input.
      <a href="namespacecudf.html#af3a1a6bea8f1e1dd224f4316bbd23fbc">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:af3a1a6bea8f1e1dd224f4316bbd23fbc">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a13d885159232b25ffdf8d7980f178c3a">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a13d885159232b25ffdf8d7980f178c3a">
       allocate_like
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;t, gdf_size_type size, bool allocate_mask_if_exists=true, cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:a13d885159232b25ffdf8d7980f178c3a">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Creates a table of columns with the specified size and same type as the input.
      <a href="namespacecudf.html#a13d885159232b25ffdf8d7980f178c3a">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a13d885159232b25ffdf8d7980f178c3a">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a9fae65b5e23d13aec03edef7a8aeacb0">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a9fae65b5e23d13aec03edef7a8aeacb0">
       copy
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;t, cudaStream_t stream=0)
     </td>
</tr>
<tr class="memdesc:a9fae65b5e23d13aec03edef7a8aeacb0">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Creates a table of columns and deep copies the data from an input table.
      <a href="namespacecudf.html#a9fae65b5e23d13aec03edef7a8aeacb0">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a9fae65b5e23d13aec03edef7a8aeacb0">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ab67996c2986be62de33c6685e1702755">
<td align="right" class="memItemLeft" valign="top">
      void
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ab67996c2986be62de33c6685e1702755">
       copy_range
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *out_column,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;in_column, gdf_index_type out_begin, gdf_index_type out_end, gdf_index_type in_begin)
     </td>
</tr>
<tr class="memdesc:ab67996c2986be62de33c6685e1702755">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Copies a range of elements from one column to another.
      <a href="namespacecudf.html#ab67996c2986be62de33c6685e1702755">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ab67996c2986be62de33c6685e1702755">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a03f762fbe22ea8e824e426d3880b085a">
<td align="right" class="memItemLeft" valign="top">
      void
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a03f762fbe22ea8e824e426d3880b085a">
       gather
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  *source_table, gdf_index_type const gather_map[],
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      *destination_table)
     </td>
</tr>
<tr class="memdesc:a03f762fbe22ea8e824e426d3880b085a">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Gathers the rows (including null values) of a set of source columns into a set of destination columns.
      <a href="namespacecudf.html#a03f762fbe22ea8e824e426d3880b085a">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a03f762fbe22ea8e824e426d3880b085a">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a7574c3f8a91c7ae6c24304f3cc61e606">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a7574c3f8a91c7ae6c24304f3cc61e606">
       scatter
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;source, gdf_index_type const scatter_map[],
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;target)
     </td>
</tr>
<tr class="memdesc:a7574c3f8a91c7ae6c24304f3cc61e606">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Creates a new
      <code>
       table
      </code>
      as if an in-place scatter from a
      <code>
       source
      </code>
      table was performed on the
      <code>
       target
      </code>
      table.
      <a href="namespacecudf.html#a7574c3f8a91c7ae6c24304f3cc61e606">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a7574c3f8a91c7ae6c24304f3cc61e606">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a8f032f6bab98db53bf7fa76259e09e92">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a8f032f6bab98db53bf7fa76259e09e92">
       scatter
      </a>
      (std::vector&lt;
      <a class="el" href="structgdf__scalar.html">
       gdf_scalar
      </a>
      &gt; const  &amp;source, gdf_index_type const scatter_map[], gdf_size_type num_scatter_rows,
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;target)
     </td>
</tr>
<tr class="memdesc:a8f032f6bab98db53bf7fa76259e09e92">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Creates a new
      <code>
       table
      </code>
      as if scattering a set of
      <code>
<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
        gdf_scalar
       </a>
</code>
      values into the rows of a
      <code>
       target
      </code>
      table in-place.
      <a href="namespacecudf.html#a8f032f6bab98db53bf7fa76259e09e92">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a8f032f6bab98db53bf7fa76259e09e92">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a31f4a85729765c154b21d8102be5a9d5">
<td align="right" class="memItemLeft" valign="top">
      std::vector&lt;
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      * &gt;
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a31f4a85729765c154b21d8102be5a9d5">
       slice
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;input_column, gdf_index_type const  *indices, gdf_size_type num_indices)
     </td>
</tr>
<tr class="memdesc:a31f4a85729765c154b21d8102be5a9d5">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Slices a column (including null values) into a set of columns according to a set of indices.
      <a href="namespacecudf.html#a31f4a85729765c154b21d8102be5a9d5">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a31f4a85729765c154b21d8102be5a9d5">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a69299f48fdcd25864a2f560e55d18ea9">
<td align="right" class="memItemLeft" valign="top">
      std::vector&lt;
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      * &gt;
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a69299f48fdcd25864a2f560e55d18ea9">
       split
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;input_column, gdf_index_type const  *indices, gdf_size_type num_indices)
     </td>
</tr>
<tr class="memdesc:a69299f48fdcd25864a2f560e55d18ea9">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Splits a column (including null values) into a set of columns according to a set of indices.
      <a href="namespacecudf.html#a69299f48fdcd25864a2f560e55d18ea9">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a69299f48fdcd25864a2f560e55d18ea9">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a0fdaf17cbac0f8976b27199b4aed31f5">
<td align="right" class="memItemLeft" valign="top">
      void
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a0fdaf17cbac0f8976b27199b4aed31f5">
       fill
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *column,
      <a class="el" href="structgdf__scalar.html">
       gdf_scalar
      </a>
      const  &amp;value, gdf_index_type begin, gdf_index_type end)
     </td>
</tr>
<tr class="memdesc:a0fdaf17cbac0f8976b27199b4aed31f5">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Fills a range of elements in a column with a scalar value.
      <a href="namespacecudf.html#a0fdaf17cbac0f8976b27199b4aed31f5">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a0fdaf17cbac0f8976b27199b4aed31f5">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a30c6e502e3755eefe9a720cdf0f3ed5e">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a30c6e502e3755eefe9a720cdf0f3ed5e">
       point_in_polygon
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;polygon_latitudes,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;polygon_longitudes,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;query_point_latitudes,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;query_point_longitudes)
     </td>
</tr>
<tr class="memdesc:a30c6e502e3755eefe9a720cdf0f3ed5e">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Determine whether or not coordinates (query points) are completely inside a static polygon.
      <a href="namespacecudf.html#a30c6e502e3755eefe9a720cdf0f3ed5e">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a30c6e502e3755eefe9a720cdf0f3ed5e">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:abcaa3abcef29306b7b544e847ae5da46">
<td align="right" class="memItemLeft" valign="top">
<a id="abcaa3abcef29306b7b544e847ae5da46">
</a>
      gdf_dtype
     </td>
<td class="memItemRight" valign="bottom">
<b>
       convertStringToDtype
      </b>
      (const std::string &amp;dtype)
     </td>
</tr>
<tr class="separator:abcaa3abcef29306b7b544e847ae5da46">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:acb570307357da1e8c28cee58d653b5cb">
<td align="right" class="memItemLeft" valign="top">
      std::string
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#acb570307357da1e8c28cee58d653b5cb">
       inferCompressionType
      </a>
      (const std::string &amp;compression_arg, gdf_input_type source_type, const std::string &amp;source, const std::map&lt; std::string, std::string &gt; &amp;ext_to_compression)
     </td>
</tr>
<tr class="memdesc:acb570307357da1e8c28cee58d653b5cb">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Infer the compression type from the compression parameter and the input data.
      <a href="namespacecudf.html#acb570307357da1e8c28cee58d653b5cb">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:acb570307357da1e8c28cee58d653b5cb">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aa7969fa8f427959b25681e979ea2c01a">
<td align="right" class="memItemLeft" valign="top">
<a id="aa7969fa8f427959b25681e979ea2c01a">
</a>
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<b>
       read_avro
      </b>
      (
      <a class="el" href="structcudf_1_1avro__read__arg.html">
       avro_read_arg
      </a>
      const &amp;args)
     </td>
</tr>
<tr class="separator:aa7969fa8f427959b25681e979ea2c01a">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ab59a215482cdc7bc3ba850d2a0fa9f86">
<td align="right" class="memItemLeft" valign="top">
<a id="ab59a215482cdc7bc3ba850d2a0fa9f86">
</a>
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<b>
       read_csv
      </b>
      (
      <a class="el" href="structcudf_1_1csv__read__arg.html">
       csv_read_arg
      </a>
      const &amp;args)
     </td>
</tr>
<tr class="separator:ab59a215482cdc7bc3ba850d2a0fa9f86">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a2430dcb97885610d55a2ddc34f7e8c1e">
<td align="right" class="memItemLeft" valign="top">
<a id="a2430dcb97885610d55a2ddc34f7e8c1e">
</a>
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<b>
       read_json
      </b>
      (
      <a class="el" href="structcudf_1_1json__read__arg.html">
       json_read_arg
      </a>
      const &amp;args)
     </td>
</tr>
<tr class="separator:a2430dcb97885610d55a2ddc34f7e8c1e">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:af36ad77aef16f9ee3607c92778e14417">
<td align="right" class="memItemLeft" valign="top">
<a id="af36ad77aef16f9ee3607c92778e14417">
</a>
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<b>
       read_orc
      </b>
      (
      <a class="el" href="structcudf_1_1orc__read__arg.html">
       orc_read_arg
      </a>
      const &amp;args)
     </td>
</tr>
<tr class="separator:af36ad77aef16f9ee3607c92778e14417">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a67516b133f0735f23f0024f86d8756d8">
<td align="right" class="memItemLeft" valign="top">
<a id="a67516b133f0735f23f0024f86d8756d8">
</a>
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<b>
       read_parquet
      </b>
      (
      <a class="el" href="structcudf_1_1parquet__read__arg.html">
       parquet_read_arg
      </a>
      const &amp;args)
     </td>
</tr>
<tr class="separator:a67516b133f0735f23f0024f86d8756d8">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a5315ca38e017e2ed42a400483bba3b56">
<td class="memTemplParams" colspan="2">
      template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt;
     </td>
</tr>
<tr class="memitem:a5315ca38e017e2ed42a400483bba3b56">
<td align="right" class="memTemplItemLeft" valign="top">
      auto
     </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a5315ca38e017e2ed42a400483bba3b56">
       make_iterator
      </a>
      (const ElementType *data, const bit_mask::bit_mask_t *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))
     </td>
</tr>
<tr class="memdesc:a5315ca38e017e2ed42a400483bba3b56">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Constructs an iterator over the elements of a column.
      <a href="namespacecudf.html#a5315ca38e017e2ed42a400483bba3b56">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a5315ca38e017e2ed42a400483bba3b56">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a4644fa78d40f010ce935b4358d1a9e25">
<td class="memTemplParams" colspan="2">
<a id="a4644fa78d40f010ce935b4358d1a9e25">
</a>
      template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt;
     </td>
</tr>
<tr class="memitem:a4644fa78d40f010ce935b4358d1a9e25">
<td align="right" class="memTemplItemLeft" valign="top">
      auto
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       make_iterator
      </b>
      (const ElementType *data, const gdf_valid_type *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))
     </td>
</tr>
<tr class="separator:a4644fa78d40f010ce935b4358d1a9e25">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:af06d674f7e1bd773e4166ef4d7fcf959">
<td class="memTemplParams" colspan="2">
<a id="af06d674f7e1bd773e4166ef4d7fcf959">
</a>
      template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt;
     </td>
</tr>
<tr class="memitem:af06d674f7e1bd773e4166ef4d7fcf959">
<td align="right" class="memTemplItemLeft" valign="top">
      auto
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       make_iterator
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;column, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))
     </td>
</tr>
<tr class="separator:af06d674f7e1bd773e4166ef4d7fcf959">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a20b11ec1348ab46ae20792ea4e2c0ca4">
<td class="memTemplParams" colspan="2">
      template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt;
     </td>
</tr>
<tr class="memitem:a20b11ec1348ab46ae20792ea4e2c0ca4">
<td align="right" class="memTemplItemLeft" valign="top">
      auto
     </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a20b11ec1348ab46ae20792ea4e2c0ca4">
       make_pair_iterator
      </a>
      (const ElementType *data, const bit_mask::bit_mask_t *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))
     </td>
</tr>
<tr class="memdesc:a20b11ec1348ab46ae20792ea4e2c0ca4">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Constructs an iterator over the elements of a column Input iterator which can be used for cub and thrust.
      <a href="namespacecudf.html#a20b11ec1348ab46ae20792ea4e2c0ca4">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a20b11ec1348ab46ae20792ea4e2c0ca4">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a8fee5f476efe3d2ba71060aa0ffe202f">
<td class="memTemplParams" colspan="2">
<a id="a8fee5f476efe3d2ba71060aa0ffe202f">
</a>
      template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt;
     </td>
</tr>
<tr class="memitem:a8fee5f476efe3d2ba71060aa0ffe202f">
<td align="right" class="memTemplItemLeft" valign="top">
      auto
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       make_pair_iterator
      </b>
      (const ElementType *data, const gdf_valid_type *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))
     </td>
</tr>
<tr class="separator:a8fee5f476efe3d2ba71060aa0ffe202f">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a657f930d43783b2f9ff84a219b19d245">
<td class="memTemplParams" colspan="2">
<a id="a657f930d43783b2f9ff84a219b19d245">
</a>
      template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt;
     </td>
</tr>
<tr class="memitem:a657f930d43783b2f9ff84a219b19d245">
<td align="right" class="memTemplItemLeft" valign="top">
      auto
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       make_pair_iterator
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;column, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))
     </td>
</tr>
<tr class="separator:a657f930d43783b2f9ff84a219b19d245">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aba9b7e3e01a011595712fcaa6fb3a678">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#aba9b7e3e01a011595712fcaa6fb3a678">
       merge
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;left_table,
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;right_table, std::vector&lt; gdf_size_type &gt; const  &amp;key_cols, std::vector&lt; order_by_type &gt; const  &amp;asc_desc, bool nulls_are_smallest=false)
     </td>
</tr>
<tr class="memdesc:aba9b7e3e01a011595712fcaa6fb3a678">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Merge sorted tables.
      <a href="namespacecudf.html#aba9b7e3e01a011595712fcaa6fb3a678">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:aba9b7e3e01a011595712fcaa6fb3a678">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aac52a52a504d46887f1368ae13a96ffb">
<td align="right" class="memItemLeft" valign="top">
      bool
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#aac52a52a504d46887f1368ae13a96ffb">
       is_sorted
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       cudf::table
      </a>
      const  &amp;
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      , std::vector&lt; int8_t &gt; const  &amp;descending, bool nulls_are_smallest)
     </td>
</tr>
<tr class="memdesc:aac52a52a504d46887f1368ae13a96ffb">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Checks whether the rows of a
      <code>
       table
      </code>
      are sorted in a lexicographical order.
      <a href="namespacecudf.html#aac52a52a504d46887f1368ae13a96ffb">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:aac52a52a504d46887f1368ae13a96ffb">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a34eb2aea42d4ee97fb98cc4b38dabd7c">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__scalar.html">
       gdf_scalar
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a34eb2aea42d4ee97fb98cc4b38dabd7c">
       reduce
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *col, cudf::reduction::operators op, gdf_dtype output_dtype, gdf_size_type ddof=1)
     </td>
</tr>
<tr class="memdesc:a34eb2aea42d4ee97fb98cc4b38dabd7c">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision
      <code>
       dtype
      </code>
      may prevent overflow. Only
      <code>
       min
      </code>
      and
      <code>
       max
      </code>
      ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output
      <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
       gdf_scalar
      </a>
      will contain
      <code>
       false
      </code>
      .
      <a href="namespacecudf.html#a34eb2aea42d4ee97fb98cc4b38dabd7c">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a34eb2aea42d4ee97fb98cc4b38dabd7c">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a65546aa9c42e87334fb5e1e3f274bc6b">
<td align="right" class="memItemLeft" valign="top">
      void
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a65546aa9c42e87334fb5e1e3f274bc6b">
       scan
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *input,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *output, gdf_scan_op op, bool inclusive)
     </td>
</tr>
<tr class="memdesc:a65546aa9c42e87334fb5e1e3f274bc6b">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at
      <code>
       i
      </code>
      is null, then the output element at
      <code>
       i
      </code>
      will also be null.
      <a href="namespacecudf.html#a65546aa9c42e87334fb5e1e3f274bc6b">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a65546aa9c42e87334fb5e1e3f274bc6b">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a68e93b1c814e07e108ad015d27ca2372">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a68e93b1c814e07e108ad015d27ca2372">
       find_and_replace_all
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;input_col, const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;values_to_replace, const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;replacement_values)
     </td>
</tr>
<tr class="memdesc:a68e93b1c814e07e108ad015d27ca2372">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Replace elements from
      <code>
       input_col
      </code>
      according to the mapping
      <code>
       values_to_replace
      </code>
      to
      <code>
       replacement_values
      </code>
      , that is, replace all
      <code>
       values_to_replace[i]
      </code>
      present in
      <code>
       input_col
      </code>
      with
      <code>
       replacement_values[i]
      </code>
      .
      <a href="namespacecudf.html#a68e93b1c814e07e108ad015d27ca2372">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a68e93b1c814e07e108ad015d27ca2372">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a85645250c7ada0b73a61e9a691931b36">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a85645250c7ada0b73a61e9a691931b36">
       replace_nulls
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;input, const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;replacement)
     </td>
</tr>
<tr class="memdesc:a85645250c7ada0b73a61e9a691931b36">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Replaces all null values in a column with corresponding values of another column.
      <a href="namespacecudf.html#a85645250c7ada0b73a61e9a691931b36">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a85645250c7ada0b73a61e9a691931b36">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad66cc66793473e7fc90ad3ed4cd1b450">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ad66cc66793473e7fc90ad3ed4cd1b450">
       replace_nulls
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;input, const
      <a class="el" href="structgdf__scalar.html">
       gdf_scalar
      </a>
      &amp;replacement)
     </td>
</tr>
<tr class="memdesc:ad66cc66793473e7fc90ad3ed4cd1b450">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Replaces all null values in a column with a scalar.
      <a href="namespacecudf.html#ad66cc66793473e7fc90ad3ed4cd1b450">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ad66cc66793473e7fc90ad3ed4cd1b450">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aa9d88717a2c068bbfac0f10352296c09">
<td align="right" class="memItemLeft" valign="top">
<a id="aa9d88717a2c068bbfac0f10352296c09">
</a>
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *
     </td>
<td class="memItemRight" valign="bottom">
<b>
       rolling_window
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;input_col, gdf_size_type window, gdf_size_type min_periods, gdf_size_type forward_window, gdf_agg_op agg_type, const gdf_size_type *window_col, const gdf_size_type *min_periods_col, const gdf_size_type *forward_window_col)
     </td>
</tr>
<tr class="separator:aa9d88717a2c068bbfac0f10352296c09">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:abea7916598188f7011fdcfcadbb71cac">
<td align="right" class="memItemLeft" valign="top">
<a id="abea7916598188f7011fdcfcadbb71cac">
</a>
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<b>
       rolling_window
      </b>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;input, gdf_size_type window, gdf_size_type min_periods, gdf_size_type forward_window, const std::string &amp;user_defined_aggregator, gdf_agg_op agg_op, gdf_dtype output_type, gdf_size_type const *window_col, gdf_size_type const *min_periods_col, gdf_size_type const *forward_window_col)
     </td>
</tr>
<tr class="separator:abea7916598188f7011fdcfcadbb71cac">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ae90960c52c1f1fe3ab2257bad89b18fc">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ae90960c52c1f1fe3ab2257bad89b18fc">
       lower_bound
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;t,
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;values, std::vector&lt; bool &gt; const  &amp;desc_flags, bool nulls_as_largest=true)
     </td>
</tr>
<tr class="memdesc:ae90960c52c1f1fe3ab2257bad89b18fc">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Find smallest indices in a sorted table where values should be inserted to maintain order.
      <a href="namespacecudf.html#ae90960c52c1f1fe3ab2257bad89b18fc">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ae90960c52c1f1fe3ab2257bad89b18fc">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad4423a474f1918e65aed295f0600c488">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ad4423a474f1918e65aed295f0600c488">
       upper_bound
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;t,
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const  &amp;values, std::vector&lt; bool &gt; const  &amp;desc_flags, bool nulls_as_largest=true)
     </td>
</tr>
<tr class="memdesc:ad4423a474f1918e65aed295f0600c488">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Find largest indices in a sorted table where values should be inserted to maintain order.
      <a href="namespacecudf.html#ad4423a474f1918e65aed295f0600c488">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ad4423a474f1918e65aed295f0600c488">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad888a160fd5439ce10ed29232debc200">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ad888a160fd5439ce10ed29232debc200">
       apply_boolean_mask
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const &amp;input,
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const &amp;boolean_mask)
     </td>
</tr>
<tr class="memdesc:ad888a160fd5439ce10ed29232debc200">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Filters a table using a column of boolean values as a mask.
      <a href="namespacecudf.html#ad888a160fd5439ce10ed29232debc200">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ad888a160fd5439ce10ed29232debc200">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad33dca48e0e06d182698cefb81b14be2">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       cudf::table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ad33dca48e0e06d182698cefb81b14be2">
       drop_duplicates
      </a>
      (const
      <a class="el" href="structcudf_1_1table.html">
       cudf::table
      </a>
      &amp;input_table, const
      <a class="el" href="structcudf_1_1table.html">
       cudf::table
      </a>
      &amp;key_columns, const
      <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">
       duplicate_keep_option
      </a>
      keep, const bool nulls_are_equal=true)
     </td>
</tr>
<tr class="memdesc:ad33dca48e0e06d182698cefb81b14be2">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Create a new table without duplicate rows.
      <a href="namespacecudf.html#ad33dca48e0e06d182698cefb81b14be2">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ad33dca48e0e06d182698cefb81b14be2">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a7ff623cffbfe93433009a4c18571ea49">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a7ff623cffbfe93433009a4c18571ea49">
       drop_nulls
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const &amp;input,
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const &amp;keys, gdf_size_type keep_threshold)
     </td>
</tr>
<tr class="memdesc:a7ff623cffbfe93433009a4c18571ea49">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Filters a table to remove null elements.
      <a href="namespacecudf.html#a7ff623cffbfe93433009a4c18571ea49">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a7ff623cffbfe93433009a4c18571ea49">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ac4c1f9dc1aaa71e250df1eed4b02f3d8">
<td align="right" class="memItemLeft" valign="top">
<a id="ac4c1f9dc1aaa71e250df1eed4b02f3d8">
</a>
<a class="el" href="structcudf_1_1table.html">
       table
      </a>
</td>
<td class="memItemRight" valign="bottom">
<b>
       drop_nulls
      </b>
      (
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const &amp;input,
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      const &amp;keys)
     </td>
</tr>
<tr class="separator:ac4c1f9dc1aaa71e250df1eed4b02f3d8">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad2f973d94c67ab3dc1a183c5adb3753d">
<td align="right" class="memItemLeft" valign="top">
      std::vector&lt; gdf_dtype &gt;
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ad2f973d94c67ab3dc1a183c5adb3753d">
       column_dtypes
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       cudf::table
      </a>
      const  &amp;
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      )
     </td>
</tr>
<tr class="memdesc:ad2f973d94c67ab3dc1a183c5adb3753d">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Returns vector of the dtypes of the columns in a table.
      <a href="namespacecudf.html#ad2f973d94c67ab3dc1a183c5adb3753d">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ad2f973d94c67ab3dc1a183c5adb3753d">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad2c2c74e4d88e3c0b67e7dea9f7086cc">
<td align="right" class="memItemLeft" valign="top">
      std::vector&lt;
      <a class="el" href="structgdf__dtype__extra__info.html">
       gdf_dtype_extra_info
      </a>
      &gt;
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ad2c2c74e4d88e3c0b67e7dea9f7086cc">
       column_dtype_infos
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       cudf::table
      </a>
      const  &amp;
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      )
     </td>
</tr>
<tr class="memdesc:ad2c2c74e4d88e3c0b67e7dea9f7086cc">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Returns vector of the dtype_infos of the columns in a table.
      <a href="namespacecudf.html#ad2c2c74e4d88e3c0b67e7dea9f7086cc">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ad2c2c74e4d88e3c0b67e7dea9f7086cc">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ada393acb565321d740f2b9950ffe2941">
<td align="right" class="memItemLeft" valign="top">
      bool
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ada393acb565321d740f2b9950ffe2941">
       has_nulls
      </a>
      (
      <a class="el" href="structcudf_1_1table.html">
       cudf::table
      </a>
      const  &amp;
      <a class="el" href="structcudf_1_1table.html">
       table
      </a>
      )
     </td>
</tr>
<tr class="memdesc:ada393acb565321d740f2b9950ffe2941">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Indicates if a table contains any null values.
      <a href="namespacecudf.html#ada393acb565321d740f2b9950ffe2941">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ada393acb565321d740f2b9950ffe2941">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a33e3a1ed670c88771cd7e594dda2f225">
<td align="right" class="memItemLeft" valign="top">
      std::pair&lt; bit_mask_t *, gdf_size_type &gt;
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a33e3a1ed670c88771cd7e594dda2f225">
       nans_to_nulls
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const  &amp;input)
     </td>
</tr>
<tr class="memdesc:a33e3a1ed670c88771cd7e594dda2f225">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Given a column with floating point values, generate a bitmask where every NaN is indicated as the corresponding null bit.
      <a href="namespacecudf.html#a33e3a1ed670c88771cd7e594dda2f225">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a33e3a1ed670c88771cd7e594dda2f225">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a45876c5d57c0d0afb921add28b3516e3">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a45876c5d57c0d0afb921add28b3516e3">
       transform
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;input, const std::string &amp;unary_udf, gdf_dtype output_type, bool is_ptx)
     </td>
</tr>
<tr class="memdesc:a45876c5d57c0d0afb921add28b3516e3">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Creates a new column by applying a unary function against every element of an input column.
      <a href="namespacecudf.html#a45876c5d57c0d0afb921add28b3516e3">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a45876c5d57c0d0afb921add28b3516e3">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aca9904c47d7ae6d33143b6441cba45d2">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#aca9904c47d7ae6d33143b6441cba45d2">
       cast
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const  &amp;input, gdf_dtype out_type,
      <a class="el" href="structgdf__dtype__extra__info.html">
       gdf_dtype_extra_info
      </a>
      out_info=
      <a class="el" href="structgdf__dtype__extra__info.html">
       gdf_dtype_extra_info
      </a>
      {})
     </td>
</tr>
<tr class="memdesc:aca9904c47d7ae6d33143b6441cba45d2">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Casts data from dtype specified in input to dtype specified in output.
      <a href="namespacecudf.html#aca9904c47d7ae6d33143b6441cba45d2">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:aca9904c47d7ae6d33143b6441cba45d2">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ae4de4905066fbb3c645b05a1fc1d31d2">
<td align="right" class="memItemLeft" valign="top">
<a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
</td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ae4de4905066fbb3c645b05a1fc1d31d2">
       unary_operation
      </a>
      (
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      const  &amp;input,
      <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">
       unary_op
      </a>
      op)
     </td>
</tr>
<tr class="memdesc:ae4de4905066fbb3c645b05a1fc1d31d2">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Performs unary op on all values in column.
      <a href="namespacecudf.html#ae4de4905066fbb3c645b05a1fc1d31d2">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ae4de4905066fbb3c645b05a1fc1d31d2">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:afa70e889e2b83eba15ed8e8e864dd3ff">
<td align="right" class="memItemLeft" valign="top">
      void
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">
       validate
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;column)
     </td>
</tr>
<tr class="memdesc:afa70e889e2b83eba15ed8e8e864dd3ff">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Ensures a gdf_column is valid, i.e. that its fields are consistent with each other, and logical in themselves, in representing a proper column.
      <a href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:afa70e889e2b83eba15ed8e8e864dd3ff">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ab9985a7fc88fb9b13d429e29405e12ae">
<td align="right" class="memItemLeft" valign="top">
<a id="ab9985a7fc88fb9b13d429e29405e12ae">
</a>
      void
     </td>
<td class="memItemRight" valign="bottom">
<b>
       validate
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *column_ptr)
     </td>
</tr>
<tr class="separator:ab9985a7fc88fb9b13d429e29405e12ae">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a0d288a83fd8de580d2274f825997cbf3">
<td align="right" class="memItemLeft" valign="top">
      bool
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#a0d288a83fd8de580d2274f825997cbf3">
       have_same_type
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;validated_column_1, const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;validated_column_2, bool ignore_extra_type_info=false) noexcept
     </td>
</tr>
<tr class="memdesc:a0d288a83fd8de580d2274f825997cbf3">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Ensures two (valid!) columns have the same type.
      <a href="namespacecudf.html#a0d288a83fd8de580d2274f825997cbf3">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:a0d288a83fd8de580d2274f825997cbf3">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a11851549cdd993a7a09c280a6d015135">
<td align="right" class="memItemLeft" valign="top">
<a id="a11851549cdd993a7a09c280a6d015135">
</a>
      bool
     </td>
<td class="memItemRight" valign="bottom">
<b>
       have_same_type
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *validated_column_ptr_1, const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *validated_column_ptr_2, bool ignore_extra_type_info) noexcept
     </td>
</tr>
<tr class="separator:a11851549cdd993a7a09c280a6d015135">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a40f193177256b121627a35887dc9f816">
<td class="memTemplParams" colspan="2">
<a id="a40f193177256b121627a35887dc9f816">
</a>
      template&lt;typename T &gt;
     </td>
</tr>
<tr class="memitem:a40f193177256b121627a35887dc9f816">
<td align="right" class="memTemplItemLeft" valign="top">
      T *
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       get_data
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;column) noexcept
     </td>
</tr>
<tr class="separator:a40f193177256b121627a35887dc9f816">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a52b3e096195676e94b7c8398747459ff">
<td class="memTemplParams" colspan="2">
<a id="a52b3e096195676e94b7c8398747459ff">
</a>
      template&lt;typename T &gt;
     </td>
</tr>
<tr class="memitem:a52b3e096195676e94b7c8398747459ff">
<td align="right" class="memTemplItemLeft" valign="top">
      T *
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       get_data
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *column) noexcept
     </td>
</tr>
<tr class="separator:a52b3e096195676e94b7c8398747459ff">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a571f2362be95df8c2348bcce96fc522b">
<td align="right" class="memItemLeft" valign="top">
<a id="a571f2362be95df8c2348bcce96fc522b">
</a>
      constexpr bool
     </td>
<td class="memItemRight" valign="bottom">
<b>
       is_an_integer
      </b>
      (gdf_dtype element_type) noexcept
     </td>
</tr>
<tr class="separator:a571f2362be95df8c2348bcce96fc522b">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a8d1090d2083c2700bef73bb07b29f8eb">
<td align="right" class="memItemLeft" valign="top">
<a id="a8d1090d2083c2700bef73bb07b29f8eb">
</a>
      constexpr bool
     </td>
<td class="memItemRight" valign="bottom">
<b>
       is_integral
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;column) noexcept
     </td>
</tr>
<tr class="separator:a8d1090d2083c2700bef73bb07b29f8eb">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a49a3589a60ac4e16c069ae1852d80264">
<td align="right" class="memItemLeft" valign="top">
<a id="a49a3589a60ac4e16c069ae1852d80264">
</a>
      constexpr bool
     </td>
<td class="memItemRight" valign="bottom">
<b>
       is_integral
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      *column) noexcept
     </td>
</tr>
<tr class="separator:a49a3589a60ac4e16c069ae1852d80264">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a2db5b2cb45e0e4d7f9f1d7cb25ca32ae">
<td align="right" class="memItemLeft" valign="top">
<a id="a2db5b2cb45e0e4d7f9f1d7cb25ca32ae">
</a>
      constexpr bool
     </td>
<td class="memItemRight" valign="bottom">
<b>
       is_nullable
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;column) noexcept
     </td>
</tr>
<tr class="separator:a2db5b2cb45e0e4d7f9f1d7cb25ca32ae">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a83a4a65a257d9746a9d65f8a8a6de1a5">
<td align="right" class="memItemLeft" valign="top">
<a id="a83a4a65a257d9746a9d65f8a8a6de1a5">
</a>
      constexpr bool
     </td>
<td class="memItemRight" valign="bottom">
<b>
       has_nulls
      </b>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;column) noexcept
     </td>
</tr>
<tr class="separator:a83a4a65a257d9746a9d65f8a8a6de1a5">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aea3dfde6d57f821aa1825a90a8cdddcb">
<td align="right" class="memItemLeft" valign="top">
<a id="aea3dfde6d57f821aa1825a90a8cdddcb">
</a>
      constexpr std::size_t
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#aea3dfde6d57f821aa1825a90a8cdddcb">
       size_of
      </a>
      (gdf_dtype element_type)
     </td>
</tr>
<tr class="memdesc:aea3dfde6d57f821aa1825a90a8cdddcb">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Returns the size in bytes of values of a column element type.
      <br/>
</td>
</tr>
<tr class="separator:aea3dfde6d57f821aa1825a90a8cdddcb">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aaf37d87f3ef5bb0736ad2dfeeac3e766">
<td align="right" class="memItemLeft" valign="top">
<a id="aaf37d87f3ef5bb0736ad2dfeeac3e766">
</a>
      std::size_t
     </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#aaf37d87f3ef5bb0736ad2dfeeac3e766">
       byte_width
      </a>
      (const
      <a class="el" href="structgdf__column__.html">
       gdf_column
      </a>
      &amp;col) noexcept
     </td>
</tr>
<tr class="memdesc:aaf37d87f3ef5bb0736ad2dfeeac3e766">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Returns the size in bytes of each element of a column (a.k.a. the column's width)
      <br/>
</td>
</tr>
<tr class="separator:aaf37d87f3ef5bb0736ad2dfeeac3e766">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ae62151c46119cd04dc146c9e4175375f">
<td class="memTemplParams" colspan="2">
      template&lt;typename T , typename BinaryOp &gt;
     </td>
</tr>
<tr class="memitem:ae62151c46119cd04dc146c9e4175375f">
<td align="right" class="memTemplItemLeft" valign="top">
      __forceinline__ __device__ T
     </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ae62151c46119cd04dc146c9e4175375f">
       genericAtomicOperation
      </a>
      (T *address, T const &amp;update_value, BinaryOp op)
     </td>
</tr>
<tr class="memdesc:ae62151c46119cd04dc146c9e4175375f">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      compute atomic binary operation reads the
      <code>
       old
      </code>
      located at the
      <code>
       address
      </code>
      in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction.
      <a href="namespacecudf.html#ae62151c46119cd04dc146c9e4175375f">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ae62151c46119cd04dc146c9e4175375f">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9">
<td class="memTemplParams" colspan="2">
<a id="acafbd5dbae09b26c92b964e0122d5fc9">
</a>
      template&lt;typename BinaryOp &gt;
     </td>
</tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9">
<td align="right" class="memTemplItemLeft" valign="top">
      __forceinline__ __device__
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       cudf::bool8
      </a>
</td>
<td class="memTemplItemRight" valign="bottom">
<b>
       genericAtomicOperation
      </b>
      (
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       cudf::bool8
      </a>
      *address,
      <a class="el" href="structcudf_1_1detail_1_1wrapper.html">
       cudf::bool8
      </a>
      const &amp;update_value, BinaryOp op)
     </td>
</tr>
<tr class="separator:acafbd5dbae09b26c92b964e0122d5fc9">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a16ced5d0e49afdda2879ae5535a03167">
<td class="memTemplParams" colspan="2">
<a id="a16ced5d0e49afdda2879ae5535a03167">
</a>
      template&lt;class functor_t , typename... Ts&gt;
     </td>
</tr>
<tr class="memitem:a16ced5d0e49afdda2879ae5535a03167">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr decltype(auto) CUDA_HOST_DEVICE_CALLABLE
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       type_dispatcher
      </b>
      (gdf_dtype dtype, functor_t f, Ts &amp;&amp;... args)
     </td>
</tr>
<tr class="separator:a16ced5d0e49afdda2879ae5535a03167">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989">
<td class="memTemplParams" colspan="2">
      template&lt;typename T &gt;
     </td>
</tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="namespacecudf.html#ad7b0f1bc518e47eaa2cfdd0ec88e3989">
       gdf_dtype_of
      </a>
      ()
     </td>
</tr>
<tr class="memdesc:ad7b0f1bc518e47eaa2cfdd0ec88e3989">
<td class="mdescLeft">
</td>
<td class="mdescRight">
      Maps a C++ type to it's corresponding gdf_dtype.
      <a href="namespacecudf.html#ad7b0f1bc518e47eaa2cfdd0ec88e3989">
       More...
      </a>
<br/>
</td>
</tr>
<tr class="separator:ad7b0f1bc518e47eaa2cfdd0ec88e3989">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412">
<td class="memTemplParams" colspan="2">
<a id="ad0a0a98fdfe7a302afb2dfcaeb536412">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; int8_t &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:ad0a0a98fdfe7a302afb2dfcaeb536412">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d">
<td class="memTemplParams" colspan="2">
<a id="ae3d9564b2dc03eee3515499cae68827d">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; int16_t &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:ae3d9564b2dc03eee3515499cae68827d">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5">
<td class="memTemplParams" colspan="2">
<a id="ae5ac9bfed0ac9684cc5c201271d4bca5">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; int32_t &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:ae5ac9bfed0ac9684cc5c201271d4bca5">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682">
<td class="memTemplParams" colspan="2">
<a id="a17d6aab829fdfa0a8e805693fe6d0682">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; int64_t &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:a17d6aab829fdfa0a8e805693fe6d0682">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124">
<td class="memTemplParams" colspan="2">
<a id="aef0bacd5dab94476140d35bd1a44c124">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; float &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:aef0bacd5dab94476140d35bd1a44c124">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac">
<td class="memTemplParams" colspan="2">
<a id="aa02973e71d09dc7a3636d2a836968dac">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; double &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:aa02973e71d09dc7a3636d2a836968dac">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5">
<td class="memTemplParams" colspan="2">
<a id="ab49efe66b146dc87425669653bde18f5">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; cudf::bool8 &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:ab49efe66b146dc87425669653bde18f5">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52">
<td class="memTemplParams" colspan="2">
<a id="a1e1b828c8f1b2b46e015afb85902ba52">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; cudf::date32 &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:a1e1b828c8f1b2b46e015afb85902ba52">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c">
<td class="memTemplParams" colspan="2">
<a id="adb20c98631c4c203372547135f13732c">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; cudf::date64 &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:adb20c98631c4c203372547135f13732c">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854">
<td class="memTemplParams" colspan="2">
<a id="ad2576f3b441a5f87a0d5b67b7d21b854">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; cudf::timestamp &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:ad2576f3b441a5f87a0d5b67b7d21b854">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309">
<td class="memTemplParams" colspan="2">
<a id="a4e807d272b4582ff4d2a0dd9c6b8b309">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; cudf::category &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:a4e807d272b4582ff4d2a0dd9c6b8b309">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919">
<td class="memTemplParams" colspan="2">
<a id="a0f831e82c6b13cd54c940e74fc46b919">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; cudf::nvstring_category &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:a0f831e82c6b13cd54c940e74fc46b919">
<td class="memSeparator" colspan="2">
</td>
</tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606">
<td class="memTemplParams" colspan="2">
<a id="a5d1e00fa2d40d07ed6114dc064582606">
</a>
      template&lt;&gt;
     </td>
</tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606">
<td align="right" class="memTemplItemLeft" valign="top">
      constexpr gdf_dtype
     </td>
<td class="memTemplItemRight" valign="bottom">
<b>
       gdf_dtype_of&lt; NVStrings &gt;
      </b>
      ()
     </td>
</tr>
<tr class="separator:a5d1e00fa2d40d07ed6114dc064582606">
<td class="memSeparator" colspan="2">
</td>
</tr>
</table>
<a id="details" name="details">
</a>
<h2 class="groupheader">
    Detailed Description
   </h2>
<div class="textblock">
<p>
     Parse and Transform a piece of PTX code that contains the implementation of a
     <code>
      __device__
     </code>
     function into a CUDA
     <code>
      __device__
     </code>
<code>
      __inline__
     </code>
     function.
    </p>
<p>
     Invokes an instance of a functor template with the appropriate type determined by a gdf_dtype enum value.
    </p>
<dl class="params">
<dt>
      Parameters
     </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
         &lt;tt&gt;src&lt;/tt&gt;
        </td>
<td>
         The input PTX code.
        </td>
</tr>
<tr>
<td class="paramname">
         &lt;tt&gt;function_name&lt;/tt&gt;
        </td>
<td>
         The User defined function that the output CUDA function will have.
        </td>
</tr>
<tr>
<td class="paramname">
         &lt;tt&gt;output_arg_type&lt;/tt&gt;
        </td>
<td>
         The output type of the PTX function, e.g. "int", "int64_t"
        </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
      Returns
     </dt>
<dd>
      The output CUDA
      <code>
       __device__
      </code>
<code>
       __inline__
      </code>
      function
     </dd>
</dl>
<p>
     This helper function accepts any object with an "operator()" template, e.g., a functor. It will invoke an instance of the template by passing in as the template argument an appropriate type determined by the value of the gdf_dtype argument.
    </p>
<p>
     The template may have 1 or more template parameters, but the first parameter must be the type dispatched from the gdf_dtype enum. The remaining template parameters must be able to be automatically deduced.
    </p>
<p>
     There is a 1-to-1 mapping of gdf_dtype enum values and dispatched types. However, different gdf_dtype values may have the same underlying type. Therefore, in order to provide the 1-to-1 mapping, a wrapper struct may be dispatched for certain gdf_dtype enum values in order to emulate a "strong
typedef".
    </p>
<p>
     A strong typedef provides a new, concrete type unlike a normal C++ typedef which is simply a type alias. These "strong typedef" structs simply wrap a single member variable of a fundamental type called 'value'.
    </p>
<p>
     The standard arithmetic operators are defined for the wrapper structs and therefore the wrapper struct types can be used as if they were fundamental types.
    </p>
<p>
     See
     <a class="el" href="wrapper__types_8hpp.html" title="Wrapper structs for for the non-fundamental gdf_dtype types.">
      wrapper_types.hpp
     </a>
     for more detail.
    </p>
<p>
     Example usage with a functor that returns the size of the dispatched type:
    </p>
<div class="fragment">
<div class="line">
<span class="keyword">
       struct
      </span>
      example_functor{
     </div>
<div class="line">
<span class="keyword">
       template
      </span>
      &lt;
      <span class="keyword">
       typename
      </span>
      T&gt;
     </div>
<div class="line">
<span class="keywordtype">
       int
      </span>
      operator()(){
     </div>
<div class="line">
<span class="keywordflow">
       return
      </span>
<span class="keyword">
       sizeof
      </span>
      (T);
     </div>
<div class="line">
      }
     </div>
<div class="line">
      };
     </div>
<div class="line">
</div>
<div class="line">
      cudf::type_dispatcher(GDF_INT8, example_functor{});
      <span class="comment">
       // returns 1
      </span>
</div>
<div class="line">
      cudf::type_dispatcher(GDF_INT64, example_functor{});
      <span class="comment">
       // returns 8
      </span>
</div>
</div>
<!-- fragment -->
<p>
     Example usage of a functor for checking if element "i" in column "lhs" is equal to element "j" in column "rhs":
    </p>
<div class="fragment">
<div class="line">
<span class="keyword">
       struct
      </span>
      elements_are_equal{
     </div>
<div class="line">
<span class="keyword">
       template
      </span>
      &lt;
      <span class="keyword">
       typename
      </span>
      ColumnType&gt;
     </div>
<div class="line">
<span class="keywordtype">
       bool
      </span>
      operator()(
      <span class="keywordtype">
       void
      </span>
<span class="keyword">
       const
      </span>
      * lhs,
      <span class="keywordtype">
       int
      </span>
      i,
     </div>
<div class="line">
<span class="keywordtype">
       void
      </span>
<span class="keyword">
       const
      </span>
      * rhs,
      <span class="keywordtype">
       int
      </span>
      j)
     </div>
<div class="line">
      {
     </div>
<div class="line">
<span class="comment">
       // Cast the void* data buffer to the dispatched type and retrieve
      </span>
</div>
<div class="line">
      elements
     </div>
<div class="line">
<span class="comment">
       // "i" and "j" from the respective columns
      </span>
</div>
<div class="line">
      ColumnType
      <span class="keyword">
       const
      </span>
      i_elem = static_cast&lt;ColumnType const*&gt;(lhs)[i];
     </div>
<div class="line">
      ColumnType
      <span class="keyword">
       const
      </span>
      j_elem = static_cast&lt;ColumnType const*&gt;(rhs)[j];
     </div>
<div class="line">
</div>
<div class="line">
<span class="comment">
       // operator== is defined for wrapper structs such that it performs the
      </span>
</div>
<div class="line">
<span class="comment">
       // operator== on the underlying values. Therefore, the wrapper structs
      </span>
</div>
<div class="line">
<span class="comment">
       // can be used as if they were fundamental arithmetic types
      </span>
</div>
<div class="line">
<span class="keywordflow">
       return
      </span>
      i_elem == j_elem;
     </div>
<div class="line">
      }
     </div>
<div class="line">
      };
     </div>
</div>
<!-- fragment -->
<p>
     It is sometimes neccessary to customize the dispatched functor's
     <code>
      operator()
     </code>
     for different types. This can be done in several ways.
    </p>
<p>
     The first method is to use explicit template specialization. This is useful for specializing behavior for single types. For example, a functor that prints
     <code>
      int32_t
     </code>
     or
     <code>
      double
     </code>
     when invoked with either of those types, else it prints
     <code>
      unhandled type
     </code>
     :
    </p>
<div class="fragment">
<div class="line">
<span class="keyword">
       struct
      </span>
      type_printer {
     </div>
<div class="line">
<span class="keyword">
       template
      </span>
      &lt;
      <span class="keyword">
       typename
      </span>
      ColumnType&gt;
     </div>
<div class="line">
<span class="keywordtype">
       void
      </span>
      operator()() { std::cout &lt;&lt;
      <span class="stringliteral">
       "unhandled type\n"
      </span>
      ; }
     </div>
<div class="line">
      };
     </div>
<div class="line">
</div>
<div class="line">
<span class="comment">
       // Due to a bug in g++, explicit member function specializations need to be
      </span>
</div>
<div class="line">
<span class="comment">
       // defined outside of the class definition
      </span>
</div>
<div class="line">
<span class="keyword">
       template
      </span>
      &lt;&gt;
     </div>
<div class="line">
<span class="keywordtype">
       void
      </span>
      type_printer::operator()&lt;int32_t&gt;() { std::cout &lt;&lt;
      <span class="stringliteral">
       "int32_t\n"
      </span>
      ; }
     </div>
<div class="line">
</div>
<div class="line">
<span class="keyword">
       template
      </span>
      &lt;&gt;
     </div>
<div class="line">
<span class="keywordtype">
       void
      </span>
      type_printer::operator()&lt;
      <span class="keywordtype">
       double
      </span>
      &gt;() { std::cout &lt;&lt;
      <span class="stringliteral">
       "double\n"
      </span>
      ; }
     </div>
</div>
<!-- fragment -->
<p>
     A second method is to use SFINAE with
     <code>
      std::enable_if_t
     </code>
     . This is useful for specializing for a set of types that share some property. For example, a functor that prints
     <code>
      integral
     </code>
     or
     <code>
      floating point
     </code>
     for integral or floating point types:
    </p>
<div class="fragment">
<div class="line">
<span class="keyword">
       struct
      </span>
      integral_or_floating_point {
     </div>
<div class="line">
<span class="keyword">
       template
      </span>
      &lt;
      <span class="keyword">
       typename
      </span>
      ColumnType,
     </div>
<div class="line">
      std::enable_if_t&lt;not std::is_integral&lt;ColumnType&gt;::value and
     </div>
<div class="line">
      not std::is_floating_point&lt;ColumnType&gt;::value&gt;* =
      <span class="keyword">
       nullptr
      </span>
      &gt;
     </div>
<div class="line">
<span class="keywordtype">
       void
      </span>
      operator()() { std::cout &lt;&lt;
      <span class="stringliteral">
       "neither integral nor floating point\n"
      </span>
      ; }
     </div>
<div class="line">
</div>
<div class="line">
<span class="keyword">
       template
      </span>
      &lt;
      <span class="keyword">
       typename
      </span>
      ColumnType,
     </div>
<div class="line">
      std::enable_if_t&lt;std::is_integral&lt;ColumnType&gt;::value&gt;* =
      <span class="keyword">
       nullptr
      </span>
      &gt;
     </div>
<div class="line">
<span class="keywordtype">
       void
      </span>
      operator()() { std::cout &lt;&lt;
      <span class="stringliteral">
       "integral\n"
      </span>
      ; }
     </div>
<div class="line">
</div>
<div class="line">
<span class="keyword">
       template
      </span>
      &lt;
      <span class="keyword">
       typename
      </span>
      ColumnType,
     </div>
<div class="line">
      std::enable_if_t&lt;std::is_floating_point&lt;ColumnType&gt;::value&gt;* =
      <span class="keyword">
       nullptr
      </span>
      &gt;
     </div>
<div class="line">
<span class="keywordtype">
       void
      </span>
      operator()() { std::cout &lt;&lt;
      <span class="stringliteral">
       "floating point\n"
      </span>
      ; }
     </div>
<div class="line">
      };
     </div>
</div>
<!-- fragment -->
<p>
     For more info on SFINAE and
     <code>
      std::enable_if
     </code>
     , see
     <a href="https://eli.thegreenplace.net/2014/sfinae-and-enable_if/">
      https://eli.thegreenplace.net/2014/sfinae-and-enable_if/
     </a>
</p>
<p>
     The return type for all template instantiations of the functor's "operator()" lambda must be the same, else there will be a compiler error as you would be trying to return different types from the same function.
    </p>
<p>
     NOTE: It is undefined behavior if an unsupported or invalid
     <code>
      gdf_dtype
     </code>
     is supplied.
    </p>
<dl class="params">
<dt>
      Parameters
     </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
         dtype
        </td>
<td>
         The gdf_dtype enum that determines which type will be dispatched
        </td>
</tr>
<tr>
<td class="paramname">
         f
        </td>
<td>
         The functor with a templated "operator()" that will be invoked with the dispatched type
        </td>
</tr>
<tr>
<td class="paramname">
         args
        </td>
<td>
         A parameter-pack (i.e., arbitrary number of arguments) that will be perfectly-forwarded as the arguments of the functor's "operator()".
        </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
      Returns
     </dt>
<dd>
      Whatever is returned by the functor's "operator()".
     </dd>
</dl>
</div>
<h2 class="groupheader">
    Enumeration Type Documentation
   </h2>
<a id="a69091647ea1f9c9d4cdcf7c8876bea3a">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a69091647ea1f9c9d4cdcf7c8876bea3a">
      
     </a>
</span>
    duplicate_keep_option
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        enum
        <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">
         cudf::duplicate_keep_option
        </a>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Choices for drop_duplicates API for retainment of duplicate rows.
     </p>
<table class="fieldtable">
<tr>
<th colspan="2">
        Enumerator
       </th>
</tr>
<tr>
<td class="fieldname">
<a id="a69091647ea1f9c9d4cdcf7c8876bea3aa86ea4bfd2b3121412b0a63a3697926ec">
</a>
        KEEP_FIRST
       </td>
<td class="fielddoc">
<p>
         Keeps first duplicate row and unique rows.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="a69091647ea1f9c9d4cdcf7c8876bea3aa1d1398f646d74e801389737f07d89d1c">
</a>
        KEEP_LAST
       </td>
<td class="fielddoc">
<p>
         Keeps last duplicate row and unique rows.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="a69091647ea1f9c9d4cdcf7c8876bea3aa6fb3154b77231184b596b4add407aa2a">
</a>
        KEEP_NONE
       </td>
<td class="fielddoc">
<p>
         Don't keep any duplicate rows, Keeps only unique rows.
        </p>
</td>
</tr>
</table>
</div>
</div>
<a id="ab15567f1034536ae6f7f14179334a19b">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ab15567f1034536ae6f7f14179334a19b">
      
     </a>
</span>
    unary_op
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        enum
        <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">
         cudf::unary_op
        </a>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Types of unary operations that can be performed on data.
     </p>
<table class="fieldtable">
<tr>
<th colspan="2">
        Enumerator
       </th>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba6b585cf453d36fbb0381b38bc2c966e1">
</a>
        SIN
       </td>
<td class="fielddoc">
<p>
         Trigonometric sine.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19baf7c88ff3bee94b5c3c16c405706ef34a">
</a>
        COS
       </td>
<td class="fielddoc">
<p>
         Trigonometric cosine.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19baa91cdd09214d36d756b5f13803ddd890">
</a>
        TAN
       </td>
<td class="fielddoc">
<p>
         Trigonometric tangent.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba463397f416a024fb7df7d906a0436dbb">
</a>
        ARCSIN
       </td>
<td class="fielddoc">
<p>
         Trigonometric sine inverse.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba1e17febbc6d14208d0a264562dcee2e9">
</a>
        ARCCOS
       </td>
<td class="fielddoc">
<p>
         Trigonometric cosine inverse.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19bad1c5c0c8ffe6bf038e617b0aad0f9aac">
</a>
        ARCTAN
       </td>
<td class="fielddoc">
<p>
         Trigonometric tangent inverse.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba6e272b8c75625066b2c8994cec6c8f73">
</a>
        EXP
       </td>
<td class="fielddoc">
<p>
         Exponential (base e, Euler number)
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba1509f8449abb15062ad85e15fb3861d7">
</a>
        LOG
       </td>
<td class="fielddoc">
<p>
         Natural Logarithm (base e)
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba6ac653ea3d15f23b0f6e61b447f783ea">
</a>
        SQRT
       </td>
<td class="fielddoc">
<p>
         Square-root (x^0.5)
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba8b0d502b44d1472a2d5fa3638f0ce945">
</a>
        CEIL
       </td>
<td class="fielddoc">
<p>
         Smallest integer value not less than arg.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba07e330cc72f454a6369d267d1bfb2d7e">
</a>
        FLOOR
       </td>
<td class="fielddoc">
<p>
         largest integer value not greater than arg
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19bab226be3789467f51f32cf06550a4c46e">
</a>
        ABS
       </td>
<td class="fielddoc">
<p>
         Absolute value.
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba62a7f82a72f8422f631cb550b7201667">
</a>
        BIT_INVERT
       </td>
<td class="fielddoc">
<p>
         Bitwise Not (~)
        </p>
</td>
</tr>
<tr>
<td class="fieldname">
<a id="ab15567f1034536ae6f7f14179334a19ba5e654d9830c09fc254d4f9f19fbdfe6e">
</a>
        NOT
       </td>
<td class="fielddoc">
<p>
         Logical Not (!)
        </p>
</td>
</tr>
</table>
</div>
</div>
<h2 class="groupheader">
    Function Documentation
   </h2>
<a id="a38150f11c542f3238874911d4a30a530">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a38150f11c542f3238874911d4a30a530">
      
     </a>
</span>
    allocate_column()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::allocate_column
       </td>
<td>
        (
       </td>
<td class="paramtype">
        gdf_dtype
       </td>
<td class="paramname">
<em>
         dtype
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_size_type
       </td>
<td class="paramname">
<em>
         size
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         allocate_mask
        </em>
        =
        <code>
         true
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__dtype__extra__info.html">
         gdf_dtype_extra_info
        </a>
</td>
<td class="paramname">
<em>
         info
        </em>
        =
        <code>
<a class="el" href="structgdf__dtype__extra__info.html">
          gdf_dtype_extra_info
         </a>
         {}
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Allocates a new column of the specified size and type.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          dtype
         </td>
<td>
          Datatype of the column
         </td>
</tr>
<tr>
<td class="paramname">
          size
         </td>
<td>
          Size of the column
         </td>
</tr>
<tr>
<td class="paramname">
          allocate_mask
         </td>
<td>
          Optional Whether or not to allocate bitmask
         </td>
</tr>
<tr>
<td class="paramname">
          info
         </td>
<td>
          Optional Extra info for the column
         </td>
</tr>
<tr>
<td class="paramname">
          stream
         </td>
<td>
          Optional stream in which to perform allocation
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column An allocated column of given size and type
      </dd>
</dl>
</div>
</div>
<a id="ae08cb8501fe52a732913af1ac7b25ace">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ae08cb8501fe52a732913af1ac7b25ace">
      
     </a>
</span>
    allocate_like()
    <span class="overload">
     [1/4]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::allocate_like
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         allocate_mask_if_exists
        </em>
        =
        <code>
         true
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Allocates a new column of the same size and type as the input.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          input
         </td>
<td>
          The input column to emulate
         </td>
</tr>
<tr>
<td class="paramname">
          allocate_mask_if_exists
         </td>
<td>
          Optional whether or not to allocate bitmask if it exists in input
         </td>
</tr>
<tr>
<td class="paramname">
          stream
         </td>
<td>
          Optional stream in which to perform copies
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column An allocated column of same size and type of input
      </dd>
</dl>
</div>
</div>
<a id="af8183dc03a72e9c6cc1d7cd4cda37816">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#af8183dc03a72e9c6cc1d7cd4cda37816">
      
     </a>
</span>
    allocate_like()
    <span class="overload">
     [2/4]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::allocate_like
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_size_type
       </td>
<td class="paramname">
<em>
         size
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         allocate_mask_if_exists
        </em>
        =
        <code>
         true
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Allocates a new column of the specified size and same type as the input.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          input
         </td>
<td>
          The input column to emulate
         </td>
</tr>
<tr>
<td class="paramname">
          size
         </td>
<td>
          The size of the column to allocate in rows
         </td>
</tr>
<tr>
<td class="paramname">
          allocate_mask_if_exists
         </td>
<td>
          Optional whether or not to allocate bitmask if it exists in input
         </td>
</tr>
<tr>
<td class="paramname">
          stream
         </td>
<td>
          Optional stream in which to perform copies
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column An allocated column of same size and type of input
      </dd>
</dl>
</div>
</div>
<a id="af3a1a6bea8f1e1dd224f4316bbd23fbc">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#af3a1a6bea8f1e1dd224f4316bbd23fbc">
      
     </a>
</span>
    allocate_like()
    <span class="overload">
     [3/4]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::allocate_like
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         t
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         allocate_mask_if_exists
        </em>
        =
        <code>
         true
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Creates a table of columns with the same type and allocation size as the input.
     </p>
<p>
      Creates the
      <code>
       gdf_column
      </code>
      objects, and allocates underlying device memory for each column matching the input columns
     </p>
<dl class="section note">
<dt>
       Note
      </dt>
<dd>
       It is the caller's responsibility to free each column's device memory allocation in addition to deleting the
       <code>
        gdf_column
       </code>
       object for every column in the new table.
      </dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          t
         </td>
<td>
          The table to emulate
         </td>
</tr>
<tr>
<td class="paramname">
          allocate_mask_if_exists
         </td>
<td>
          Optional whether or not to allocate the bitmask for each column if it exists in the corresponding input column
         </td>
</tr>
<tr>
<td class="paramname">
          stream
         </td>
<td>
          Optional stream in which to perform allocations
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       table A table of columns with same type and allocation size as input
      </dd>
</dl>
</div>
</div>
<a id="a13d885159232b25ffdf8d7980f178c3a">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a13d885159232b25ffdf8d7980f178c3a">
      
     </a>
</span>
    allocate_like()
    <span class="overload">
     [4/4]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::allocate_like
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         t
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_size_type
       </td>
<td class="paramname">
<em>
         size
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         allocate_mask_if_exists
        </em>
        =
        <code>
         true
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Creates a table of columns with the specified size and same type as the input.
     </p>
<p>
      Creates the
      <code>
       gdf_column
      </code>
      objects, and allocates underlying device memory for each column matching the input columns
     </p>
<dl class="section note">
<dt>
       Note
      </dt>
<dd>
       It is the caller's responsibility to free each column's device memory allocation in addition to deleting the
       <code>
        gdf_column
       </code>
       object for every column in the new table.
      </dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          t
         </td>
<td>
          The table to emulate
         </td>
</tr>
<tr>
<td class="paramname">
          size
         </td>
<td>
          The size of the columns to allocate
         </td>
</tr>
<tr>
<td class="paramname">
          allocate_mask_if_exists
         </td>
<td>
          Optional whether or not to allocate the bitmask for each column if it exists in the corresponding input column
         </td>
</tr>
<tr>
<td class="paramname">
          stream
         </td>
<td>
          Optional stream in which to perform allocations
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       table A table of columns with same type as
       <code>
        t
       </code>
       and specified
       <code>
        size
       </code>
</dd>
</dl>
</div>
</div>
<a id="ad888a160fd5439ce10ed29232debc200">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ad888a160fd5439ce10ed29232debc200">
      
     </a>
</span>
    apply_boolean_mask()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::apply_boolean_mask
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         boolean_mask
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Filters a table using a column of boolean values as a mask.
     </p>
<p>
      Given an input table and a mask column, an element
      <code>
       i
      </code>
      from each column of the input table is copied to the corresponding output column if the corresponding element
      <code>
       i
      </code>
      in the mask is non-null and
      <code>
       true
      </code>
      . This operation is stable: the input order is preserved.
     </p>
<p>
      The input and mask columns must be of equal size (number of rows).
     </p>
<p>
      The output table has number of rows equal to the number of elements in boolean_mask that are both non-null and
      <code>
       true
      </code>
      . Note that the output table memory is allocated by this function but must be freed by the caller when finished.
     </p>
<dl class="section note">
<dt>
       Note
      </dt>
<dd>
       that the
       <code>
        boolean_mask
       </code>
       may have just boolean data (no valid bitmask), or just a valid bitmask (no boolean data), or it may have both. The filter adapts to these three situations.
      </dd>
<dd>
       if
       <code>
        input.num_rows()
       </code>
       is zero, there is no error, and an empty table is returned.
      </dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input
         </td>
<td>
          The input table to filter
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          boolean_mask
         </td>
<td>
          A column of type GDF_BOOL8 used as a mask to filter the input column corresponding index passes the filter.
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
<a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">
        cudf::table
       </a>
       Table containing copy of all rows of
       <code>
        input
       </code>
       passing the filter defined by
       <code>
        boolean_mask
       </code>
       .
      </dd>
</dl>
</div>
</div>
<a id="a1f727c257f82efc1a7b144eb6dcbb2d8">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a1f727c257f82efc1a7b144eb6dcbb2d8">
      
     </a>
</span>
    binary_operation()
    <span class="overload">
     [1/4]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::binary_operation
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         lhs
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         rhs
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const std::string &amp;
       </td>
<td class="paramname">
<em>
         ptx
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_dtype
       </td>
<td class="paramname">
<em>
         output_type
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Performs a binary operation between two gdf_columns using a user-defined PTX function.
     </p>
<p>
      Accepts a user-defined PTX function to apply between the
      <code>
       lhs
      </code>
      and
      <code>
       rhs
      </code>
      .
     </p>
<p>
      The desired output type must be specified in output_type. It is assumed that this output type is compatable with the output type in the PTX code.
     </p>
<p>
      The output column will be allocated and it is the user's reponsibility to free the device memory
     </p>
<p>
      If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid masks of lhs and rhs gdf_columns
     </p>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       A gdf_column as the output of the operation.
      </dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          lhs
         </td>
<td>
          (gdf_column) First operand of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          rhs
         </td>
<td>
          (gdf_column) Second operand of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          ptx
         </td>
<td>
          String containing the PTX of a binary function to apply between
          <code>
           lhs
          </code>
          and
          <code>
           rhs
          </code>
</td>
</tr>
<tr>
<td class="paramname">
          output_type
         </td>
<td>
          The desired output type
         </td>
</tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ad01e2e81bc2b671dfb8963a7be22e3b0">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ad01e2e81bc2b671dfb8963a7be22e3b0">
      
     </a>
</span>
    binary_operation()
    <span class="overload">
     [2/4]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        void cudf::binary_operation
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         out
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         lhs
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         rhs
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_binary_operator
       </td>
<td class="paramname">
<em>
         ope
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Performs a binary operation between two gdf_columns.
     </p>
<p>
      The desired output type must be specified in out-&gt;dtype.
     </p>
<p>
      If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid masks of lhs and rhs gdf_columns
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          out
         </td>
<td>
          (gdf_column) Output of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          lhs
         </td>
<td>
          (gdf_column) First operand of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          rhs
         </td>
<td>
          (gdf_column) Second operand of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          ope
         </td>
<td>
          (enum) The binary operator to use
         </td>
</tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aa02af1454978d7d7f7b9f651437b3ab5">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#aa02af1454978d7d7f7b9f651437b3ab5">
      
     </a>
</span>
    binary_operation()
    <span class="overload">
     [3/4]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        void cudf::binary_operation
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         out
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         lhs
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__scalar.html">
         gdf_scalar
        </a>
        *
       </td>
<td class="paramname">
<em>
         rhs
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_binary_operator
       </td>
<td class="paramname">
<em>
         ope
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Performs a binary operation between a gdf_column and a
      <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
       gdf_scalar
      </a>
      .
     </p>
<p>
      The desired output type must be specified in out-&gt;dtype.
     </p>
<p>
      If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid mask of lhs gdf_column and is_valid bool of rhs
      <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
       gdf_scalar
      </a>
</p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          out
         </td>
<td>
          (gdf_column) Output of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          lhs
         </td>
<td>
          (gdf_column) First operand of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          rhs
         </td>
<td>
          (
          <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
           gdf_scalar
          </a>
          ) Second operand of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          ope
         </td>
<td>
          (enum) The binary operator to use
         </td>
</tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ae942e9a8d320f23d61bee22ddc06df55">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ae942e9a8d320f23d61bee22ddc06df55">
      
     </a>
</span>
    binary_operation()
    <span class="overload">
     [4/4]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        void cudf::binary_operation
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         out
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__scalar.html">
         gdf_scalar
        </a>
        *
       </td>
<td class="paramname">
<em>
         lhs
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         rhs
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_binary_operator
       </td>
<td class="paramname">
<em>
         ope
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Performs a binary operation between a
      <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
       gdf_scalar
      </a>
      and a gdf_column.
     </p>
<p>
      The desired output type must be specified in out-&gt;dtype.
     </p>
<p>
      If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid mask of rhs gdf_column and is_valid bool of lhs
      <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
       gdf_scalar
      </a>
</p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          out
         </td>
<td>
          (gdf_column) Output of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          lhs
         </td>
<td>
          (
          <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
           gdf_scalar
          </a>
          ) First operand of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          rhs
         </td>
<td>
          (gdf_column) Second operand of the operation.
         </td>
</tr>
<tr>
<td class="paramname">
          ope
         </td>
<td>
          (enum) The binary operator to use
         </td>
</tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aca9904c47d7ae6d33143b6441cba45d2">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#aca9904c47d7ae6d33143b6441cba45d2">
      
     </a>
</span>
    cast()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::cast
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_dtype
       </td>
<td class="paramname">
<em>
         out_type
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__dtype__extra__info.html">
         gdf_dtype_extra_info
        </a>
</td>
<td class="paramname">
<em>
         out_info
        </em>
        =
        <code>
<a class="el" href="structgdf__dtype__extra__info.html">
          gdf_dtype_extra_info
         </a>
         {}
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Casts data from dtype specified in input to dtype specified in output.
     </p>
<dl class="section note">
<dt>
       Note
      </dt>
<dd>
       In case of conversion from GDF_DATE32/GDF_DATE64/GDF_TIMESTAMP to GDF_TIMESTAMP, the time unit for output should be set in out_info.time_unit
      </dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          gdf_column
         </td>
<td>
          Input column
         </td>
</tr>
<tr>
<td class="paramname">
          out_type
         </td>
<td>
          Desired datatype of output column
         </td>
</tr>
<tr>
<td class="paramname">
          out_info
         </td>
<td>
          Extra info for output column in case of conversion to types that require extra info
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column Result of the cast operation
      </dd>
</dl>
</div>
</div>
<a id="ad2c2c74e4d88e3c0b67e7dea9f7086cc">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ad2c2c74e4d88e3c0b67e7dea9f7086cc">
      
     </a>
</span>
    column_dtype_infos()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        std::vector&lt;
        <a class="el" href="structgdf__dtype__extra__info.html">
         gdf_dtype_extra_info
        </a>
        &gt; cudf::column_dtype_infos
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         cudf::table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         table
        </em>
</td>
<td>
        )
       </td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Returns vector of the dtype_infos of the columns in a table.
     </p>
<p>
      ------------------------------------------------------------------------*
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          table
         </td>
<td>
          The table to get the column dtypes_infos from
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md246">
</a>
      @return std::vector&lt;gdf_dtype_extra_info&gt;
     </h2>
</div>
</div>
<a id="ad2f973d94c67ab3dc1a183c5adb3753d">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ad2f973d94c67ab3dc1a183c5adb3753d">
      
     </a>
</span>
    column_dtypes()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        std::vector&lt; gdf_dtype &gt; cudf::column_dtypes
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         cudf::table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         table
        </em>
</td>
<td>
        )
       </td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Returns vector of the dtypes of the columns in a table.
     </p>
<p>
      ------------------------------------------------------------------------*
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          table
         </td>
<td>
          The table to get the column dtypes from
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md245">
</a>
      @return std::vector&lt;gdf_dtype&gt;
     </h2>
</div>
</div>
<a id="aa7e6bf39cb5dd5cdb370d0a562675922">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#aa7e6bf39cb5dd5cdb370d0a562675922">
      
     </a>
</span>
    copy()
    <span class="overload">
     [1/2]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::copy
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Creates a new column that is a copy of input.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          input
         </td>
<td>
          The input column to copy
         </td>
</tr>
<tr>
<td class="paramname">
          stream
         </td>
<td>
          Optional stream in which to perform copies
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column A copy of input
      </dd>
</dl>
</div>
</div>
<a id="a9fae65b5e23d13aec03edef7a8aeacb0">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a9fae65b5e23d13aec03edef7a8aeacb0">
      
     </a>
</span>
    copy()
    <span class="overload">
     [2/2]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::copy
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         t
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Creates a table of columns and deep copies the data from an input table.
     </p>
<dl class="section note">
<dt>
       Note
      </dt>
<dd>
       It is the caller's responsibility to free each column's device memory allocation in addition to deleting the
       <code>
        gdf_column
       </code>
       object for every column in the new table.
      </dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          t
         </td>
<td>
          The table to copy
         </td>
</tr>
<tr>
<td class="paramname">
          stream
         </td>
<td>
          Optional stream in which to perform allocations and copies
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       table A table that is an exact copy of
       <code>
        t
       </code>
</dd>
</dl>
</div>
</div>
<a id="ab67996c2986be62de33c6685e1702755">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ab67996c2986be62de33c6685e1702755">
      
     </a>
</span>
    copy_range()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        void cudf::copy_range
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         out_column
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         in_column
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type
       </td>
<td class="paramname">
<em>
         out_begin
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type
       </td>
<td class="paramname">
<em>
         out_end
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type
       </td>
<td class="paramname">
<em>
         in_begin
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Copies a range of elements from one column to another.
     </p>
<p>
      Copies N elements of
      <code>
       in_column
      </code>
      starting at
      <code>
       in_begin
      </code>
      to the N elements of
      <code>
       out_column
      </code>
      starting at
      <code>
       out_begin
      </code>
      , where N = (
      <code>
       out_end
      </code>
      -
      <code>
       out_begin
      </code>
      )
     </p>
<p>
      The datatypes of in_column and out_column must be the same.
     </p>
<p>
      If the input and output columns are the same and ranges overlap, the behavior is undefined.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [out]
         </td>
<td class="paramname">
          out_column
         </td>
<td>
          The preallocated column to copy into
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          in_column
         </td>
<td>
          The column to copy from
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          out_begin
         </td>
<td>
          The starting index of the output range
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          out_end
         </td>
<td>
          The index one past the end of the output range
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          in_begin
         </td>
<td>
          The starting index of the input range
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       void
      </dd>
</dl>
</div>
</div>
<a id="ad33dca48e0e06d182698cefb81b14be2">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ad33dca48e0e06d182698cefb81b14be2">
      
     </a>
</span>
    drop_duplicates()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         cudf::table
        </a>
        cudf::drop_duplicates
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structcudf_1_1table.html">
         cudf::table
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         input_table
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const
        <a class="el" href="structcudf_1_1table.html">
         cudf::table
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         key_columns
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const
        <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">
         duplicate_keep_option
        </a>
</td>
<td class="paramname">
<em>
         keep
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const bool
       </td>
<td class="paramname">
<em>
         nulls_are_equal
        </em>
        =
        <code>
         true
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Create a new table without duplicate rows.
     </p>
<p>
      Given an input table, each row is copied to output table if the corresponding row of key column table is unique, where the definition of unique depends on the value of
      <code>
       keep:
      </code>
</p>
<ul>
<li>
       KEEP_FIRST: only the first of a sequence of duplicate rows is copied
      </li>
<li>
       KEEP_LAST: only the last of a sequence of duplicate rows is copied
      </li>
<li>
       KEEP_NONE: no duplicate rows are copied
      </li>
</ul>
<p>
      The input table and key columns table should have same number of rows. Note that the memory for the output table columns is allocated by this function, so it must be freed by the caller when finished.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input_table
         </td>
<td>
          input table to copy only unique rows
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          key_columns
         </td>
<td>
          columns to consider to identify duplicate rows
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          keep
         </td>
<td>
          keep first entry, last entry, or no entries if duplicates found
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          nulls_are_equal
         </td>
<td>
          flag to denote nulls are equal if true, nulls are not equal if false
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       out_table with only unique rows
      </dd>
</dl>
</div>
</div>
<a id="a7ff623cffbfe93433009a4c18571ea49">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a7ff623cffbfe93433009a4c18571ea49">
      
     </a>
</span>
    drop_nulls()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::drop_nulls
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         keys
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_size_type
       </td>
<td class="paramname">
<em>
         keep_threshold
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Filters a table to remove null elements.
     </p>
<p>
      Filters the rows of the input table considering only specified columns for validity / null values.
     </p>
<p>
      Given an input table, row
      <code>
       i
      </code>
      from the input columns is copied to the output if the same row
      <code>
       i
      </code>
      of
      <code>
       keys
      </code>
      has at leaast
      <code>
       keep_threshold
      </code>
      non-null fields.
     </p>
<p>
      This operation is stable: the input order is preserved in the output.
     </p>
<p>
      Note that the memory for the columns of the output table is allocated by this function but must be freed by the caller when finished.
     </p>
<p>
      Any non-nullable column in the input is treated as all non-null.
     </p>
<dl class="section note">
<dt>
       Note
      </dt>
<dd>
       if
       <code>
        input.num_rows()
       </code>
       is zero, or
       <code>
        keys
       </code>
       is empty or has no nulls, there is no error, and an empty table is returned
      </dd>
</dl>
<dl class="exception">
<dt>
       Exceptions
      </dt>
<dd>
<table class="exception">
<tr>
<td class="paramname">
<a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
</td>
<td>
          if
          <code>
           keys
          </code>
          is non-empty and keys.num_rows() is less than input.num_rows()
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input
         </td>
<td>
          The input table to filter.
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          keys
         </td>
<td>
          The table of columns to check for nulls.
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          keep_threshold
         </td>
<td>
          The minimum number of non-null fields in a row required to keep the row.
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
<a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">
        cudf::table
       </a>
       Table containing all rows of the input table with at least
       <code>
        keep_threshold
       </code>
       non-null fields in
       <code>
        keys
       </code>
       .
      </dd>
</dl>
</div>
</div>
<a id="a3588fc0b833a8f2d7213651a05f48c80">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a3588fc0b833a8f2d7213651a05f48c80">
      
     </a>
</span>
    empty_like()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::empty_like
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         t
        </em>
</td>
<td>
        )
       </td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Creates a table of empty columns with the same types as the inputs.
     </p>
<p>
      Creates the
      <code>
       gdf_column
      </code>
      objects, but does not allocate any underlying device memory for the column's data or bitmask.
     </p>
<dl class="section note">
<dt>
       Note
      </dt>
<dd>
       It is the caller's responsibility to delete the
       <code>
        gdf_column
       </code>
       object for every column in the new table.
      </dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          t
         </td>
<td>
          The input table to emulate
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       table A table of empty columns of same type as input
      </dd>
</dl>
</div>
</div>
<a id="a0fdaf17cbac0f8976b27199b4aed31f5">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a0fdaf17cbac0f8976b27199b4aed31f5">
      
     </a>
</span>
    fill()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        void cudf::fill
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         column
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__scalar.html">
         gdf_scalar
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         value
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type
       </td>
<td class="paramname">
<em>
         begin
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type
       </td>
<td class="paramname">
<em>
         end
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Fills a range of elements in a column with a scalar value.
     </p>
<p>
      Fills N elements of
      <code>
       column
      </code>
      starting at
      <code>
       begin
      </code>
      with
      <code>
       value
      </code>
      , where N = (
      <code>
       end
      </code>
      -
      <code>
       begin
      </code>
      )
     </p>
<p>
      The datatypes of
      <code>
       column
      </code>
      and
      <code>
       value
      </code>
      must be the same.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [out]
         </td>
<td class="paramname">
          column
         </td>
<td>
          The preallocated column to fill into
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          value
         </td>
<td>
          The scalar value to fill
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          begin
         </td>
<td>
          The starting index of the fill range
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          end
         </td>
<td>
          The index one past the end of the fill range
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       void
      </dd>
</dl>
</div>
</div>
<a id="a68e93b1c814e07e108ad015d27ca2372">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a68e93b1c814e07e108ad015d27ca2372">
      
     </a>
</span>
    find_and_replace_all()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::find_and_replace_all
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         input_col
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         values_to_replace
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         replacement_values
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Replace elements from
      <code>
       input_col
      </code>
      according to the mapping
      <code>
       values_to_replace
      </code>
      to
      <code>
       replacement_values
      </code>
      , that is, replace all
      <code>
       values_to_replace[i]
      </code>
      present in
      <code>
       input_col
      </code>
      with
      <code>
       replacement_values[i]
      </code>
      .
     </p>
<p>
      Replace elements from
      <code>
       input_col
      </code>
      according to the mapping
      <code>
       old_values
      </code>
      to
      <code>
       new_values
      </code>
      , that is, replace all
      <code>
       old_values[i]
      </code>
      present in
      <code>
       col
      </code>
      with
      <code>
       new_values[i]
      </code>
      and return a new gdf_column
      <code>
       output
      </code>
      .
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          col
         </td>
<td>
          gdf_column with the data to be modified
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          values_to_replace
         </td>
<td>
          gdf_column with the old values to be replaced
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          replacement_values
         </td>
<td>
          gdf_column with the new values
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       output gdf_column with the modified data
      </dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          col
         </td>
<td>
          gdf_column with the data to be modified
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          values_to_replace
         </td>
<td>
          gdf_column with the old values to be replaced
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          replacement_values
         </td>
<td>
          gdf_column with the new replacement values
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       output gdf_column with the modified data
      </dd>
</dl>
</div>
</div>
<a id="a03f762fbe22ea8e824e426d3880b085a">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a03f762fbe22ea8e824e426d3880b085a">
      
     </a>
</span>
    gather()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        void cudf::gather
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const *
       </td>
<td class="paramname">
<em>
         source_table
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type const
       </td>
<td class="paramname">
<em>
         gather_map
        </em>
        [],
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        *
       </td>
<td class="paramname">
<em>
         destination_table
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Gathers the rows (including null values) of a set of source columns into a set of destination columns.
     </p>
<p>
      The two sets of columns must have equal numbers of columns.
     </p>
<p>
      Gathers the rows of the source columns into the destination columns according to a gather map such that row "i" in the destination columns will contain row "gather_map[i]" from the source columns.
     </p>
<p>
      The datatypes between coresponding columns in the source and destination columns must be the same.
     </p>
<p>
      The number of elements in the gather_map must equal the number of rows in the destination columns.
     </p>
<p>
      If any index in the gather_map is outside the range [0, num rows in source_columns), the result is undefined.
     </p>
<p>
      If the same index appears more than once in gather_map, the result is undefined.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          source_table
         </td>
<td>
          The input columns whose rows will be gathered
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          gather_map
         </td>
<td>
          An array of indices that maps the rows in the source columns to rows in the destination columns.
         </td>
</tr>
<tr>
<td class="paramdir">
          [out]
         </td>
<td class="paramname">
          destination_table
         </td>
<td>
          A preallocated set of columns with a number of rows equal in size to the number of elements in the gather_map that will contain the rearrangement of the source columns based on the mapping. Can be the same as
          <code>
           source_table
          </code>
          (in-place gather).
         </td>
</tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ad7b0f1bc518e47eaa2cfdd0ec88e3989">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ad7b0f1bc518e47eaa2cfdd0ec88e3989">
      
     </a>
</span>
    gdf_dtype_of()
   </h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
      template&lt;typename T &gt;
     </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">
           constexpr gdf_dtype cudf::gdf_dtype_of
          </td>
<td>
           (
          </td>
<td class="paramname">
</td>
<td>
           )
          </td>
<td>
</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels">
<span class="mlabel">
          inline
         </span>
<span class="mlabel">
          constexpr
         </span>
</span>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Maps a C++ type to it's corresponding gdf_dtype.
     </p>
<p>
      ------------------------------------------------------------------------* When explicitly passed a template argument of a given type, returns the appropriate
      <code>
       gdf_dtype
      </code>
      for the specified C++ type.
     </p>
<p>
      For example:
     </p>
<div class="fragment">
<div class="line">
<span class="keywordflow">
        return
       </span>
       gdf_dtype_of&lt;int32_t&gt;();
       <span class="comment">
        // Returns GDF_INT32
       </span>
</div>
<div class="line">
<span class="keywordflow">
        return
       </span>
       gdf_dtype_of&lt;cudf::category&gt;();
       <span class="comment">
        // Returns GDF_CATEGORY
       </span>
</div>
</div>
<!-- fragment -->
<h2>
<a class="anchor" id="autotoc_md266">
</a>
      @tparam T The type to map to a &lt;tt&gt;gdf_dtype&lt;/tt&gt;
     </h2>
</div>
</div>
<a id="ae62151c46119cd04dc146c9e4175375f">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ae62151c46119cd04dc146c9e4175375f">
      
     </a>
</span>
    genericAtomicOperation()
   </h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
      template&lt;typename T , typename BinaryOp &gt;
     </div>
<table class="memname">
<tr>
<td class="memname">
        __forceinline__ __device__ T cudf::genericAtomicOperation
       </td>
<td>
        (
       </td>
<td class="paramtype">
        T *
       </td>
<td class="paramname">
<em>
         address
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        T const &amp;
       </td>
<td class="paramname">
<em>
         update_value
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        BinaryOp
       </td>
<td class="paramname">
<em>
         op
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      compute atomic binary operation reads the
      <code>
       old
      </code>
      located at the
      <code>
       address
      </code>
      in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction.
     </p>
<p>
      ----------------------------------------------------------------------* The supported cudf types for
      <code>
       genericAtomicOperation
      </code>
      are: int8_t, int16_t, int32_t, int64_t, float, double, cudf::date32, cudf::date64, cudf::timestamp, cudf::category, cudf::nvstring_category, cudf::bool8
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          address
         </td>
<td>
          The address of old value in global or shared memory
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          val
         </td>
<td>
          The value to be computed
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          op
         </td>
<td>
          The binary operator used for compute
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md174">
</a>
      @returns The old value at &lt;tt&gt;address&lt;/tt&gt;
     </h2>
</div>
</div>
<a id="ada393acb565321d740f2b9950ffe2941">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ada393acb565321d740f2b9950ffe2941">
      
     </a>
</span>
    has_nulls()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        bool cudf::has_nulls
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         cudf::table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         table
        </em>
</td>
<td>
        )
       </td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Indicates if a table contains any null values.
     </p>
<p>
      ------------------------------------------------------------------------*
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          table
         </td>
<td>
          The table to check for null values
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       true If the table contains one or more null values
      </dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md247">
</a>
      @return false If the table contains zero null values
     </h2>
</div>
</div>
<a id="a0d288a83fd8de580d2274f825997cbf3">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a0d288a83fd8de580d2274f825997cbf3">
      
     </a>
</span>
    have_same_type()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">
           bool cudf::have_same_type
          </td>
<td>
           (
          </td>
<td class="paramtype">
           const
           <a class="el" href="structgdf__column__.html">
            gdf_column
           </a>
           &amp;
          </td>
<td class="paramname">
<em>
            validated_column_1
           </em>
           ,
          </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
           const
           <a class="el" href="structgdf__column__.html">
            gdf_column
           </a>
           &amp;
          </td>
<td class="paramname">
<em>
            validated_column_2
           </em>
           ,
          </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
           bool
          </td>
<td class="paramname">
<em>
            ignore_extra_type_info
           </em>
           =
           <code>
            false
           </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
           )
          </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels">
<span class="mlabel">
          noexcept
         </span>
</span>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Ensures two (valid!) columns have the same type.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          validated_column_1
         </td>
<td>
          A column which would pass
          <a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">
           validate()
          </a>
          .
         </td>
</tr>
<tr>
<td class="paramname">
          validated_column_2
         </td>
<td>
          A column which would pass
          <a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">
           validate()
          </a>
          .
         </td>
</tr>
<tr>
<td class="paramname">
          ignore_extra_type_info
         </td>
<td>
          For some column element types, a column carries some qualifying information which applies to all elements (and thus not repeated for each one). Generally, this information should not be ignored, so that for two columns to have the same type, they must also share it. However, for potential practical reasons (with this being a utility rather than an API function), we allow the extra information to be ignored by setting this parameter to
          <code>
           true
          </code>
          .
         </td>
</tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="acb570307357da1e8c28cee58d653b5cb">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#acb570307357da1e8c28cee58d653b5cb">
      
     </a>
</span>
    inferCompressionType()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        std::string cudf::inferCompressionType
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const std::string &amp;
       </td>
<td class="paramname">
<em>
         compression_arg
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_input_type
       </td>
<td class="paramname">
<em>
         source_type
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const std::string &amp;
       </td>
<td class="paramname">
<em>
         source
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const std::map&lt; std::string, std::string &gt; &amp;
       </td>
<td class="paramname">
<em>
         ext_to_compression
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Infer the compression type from the compression parameter and the input data.
     </p>
<p>
      Infer the compression type from the compression parameter and the input file extension.
     </p>
<p>
      ------------------------------------------------------------------------* Returns "none" if the input is not compressed. Throws if the input is not not valid.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          compression_arg
         </td>
<td>
          Input string that is potentially describing the compression type. Can also be "none" or "infer".
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          source_type
         </td>
<td>
          Enum describing the type of the data source
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          source
         </td>
<td>
          If source_type is FILE_PATH, contains the filepath. If source_type is HOST_BUFFER, contains the input JSON data.
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md78">
</a>
      @return string representing the compression type.
     </h2>
<p>
      ------------------------------------------------------------------------* Returns "none" if the input is not compressed. Throws if the input is not valid.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          compression_arg
         </td>
<td>
          Input string that is potentially describing the compression type. Can also be "none" or "infer".
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          source_type
         </td>
<td>
          Enum describing the type of the data source.
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          source
         </td>
<td>
          If source_type is FILE_PATH, contains the filepath. If source_type is HOST_BUFFER, contains the input data.
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          ext_to_compression
         </td>
<td>
          Map between file extensions and compression types.
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md79">
</a>
      @return string representing the compression type.
     </h2>
</div>
</div>
<a id="aac52a52a504d46887f1368ae13a96ffb">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#aac52a52a504d46887f1368ae13a96ffb">
      
     </a>
</span>
    is_sorted()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        bool cudf::is_sorted
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         cudf::table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         table
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        std::vector&lt; int8_t &gt; const &amp;
       </td>
<td class="paramname">
<em>
         descending
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         nulls_are_smallest
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Checks whether the rows of a
      <code>
       table
      </code>
      are sorted in a lexicographical order.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input
         </td>
<td>
          table whose rows need to be compared for ordering
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          descending
         </td>
<td>
          vector that specifies the expected ordering of each input column (0 is ascending order and 1 is descending) If this an empty vector, then it will be assumed that each column is in ascending order.
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          nulls_are_smallest
         </td>
<td>
          true indicates nulls are to be considered smaller than non-nulls ; false indicates opposite
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       true - if sorted , false - if not.
      </dd>
</dl>
</div>
</div>
<a id="ae90960c52c1f1fe3ab2257bad89b18fc">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ae90960c52c1f1fe3ab2257bad89b18fc">
      
     </a>
</span>
    lower_bound()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::lower_bound
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         t
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         values
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        std::vector&lt; bool &gt; const &amp;
       </td>
<td class="paramname">
<em>
         desc_flags
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         nulls_as_largest
        </em>
        =
        <code>
         true
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Find smallest indices in a sorted table where values should be inserted to maintain order.
     </p>
<p>
      ------------------------------------------------------------------------* For each row v in
      <code>
       values
      </code>
      , find the first index in
      <code>
       t
      </code>
      where inserting the row will maintain the sort order of
      <code>
       t
      </code>
</p>
<p>
      Example:
     </p>
<p>
      Single column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 1 }
     </p>
<p>
      Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 3 }
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          t
         </td>
<td>
          Table to search
         </td>
</tr>
<tr>
<td class="paramname">
          values
         </td>
<td>
          Find insert locations for these values
         </td>
</tr>
<tr>
<td class="paramname">
          desc_flags
         </td>
<td>
          Vector of column sort order. False indicates the corresponding column is sorted ascending
         </td>
</tr>
<tr>
<td class="paramname">
          nulls_as_largest
         </td>
<td>
          If true, nulls are considered larger than valid values, otherwise, nulls are considered smaller than valid values
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md263">
</a>
      @return gdf_column   Insertion points. Non-nullable column of type GDF_INT32 with same size as values.
     </h2>
</div>
</div>
<a id="a5315ca38e017e2ed42a400483bba3b56">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a5315ca38e017e2ed42a400483bba3b56">
      
     </a>
</span>
    make_iterator()
   </h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
      template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt;
     </div>
<table class="memname">
<tr>
<td class="memname">
        auto cudf::make_iterator
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const ElementType *
       </td>
<td class="paramname">
<em>
         data
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const bit_mask::bit_mask_t *
       </td>
<td class="paramname">
<em>
         valid
        </em>
        =
        <code>
         nullptr
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        ResultType
       </td>
<td class="paramname">
<em>
         identity
        </em>
        =
        <code>
         ResultType{0}
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        Iterator_Index const
       </td>
<td class="paramname">
<em>
         it
        </em>
        =
        <code>
         Iterator_Index(0)
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Constructs an iterator over the elements of a column.
     </p>
<p>
      ----------------------------------------------------------------------* If the column contains no null values (indicated by
      <code>
       has_nulls == false
      </code>
      ) then dereferencing an iterator
      <code>
       it
      </code>
      returned by this function as
      <code>
       *(it + n)
      </code>
      will return
      <code>
       ResultType{ static_cast&lt;ElementType*&gt;(data)[n] }
      </code>
      .
     </p>
<p>
      If the column contains null values (indicated by
      <code>
       has_nulls == true
      </code>
      ) then the result of de-referencing an iterator
      <code>
       it
      </code>
      returned by this function as
      <code>
       *(it+n)
      </code>
      will depend if element is valid or null. If the element is valid, it will return
      <code>
       ResultType{ static_cast&lt;ElementType*&gt;(data)[n] }
      </code>
      . If the element is null, it will return
      <code>
       ResultType{identity}
      </code>
      .
     </p>
<dl class="tparams">
<dt>
       Template Parameters
      </dt>
<dd>
<table class="tparams">
<tr>
<td class="paramname">
          has_nulls
         </td>
<td>
          Indicates if the column contains null values (
          <code>
           null_count &gt; 0
          </code>
          )
         </td>
</tr>
<tr>
<td class="paramname">
          ElementType
         </td>
<td>
          The cudf data type of input array
         </td>
</tr>
<tr>
<td class="paramname">
          ResultType
         </td>
<td>
          cudf data type of output and
          <code>
           identity
          </code>
          value which is used when null bitmaps flag is false.
         </td>
</tr>
<tr>
<td class="paramname">
          Iterator_Index
         </td>
<td>
          The base iterator which gives the index of array. The default is
          <code>
           thrust::counting_iterator
          </code>
</td>
</tr>
</table>
</dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          data
         </td>
<td>
          The pointer of column data array
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          valid
         </td>
<td>
          The pointer of null bitmask of column
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          identity
         </td>
<td>
          The identity value used when the mask value is false
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md123">
</a>
      @param[in] it       The index iterator, &lt;tt&gt;thrust::counting_iterator&lt;/tt&gt; by default
     </h2>
</div>
</div>
<a id="a20b11ec1348ab46ae20792ea4e2c0ca4">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a20b11ec1348ab46ae20792ea4e2c0ca4">
      
     </a>
</span>
    make_pair_iterator()
   </h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
      template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt;
     </div>
<table class="memname">
<tr>
<td class="memname">
        auto cudf::make_pair_iterator
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const ElementType *
       </td>
<td class="paramname">
<em>
         data
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const bit_mask::bit_mask_t *
       </td>
<td class="paramname">
<em>
         valid
        </em>
        =
        <code>
         nullptr
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        ResultType
       </td>
<td class="paramname">
<em>
         identity
        </em>
        =
        <code>
         ResultType{0}
        </code>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        Iterator_Index const
       </td>
<td class="paramname">
<em>
         it
        </em>
        =
        <code>
         Iterator_Index(0)
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Constructs an iterator over the elements of a column Input iterator which can be used for cub and thrust.
     </p>
<p>
      ----------------------------------------------------------------------* The iterator returns thrust::pair&lt;ResultType, bool&gt; This is useful for more complex logic that depends on the validity. e.g. group_by.count, mean_var, sort algorism.
     </p>
<dl class="tparams">
<dt>
       Template Parameters
      </dt>
<dd>
<table class="tparams">
<tr>
<td class="paramname">
          has_nulls
         </td>
<td>
          True if the data has valid bit mask, False else
         </td>
</tr>
<tr>
<td class="paramname">
          ElementType
         </td>
<td>
          The cudf data type of input array
         </td>
</tr>
<tr>
<td class="paramname">
          ResultType
         </td>
<td>
          cudf data type of output and
          <code>
           identity
          </code>
          value which is used when null bitmaps flag is false.
         </td>
</tr>
<tr>
<td class="paramname">
          Iterator_Index
         </td>
<td>
          The base iterator which gives the index of array. The default is
          <code>
           thrust::counting_iterator
          </code>
</td>
</tr>
</table>
</dd>
</dl>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          data
         </td>
<td>
          The pointer of column data array
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          valid
         </td>
<td>
          The pointer of null bitmask of column
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          identity
         </td>
<td>
          The identity value used when the mask value is false
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md126">
</a>
      @param[in] it       The index iterator, &lt;tt&gt;thrust::counting_iterator&lt;/tt&gt; by default
     </h2>
</div>
</div>
<a id="aba9b7e3e01a011595712fcaa6fb3a678">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#aba9b7e3e01a011595712fcaa6fb3a678">
      
     </a>
</span>
    merge()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::merge
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         left_table
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         right_table
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        std::vector&lt; gdf_size_type &gt; const &amp;
       </td>
<td class="paramname">
<em>
         key_cols
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        std::vector&lt; order_by_type &gt; const &amp;
       </td>
<td class="paramname">
<em>
         asc_desc
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         nulls_are_smallest
        </em>
        =
        <code>
         false
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Merge sorted tables.
     </p>
<p>
      Merges two sorted tables (including null values) into one sorted table containing data from both tables.
     </p>
<p>
      Example: input: table 1 =&gt; col 1 {0, 1, 2, 3} col 2 {4, 5, 6, 7} table 2 =&gt; col 1 {1, 2} col 2 {8, 9} output: table =&gt; col 1 {0, 1, 1, 2, 2, 3} col 2 {4, 5, 8, 6, 9, 7}
     </p>
<p>
      @Param[in] left_table A sorted table to be merged @Param[in] right_table A sorted table to be merged @Param[in] key_cols Indices of left_cols and right_cols to be used for comparison criteria @Param[in] asc_desc Sort order types of columns indexed by key_cols @Param[in] nulls_are_smallest Flag indicating is nulls are to be treated as the smallest value
     </p>
<p>
      @Returns A table containing sorted data from left_table and right_table
     </p>
</div>
</div>
<a id="a33e3a1ed670c88771cd7e594dda2f225">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a33e3a1ed670c88771cd7e594dda2f225">
      
     </a>
</span>
    nans_to_nulls()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        std::pair&lt; bit_mask::bit_mask_t *, gdf_size_type &gt; cudf::nans_to_nulls
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
</td>
<td>
        )
       </td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Given a column with floating point values, generate a bitmask where every NaN is indicated as the corresponding null bit.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          input
         </td>
<td>
          The input column to generate bitmask from
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       An
       <code>
        std::pair
       </code>
       of
       <code>
        bit_mask_t*
       </code>
       , the output bitmask, and its null count
      </dd>
</dl>
</div>
</div>
<a id="a30c6e502e3755eefe9a720cdf0f3ed5e">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a30c6e502e3755eefe9a720cdf0f3ed5e">
      
     </a>
</span>
    point_in_polygon()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::point_in_polygon
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         polygon_latitudes
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         polygon_longitudes
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         query_point_latitudes
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         query_point_longitudes
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Determine whether or not coordinates (query points) are completely inside a static polygon.
     </p>
<p>
      Note: The polygon must not have holes or intersect with itself, but it is not required to be convex.
     </p>
<p>
      The polygon is defined by a set of coordinates (latitudes and longitudes), where the first and last coordinates must have the same value (closed).
     </p>
<p>
      This function supports clockwise and counter-clockwise polygons.
     </p>
<p>
      If a query point is colinear with two contiguous polygon coordinates then this query point isn't inside.
     </p>
<p>
      polygon_latitudes and polygon_longitudes must have equal size.
     </p>
<p>
      point_latitudes and point_longitudes must have equal size.
     </p>
<p>
      All input params must have equal datatypes (for numeric operations).
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          polygon_latitudes
         </td>
<td>
          column with latitudes of a polygon
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          polygon_longitudes
         </td>
<td>
          column with longitudes of a polygon
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          query_point_latitudes
         </td>
<td>
          column with latitudes of query points
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          query_point_longitudes
         </td>
<td>
          column with longitudes of query points
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column of type GDF_BOOL8 indicating whether the i-th query point is inside (true) or not (false)
      </dd>
</dl>
</div>
</div>
<a id="a34eb2aea42d4ee97fb98cc4b38dabd7c">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a34eb2aea42d4ee97fb98cc4b38dabd7c">
      
     </a>
</span>
    reduce()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__scalar.html">
         gdf_scalar
        </a>
        cudf::reduce
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         col
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudf::reduction::operators
       </td>
<td class="paramname">
<em>
         op
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_dtype
       </td>
<td class="paramname">
<em>
         output_dtype
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_size_type
       </td>
<td class="paramname">
<em>
         ddof
        </em>
        =
        <code>
         1
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision
      <code>
       dtype
      </code>
      may prevent overflow. Only
      <code>
       min
      </code>
      and
      <code>
       max
      </code>
      ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output
      <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
       gdf_scalar
      </a>
      will contain
      <code>
       false
      </code>
      .
     </p>
<p>
      -----------------------------------------------------------------------*
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          col
         </td>
<td>
          Input column
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          op
         </td>
<td>
          The operator applied by the reduction
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          output_dtype
         </td>
<td>
          The computation and output precision.
          <code>
           dtype
          </code>
          must be a data type that is convertible from the input dtype. If the input column has arithmetic type or cudf::bool8 type, output_dtype can be any arithmetic type or cudf::bool8 type. For
          <code>
           mean
          </code>
          ,
          <code>
           var
          </code>
          and
          <code>
           std
          </code>
          ops, a floating point type must be specified. If the input column has non-arithmetic type (date32, timestamp, category...), the same type must be specified.
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          ddof
         </td>
<td>
          Delta Degrees of Freedom: the divisor used in calculation of
          <code>
           std
          </code>
          and
          <code>
           var
          </code>
          is
          <code>
           N - ddof
          </code>
          , where
          <code>
           N
          </code>
          is the population size.`
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
        gdf_scalar
       </a>
       the result value If the reduction fails, the member is_valid of the output
       <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
        gdf_scalar
       </a>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md261">
</a>
      will contain &lt;tt&gt;false&lt;/tt&gt;.
     </h2>
</div>
</div>
<a id="a85645250c7ada0b73a61e9a691931b36">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a85645250c7ada0b73a61e9a691931b36">
      
     </a>
</span>
    replace_nulls()
    <span class="overload">
     [1/2]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::replace_nulls
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         replacement
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Replaces all null values in a column with corresponding values of another column.
     </p>
<p>
      Returns a column
      <code>
       output
      </code>
      such that if
      <code>
       input[i]
      </code>
      is valid, its value will be copied to
      <code>
       output[i]
      </code>
      . Otherwise,
      <code>
       replacements[i]
      </code>
      will be copied to
      <code>
       output[i]
      </code>
      .
     </p>
<p>
      The
      <code>
       input
      </code>
      and
      <code>
       replacement
      </code>
      columns must be of same size and have the same data type.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input
         </td>
<td>
          A gdf_column containing null values
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          replacement
         </td>
<td>
          A gdf_column whose values will replace null values in input
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column Column with nulls replaced
      </dd>
</dl>
</div>
</div>
<a id="ad66cc66793473e7fc90ad3ed4cd1b450">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ad66cc66793473e7fc90ad3ed4cd1b450">
      
     </a>
</span>
    replace_nulls()
    <span class="overload">
     [2/2]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::replace_nulls
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__scalar.html">
         gdf_scalar
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         replacement
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Replaces all null values in a column with a scalar.
     </p>
<p>
      Returns a column
      <code>
       output
      </code>
      such that if
      <code>
       input[i]
      </code>
      is valid, its value will be copied to
      <code>
       output[i]
      </code>
      . Otherise,
      <code>
       replacement
      </code>
      will be coped to
      <code>
       output[i]
      </code>
      .
     </p>
<p>
<code>
       replacement
      </code>
      must have the same data type as
      <code>
       input
      </code>
      .
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input
         </td>
<td>
          A gdf_column containing null values
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          replacement
         </td>
<td>
          A
          <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
           gdf_scalar
          </a>
          whose value will replace null values in input
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column Column with nulls replaced
      </dd>
</dl>
</div>
</div>
<a id="aec006bc00092dd8ec47f2c7ca6fe01d4">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#aec006bc00092dd8ec47f2c7ca6fe01d4">
      
     </a>
</span>
    row_bitmask()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        rmm::device_vector&lt; bit_mask::bit_mask_t &gt; cudf::row_bitmask
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         cudf::table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         table
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Computes a bitmask indicating the presence of NULL values in rows of a table.
     </p>
<p>
      ------------------------------------------------------------------------* If a row
      <code>
       i
      </code>
      in
      <code>
       table
      </code>
      contains one or more NULL values, then bit
      <code>
       i
      </code>
      in the returned bitmask will be 0.
     </p>
<p>
      Otherwise, bit
      <code>
       i
      </code>
      will be 1.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          table
         </td>
<td>
          The table to compute the row bitmask of.
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       bit_mask::bit_mask_t* The bitmask indicating the presence of NULLs in
      </dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md6">
</a>
      a row
     </h2>
</div>
</div>
<a id="a65546aa9c42e87334fb5e1e3f274bc6b">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a65546aa9c42e87334fb5e1e3f274bc6b">
      
     </a>
</span>
    scan()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        void cudf::scan
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        *
       </td>
<td class="paramname">
<em>
         output
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_scan_op
       </td>
<td class="paramname">
<em>
         op
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         inclusive
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at
      <code>
       i
      </code>
      is null, then the output element at
      <code>
       i
      </code>
      will also be null.
     </p>
<p>
      -----------------------------------------------------------------------*
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input
         </td>
<td>
          The input column for the san
         </td>
</tr>
<tr>
<td class="paramdir">
          [out]
         </td>
<td class="paramname">
          output
         </td>
<td>
          The pre-allocated output column
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          op
         </td>
<td>
          The operation of the scan
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          inclusive
         </td>
<td>
          The flag for applying an inclusive scan if true,
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md262">
</a>
      an exclusive scan if false.
     </h2>
</div>
</div>
<a id="a8f032f6bab98db53bf7fa76259e09e92">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a8f032f6bab98db53bf7fa76259e09e92">
      
     </a>
</span>
    scatter()
    <span class="overload">
     [1/2]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::scatter
       </td>
<td>
        (
       </td>
<td class="paramtype">
        std::vector&lt;
        <a class="el" href="structgdf__scalar.html">
         gdf_scalar
        </a>
        &gt; const &amp;
       </td>
<td class="paramname">
<em>
         source
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type const
       </td>
<td class="paramname">
<em>
         scatter_map
        </em>
        [],
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_size_type
       </td>
<td class="paramname">
<em>
         num_scatter_rows
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         target
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Creates a new
      <code>
       table
      </code>
      as if scattering a set of
      <code>
<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">
        gdf_scalar
       </a>
</code>
      values into the rows of a
      <code>
       target
      </code>
      table in-place.
     </p>
<p>
<code>
       data
      </code>
      and
      <code>
       valid
      </code>
      of a specific row of the target_column is kept unchanged if the
      <code>
       scatter_map
      </code>
      does not map to that row.
     </p>
<p>
      The datatypes between coresponding columns in the source and target columns must be the same.
     </p>
<p>
      If any index in scatter_map is outside the range of [0, num rows in target_columns), the result is undefined.
     </p>
<p>
      If the same index appears more than once in scatter_map, the result is undefined.
     </p>
<p>
      If the scalar is null (is_valid == false) and the target column does not have a valid bitmask, the destination column will have a bitmask allocated.
     </p>
<p>
      @Param[in] source The row to be scattered @Param[in] scatter_map An array that maps to rows in the output columns. @Param[in] target The table to copy and then perform an in-place scatter into the copy.
     </p>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       [out] The result of the scatter
      </dd>
</dl>
</div>
</div>
<a id="a7574c3f8a91c7ae6c24304f3cc61e606">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a7574c3f8a91c7ae6c24304f3cc61e606">
      
     </a>
</span>
    scatter()
    <span class="overload">
     [2/2]
    </span>
</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        cudf::scatter
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         source
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type const
       </td>
<td class="paramname">
<em>
         scatter_map
        </em>
        [],
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         target
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Creates a new
      <code>
       table
      </code>
      as if an in-place scatter from a
      <code>
       source
      </code>
      table was performed on the
      <code>
       target
      </code>
      table.
     </p>
<p>
      It is the user's reponsibility to free the device memory allocated in the returned table
      <code>
       destination_table
      </code>
      .
     </p>
<p>
      The
      <code>
       source_table
      </code>
      and the
      <code>
       target_table
      </code>
      must have equal numbers of columns.
     </p>
<p>
      The datatypes between coresponding columns in the source and target columns must be the same.
     </p>
<p>
      The number of rows in the scatter_map must equal the number of rows in the source columns.
     </p>
<p>
      If any index in scatter_map is outside the range of [0, target.num_rows()), the result is undefined.
     </p>
<p>
      If the same index appears more than once in scatter_map, the result is undefined.
     </p>
<p>
      A column in the output will only be nullable if:
     </p>
<ul>
<li>
       Its corresponding column in
       <code>
        target
       </code>
       is nullable
      </li>
<li>
       Its corresponding column in
       <code>
        source
       </code>
       has
       <code>
        null_count &gt; 0
       </code>
</li>
</ul>
<p>
      @Param[in] source The columns whose rows will be scattered @Param[in] scatter_map An array that maps rows in the input columns to rows in the output columns. @Param[in] target The table to copy and then perform an in-place scatter into the copy.
     </p>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       [out] The result of the scatter
      </dd>
</dl>
</div>
</div>
<a id="a31f4a85729765c154b21d8102be5a9d5">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a31f4a85729765c154b21d8102be5a9d5">
      
     </a>
</span>
    slice()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        std::vector&lt;
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        * &gt; cudf::slice
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input_column
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type const *
       </td>
<td class="paramname">
<em>
         indices
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_size_type
       </td>
<td class="paramname">
<em>
         num_indices
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Slices a column (including null values) into a set of columns according to a set of indices.
     </p>
<p>
      The "slice" function divides part of the input column into multiple intervals of rows using the indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.
     </p>
<p>
      The pairs of indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.
     </p>
<p>
      Exceptional cases for the indices array are: When the values in the pair are equal, the function returns an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.
     </p>
<p>
      The output columns will be allocated by the function.
     </p>
<p>
      Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} indices: {1, 3, 5, 9, 2, 4, 8, 8} output: {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input_column
         </td>
<td>
          The input column whose rows will be sliced.
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          indices
         </td>
<td>
          An device array of indices that are used to take 'slices' of the input column.
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       A std::vector of gdf_column*, each of which may have a different number of rows. a different number of rows that are equal to the difference of two consecutive indices in the indices array.
      </dd>
</dl>
</div>
</div>
<a id="a69299f48fdcd25864a2f560e55d18ea9">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a69299f48fdcd25864a2f560e55d18ea9">
      
     </a>
</span>
    split()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        std::vector&lt;
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        * &gt; cudf::split
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input_column
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_index_type const *
       </td>
<td class="paramname">
<em>
         indices
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_size_type
       </td>
<td class="paramname">
<em>
         num_indices
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Splits a column (including null values) into a set of columns according to a set of indices.
     </p>
<p>
      The "split" function divides the input column into multiple intervals of rows using the indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.
     </p>
<p>
      The indices array ('indices') is require to be a monotonic non-decreasing set. The indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.
     </p>
<p>
      The split function will take a pair of indices from the indices array ('indices') in a consecutive manner. For the first pair, the function will take the value 0 and the first element of the indices array. For the last pair, the function will take the last element of the indices array and the size of the input column.
     </p>
<p>
      Exceptional cases for the indices array are: When the values in the pair are equal, the function return an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.
     </p>
<p>
      It is required that the output columns will be preallocated. The size of each of the columns can be of different value. The number of columns must be equal to the number of indices in the array plus one. The datatypes of the input column and the output columns must be the same.
     </p>
<p>
      Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} indices: {2, 5, 9} output: {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          input_column
         </td>
<td>
          The input column whose rows will be split.
         </td>
</tr>
<tr>
<td class="paramdir">
          [in]
         </td>
<td class="paramname">
          indices
         </td>
<td>
          An device array of indices that are used to divide the input column into multiple columns.
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       A std::vector of gdf_column*, each of which may have a different size a different number of rows.
      </dd>
</dl>
</div>
</div>
<a id="a45876c5d57c0d0afb921add28b3516e3">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a45876c5d57c0d0afb921add28b3516e3">
      
     </a>
</span>
    transform()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::transform
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const std::string &amp;
       </td>
<td class="paramname">
<em>
         unary_udf
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        gdf_dtype
       </td>
<td class="paramname">
<em>
         output_type
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         is_ptx
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Creates a new column by applying a unary function against every element of an input column.
     </p>
<p>
      Computes:
      <code>
       out[i] = F(in[i])
      </code>
</p>
<p>
      Support all GDF data types except for GDF_CATEGORY or GDF_STRING. For GDF_STRING_CATEGORY the UDF is only applied to the indices, after which the underlying category is cleared and remapped.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          input
         </td>
<td>
          The input column to transform
         </td>
</tr>
<tr>
<td class="paramname">
          unary_udf
         </td>
<td>
          The PTX/CUDA string of the unary function to apply
         </td>
</tr>
<tr>
<td class="paramname">
          outout_type
         </td>
<td>
          The output type that is compatible with the output type in the PTX code
         </td>
</tr>
<tr>
<td class="paramname">
          is_ptx
         </td>
<td>
          If true the UDF is treated as a piece of PTX code; if fasle the UDF is treated as a piece of CUDA code
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column The column resulting from applying the unary function to every element of the input
      </dd>
</dl>
</div>
</div>
<a id="ae4de4905066fbb3c645b05a1fc1d31d2">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ae4de4905066fbb3c645b05a1fc1d31d2">
      
     </a>
</span>
    unary_operation()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::unary_operation
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         input
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">
         unary_op
        </a>
</td>
<td class="paramname">
<em>
         op
        </em>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Performs unary op on all values in column.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          gdf_column
         </td>
<td>
          Input column
         </td>
</tr>
<tr>
<td class="paramname">
          unary_op
         </td>
<td>
          operation to perform
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       gdf_column Result of the operation
      </dd>
</dl>
</div>
</div>
<a id="ad4423a474f1918e65aed295f0600c488">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#ad4423a474f1918e65aed295f0600c488">
      
     </a>
</span>
    upper_bound()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
<a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        cudf::upper_bound
       </td>
<td>
        (
       </td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         t
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
<a class="el" href="structcudf_1_1table.html">
         table
        </a>
        const &amp;
       </td>
<td class="paramname">
<em>
         values
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        std::vector&lt; bool &gt; const &amp;
       </td>
<td class="paramname">
<em>
         desc_flags
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        bool
       </td>
<td class="paramname">
<em>
         nulls_as_largest
        </em>
        =
        <code>
         true
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Find largest indices in a sorted table where values should be inserted to maintain order.
     </p>
<p>
      ------------------------------------------------------------------------* For each row v in
      <code>
       values
      </code>
      , find the last index in
      <code>
       t
      </code>
      where inserting the row will maintain the sort order of
      <code>
       t
      </code>
</p>
<p>
      Example:
     </p>
<p>
      Single Column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 3 }
     </p>
<p>
      Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 5 * *
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          column
         </td>
<td>
          Table to search
         </td>
</tr>
<tr>
<td class="paramname">
          values
         </td>
<td>
          Find insert locations for these values
         </td>
</tr>
<tr>
<td class="paramname">
          desc_flags
         </td>
<td>
          Vector of column sort order. False indicates the corresponding column is sorted ascending
         </td>
</tr>
<tr>
<td class="paramname">
          nulls_as_largest
         </td>
<td>
          If true, nulls are considered larger than valid values, otherwise, nulls are considered smaller than valid values
         </td>
</tr>
</table>
</dd>
</dl>
<h2>
<a class="anchor" id="autotoc_md264">
</a>
      @return gdf_column   Insertion points. Non-nullable column of type GDF_INT32 with same size as values.
     </h2>
</div>
</div>
<a id="a084ff0262deda4407ff67857cf1660c0">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#a084ff0262deda4407ff67857cf1660c0">
      
     </a>
</span>
    valid_if()
   </h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
      template&lt;typename bit_container , typename predicate , typename size_type &gt;
     </div>
<table class="memname">
<tr>
<td class="memname">
        std::pair&lt;bit_container*, size_type&gt; cudf::valid_if
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const bit_container *
       </td>
<td class="paramname">
<em>
         source_mask
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        const predicate &amp;
       </td>
<td class="paramname">
<em>
         p
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        size_type
       </td>
<td class="paramname">
<em>
         num_bits
        </em>
        ,
       </td>
</tr>
<tr>
<td class="paramkey">
</td>
<td>
</td>
<td class="paramtype">
        cudaStream_t
       </td>
<td class="paramname">
<em>
         stream
        </em>
        =
        <code>
         0
        </code>
</td>
</tr>
<tr>
<td>
</td>
<td>
        )
       </td>
<td>
</td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Generate a bitmask where every bit is marked with valid if and only if predicate(bit) and source_mask(bit) are both true.
     </p>
<dl class="params">
<dt>
       Parameters
      </dt>
<dd>
<table class="params">
<tr>
<td class="paramname">
          source_mask
         </td>
<td>
          The source mask
         </td>
</tr>
<tr>
<td class="paramname">
          p
         </td>
<td>
          The predicate that has an operator() member function
         </td>
</tr>
<tr>
<td class="paramname">
          num_bits
         </td>
<td>
          Number of bits
         </td>
</tr>
<tr>
<td class="paramname">
          stream
         </td>
<td>
          An optional cudaStream_t object
         </td>
</tr>
</table>
</dd>
</dl>
<dl class="section return">
<dt>
       Returns
      </dt>
<dd>
       The generated bitmask as well as its null_count
      </dd>
</dl>
</div>
</div>
<a id="afa70e889e2b83eba15ed8e8e864dd3ff">
</a>
<h2 class="memtitle">
<span class="permalink">
<a href="#afa70e889e2b83eba15ed8e8e864dd3ff">
      
     </a>
</span>
    validate()
   </h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">
        void cudf::validate
       </td>
<td>
        (
       </td>
<td class="paramtype">
        const
        <a class="el" href="structgdf__column__.html">
         gdf_column
        </a>
        &amp;
       </td>
<td class="paramname">
<em>
         column
        </em>
</td>
<td>
        )
       </td>
<td>
</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>
      Ensures a gdf_column is valid, i.e. that its fields are consistent with each other, and logical in themselves, in representing a proper column.
     </p>
<p>
      Ensure the input is in a valid state representing a proper column. Specifically, ensures all fields have valid (rather than junk, uninitialized or declared-invalid values), and that they are consistent with each other.
     </p>
</div>
</div>
</div>
<!-- contents -->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
<small>
    Generated by
    <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a>
    1.8.16
   </small>
</address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
