<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcudf: Aggregation Factories</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer="" src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/nightly">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (22.10)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (23.02)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (22.12)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/legacy/namespacecudf.html">legacy (22.10)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> |
<a href="#nested-classes">Classes</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Aggregation Factories<div class="ingroups"><a class="el" href="group__column__apis.html">Column and Table</a> &raquo; <a class="el" href="group__column__aggregation.html">Aggregation</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:aggregation_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8hpp.html">aggregation.hpp</a></td></tr>
<tr class="memdesc:aggregation_8hpp"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representation for specifying desired aggregations from aggregation-based APIs, e.g., groupby, reductions, rolling, etc. <br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1aggregation.html">cudf::aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for specifying the desired aggregation in an <code>aggregation_request</code>.  <a href="classcudf_1_1aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1rolling__aggregation.html">cudf::rolling_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for rolling_window specific aggregation usage.  <a href="classcudf_1_1rolling__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1groupby__aggregation.html">cudf::groupby_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for groupby specific aggregation usage.  <a href="classcudf_1_1groupby__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1groupby__scan__aggregation.html">cudf::groupby_scan_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for groupby specific scan usage.  <a href="classcudf_1_1groupby__scan__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1reduce__aggregation.html">cudf::reduce_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for reduction usage.  <a href="classcudf_1_1reduce__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1scan__aggregation.html">cudf::scan_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for scan usage.  <a href="classcudf_1_1scan__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1segmented__reduce__aggregation.html">cudf::segmented_reduce_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived class intended for segmented reduction usage.  <a href="classcudf_1_1segmented__reduce__aggregation.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3701f066cd6ad8bad2a70fbfcef93071"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3701f066cd6ad8bad2a70fbfcef93071">cudf::rank_percentage</a> : int32_t { <a class="el" href="group__aggregation__factories.html#gga3701f066cd6ad8bad2a70fbfcef93071ab50339a10e1de285ac99d4c3990b8693">cudf::rank_percentage::NONE</a>, 
<a class="el" href="group__aggregation__factories.html#gga3701f066cd6ad8bad2a70fbfcef93071a90fa47f34fe7e9926f52e5eb144c798d">cudf::rank_percentage::ZERO_NORMALIZED</a>, 
<a class="el" href="group__aggregation__factories.html#gga3701f066cd6ad8bad2a70fbfcef93071a552e99f7f1cb96081c640e1756f137b6">cudf::rank_percentage::ONE_NORMALIZED</a>
 }</td></tr>
<tr class="memdesc:ga3701f066cd6ad8bad2a70fbfcef93071"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether returned rank should be percentage or not and mention the type of percentage normalization.  <a href="group__aggregation__factories.html#ga3701f066cd6ad8bad2a70fbfcef93071">More...</a><br></td></tr>
<tr class="separator:ga3701f066cd6ad8bad2a70fbfcef93071"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gad2e43a487f20c968b2474a5cb980527e"><td align="right" class="memItemLeft" valign="top"><a id="gad2e43a487f20c968b2474a5cb980527e"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gad2e43a487f20c968b2474a5cb980527e">cudf::udf_type</a> : bool { <b>CUDA</b>, 
<b>PTX</b>
 }</td></tr>
<tr class="memdesc:gad2e43a487f20c968b2474a5cb980527e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of code in the user defined function string. <br></td></tr>
<tr class="separator:gad2e43a487f20c968b2474a5cb980527e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga1dc83597d5b1e9cf752fc20fcdd77d40"><td align="right" class="memItemLeft" valign="top"><a id="ga1dc83597d5b1e9cf752fc20fcdd77d40"></a>enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga1dc83597d5b1e9cf752fc20fcdd77d40">cudf::correlation_type</a> : int32_t { <b>PEARSON</b>, 
<b>KENDALL</b>, 
<b>SPEARMAN</b>
 }</td></tr>
<tr class="memdesc:ga1dc83597d5b1e9cf752fc20fcdd77d40"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of correlation method. <br></td></tr>
<tr class="separator:ga1dc83597d5b1e9cf752fc20fcdd77d40"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaac155324eba255d69d0d9888008d407"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaaac155324eba255d69d0d9888008d407"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaaac155324eba255d69d0d9888008d407">cudf::make_sum_aggregation</a> ()</td></tr>
<tr class="separator:gaaac155324eba255d69d0d9888008d407"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gac2e8435b8778492ebc67779dfa294506"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gac2e8435b8778492ebc67779dfa294506"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gac2e8435b8778492ebc67779dfa294506">cudf::make_product_aggregation</a> ()</td></tr>
<tr class="separator:gac2e8435b8778492ebc67779dfa294506"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gabe538c8907ab48981e1e9602993db74c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gabe538c8907ab48981e1e9602993db74c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gabe538c8907ab48981e1e9602993db74c">cudf::make_min_aggregation</a> ()</td></tr>
<tr class="separator:gabe538c8907ab48981e1e9602993db74c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga5d2b6d7b0c5261dfc4e797f904bb5dd7"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga5d2b6d7b0c5261dfc4e797f904bb5dd7"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga5d2b6d7b0c5261dfc4e797f904bb5dd7">cudf::make_max_aggregation</a> ()</td></tr>
<tr class="separator:ga5d2b6d7b0c5261dfc4e797f904bb5dd7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga7e70bc7722fe1626802cf8441fbf9fa5"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga7e70bc7722fe1626802cf8441fbf9fa5"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga7e70bc7722fe1626802cf8441fbf9fa5">cudf::make_count_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=null_policy::EXCLUDE)</td></tr>
<tr class="memdesc:ga7e70bc7722fe1626802cf8441fbf9fa5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a COUNT aggregation.  <a href="group__aggregation__factories.html#ga7e70bc7722fe1626802cf8441fbf9fa5">More...</a><br></td></tr>
<tr class="separator:ga7e70bc7722fe1626802cf8441fbf9fa5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga55cfff4e36496925b0eaa46c0fae9fae"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga55cfff4e36496925b0eaa46c0fae9fae"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga55cfff4e36496925b0eaa46c0fae9fae">cudf::make_any_aggregation</a> ()</td></tr>
<tr class="separator:ga55cfff4e36496925b0eaa46c0fae9fae"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gab05157b9f041bfc674dd11c719d628a2"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gab05157b9f041bfc674dd11c719d628a2"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gab05157b9f041bfc674dd11c719d628a2">cudf::make_all_aggregation</a> ()</td></tr>
<tr class="separator:gab05157b9f041bfc674dd11c719d628a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gabd9ccbdfe6ffcb13401bf2357e711119"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gabd9ccbdfe6ffcb13401bf2357e711119"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gabd9ccbdfe6ffcb13401bf2357e711119">cudf::make_sum_of_squares_aggregation</a> ()</td></tr>
<tr class="separator:gabd9ccbdfe6ffcb13401bf2357e711119"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gafc5553cfc6e762346951a049d0664a8c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gafc5553cfc6e762346951a049d0664a8c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gafc5553cfc6e762346951a049d0664a8c">cudf::make_mean_aggregation</a> ()</td></tr>
<tr class="separator:gafc5553cfc6e762346951a049d0664a8c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gab600cbeb5a9fe9f6d2a7c6b5a769308a"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gab600cbeb5a9fe9f6d2a7c6b5a769308a"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gab600cbeb5a9fe9f6d2a7c6b5a769308a">cudf::make_m2_aggregation</a> ()</td></tr>
<tr class="memdesc:gab600cbeb5a9fe9f6d2a7c6b5a769308a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a M2 aggregation.  <a href="group__aggregation__factories.html#gab600cbeb5a9fe9f6d2a7c6b5a769308a">More...</a><br></td></tr>
<tr class="separator:gab600cbeb5a9fe9f6d2a7c6b5a769308a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga4f3a4efc7e531724b51b4ed2f11367d1"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga4f3a4efc7e531724b51b4ed2f11367d1"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga4f3a4efc7e531724b51b4ed2f11367d1">cudf::make_variance_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> ddof=1)</td></tr>
<tr class="memdesc:ga4f3a4efc7e531724b51b4ed2f11367d1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a VARIANCE aggregation.  <a href="group__aggregation__factories.html#ga4f3a4efc7e531724b51b4ed2f11367d1">More...</a><br></td></tr>
<tr class="separator:ga4f3a4efc7e531724b51b4ed2f11367d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3d0f22ac076169ad064357f3a62ee40c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga3d0f22ac076169ad064357f3a62ee40c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3d0f22ac076169ad064357f3a62ee40c">cudf::make_std_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> ddof=1)</td></tr>
<tr class="memdesc:ga3d0f22ac076169ad064357f3a62ee40c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a STD aggregation.  <a href="group__aggregation__factories.html#ga3d0f22ac076169ad064357f3a62ee40c">More...</a><br></td></tr>
<tr class="separator:ga3d0f22ac076169ad064357f3a62ee40c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga1a1568d94242ece1768494349930e367"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga1a1568d94242ece1768494349930e367"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga1a1568d94242ece1768494349930e367">cudf::make_median_aggregation</a> ()</td></tr>
<tr class="separator:ga1a1568d94242ece1768494349930e367"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf27931287bb704b589369ea856f24f97"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaf27931287bb704b589369ea856f24f97"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaf27931287bb704b589369ea856f24f97">cudf::make_quantile_aggregation</a> (std::vector&lt; double &gt; const &amp;<a class="el" href="group__column__quantiles.html#ga3da34be52bf8791d27731bd9c330be11">quantiles</a>, <a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a> interp=interpolation::LINEAR)</td></tr>
<tr class="memdesc:gaf27931287bb704b589369ea856f24f97"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a QUANTILE aggregation.  <a href="group__aggregation__factories.html#gaf27931287bb704b589369ea856f24f97">More...</a><br></td></tr>
<tr class="separator:gaf27931287bb704b589369ea856f24f97"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaa0a7a442ff8e3f87e5b7dea812bf0b2f"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaa0a7a442ff8e3f87e5b7dea812bf0b2f"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaa0a7a442ff8e3f87e5b7dea812bf0b2f">cudf::make_argmax_aggregation</a> ()</td></tr>
<tr class="memdesc:gaa0a7a442ff8e3f87e5b7dea812bf0b2f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create an ARGMAX aggregation.  <a href="group__aggregation__factories.html#gaa0a7a442ff8e3f87e5b7dea812bf0b2f">More...</a><br></td></tr>
<tr class="separator:gaa0a7a442ff8e3f87e5b7dea812bf0b2f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaefdbbe152b032284220429403a41875c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaefdbbe152b032284220429403a41875c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaefdbbe152b032284220429403a41875c">cudf::make_argmin_aggregation</a> ()</td></tr>
<tr class="memdesc:gaefdbbe152b032284220429403a41875c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create an ARGMIN aggregation.  <a href="group__aggregation__factories.html#gaefdbbe152b032284220429403a41875c">More...</a><br></td></tr>
<tr class="separator:gaefdbbe152b032284220429403a41875c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga575d3a90787d6af802850a1573025282"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga575d3a90787d6af802850a1573025282"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga575d3a90787d6af802850a1573025282">cudf::make_nunique_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=null_policy::EXCLUDE)</td></tr>
<tr class="memdesc:ga575d3a90787d6af802850a1573025282"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a NUNIQUE aggregation.  <a href="group__aggregation__factories.html#ga575d3a90787d6af802850a1573025282">More...</a><br></td></tr>
<tr class="separator:ga575d3a90787d6af802850a1573025282"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gacbd7e79be437c234f47ad8b623741703"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gacbd7e79be437c234f47ad8b623741703"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gacbd7e79be437c234f47ad8b623741703">cudf::make_nth_element_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> n, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a>)</td></tr>
<tr class="memdesc:gacbd7e79be437c234f47ad8b623741703"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a NTH_ELEMENT aggregation.  <a href="group__aggregation__factories.html#gacbd7e79be437c234f47ad8b623741703">More...</a><br></td></tr>
<tr class="separator:gacbd7e79be437c234f47ad8b623741703"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga6e3aaa3f354d1774753c5870ae40b92f"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga6e3aaa3f354d1774753c5870ae40b92f"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga6e3aaa3f354d1774753c5870ae40b92f">cudf::make_row_number_aggregation</a> ()</td></tr>
<tr class="separator:ga6e3aaa3f354d1774753c5870ae40b92f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga6904820ea39a8a48cd12d3bcef53f1c6"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga6904820ea39a8a48cd12d3bcef53f1c6"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga6904820ea39a8a48cd12d3bcef53f1c6">cudf::make_rank_aggregation</a> (<a class="el" href="group__column__sort.html#gac8975ec1273372f6ccae83a85bee71ce">rank_method</a> method, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> column_order=order::ASCENDING, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=null_policy::EXCLUDE, <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> null_precedence=null_order::AFTER, <a class="el" href="group__aggregation__factories.html#ga3701f066cd6ad8bad2a70fbfcef93071">rank_percentage</a> percentage=rank_percentage::NONE)</td></tr>
<tr class="memdesc:ga6904820ea39a8a48cd12d3bcef53f1c6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a RANK aggregation.  <a href="group__aggregation__factories.html#ga6904820ea39a8a48cd12d3bcef53f1c6">More...</a><br></td></tr>
<tr class="separator:ga6904820ea39a8a48cd12d3bcef53f1c6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga97444ec376ca739cd16256f2fcc90b07"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga97444ec376ca739cd16256f2fcc90b07"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga97444ec376ca739cd16256f2fcc90b07">cudf::make_collect_list_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a>)</td></tr>
<tr class="memdesc:ga97444ec376ca739cd16256f2fcc90b07"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a COLLECT_LIST aggregation.  <a href="group__aggregation__factories.html#ga97444ec376ca739cd16256f2fcc90b07">More...</a><br></td></tr>
<tr class="separator:ga97444ec376ca739cd16256f2fcc90b07"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gae02625d427793418d9d1a854c81265d2"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gae02625d427793418d9d1a854c81265d2"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gae02625d427793418d9d1a854c81265d2">cudf::make_collect_set_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a>, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=null_equality::EQUAL, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::UNEQUAL</a>)</td></tr>
<tr class="memdesc:gae02625d427793418d9d1a854c81265d2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a COLLECT_SET aggregation.  <a href="group__aggregation__factories.html#gae02625d427793418d9d1a854c81265d2">More...</a><br></td></tr>
<tr class="separator:gae02625d427793418d9d1a854c81265d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga27d18f71d8ac70c0fce6e1dbccdffdc4"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga27d18f71d8ac70c0fce6e1dbccdffdc4"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga27d18f71d8ac70c0fce6e1dbccdffdc4">cudf::make_lag_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> offset)</td></tr>
<tr class="memdesc:ga27d18f71d8ac70c0fce6e1dbccdffdc4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a LAG aggregation.  <a href="group__aggregation__factories.html#ga27d18f71d8ac70c0fce6e1dbccdffdc4">More...</a><br></td></tr>
<tr class="separator:ga27d18f71d8ac70c0fce6e1dbccdffdc4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga556fa221c5ba2a73e87b7a17ad23da2c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga556fa221c5ba2a73e87b7a17ad23da2c"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga556fa221c5ba2a73e87b7a17ad23da2c">cudf::make_lead_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> offset)</td></tr>
<tr class="memdesc:ga556fa221c5ba2a73e87b7a17ad23da2c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a LEAD aggregation.  <a href="group__aggregation__factories.html#ga556fa221c5ba2a73e87b7a17ad23da2c">More...</a><br></td></tr>
<tr class="separator:ga556fa221c5ba2a73e87b7a17ad23da2c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga6cdfbd69c4ab83b73f1930d1ec1060b9"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga6cdfbd69c4ab83b73f1930d1ec1060b9"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga6cdfbd69c4ab83b73f1930d1ec1060b9">cudf::make_udf_aggregation</a> (<a class="el" href="group__aggregation__factories.html#gad2e43a487f20c968b2474a5cb980527e">udf_type</a> type, std::string const &amp;user_defined_aggregator, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type)</td></tr>
<tr class="memdesc:ga6cdfbd69c4ab83b73f1930d1ec1060b9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create an aggregation base on UDF for PTX or CUDA.  <a href="group__aggregation__factories.html#ga6cdfbd69c4ab83b73f1930d1ec1060b9">More...</a><br></td></tr>
<tr class="separator:ga6cdfbd69c4ab83b73f1930d1ec1060b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaebc1969a9d59183e804545cfc342e763"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaebc1969a9d59183e804545cfc342e763"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaebc1969a9d59183e804545cfc342e763">cudf::make_merge_lists_aggregation</a> ()</td></tr>
<tr class="memdesc:gaebc1969a9d59183e804545cfc342e763"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MERGE_LISTS aggregation.  <a href="group__aggregation__factories.html#gaebc1969a9d59183e804545cfc342e763">More...</a><br></td></tr>
<tr class="separator:gaebc1969a9d59183e804545cfc342e763"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf05edd87facfdb3c0300892e9ba2a215"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaf05edd87facfdb3c0300892e9ba2a215"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaf05edd87facfdb3c0300892e9ba2a215">cudf::make_merge_sets_aggregation</a> (<a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=null_equality::EQUAL, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::UNEQUAL</a>)</td></tr>
<tr class="memdesc:gaf05edd87facfdb3c0300892e9ba2a215"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MERGE_SETS aggregation.  <a href="group__aggregation__factories.html#gaf05edd87facfdb3c0300892e9ba2a215">More...</a><br></td></tr>
<tr class="separator:gaf05edd87facfdb3c0300892e9ba2a215"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gabcf59a102adff7e4ef0144fa9949388d"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gabcf59a102adff7e4ef0144fa9949388d"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gabcf59a102adff7e4ef0144fa9949388d">cudf::make_merge_m2_aggregation</a> ()</td></tr>
<tr class="memdesc:gabcf59a102adff7e4ef0144fa9949388d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MERGE_M2 aggregation.  <a href="group__aggregation__factories.html#gabcf59a102adff7e4ef0144fa9949388d">More...</a><br></td></tr>
<tr class="separator:gabcf59a102adff7e4ef0144fa9949388d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3b4973811f9179de79d580cbdf3503eb"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga3b4973811f9179de79d580cbdf3503eb"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3b4973811f9179de79d580cbdf3503eb">cudf::make_covariance_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods=1, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> ddof=1)</td></tr>
<tr class="memdesc:ga3b4973811f9179de79d580cbdf3503eb"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a COVARIANCE aggregation.  <a href="group__aggregation__factories.html#ga3b4973811f9179de79d580cbdf3503eb">More...</a><br></td></tr>
<tr class="separator:ga3b4973811f9179de79d580cbdf3503eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3f4ba4b1b699a74da1dc905701ce48f7"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga3f4ba4b1b699a74da1dc905701ce48f7"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3f4ba4b1b699a74da1dc905701ce48f7">cudf::make_correlation_aggregation</a> (<a class="el" href="group__aggregation__factories.html#ga1dc83597d5b1e9cf752fc20fcdd77d40">correlation_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods=1)</td></tr>
<tr class="memdesc:ga3f4ba4b1b699a74da1dc905701ce48f7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a CORRELATION aggregation.  <a href="group__aggregation__factories.html#ga3f4ba4b1b699a74da1dc905701ce48f7">More...</a><br></td></tr>
<tr class="separator:ga3f4ba4b1b699a74da1dc905701ce48f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga2a176f20e52206e2a8197d100f8a4ca0"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:ga2a176f20e52206e2a8197d100f8a4ca0"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga2a176f20e52206e2a8197d100f8a4ca0">cudf::make_tdigest_aggregation</a> (int max_centroids=1000)</td></tr>
<tr class="memdesc:ga2a176f20e52206e2a8197d100f8a4ca0"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a TDIGEST aggregation.  <a href="group__aggregation__factories.html#ga2a176f20e52206e2a8197d100f8a4ca0">More...</a><br></td></tr>
<tr class="separator:ga2a176f20e52206e2a8197d100f8a4ca0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gafe7a1b8ffd3e7890fe6bad0d13752492"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:gafe7a1b8ffd3e7890fe6bad0d13752492"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; Base &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gafe7a1b8ffd3e7890fe6bad0d13752492">cudf::make_merge_tdigest_aggregation</a> (int max_centroids=1000)</td></tr>
<tr class="memdesc:gafe7a1b8ffd3e7890fe6bad0d13752492"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory to create a MERGE_TDIGEST aggregation.  <a href="group__aggregation__factories.html#gafe7a1b8ffd3e7890fe6bad0d13752492">More...</a><br></td></tr>
<tr class="separator:gafe7a1b8ffd3e7890fe6bad0d13752492"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3701f066cd6ad8bad2a70fbfcef93071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3701f066cd6ad8bad2a70fbfcef93071">◆&nbsp;</a></span>rank_percentage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="group__aggregation__factories.html#ga3701f066cd6ad8bad2a70fbfcef93071">cudf::rank_percentage</a> : int32_t</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Whether returned rank should be percentage or not and mention the type of percentage normalization. </p>
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3701f066cd6ad8bad2a70fbfcef93071ab50339a10e1de285ac99d4c3990b8693"></a>NONE&nbsp;</td><td class="fielddoc"><p>rank </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3701f066cd6ad8bad2a70fbfcef93071a90fa47f34fe7e9926f52e5eb144c798d"></a>ZERO_NORMALIZED&nbsp;</td><td class="fielddoc"><p>rank / count </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3701f066cd6ad8bad2a70fbfcef93071a552e99f7f1cb96081c640e1756f137b6"></a>ONE_NORMALIZED&nbsp;</td><td class="fielddoc"><p>(rank - 1) / (count - 1) </p>
</td></tr>
</tbody></table>

<p class="definition">Definition at line <a class="el" href="aggregation_8hpp_source.html#l00066">66</a> of file <a class="el" href="aggregation_8hpp_source.html">aggregation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab05157b9f041bfc674dd11c719d628a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab05157b9f041bfc674dd11c719d628a2">◆&nbsp;</a></span>make_all_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_all_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a ALL aggregation </p><dl class="section return"><dt>Returns</dt><dd>A ALL aggregation object </dd></dl>

</div>
</div>
<a id="ga55cfff4e36496925b0eaa46c0fae9fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55cfff4e36496925b0eaa46c0fae9fae">◆&nbsp;</a></span>make_any_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_any_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create an ANY aggregation </p><dl class="section return"><dt>Returns</dt><dd>A ANY aggregation object </dd></dl>

</div>
</div>
<a id="gaa0a7a442ff8e3f87e5b7dea812bf0b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a7a442ff8e3f87e5b7dea812bf0b2f">◆&nbsp;</a></span>make_argmax_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_argmax_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create an ARGMAX aggregation. </p>
<p>ARGMAX returns the index of the maximum element. </p><dl class="section return"><dt>Returns</dt><dd>A ARGMAX aggregation object </dd></dl>

</div>
</div>
<a id="gaefdbbe152b032284220429403a41875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefdbbe152b032284220429403a41875c">◆&nbsp;</a></span>make_argmin_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_argmin_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create an ARGMIN aggregation. </p>
<p><code>argmin</code> returns the index of the minimum element. </p><dl class="section return"><dt>Returns</dt><dd>A ARGMIN aggregation object </dd></dl>

</div>
</div>
<a id="ga97444ec376ca739cd16256f2fcc90b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97444ec376ca739cd16256f2fcc90b07">◆&nbsp;</a></span>make_collect_list_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_collect_list_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code><a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a COLLECT_LIST aggregation. </p>
<p><code>COLLECT_LIST</code> returns a list column of all included elements in the group/series.</p>
<p>If <code>null_handling</code> is set to <code>EXCLUDE</code>, null elements are dropped from each of the list rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">null_handling</td><td>Indicates whether to include/exclude nulls in list elements </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A COLLECT_LIST aggregation object </dd></dl>

</div>
</div>
<a id="gae02625d427793418d9d1a854c81265d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae02625d427793418d9d1a854c81265d2">◆&nbsp;</a></span>make_collect_set_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_collect_set_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code><a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&nbsp;</td>
          <td class="paramname"><em>nulls_equal</em> = <code>null_equality::EQUAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a>&nbsp;</td>
          <td class="paramname"><em>nans_equal</em> = <code><a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::UNEQUAL</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a COLLECT_SET aggregation. </p>
<p><code>COLLECT_SET</code> returns a lists column of all included elements in the group/series. Within each list, the duplicated entries are dropped out such that each entry appears only once.</p>
<p>If <code>null_handling</code> is set to <code>EXCLUDE</code>, null elements are dropped from each of the list rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">null_handling</td><td>Indicates whether to include/exclude nulls during collection </td></tr>
    <tr><td class="paramname">nulls_equal</td><td>Flag to specify whether null entries within each list should be considered equal. </td></tr>
    <tr><td class="paramname">nans_equal</td><td>Flag to specify whether NaN values in floating point column should be considered equal. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A COLLECT_SET aggregation object </dd></dl>

</div>
</div>
<a id="ga3f4ba4b1b699a74da1dc905701ce48f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f4ba4b1b699a74da1dc905701ce48f7">◆&nbsp;</a></span>make_correlation_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_correlation_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aggregation__factories.html#ga1dc83597d5b1e9cf752fc20fcdd77d40">correlation_type</a>&nbsp;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em> = <code>1</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a CORRELATION aggregation. </p>
<p>Compute correlation coefficient between two columns. The input columns are child columns of a non-nullable struct columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">type</td><td>correlation_type </td></tr>
    <tr><td class="paramname">min_periods</td><td>Minimum number of non-null observations required to produce a result </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CORRELATION aggregation object </dd></dl>

</div>
</div>
<a id="ga7e70bc7722fe1626802cf8441fbf9fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e70bc7722fe1626802cf8441fbf9fa5">◆&nbsp;</a></span>make_count_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_count_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code>null_policy::EXCLUDE</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a COUNT aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">null_handling</td><td>Indicates if null values will be counted </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A COUNT aggregation object </dd></dl>

</div>
</div>
<a id="ga3b4973811f9179de79d580cbdf3503eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4973811f9179de79d580cbdf3503eb">◆&nbsp;</a></span>make_covariance_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_covariance_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>min_periods</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a COVARIANCE aggregation. </p>
<p>Compute covariance between two columns. The input columns are child columns of a non-nullable struct columns. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">min_periods</td><td>Minimum number of non-null observations required to produce a result </td></tr>
    <tr><td class="paramname">ddof</td><td>Delta Degrees of Freedom. The divisor used in calculations is N - ddof, where N is the number of non-null observations. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A COVARIANCE aggregation object </dd></dl>

</div>
</div>
<a id="ga27d18f71d8ac70c0fce6e1dbccdffdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27d18f71d8ac70c0fce6e1dbccdffdc4">◆&nbsp;</a></span>make_lag_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_lag_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a LAG aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">offset</td><td>The number of rows to lag the input </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A LAG aggregation object </dd></dl>

</div>
</div>
<a id="ga556fa221c5ba2a73e87b7a17ad23da2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga556fa221c5ba2a73e87b7a17ad23da2c">◆&nbsp;</a></span>make_lead_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_lead_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a LEAD aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">offset</td><td>The number of rows to lead the input </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A LEAD aggregation object </dd></dl>

</div>
</div>
<a id="gab600cbeb5a9fe9f6d2a7c6b5a769308a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab600cbeb5a9fe9f6d2a7c6b5a769308a">◆&nbsp;</a></span>make_m2_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_m2_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a M2 aggregation. </p>
<p>A M2 aggregation is sum of squares of differences from the mean. That is: <code>M2 = SUM((x - MEAN) * (x - MEAN))</code>.</p>
<p>This aggregation produces the intermediate values that are used to compute variance and standard deviation across multiple discrete sets. See <code><a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</a>#Parallel_algorithm</code> for more detail. </p><dl class="section return"><dt>Returns</dt><dd>A M2 aggregation object </dd></dl>

</div>
</div>
<a id="ga5d2b6d7b0c5261dfc4e797f904bb5dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d2b6d7b0c5261dfc4e797f904bb5dd7">◆&nbsp;</a></span>make_max_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_max_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a MAX aggregation </p><dl class="section return"><dt>Returns</dt><dd>A MAX aggregation object </dd></dl>

</div>
</div>
<a id="gafc5553cfc6e762346951a049d0664a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc5553cfc6e762346951a049d0664a8c">◆&nbsp;</a></span>make_mean_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_mean_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a MEAN aggregation </p><dl class="section return"><dt>Returns</dt><dd>A MEAN aggregation object </dd></dl>

</div>
</div>
<a id="ga1a1568d94242ece1768494349930e367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a1568d94242ece1768494349930e367">◆&nbsp;</a></span>make_median_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_median_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a MEDIAN aggregation </p><dl class="section return"><dt>Returns</dt><dd>A MEDIAN aggregation object </dd></dl>

</div>
</div>
<a id="gaebc1969a9d59183e804545cfc342e763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebc1969a9d59183e804545cfc342e763">◆&nbsp;</a></span>make_merge_lists_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_merge_lists_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a MERGE_LISTS aggregation. </p>
<p>Given a lists column, this aggregation merges all the lists corresponding to the same key value into one list. It is designed specifically to merge the partial results of multiple (distributed) groupby <code>COLLECT_LIST</code> aggregations into a final <code>COLLECT_LIST</code> result. As such, it requires the input lists column to be non-nullable (the child column containing list entries is not subjected to this requirement).</p>
<dl class="section return"><dt>Returns</dt><dd>A MERGE_LISTS aggregation object </dd></dl>

</div>
</div>
<a id="gabcf59a102adff7e4ef0144fa9949388d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcf59a102adff7e4ef0144fa9949388d">◆&nbsp;</a></span>make_merge_m2_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_merge_m2_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a MERGE_M2 aggregation. </p>
<p>Merges the results of <code>M2</code> aggregations on independent sets into a new <code>M2</code> value equivalent to if a single <code>M2</code> aggregation was done across all of the sets at once. This aggregation is only valid on structs whose members are the result of the <code>COUNT_VALID</code>, <code>MEAN</code>, and <code>M2</code> aggregations on the same sets. The output of this aggregation is a struct containing the merged <code>COUNT_VALID</code>, <code>MEAN</code>, and <code>M2</code> aggregations.</p>
<p>The input <code>M2</code> aggregation values are expected to be all non-negative numbers, since they were output from <code>M2</code> aggregation.</p>
<dl class="section return"><dt>Returns</dt><dd>A MERGE_M2 aggregation object </dd></dl>

</div>
</div>
<a id="gaf05edd87facfdb3c0300892e9ba2a215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf05edd87facfdb3c0300892e9ba2a215">◆&nbsp;</a></span>make_merge_sets_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_merge_sets_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&nbsp;</td>
          <td class="paramname"><em>nulls_equal</em> = <code>null_equality::EQUAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a>&nbsp;</td>
          <td class="paramname"><em>nans_equal</em> = <code><a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::UNEQUAL</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a MERGE_SETS aggregation. </p>
<p>Given a lists column, this aggregation firstly merges all the lists corresponding to the same key value into one list, then it drops all the duplicate entries in each lists, producing a lists column containing non-repeated entries.</p>
<p>This aggregation is designed specifically to merge the partial results of multiple (distributed) groupby <code>COLLECT_LIST</code> or <code>COLLECT_SET</code> aggregations into a final <code>COLLECT_SET</code> result. As such, it requires the input lists column to be non-nullable (the child column containing list entries is not subjected to this requirement).</p>
<p>In practice, the input (partial results) to this aggregation should be generated by (distributed) <code>COLLECT_LIST</code> aggregations, not <code>COLLECT_SET</code>, to avoid unnecessarily removing duplicate entries for the partial results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">nulls_equal</td><td>Flag to specify whether nulls within each list should be considered equal during dropping duplicate list entries. </td></tr>
    <tr><td class="paramname">nans_equal</td><td>Flag to specify whether NaN values in floating point column should be considered equal during dropping duplicate list entries. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A MERGE_SETS aggregation object </dd></dl>

</div>
</div>
<a id="gafe7a1b8ffd3e7890fe6bad0d13752492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe7a1b8ffd3e7890fe6bad0d13752492">◆&nbsp;</a></span>make_merge_tdigest_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_merge_tdigest_aggregation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_centroids</em> = <code>1000</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a MERGE_TDIGEST aggregation. </p>
<p>Merges the results from a previous aggregation resulting from a <code>make_tdigest_aggregation</code> or <code>make_merge_tdigest_aggregation</code> to produce a new a tdigest (<a href="https://arxiv.org/pdf/1902.04023.pdf">https://arxiv.org/pdf/1902.04023.pdf</a>) column.</p>
<p>The tdigest column produced is of the following structure:</p>
<p>struct { // centroids for the digest list { struct { double // mean double // weight }, ... } // these are from the input stream, not the centroids. they are used // during the percentile_approx computation near the beginning or // end of the quantiles double // min double // max }</p>
<p>Each output row is a single tdigest. The length of the row is the "size" of the tdigest, each element of which represents a weighted centroid (mean, weight).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">max_centroids</td><td>Parameter controlling compression level and accuracy on subsequent queries on the output tdigest data. <code>max_centroids</code> places an upper bound on the size of the computed tdigests: A value of 1000 will result in a tdigest containing no more than 1000 centroids (32 bytes each). Higher result in more accurate tdigest information.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A MERGE_TDIGEST aggregation object </dd></dl>

</div>
</div>
<a id="gabe538c8907ab48981e1e9602993db74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe538c8907ab48981e1e9602993db74c">◆&nbsp;</a></span>make_min_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_min_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a MIN aggregation </p><dl class="section return"><dt>Returns</dt><dd>A MIN aggregation object </dd></dl>

</div>
</div>
<a id="gacbd7e79be437c234f47ad8b623741703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbd7e79be437c234f47ad8b623741703">◆&nbsp;</a></span>make_nth_element_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_nth_element_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code><a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::INCLUDE</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a NTH_ELEMENT aggregation. </p>
<p>NTH_ELEMENT returns the n'th element of the group/series.</p>
<p>If <code>n</code> is not within the range <code>[-group_size, group_size)</code>, the result of the respective group will be null. Negative indices <code>[-group_size, -1]</code> corresponds to <code>[0, group_size-1]</code> indices respectively where <code>group_size</code> is the size of each group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">n</td><td>index of nth element in each group </td></tr>
    <tr><td class="paramname">null_handling</td><td>Indicates to include/exclude nulls during indexing </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NTH_ELEMENT aggregation object </dd></dl>

</div>
</div>
<a id="ga575d3a90787d6af802850a1573025282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575d3a90787d6af802850a1573025282">◆&nbsp;</a></span>make_nunique_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_nunique_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code>null_policy::EXCLUDE</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a NUNIQUE aggregation. </p>
<p>NUNIQUE returns the number of unique elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">null_handling</td><td>Indicates if null values will be counted </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NUNIQUE aggregation object </dd></dl>

</div>
</div>
<a id="gac2e8435b8778492ebc67779dfa294506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e8435b8778492ebc67779dfa294506">◆&nbsp;</a></span>make_product_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_product_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a PRODUCT aggregation </p><dl class="section return"><dt>Returns</dt><dd>A PRODUCT aggregation object </dd></dl>

</div>
</div>
<a id="gaf27931287bb704b589369ea856f24f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27931287bb704b589369ea856f24f97">◆&nbsp;</a></span>make_quantile_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_quantile_aggregation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"><em>quantiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a>&nbsp;</td>
          <td class="paramname"><em>interp</em> = <code>interpolation::LINEAR</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a QUANTILE aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">quantiles</td><td>The desired quantiles </td></tr>
    <tr><td class="paramname">interp</td><td>The desired interpolation </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A QUANTILE aggregation object </dd></dl>

</div>
</div>
<a id="ga6904820ea39a8a48cd12d3bcef53f1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6904820ea39a8a48cd12d3bcef53f1c6">◆&nbsp;</a></span>make_rank_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_rank_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__column__sort.html#gac8975ec1273372f6ccae83a85bee71ce">rank_method</a>&nbsp;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a>&nbsp;</td>
          <td class="paramname"><em>column_order</em> = <code>order::ASCENDING</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&nbsp;</td>
          <td class="paramname"><em>null_handling</em> = <code>null_policy::EXCLUDE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a>&nbsp;</td>
          <td class="paramname"><em>null_precedence</em> = <code>null_order::AFTER</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aggregation__factories.html#ga3701f066cd6ad8bad2a70fbfcef93071">rank_percentage</a>&nbsp;</td>
          <td class="paramname"><em>percentage</em> = <code>rank_percentage::NONE</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a RANK aggregation. </p>
<p><code>RANK</code> returns a column of size_type or double "ranks" (see note 3 below for how the data type is determined) for a given rank method and column order. If nulls are excluded, the rank will be null for those rows, otherwise a non-nullable column is returned. Double precision column is returned only when percentage!=NONE and when rank method is average.</p>
<p>This aggregation only works with "scan" algorithms. The input column into the group or ungrouped scan is an orderby column that orders the rows that the aggregate function ranks. If rows are ordered by more than one column, the orderby input column should be a struct column containing the ordering columns.</p>
<p>Note:</p><ol type="1">
<li>This method could work faster with the rows that are presorted by the group keys and order_by columns. Though groupby object does not require order_by column to be sorted, groupby rank scan aggregation does require the order_by column to be sorted if the keys are sorted.</li>
<li><code>RANK</code> aggregations are not compatible with exclusive scans.</li>
<li>All rank methods except AVERAGE method and percentage!=NONE returns size_type column. For AVERAGE method and percentage!=NONE, the return type is double column.</li>
</ol>
<div class="fragment"><div class="line">Example: Consider a motor-racing statistics dataset, containing the following columns:</div>
<div class="line">  1. venue:  (STRING) Location of the race event</div>
<div class="line">  2. driver: (STRING) Name of the car driver (abbreviated to 3 characters)</div>
<div class="line">  3. time:   (INT32)  Time taken to complete the circuit</div>
<div class="line"> </div>
<div class="line">For the following presorted data:</div>
<div class="line"> </div>
<div class="line"> [ //      venue,           driver,           time</div>
<div class="line">   {   "silverstone",  "HAM" ("hamilton"),   15823},</div>
<div class="line">   {   "silverstone",  "LEC" ("leclerc"),    15827},</div>
<div class="line">   {   "silverstone",  "BOT" ("bottas"),     15834},  // &lt;-- Tied for 3rd place.</div>
<div class="line">   {   "silverstone",  "NOR" ("norris"),     15834},  // &lt;-- Tied for 3rd place.</div>
<div class="line">   {   "silverstone",  "RIC" ("ricciardo"),  15905},</div>
<div class="line">   {      "monza",     "RIC" ("ricciardo"),  12154},</div>
<div class="line">   {      "monza",     "NOR" ("norris"),     12156},  // &lt;-- Tied for 2nd place.</div>
<div class="line">   {      "monza",     "BOT" ("bottas"),     12156},  // &lt;-- Tied for 2nd place.</div>
<div class="line">   {      "monza",     "LEC" ("leclerc"),    12201},</div>
<div class="line">   {      "monza",     "PER" ("perez"),      12203}</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">A grouped rank aggregation scan with:</div>
<div class="line">  groupby column      : venue</div>
<div class="line">  input orderby column: time</div>
<div class="line">Produces the following rank column for each methods:</div>
<div class="line">first:   {   1,     2,     3,     4,     5,      1,     2,     3,     4,     5}</div>
<div class="line">average: {   1,     2,   3.5,   3.5,     5,      1,   2.5,   2.5,     4,     5}</div>
<div class="line">min:     {   1,     2,     3,     3,     5,      1,     2,     2,     4,     5}</div>
<div class="line">max:     {   1,     2,     4,     4,     5,      1,     3,     3,     4,     5}</div>
<div class="line">dense:   {   1,     2,     3,     3,     4,      1,     2,     2,     3,     4}</div>
<div class="line">This corresponds to the following grouping and `driver` rows:</div>
<div class="line">         { "HAM", "LEC", "BOT", "NOR", "RIC",  "RIC", "NOR", "BOT", "LEC", "PER" }</div>
<div class="line">           &lt;----------silverstone-----------&gt;|&lt;-------------monza--------------&gt;</div>
<div class="line"> </div>
<div class="line">min rank for each percentage types:</div>
<div class="line">NONE:             {   1,      2,     3,     3,     5,      1,     2,     2,     4,     5 }</div>
<div class="line">ZERO_NORMALIZED : { 0.16,  0.33,  0.50,  0.50,  0.83,   0.16,  0.33,  0.33,  0.66,  0.83 }</div>
<div class="line">ONE_NORMALIZED:   { 0.00,  0.25,  0.50,  0.50,  1.00,   0.00,  0.25,  0.25,  0.75,  1.00 }</div>
<div class="line">where count corresponds to the number of rows in the group. @see cudf::rank_percentage</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">method</td><td>The ranking method used for tie breaking (same values) </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired sort order for ranking </td></tr>
    <tr><td class="paramname">null_handling</td><td>flag to include nulls during ranking If nulls are not included, the corresponding rank will be null. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of null compared to other elements for column </td></tr>
    <tr><td class="paramname">percentage</td><td>enum to denote the type of conversion of ranks to percentage in range (0,1] </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A RANK aggregation object </dd></dl>

</div>
</div>
<a id="ga6e3aaa3f354d1774753c5870ae40b92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e3aaa3f354d1774753c5870ae40b92f">◆&nbsp;</a></span>make_row_number_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_row_number_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a ROW_NUMBER aggregation </p><dl class="section return"><dt>Returns</dt><dd>A ROW_NUMBER aggregation object </dd></dl>

</div>
</div>
<a id="ga3d0f22ac076169ad064357f3a62ee40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d0f22ac076169ad064357f3a62ee40c">◆&nbsp;</a></span>make_std_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_std_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a STD aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ddof</td><td>Delta degrees of freedom. The divisor used in calculation of <code>std</code> is <code>N - ddof</code>, where <code>N</code> is the population size.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input type is chrono or compound types. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A STD aggregation object </dd></dl>

</div>
</div>
<a id="gaaac155324eba255d69d0d9888008d407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaac155324eba255d69d0d9888008d407">◆&nbsp;</a></span>make_sum_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_sum_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a SUM aggregation </p><dl class="section return"><dt>Returns</dt><dd>A SUM aggregation object </dd></dl>

</div>
</div>
<a id="gabd9ccbdfe6ffcb13401bf2357e711119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd9ccbdfe6ffcb13401bf2357e711119">◆&nbsp;</a></span>make_sum_of_squares_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_sum_of_squares_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Factory to create a SUM_OF_SQUARES aggregation </p><dl class="section return"><dt>Returns</dt><dd>A SUM_OF_SQUARES aggregation object </dd></dl>

</div>
</div>
<a id="ga2a176f20e52206e2a8197d100f8a4ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a176f20e52206e2a8197d100f8a4ca0">◆&nbsp;</a></span>make_tdigest_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_tdigest_aggregation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_centroids</em> = <code>1000</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a TDIGEST aggregation. </p>
<p>Produces a tdigest (<a href="https://arxiv.org/pdf/1902.04023.pdf">https://arxiv.org/pdf/1902.04023.pdf</a>) column from input values. The input aggregation values are expected to be fixed-width numeric types.</p>
<p>The tdigest column produced is of the following structure:</p>
<p>struct { // centroids for the digest list { struct { double // mean double // weight }, ... } // these are from the input stream, not the centroids. they are used // during the percentile_approx computation near the beginning or // end of the quantiles double // min double // max }</p>
<p>Each output row is a single tdigest. The length of the row is the "size" of the tdigest, each element of which represents a weighted centroid (mean, weight).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">max_centroids</td><td>Parameter controlling compression level and accuracy on subsequent queries on the output tdigest data. <code>max_centroids</code> places an upper bound on the size of the computed tdigests: A value of 1000 will result in a tdigest containing no more than 1000 centroids (32 bytes each). Higher result in more accurate tdigest information.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A TDIGEST aggregation object </dd></dl>

</div>
</div>
<a id="ga6cdfbd69c4ab83b73f1930d1ec1060b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cdfbd69c4ab83b73f1930d1ec1060b9">◆&nbsp;</a></span>make_udf_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_udf_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aggregation__factories.html#gad2e43a487f20c968b2474a5cb980527e">udf_type</a>&nbsp;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"><em>user_defined_aggregator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&nbsp;</td>
          <td class="paramname"><em>output_type</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create an aggregation base on UDF for PTX or CUDA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>either udf_type::PTX or udf_type::CUDA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_defined_aggregator</td><td>A string containing the aggregator code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_type</td><td>expected output type</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An aggregation containing a user-defined aggregator string </dd></dl>

</div>
</div>
<a id="ga4f3a4efc7e531724b51b4ed2f11367d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f3a4efc7e531724b51b4ed2f11367d1">◆&nbsp;</a></span>make_variance_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base  = aggregation&gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;Base&gt; cudf::make_variance_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Factory to create a VARIANCE aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ddof</td><td>Delta degrees of freedom. The divisor used in calculation of <code>variance</code> is <code>N - ddof</code>, where <code>N</code> is the population size.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input type is chrono or compound types. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A VARIANCE aggregation object </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>