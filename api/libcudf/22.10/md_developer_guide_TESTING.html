<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcudf: Unit Testing in libcudf</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">stable (22.10)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (22.12)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">stable (22.10)</a><a class="rapids-selector__menu-item" href="/api/libcudf/legacy/namespacecudf.html">legacy (22.08)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Unit Testing in libcudf </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Unit tests in libcudf are written using <a href="https://github.com/google/googletest/blob/master/docs/primer.md">Google Test</a>.</p>
<p><b>Important:</b> Instead of including <code>gtest/gtest.h</code> directly, use <code>#include &lt;cudf_test/cudf_gtest.hpp&gt;</code>.</p>
<h1><a class="anchor" id="autotoc_md113"></a>
Best Practices: What Should We Test?</h1>
<p>In general we should test to make sure all code paths are covered. This is not always easy or possible. But generally this means we test all supported combinations of algorithms and data types, and all operators supported by algorithms that support multiple operators (e.g. reductions, groupby). Here are some other guidelines.</p>
<ul>
<li>In general empty input is not an error in libcudf. Typically empty input results in empty output. Tests should verify this.</li>
<li>Anything that involves manipulating bitmasks (especially hand-rolled kernels) should have tests that check varying number of rows, especially around boundaries like the warp size (32). So, test fewer than 32 rows, more than 32 rows, exactly 32 rows, and greater than 64 rows.</li>
<li>Most algorithms should have one or more tests exercising inputs with a large enough number of rows to require launching multiple thread blocks, especially when values are ultimately communicated between blocks (e.g. reductions). This is especially important for custom kernels but also applies to Thrust and CUB algorithm calls with lambdas / functors.</li>
<li>For anything involving strings or lists, test exhaustive combinations of empty strings/lists, null strings/lists and strings/lists with null elements.</li>
<li>Strings tests should include a mixture of non-ASCII UTF-8 characters like <code>&eacute;</code> in test data.</li>
<li>Test sliced columns as input (that is, columns that have a nonzero <code>offset</code>). This is an easy to forget case.</li>
<li>Tests that verify various forms of "degenerate" column inputs, for example: empty string columns that have no children (not many paths in cudf can generate these but it does happen); columns with zero size but that somehow have non-null data pointers; and struct columns with no children.</li>
<li>Decimal types are not included in the <code>NumericTypes</code> type list, but are included in <code>FixedWidthTypes</code>, so be careful that tests either include or exclude decimal types as appropriate.</li>
</ul>
<h1><a class="anchor" id="autotoc_md114"></a>
Directory and File Naming</h1>
<p>The naming of unit test directories and source files should be consistent with the feature being tested. For example, the tests for APIs in <code><a class="el" href="copying_8hpp.html" title="Column APIs for gather, scatter, split, slice, etc.">copying.hpp</a></code> should live in <code>cudf/cpp/tests/copying</code>. Each feature (or set of related features) should have its own test source file named <code>&lt;feature&gt;_tests.cu/cpp</code>. For example, <code>cudf/cpp/src/copying/scatter.cu</code> has tests in <code>cudf/cpp/tests/copying/scatter_tests.cu</code>.</p>
<p>In the interest of improving compile time, whenever possible, test source files should be <code>.cpp</code> files because <code>nvcc</code> is slower than <code>gcc</code> in compiling host code. Note that <code>thrust::device_vector</code> includes device code, and so must only be used in <code>.cu</code> files. <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.10/classrmm_1_1device__uvector.html">rmm::device_uvector</a></code>, <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.10/classrmm_1_1device__buffer.html">rmm::device_buffer</a></code> and the various <code>column_wrapper</code> types described later can be used in <code>.cpp</code> files, and are therefore preferred in test code over <code>thrust::device_vector</code>.</p>
<h1><a class="anchor" id="autotoc_md115"></a>
Base Fixture</h1>
<p>All libcudf unit tests should make use of a GTest <a href="https://github.com/google/googletest/blob/master/docs/primer.md#test-fixtures-using-the-same-data-configuration-for-multiple-tests-same-data-multiple-tests">"Test Fixture"</a>. Even if the fixture is empty, it should inherit from the base fixture <code>cudf::test::BaseFixture</code> found in <code>include/cudf_test/base_fixture.hpp</code>. This ensures that RMM is properly initialized and finalized. <code>cudf::test::BaseFixture</code> already inherits from <code>testing::Test</code> and therefore it is not necessary for your test fixtures to inherit from it.</p>
<p>Example: </p><pre class="fragment">class MyTestFixture : public cudf::test::BaseFixture {...};
</pre><h1><a class="anchor" id="autotoc_md116"></a>
Typed Tests</h1>
<p>In general, libcudf features must work across all of the supported types (there are exceptions e.g. not all binary operations are supported for all types). In order to automate the process of running the same tests across multiple types, we use GTest's <a href="https://github.com/google/googletest/blob/master/docs/advanced.md#typed-tests">Typed Tests</a>. Typed tests allow you to write a test once and run it across a list of types.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Fixture must be a template</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>TypedTestFixture : cudf::test::BaseFixture {...};</div>
<div class="line"><span class="keyword">using</span> TestTypes = cudf::test:Types&lt;int,float,double&gt;; <span class="comment">// Notice custom cudf type list type</span></div>
<div class="line">TYPED_TEST_SUITE(TypedTestFixture, TestTypes);</div>
<div class="line">TYPED_TEST(TypedTestFixture, FirstTest){</div>
<div class="line">    <span class="comment">// Access the current type using `TypeParam`</span></div>
<div class="line">    <span class="keyword">using</span> T = TypeParam;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To specify the list of types to use, instead of GTest's <code>testing::Types&lt;...&gt;</code>, libcudf provides <code>cudf::test::Types&lt;...&gt;</code> which is a custom, drop-in replacement for <code>testing::Types</code>. In this example, all tests using the <code>TypedTestFixture</code> fixture will run once for each type in the list defined in <code>TestTypes</code> (<code>int, float, double</code>).</p>
<h2><a class="anchor" id="autotoc_md117"></a>
Type Lists</h2>
<p>The list of types that are used in tests should be consistent across all tests. To ensure consistency, several sets of common type lists are provided in <code><a class="el" href="type__lists_8hpp.html" title="Provides centralized type lists for use in Google Test type-parameterized tests.">include/cudf_test/type_lists.hpp</a></code>. For example, <code>NumericTypes</code> is a type list of all numeric types, <code>FixedWidthTypes</code> is a list of all fixed-width element types, and <code>AllTypes</code> is a list of every element type that libcudf supports.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type__lists_8hpp.html">cudf_test/type_lists.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// All tests using TypeTestFixture will be invoked once for each numeric type</span></div>
<div class="line">TYPED_TEST_SUITE(TypedTestFixture, <a class="code" href="type__lists_8hpp.html#a82034b5f07ef26a398b8b60a31416798">cudf::test::NumericTypes</a>);</div>
</div><!-- fragment --><p>Whenever possible, use one of the type list provided in <code>include/utilities/test/type_lists.hpp</code> rather than creating new custom lists.</p>
<h3><a class="anchor" id="autotoc_md118"></a>
Advanced Type Lists</h3>
<p>Sometimes it is necessary to generate more advanced type lists than the simple lists of single types in the <code>TypeList</code> example above. libcudf provides a set of meta-programming utilities in <code><a class="el" href="type__list__utilities_8hpp.html" title="Utilities for creating type lists for typed tests in Google Test.">include/cudf_test/type_list_utilities.hpp</a></code> for generating and composing more advanced type lists.</p>
<p>For example, it may be useful to generate a <em>nested</em> type list where each element in the list is two types. In a nested type list, each element in the list is itself another list. In order to access the <code>N</code>th type within the nested list, use <code>GetType&lt;NestedList, N&gt;</code>.</p>
<p>Imagine testing all possible two-type combinations of <code>&lt;int,float&gt;</code>. This could be done manually:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>cudf::test;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TwoTypes&gt;</div>
<div class="line">TwoTypesFixture : BaseFixture{...};</div>
<div class="line"><span class="keyword">using</span> TwoTypesList = Types&lt; Types&lt;int, int&gt;, Types&lt;int, float&gt;,</div>
<div class="line">                            Types&lt;float, int&gt;, Types&lt;float, float&gt; &gt;;</div>
<div class="line">TYPED_TEST_SUITE(TwoTypesFixture, TwoTypesList);</div>
<div class="line">TYPED_TEST(TwoTypesFixture, FirstTest){</div>
<div class="line">    <span class="comment">// TypeParam is a list of two types, i.e., a "nested" type list</span></div>
<div class="line">    <span class="comment">// Use `cudf::test::GetType` to retrieve the individual types</span></div>
<div class="line">    <span class="keyword">using</span> FirstType = <a class="code" href="type__list__utilities_8hpp.html#afd069722f69b38e1c0aa0a0d0b9d291a">GetType&lt;TypeParam,0&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> SecondType = <a class="code" href="type__list__utilities_8hpp.html#afd069722f69b38e1c0aa0a0d0b9d291a">GetType&lt;TypeParam,1&gt;</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above example manually specifies all pairs composed of <code>int</code> and <code>float</code>. <code>CrossProduct</code> is a utility in <code><a class="el" href="type__list__utilities_8hpp.html" title="Utilities for creating type lists for typed tests in Google Test.">type_list_utilities.hpp</a></code> which materializes this cross product automatically.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> TwoTypesList = Types&lt; Types&lt;int, int&gt;, Types&lt;int, float&gt;,</div>
<div class="line">                            Types&lt;float, int&gt;, Types&lt;float, float&gt; &gt;;</div>
<div class="line"><span class="keyword">using</span> CrossProductTypeList = CrossProduct&lt; Types&lt;int, float&gt;, Types&lt;int, float&gt; &gt;;</div>
<div class="line"><span class="comment">// TwoTypesList and CrossProductTypeList are identical</span></div>
</div><!-- fragment --><p><code>CrossProduct</code> can be used with an arbitrary number of type lists to generate nested type lists of two or more types. <b>However</b>, overuse of <code>CrossProduct</code> can dramatically inflate compile time. The cross product of two type lists of size <code>n</code> and <code>m</code> will result in a new list with <code>n*m</code> nested type lists. This means <code>n*m</code> templates will be instantiated; <code>n</code> and <code>m</code> need not be large before compile time becomes unreasonable.</p>
<p>There are a number of other utilities in <code><a class="el" href="type__list__utilities_8hpp.html" title="Utilities for creating type lists for typed tests in Google Test.">type_list_utilities.hpp</a></code>. For more details, see the documentation in that file and their associated tests in <code>cudf/cpp/tests/utilities_tests/type_list_tests.cpp</code>.</p>
<h1><a class="anchor" id="autotoc_md119"></a>
Utilities</h1>
<p>libcudf provides a number of utilities in <code>include/cudf_test</code> to make common testing operations more convenient. Before creating your own test utilities, look to see if one already exists that does what you need. If not, consider adding a new utility to do what you need. However, make sure that the utility is generic enough to be useful for other tests and is not overly tailored to your specific testing need.</p>
<h2><a class="anchor" id="autotoc_md120"></a>
Column Wrappers</h2>
<p>In order to make generating input columns easier, libcudf provides the <code>*_column_wrapper</code> classes in <code><a class="el" href="column__wrapper_8hpp_source.html">include/cudf_test/column_wrapper.hpp</a></code>. These classes wrap a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> and provide constructors for initializing a <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> object usable with libcudf APIs. Any <code>*_column_wrapper</code> class is implicitly convertible to a <code>column_view</code> or <code>mutable_column_view</code> and therefore may be transparently passed to any API expecting a <code>column_view</code> or <code>mutable_column_view</code> argument.</p>
<h3><a class="anchor" id="autotoc_md121"></a>
fixed_width_column_wrapper</h3>
<p>The <code>fixed_width_column_wrapper</code> class should be used for constructing and initializing columns of any fixed-width element type, e.g., numeric types, timestamp types, Boolean, etc. <code>fixed_width_column_wrapper</code> provides constructors that accept an iterator range to generate each element in the column. For nullable columns, an additional iterator can be provided to indicate the validity of each element. There are also constructors that accept a <code>std::initializer_list&lt;T&gt;</code> for the column elements and optionally for the validity of each element.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Creates a non-nullable column of INT32 elements with 5 elements: {0, 1, 2, 3, 4}</span></div>
<div class="line"><span class="keyword">auto</span> elements = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i;});</div>
<div class="line">fixed_width_column_wrapper&lt;int32_t&gt; w(elements, elements + 5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable column of INT32 elements with 5 elements: {null, 1, null, 3, null}</span></div>
<div class="line"><span class="keyword">auto</span> elements = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i;});</div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i % 2;})</div>
<div class="line">fixed_width_column_wrapper&lt;int32_t&gt; w(elements, elements + 5, validity);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a non-nullable INT32 column with 4 elements: {1, 2, 3, 4}</span></div>
<div class="line">fixed_width_column_wrapper&lt;int32_t&gt; w{{1, 2, 3, 4}};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable INT32 column with 4 elements: {1, NULL, 3, NULL}</span></div>
<div class="line">fixed_width_column_wrapper&lt;int32_t&gt; w{ {1,2,3,4}, {1, 0, 1, 0}};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md122"></a>
fixed_point_column_wrapper</h3>
<p>The <code>fixed_point_column_wrapper</code> class should be used for constructing and initializing columns of any fixed-point element type (DECIMAL32 or DECIMAL64). <code>fixed_point_column_wrapper</code> provides constructors that accept an iterator range to generate each element in the column. For nullable columns, an additional iterator can be provided to indicate the validity of each element. Constructors also take the scale of the fixed-point values to create.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Creates a non-nullable column of 4 DECIMAL32 elements of scale 3: {1000, 2000, 3000, 4000}</span></div>
<div class="line"><span class="keyword">auto</span> elements = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){ <span class="keywordflow">return</span> i; });</div>
<div class="line">fixed_point_column_wrapper&lt;int32_t&gt; w(elements, elements + 4, 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable column of 5 DECIMAL32 elements of scale 2: {null, 100, null, 300, null}</span></div>
<div class="line"><span class="keyword">auto</span> elements = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){ <span class="keywordflow">return</span> i; });</div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){ <span class="keywordflow">return</span> i % 2; });</div>
<div class="line">fixed_point_column_wrapper&lt;int32_t&gt; w(elements, elements + 5, validity, 2);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md123"></a>
dictionary_column_wrapper</h3>
<p>The <code>dictionary_column_wrapper</code> class should be used to create dictionary columns. <code>dictionary_column_wrapper</code> provides constructors that accept an iterator range to generate each element in the column. For nullable columns, an additional iterator can be provided to indicate the validity of each element. There are also constructors that accept a <code>std::initializer_list&lt;T&gt;</code> for the column elements and optionally for the validity of each element.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Creates a non-nullable dictionary column of INT32 elements with 5 elements</span></div>
<div class="line"><span class="comment">// keys = {0, 2, 6}, indices = {0, 1, 1, 2, 2}</span></div>
<div class="line">std::vector&lt;int32_t&gt; elements{0, 2, 2, 6, 6};</div>
<div class="line">dictionary_column_wrapper&lt;int32_t&gt; w(element.begin(), elements.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable dictionary column with 5 elements and a validity iterator.</span></div>
<div class="line">std::vector&lt;int32_t&gt; elements{0, 2, 0, 6, 0};</div>
<div class="line"><span class="comment">// Validity iterator here sets even rows to null.</span></div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i % 2;})</div>
<div class="line"><span class="comment">// keys = {2, 6}, indices = {NULL, 0, NULL, 1, NULL}</span></div>
<div class="line">dictionary_column_wrapper&lt;int32_t&gt; w(elements, elements + 5, validity);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a non-nullable dictionary column with 4 elements.</span></div>
<div class="line"><span class="comment">// keys = {1, 2, 3}, indices = {0, 1, 2, 0}</span></div>
<div class="line">dictionary_column_wrapper&lt;int32_t&gt; w{{1, 2, 3, 1}};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable dictionary column with 4 elements and validity initializer.</span></div>
<div class="line"><span class="comment">// keys = {1, 3}, indices = {0, NULL, 1, NULL}</span></div>
<div class="line">dictionary_column_wrapper&lt;int32_t&gt; w{ {1, 0, 3, 0}, {1, 0, 1, 0}};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable column of dictionary elements with 5 elements and validity initializer.</span></div>
<div class="line">std::vector&lt;int32_t&gt; elements{0, 2, 2, 6, 6};</div>
<div class="line"><span class="comment">// keys = {2, 6}, indices = {NULL, 0, NULL, 1, NULL}</span></div>
<div class="line">dictionary_width_column_wrapper&lt;int32_t&gt; w(elements, elements + 5, {0, 1, 0, 1, 0});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a non-nullable dictionary column with 7 string elements</span></div>
<div class="line">std::vector&lt;std::string&gt; strings{<span class="stringliteral">""</span>, <span class="stringliteral">"aaa"</span>, <span class="stringliteral">"bbb"</span>, <span class="stringliteral">"aaa"</span>, <span class="stringliteral">"bbb"</span>, <span class="stringliteral">"ccc"</span>, <span class="stringliteral">"bbb"</span>};</div>
<div class="line"><span class="comment">// keys = {"","aaa","bbb","ccc"}, indices = {0, 1, 2, 1, 2, 3, 2}</span></div>
<div class="line">dictionary_column_wrapper&lt;std::string&gt; d(strings.begin(), strings.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable dictionary column with 7 string elements and a validity iterator.</span></div>
<div class="line"><span class="comment">// Validity iterator here sets even rows to null.</span></div>
<div class="line"><span class="comment">// keys = {"a", "bb"}, indices = {NULL, 1, NULL, 1, NULL, 0, NULL}</span></div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i % 2;});</div>
<div class="line">dictionary_column_wrapper&lt;std::string&gt; d({<span class="stringliteral">""</span>, <span class="stringliteral">"bb"</span>, <span class="stringliteral">""</span>, <span class="stringliteral">"bb"</span>, <span class="stringliteral">""</span>, <span class="stringliteral">"a"</span>, <span class="stringliteral">""</span>}, validity);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md124"></a>
strings_column_wrapper</h3>
<p>The <code>strings_column_wrapper</code> class should be used to create columns of strings. It provides constructors that accept an iterator range to generate each string in the column. For nullable columns, an additional iterator can be provided to indicate the validity of each string. There are also constructors that accept a <code>std::initializer_list&lt;std::string&gt;</code> for the column's strings and optionally for the validity of each element.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Creates a non-nullable STRING column with 7 string elements:</span></div>
<div class="line"><span class="comment">// {"", "this", "is", "a", "column", "of", "strings"}</span></div>
<div class="line">std::vector&lt;std::string&gt; strings{<span class="stringliteral">""</span>, <span class="stringliteral">"this"</span>, <span class="stringliteral">"is"</span>, <span class="stringliteral">"a"</span>, <span class="stringliteral">"column"</span>, <span class="stringliteral">"of"</span>, <span class="stringliteral">"strings"</span>};</div>
<div class="line">strings_column_wrapper s(strings.begin(), strings.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable STRING column with 7 string elements:</span></div>
<div class="line"><span class="comment">// {NULL, "this", NULL, "a", NULL, "of", NULL}</span></div>
<div class="line">std::vector&lt;std::string&gt; strings{<span class="stringliteral">""</span>, <span class="stringliteral">"this"</span>, <span class="stringliteral">"is"</span>, <span class="stringliteral">"a"</span>, <span class="stringliteral">"column"</span>, <span class="stringliteral">"of"</span>, <span class="stringliteral">"strings"</span>};</div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i % 2;});</div>
<div class="line">strings_column_wrapper s(strings.begin(), strings.end(), validity);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a non-nullable STRING column with 7 string elements:</span></div>
<div class="line"><span class="comment">// {"", "this", "is", "a", "column", "of", "strings"}</span></div>
<div class="line">strings_column_wrapper s({<span class="stringliteral">""</span>, <span class="stringliteral">"this"</span>, <span class="stringliteral">"is"</span>, <span class="stringliteral">"a"</span>, <span class="stringliteral">"column"</span>, <span class="stringliteral">"of"</span>, <span class="stringliteral">"strings"</span>});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a nullable STRING column with 7 string elements:</span></div>
<div class="line"><span class="comment">// {NULL, "this", NULL, "a", NULL, "of", NULL}</span></div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i % 2;});</div>
<div class="line">strings_column_wrapper s({<span class="stringliteral">""</span>, <span class="stringliteral">"this"</span>, <span class="stringliteral">"is"</span>, <span class="stringliteral">"a"</span>, <span class="stringliteral">"column"</span>, <span class="stringliteral">"of"</span>, <span class="stringliteral">"strings"</span>}, validity);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md125"></a>
lists_column_wrapper</h3>
<p>The <code>lists_column_wrapper</code> class should be used to create columns of lists. It provides constructors that accept an iterator range to generate each list in the column. For nullable columns, an additional iterator can be provided to indicate the validity of each list. There are also constructors that accept a <code>std::initializer_list&lt;T&gt;</code> for the column's lists and optionally for the validity of each element. A number of other constructors are available.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Creates an empty LIST column</span></div>
<div class="line"><span class="comment">// []</span></div>
<div class="line">lists_column_wrapper l{};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a LIST column with 1 list composed of 2 total integers</span></div>
<div class="line"><span class="comment">// [{0, 1}]</span></div>
<div class="line">lists_column_wrapper l{0, 1};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a LIST column with 3 lists</span></div>
<div class="line"><span class="comment">// [{0, 1}, {2, 3}, {4, 5}]</span></div>
<div class="line">lists_column_wrapper l{ {0, 1}, {2, 3}, {4, 5} };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a LIST of LIST columns with 2 lists on the top level and</span></div>
<div class="line"><span class="comment">// 4 below</span></div>
<div class="line"><span class="comment">// [ {{0, 1}, {2, 3}}, {{4, 5}, {6, 7}} ]</span></div>
<div class="line">lists_column_wrapper l{ {{0, 1}, {2, 3}}, {{4, 5}, {6, 7}} };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a LIST column with 1 list composed of 5 total integers</span></div>
<div class="line"><span class="comment">// [{0, 1, 2, 3, 4}]</span></div>
<div class="line"><span class="keyword">auto</span> elements = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i*2;});</div>
<div class="line">lists_column_wrapper l(elements, elements+5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a LIST column with 1 lists composed of 2 total integers</span></div>
<div class="line"><span class="comment">// [{0, NULL}]</span></div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i % 2;});</div>
<div class="line">lists_column_wrapper l{{0, 1}, validity};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a LIST column with 1 lists composed of 5 total integers</span></div>
<div class="line"><span class="comment">// [{0, NULL, 2, NULL, 4}]</span></div>
<div class="line"><span class="keyword">auto</span> elements = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i*2;});</div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i % 2;});</div>
<div class="line">lists_column_wrapper l(elements, elements+5, validity);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a LIST column with 1 list composed of 2 total strings</span></div>
<div class="line"><span class="comment">// [{"abc", "def"}]</span></div>
<div class="line">lists_column_wrapper l{<span class="stringliteral">"abc"</span>, <span class="stringliteral">"def"</span>};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a LIST of LIST columns with 2 lists on the top level and 4 below</span></div>
<div class="line"><span class="comment">// [ {{0, 1}, NULL}, {{4, 5}, NULL} ]</span></div>
<div class="line"><span class="keyword">auto</span> validity = make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){<span class="keywordflow">return</span> i % 2;});</div>
<div class="line">lists_column_wrapper l{ {{{0, 1}, {2, 3}}, validity}, {{{4, 5}, {6, 7}}, validity} };</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md126"></a>
structs_column_wrapper</h3>
<p>The <code>structs_column_wrapper</code> class should be used to create columns of structs. It provides constructors that accept a vector or initializer list of pre-constructed columns or column wrappers for child columns. For nullable columns, an additional iterator can be provided to indicate the validity of each struct.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">// The following constructs a column for struct&lt; int, string &gt;.</span></div>
<div class="line"><span class="keyword">auto</span> child_int_col = fixed_width_column_wrapper&lt;int32_t&gt;{ 1, 2, 3, 4, 5 }.release();</div>
<div class="line"><span class="keyword">auto</span> child_string_col = string_column_wrapper {<span class="stringliteral">"All"</span>, <span class="stringliteral">"the"</span>, <span class="stringliteral">"leaves"</span>, <span class="stringliteral">"are"</span>, <span class="stringliteral">"brown"</span>}.release();</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::unique_ptr&lt;column&gt;&gt; child_columns;</div>
<div class="line">child_columns.push_back(std::move(child_int_col));</div>
<div class="line">child_columns.push_back(std::move(child_string_col));</div>
<div class="line"> </div>
<div class="line">struct_column_wrapper struct_column_wrapper{</div>
<div class="line">  child_cols,</div>
<div class="line">  {1,0,1,0,1} <span class="comment">// Validity</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> struct_col {struct_column_wrapper.release()};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The following constructs a column for struct&lt; int, string &gt;.</span></div>
<div class="line">fixed_width_column_wrapper&lt;int32_t&gt; child_int_col_wrapper{ 1, 2, 3, 4, 5 };</div>
<div class="line">string_column_wrapper child_string_col_wrapper {<span class="stringliteral">"All"</span>, <span class="stringliteral">"the"</span>, <span class="stringliteral">"leaves"</span>, <span class="stringliteral">"are"</span>, <span class="stringliteral">"brown"</span>};</div>
<div class="line"> </div>
<div class="line">struct_column_wrapper struct_column_wrapper{</div>
<div class="line">  {child_int_col_wrapper, child_string_col_wrapper}</div>
<div class="line">  {1,0,1,0,1} <span class="comment">// Validity</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> struct_col {struct_column_wrapper.release()};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The following constructs a column for struct&lt; int, string &gt;.</span></div>
<div class="line">fixed_width_column_wrapper&lt;int32_t&gt; child_int_col_wrapper{ 1, 2, 3, 4, 5 };</div>
<div class="line">string_column_wrapper child_string_col_wrapper {<span class="stringliteral">"All"</span>, <span class="stringliteral">"the"</span>, <span class="stringliteral">"leaves"</span>, <span class="stringliteral">"are"</span>, <span class="stringliteral">"brown"</span>};</div>
<div class="line"> </div>
<div class="line">struct_column_wrapper struct_column_wrapper{</div>
<div class="line">  {child_int_col_wrapper, child_string_col_wrapper}</div>
<div class="line">  cudf::detail::make_counting_transform_iterator(0, [](<span class="keyword">auto</span> i){ <span class="keywordflow">return</span> i % 2; }) <span class="comment">// Validity</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> struct_col {struct_column_wrapper.release()};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md127"></a>
Column Comparison Utilities</h2>
<p>A common operation in testing is verifying that two columns are equal, or equivalent, or that they have the same metadata.</p>
<h3><a class="anchor" id="autotoc_md128"></a>
CUDF_TEST_EXPECT_COLUMN_PROPERTIES_EQUAL</h3>
<p>Verifies that two columns have the same type, size, and nullability. For nested types, recursively verifies the equality of type, size and nullability of all nested children.</p>
<h3><a class="anchor" id="autotoc_md129"></a>
CUDF_TEST_EXPECT_COLUMN_PROPERTIES_EQUIVALENT</h3>
<p>Verifies that two columns have equivalent type and equal size, ignoring nullability. For nested types, recursively verifies the equivalence of type, and equality of size of all nested children, ignoring nullability.</p>
<p>Note "equivalent type". Most types are equivalent if and only they are equal. <code>fixed_point</code> types are one exception. They are equivalent if the representation type is equal, even if they have different scales. Nested type columns can be equivalent in the case where they both have zero size, but one has children (also empty) and the other does not. For columns with nonzero size, both equals and equivalent expect equal number of children.</p>
<h3><a class="anchor" id="autotoc_md130"></a>
CUDF_TEST_EXPECT_COLUMNS_EQUAL</h3>
<p>Verifies that two columns have equal properties and verifies elementwise equality of the column data. Null elements are treated as equal.</p>
<h3><a class="anchor" id="autotoc_md131"></a>
CUDF_TEST_EXPECT_COLUMNS_EQUIVALENT</h3>
<p>Verifies that two columns have equivalent properties and verifies elementwise equivalence of the column data. Null elements are treated as equivalent.</p>
<h3><a class="anchor" id="autotoc_md132"></a>
CUDF_TEST_EXPECT_EQUAL_BUFFERS</h3>
<p>Verifies the bitwise equality of two device memory buffers.</p>
<h2><a class="anchor" id="autotoc_md133"></a>
Printing and accessing column data</h2>
<p><code><a class="el" href="column__utilities_8hpp_source.html">include/cudf_test/column_utilities.hpp</a></code> defines various functions and overloads for printing columns (<code>print</code>), converting column data to string (<code>to_string</code>, <code>to_strings</code>), and copying data to the host (<code>to_host</code>). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="atype__lists_8hpp_html"><div class="ttname"><a href="type__lists_8hpp.html">type_lists.hpp</a></div><div class="ttdoc">Provides centralized type lists for use in Google Test type-parameterized tests.</div></div>
<div class="ttc" id="atype__lists_8hpp_html_a82034b5f07ef26a398b8b60a31416798"><div class="ttname"><a href="type__lists_8hpp.html#a82034b5f07ef26a398b8b60a31416798">cudf::test::NumericTypes</a></div><div class="ttdeci">Concat&lt; IntegralTypes, FloatingPointTypes &gt; NumericTypes</div><div class="ttdoc">Provides a list of all numeric types supported in libcudf for use in a GTest typed test.</div><div class="ttdef"><b>Definition:</b> <a href="type__lists_8hpp_source.html#l00215">type_lists.hpp:215</a></div></div>
<div class="ttc" id="atype__list__utilities_8hpp_html_afd069722f69b38e1c0aa0a0d0b9d291a"><div class="ttname"><a href="type__list__utilities_8hpp.html#afd069722f69b38e1c0aa0a0d0b9d291a">cudf::test::GetType</a></div><div class="ttdeci">typename GetTypeImpl&lt; TUPLE, D &gt;::type GetType</div><div class="ttdoc">Gives the specified type from a type list.</div><div class="ttdef"><b>Definition:</b> <a href="type__list__utilities_8hpp_source.html#l00117">type_list_utilities.hpp:117</a></div></div>
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>