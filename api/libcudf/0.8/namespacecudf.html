<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: cudf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cudf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Invokes an instance of a functor template with the appropriate type determined by a gdf_dtype enum value.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1csv__read__arg.html">csv_read_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input arguments to the <code>read_csv</code> interface.  <a href="structcudf_1_1csv__read__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1cuda__error.html">cuda_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a CUDA error is encountered.  <a href="structcudf_1_1cuda__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceAnd.html">DeviceAnd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceCount.html">DeviceCount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceMax.html">DeviceMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceMin.html">DeviceMin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceOr.html">DeviceOr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceProduct.html">DeviceProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceSum.html">DeviceSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceXor.html">DeviceXor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1json__read__arg.html">json_read_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input arguments to the <code>read_json</code> interface.  <a href="structcudf_1_1json__read__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when logical precondition is violated.  <a href="structcudf_1_1logic__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1meanvar.html">meanvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">intermediate struct to calculate mean and variance This is an example case to output a struct from column input.  <a href="structcudf_1_1meanvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1orc__read__arg.html">orc_read_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h2>Input arguments to the <code>read_orc</code> interface </h2>
 <a href="structcudf_1_1orc__read__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor.html">pair_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pair accessor with/without null bitmask A unary function returns <code>thrust::pair&lt;ResultType, bool&gt;</code>. If the element at index <code>i</code> is valid, returns <code>ResultType{data[i]}</code> and <code>true</code> indicating the value was valid. If the element at <code>i</code> is null, returns <code>ResultType{identity}</code> and <code>false</code> indicating the element was null.  <a href="structcudf_1_1pair__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor_3_01ElementType_00_01ResultType_00_01false_01_4.html">pair_accessor&lt; ElementType, ResultType, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor_3_01ElementType_00_01ResultType_00_01true_01_4.html">pair_accessor&lt; ElementType, ResultType, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1parquet__read__arg.html">parquet_read_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h2>Input arguments to the <code>read_parquet</code> interface </h2>
 <a href="structcudf_1_1parquet__read__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1source__info.html">source_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h2>Input source info for <code>xxx_read_arg</code> arguments </h2>
 <a href="structcudf_1_1source__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1table.html">table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for a set of gdf_columns of equal number of rows.  <a href="structcudf_1_1table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1transformer__meanvar.html">transformer_meanvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a scalar value to construct a <code>meanvar</code> object. This transforms <code>thrust::pair&lt;ElementType, bool&gt;</code> into <code>ResultType = meanvar&lt;ElementType&gt;</code> form.  <a href="structcudf_1_1transformer__meanvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1transformer__squared.html">transformer_squared</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a scalar by first casting to another type, and then squaring the result.  <a href="structcudf_1_1transformer__squared.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor.html">value_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">value accessor with/without null bitmask A unary function returns scalar value at <code>id</code>. <code>operator() (gdf_index_type id)</code> computes <code>data</code> value and valid flag at <code>id</code>  <a href="structcudf_1_1value__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor_3_01ElementType_00_01ResultType_00_01false_01_4.html">value_accessor&lt; ElementType, ResultType, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor_3_01ElementType_00_01ResultType_00_01true_01_4.html">value_accessor&lt; ElementType, ResultType, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8c6e344a72404039eef838a8cb39295b"><td class="memItemLeft" align="right" valign="top"><a id="a8c6e344a72404039eef838a8cb39295b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>category</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_category, GDF_CATEGORY &gt;</td></tr>
<tr class="separator:a8c6e344a72404039eef838a8cb39295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64847ffcf8f0ad4069085490f9fb5c"><td class="memItemLeft" align="right" valign="top"><a id="a9b64847ffcf8f0ad4069085490f9fb5c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>nvstring_category</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_nvstring_category, GDF_STRING_CATEGORY &gt;</td></tr>
<tr class="separator:a9b64847ffcf8f0ad4069085490f9fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6916ffd2fdcad20b769afc3d4130140e"><td class="memItemLeft" align="right" valign="top"><a id="a6916ffd2fdcad20b769afc3d4130140e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_timestamp, GDF_TIMESTAMP &gt;</td></tr>
<tr class="separator:a6916ffd2fdcad20b769afc3d4130140e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788a6ac25db35f51d612644bebd86970"><td class="memItemLeft" align="right" valign="top"><a id="a788a6ac25db35f51d612644bebd86970"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>date32</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_date32, GDF_DATE32 &gt;</td></tr>
<tr class="separator:a788a6ac25db35f51d612644bebd86970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da9e96ba9d677a713403fb3704600ef"><td class="memItemLeft" align="right" valign="top"><a id="a5da9e96ba9d677a713403fb3704600ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>date64</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_date64, GDF_DATE64 &gt;</td></tr>
<tr class="separator:a5da9e96ba9d677a713403fb3704600ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2916a984683be11ca496ae1535849cb3"><td class="memItemLeft" align="right" valign="top"><a id="a2916a984683be11ca496ae1535849cb3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bool8</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_bool8, GDF_BOOL8 &gt;</td></tr>
<tr class="separator:a2916a984683be11ca496ae1535849cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> { <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa86ea4bfd2b3121412b0a63a3697926ec">KEEP_FIRST</a> = 0, 
<a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa1d1398f646d74e801389737f07d89d1c">KEEP_LAST</a>, 
<a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa6fb3154b77231184b596b4add407aa2a">KEEP_NONE</a>
 }</td></tr>
<tr class="memdesc:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choices for drop_duplicates API for retainment of duplicate rows.  <a href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">More...</a><br /></td></tr>
<tr class="separator:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae942e9a8d320f23d61bee22ddc06df55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae942e9a8d320f23d61bee22ddc06df55">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *lhs, <a class="el" href="structgdf__column__.html">gdf_column</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:ae942e9a8d320f23d61bee22ddc06df55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> and a gdf_column.  <a href="#ae942e9a8d320f23d61bee22ddc06df55">More...</a><br /></td></tr>
<tr class="separator:ae942e9a8d320f23d61bee22ddc06df55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02af1454978d7d7f7b9f651437b3ab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa02af1454978d7d7f7b9f651437b3ab5">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__column__.html">gdf_column</a> *lhs, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:aa02af1454978d7d7f7b9f651437b3ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a gdf_column and a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a>.  <a href="#aa02af1454978d7d7f7b9f651437b3ab5">More...</a><br /></td></tr>
<tr class="separator:aa02af1454978d7d7f7b9f651437b3ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad01e2e81bc2b671dfb8963a7be22e3b0">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__column__.html">gdf_column</a> *lhs, <a class="el" href="structgdf__column__.html">gdf_column</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two gdf_columns.  <a href="#ad01e2e81bc2b671dfb8963a7be22e3b0">More...</a><br /></td></tr>
<tr class="separator:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dbda70c1dee5bfd3cf2f5424fd4ad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#af8dbda70c1dee5bfd3cf2f5424fd4ad0">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__column__.html">gdf_column</a> *lhs, <a class="el" href="structgdf__column__.html">gdf_column</a> *rhs, const std::string &amp;ptx)</td></tr>
<tr class="memdesc:af8dbda70c1dee5bfd3cf2f5424fd4ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two gdf_columns using a user-defined PTX function.  <a href="#af8dbda70c1dee5bfd3cf2f5424fd4ad0">More...</a><br /></td></tr>
<tr class="separator:af8dbda70c1dee5bfd3cf2f5424fd4ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="memItemLeft" align="right" valign="top">rmm::device_vector&lt; bit_mask::bit_mask_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aec006bc00092dd8ec47f2c7ca6fe01d4">row_bitmask</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a bitmask indicating the presence of NULL values in rows of a table.  <a href="#aec006bc00092dd8ec47f2c7ca6fe01d4">More...</a><br /></td></tr>
<tr class="separator:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206ad1cc4b21f7f14c5d5f7d304efbda"><td class="memItemLeft" align="right" valign="top"><a id="a206ad1cc4b21f7f14c5d5f7d304efbda"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><b>empty_like</b> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input)</td></tr>
<tr class="separator:a206ad1cc4b21f7f14c5d5f7d304efbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08cb8501fe52a732913af1ac7b25ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae08cb8501fe52a732913af1ac7b25ace">allocate_like</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, bool allocate_mask_if_exists=true, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:ae08cb8501fe52a732913af1ac7b25ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new column of the same size and type as the input.  <a href="#ae08cb8501fe52a732913af1ac7b25ace">More...</a><br /></td></tr>
<tr class="separator:ae08cb8501fe52a732913af1ac7b25ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa7e6bf39cb5dd5cdb370d0a562675922">copy</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column that is a copy of input.  <a href="#aa7e6bf39cb5dd5cdb370d0a562675922">More...</a><br /></td></tr>
<tr class="separator:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3588fc0b833a8f2d7213651a05f48c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3588fc0b833a8f2d7213651a05f48c80">empty_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t)</td></tr>
<tr class="memdesc:a3588fc0b833a8f2d7213651a05f48c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of empty columns with the same types as the inputs.  <a href="#a3588fc0b833a8f2d7213651a05f48c80">More...</a><br /></td></tr>
<tr class="separator:a3588fc0b833a8f2d7213651a05f48c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a1a6bea8f1e1dd224f4316bbd23fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#af3a1a6bea8f1e1dd224f4316bbd23fbc">allocate_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, bool allocate_mask_if_exists=true, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:af3a1a6bea8f1e1dd224f4316bbd23fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns with the same type and allocation size as the input.  <a href="#af3a1a6bea8f1e1dd224f4316bbd23fbc">More...</a><br /></td></tr>
<tr class="separator:af3a1a6bea8f1e1dd224f4316bbd23fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a9fae65b5e23d13aec03edef7a8aeacb0">copy</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns and deep copies the data from an input table.  <a href="#a9fae65b5e23d13aec03edef7a8aeacb0">More...</a><br /></td></tr>
<tr class="separator:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67996c2986be62de33c6685e1702755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab67996c2986be62de33c6685e1702755">copy_range</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out_column, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;in_column, gdf_index_type out_begin, gdf_index_type out_end, gdf_index_type in_begin)</td></tr>
<tr class="memdesc:ab67996c2986be62de33c6685e1702755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements from one column to another.  <a href="#ab67996c2986be62de33c6685e1702755">More...</a><br /></td></tr>
<tr class="separator:ab67996c2986be62de33c6685e1702755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f762fbe22ea8e824e426d3880b085a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a03f762fbe22ea8e824e426d3880b085a">gather</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, gdf_index_type const gather_map[], <a class="el" href="structcudf_1_1table.html">table</a> *destination_table)</td></tr>
<tr class="memdesc:a03f762fbe22ea8e824e426d3880b085a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the rows (including null values) of a set of source columns into a set of destination columns.  <a href="#a03f762fbe22ea8e824e426d3880b085a">More...</a><br /></td></tr>
<tr class="separator:a03f762fbe22ea8e824e426d3880b085a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30995b318ebee41f1ab8e79dc2527c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ac30995b318ebee41f1ab8e79dc2527c0">scatter</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, gdf_index_type const scatter_map[], <a class="el" href="structcudf_1_1table.html">table</a> *destination_table)</td></tr>
<tr class="memdesc:ac30995b318ebee41f1ab8e79dc2527c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows (including null values) of a set of source columns into a set of destination columns.  <a href="#ac30995b318ebee41f1ab8e79dc2527c0">More...</a><br /></td></tr>
<tr class="separator:ac30995b318ebee41f1ab8e79dc2527c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f4a85729765c154b21d8102be5a9d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a31f4a85729765c154b21d8102be5a9d5">slice</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input_column, gdf_index_type const  *indices, gdf_size_type num_indices)</td></tr>
<tr class="memdesc:a31f4a85729765c154b21d8102be5a9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a column (including null values) into a set of columns according to a set of indices.  <a href="#a31f4a85729765c154b21d8102be5a9d5">More...</a><br /></td></tr>
<tr class="separator:a31f4a85729765c154b21d8102be5a9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69299f48fdcd25864a2f560e55d18ea9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a69299f48fdcd25864a2f560e55d18ea9">split</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input_column, gdf_index_type const  *indices, gdf_size_type num_indices)</td></tr>
<tr class="memdesc:a69299f48fdcd25864a2f560e55d18ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a column (including null values) into a set of columns according to a set of indices.  <a href="#a69299f48fdcd25864a2f560e55d18ea9">More...</a><br /></td></tr>
<tr class="separator:a69299f48fdcd25864a2f560e55d18ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdaf17cbac0f8976b27199b4aed31f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0fdaf17cbac0f8976b27199b4aed31f5">fill</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *column, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> const  &amp;value, gdf_index_type begin, gdf_index_type end)</td></tr>
<tr class="memdesc:a0fdaf17cbac0f8976b27199b4aed31f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in a column with a scalar value.  <a href="#a0fdaf17cbac0f8976b27199b4aed31f5">More...</a><br /></td></tr>
<tr class="separator:a0fdaf17cbac0f8976b27199b4aed31f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c6e502e3755eefe9a720cdf0f3ed5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a30c6e502e3755eefe9a720cdf0f3ed5e">point_in_polygon</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;polygon_latitudes, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;polygon_longitudes, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;query_point_latitudes, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;query_point_longitudes)</td></tr>
<tr class="memdesc:a30c6e502e3755eefe9a720cdf0f3ed5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not coordinates (query points) are completely inside a static polygon.  <a href="#a30c6e502e3755eefe9a720cdf0f3ed5e">More...</a><br /></td></tr>
<tr class="separator:a30c6e502e3755eefe9a720cdf0f3ed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaa3abcef29306b7b544e847ae5da46"><td class="memItemLeft" align="right" valign="top"><a id="abcaa3abcef29306b7b544e847ae5da46"></a>
gdf_dtype&#160;</td><td class="memItemRight" valign="bottom"><b>convertStringToDtype</b> (const std::string &amp;dtype)</td></tr>
<tr class="separator:abcaa3abcef29306b7b544e847ae5da46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb570307357da1e8c28cee58d653b5cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#acb570307357da1e8c28cee58d653b5cb">inferCompressionType</a> (const std::string &amp;compression_arg, gdf_input_type source_type, const std::string &amp;source, const std::map&lt; std::string, std::string &gt; &amp;ext_to_compression)</td></tr>
<tr class="memdesc:acb570307357da1e8c28cee58d653b5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the compression type from the compression parameter and the input data.  <a href="#acb570307357da1e8c28cee58d653b5cb">More...</a><br /></td></tr>
<tr class="separator:acb570307357da1e8c28cee58d653b5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59a215482cdc7bc3ba850d2a0fa9f86"><td class="memItemLeft" align="right" valign="top"><a id="ab59a215482cdc7bc3ba850d2a0fa9f86"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_csv</b> (<a class="el" href="structcudf_1_1csv__read__arg.html">csv_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:ab59a215482cdc7bc3ba850d2a0fa9f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2430dcb97885610d55a2ddc34f7e8c1e"><td class="memItemLeft" align="right" valign="top"><a id="a2430dcb97885610d55a2ddc34f7e8c1e"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_json</b> (<a class="el" href="structcudf_1_1json__read__arg.html">json_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:a2430dcb97885610d55a2ddc34f7e8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ad77aef16f9ee3607c92778e14417"><td class="memItemLeft" align="right" valign="top"><a id="af36ad77aef16f9ee3607c92778e14417"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_orc</b> (<a class="el" href="structcudf_1_1orc__read__arg.html">orc_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:af36ad77aef16f9ee3607c92778e14417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67516b133f0735f23f0024f86d8756d8"><td class="memItemLeft" align="right" valign="top"><a id="a67516b133f0735f23f0024f86d8756d8"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_parquet</b> (<a class="el" href="structcudf_1_1parquet__read__arg.html">parquet_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:a67516b133f0735f23f0024f86d8756d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5315ca38e017e2ed42a400483bba3b56"><td class="memTemplParams" colspan="2">template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a5315ca38e017e2ed42a400483bba3b56"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5315ca38e017e2ed42a400483bba3b56">make_iterator</a> (const ElementType *data, const bit_mask::bit_mask_t *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="memdesc:a5315ca38e017e2ed42a400483bba3b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an iterator over the elements of a column.  <a href="#a5315ca38e017e2ed42a400483bba3b56">More...</a><br /></td></tr>
<tr class="separator:a5315ca38e017e2ed42a400483bba3b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4644fa78d40f010ce935b4358d1a9e25"><td class="memTemplParams" colspan="2"><a id="a4644fa78d40f010ce935b4358d1a9e25"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a4644fa78d40f010ce935b4358d1a9e25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_iterator</b> (const ElementType *data, const gdf_valid_type *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a4644fa78d40f010ce935b4358d1a9e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memTemplParams" colspan="2"><a id="af06d674f7e1bd773e4166ef4d7fcf959"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_iterator</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;column, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memTemplParams" colspan="2">template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a20b11ec1348ab46ae20792ea4e2c0ca4">make_pair_iterator</a> (const ElementType *data, const bit_mask::bit_mask_t *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="memdesc:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an iterator over the elements of a column Input iterator which can be used for cub and thrust.  <a href="#a20b11ec1348ab46ae20792ea4e2c0ca4">More...</a><br /></td></tr>
<tr class="separator:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee5f476efe3d2ba71060aa0ffe202f"><td class="memTemplParams" colspan="2"><a id="a8fee5f476efe3d2ba71060aa0ffe202f"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a8fee5f476efe3d2ba71060aa0ffe202f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pair_iterator</b> (const ElementType *data, const gdf_valid_type *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a8fee5f476efe3d2ba71060aa0ffe202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f930d43783b2f9ff84a219b19d245"><td class="memTemplParams" colspan="2"><a id="a657f930d43783b2f9ff84a219b19d245"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </td></tr>
<tr class="memitem:a657f930d43783b2f9ff84a219b19d245"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pair_iterator</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;column, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a657f930d43783b2f9ff84a219b19d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d269210347c80b2a841daef1a0d136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__scalar.html">gdf_scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a16d269210347c80b2a841daef1a0d136">reduction</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *col, gdf_reduction_op op, gdf_dtype output_dtype)</td></tr>
<tr class="memdesc:a16d269210347c80b2a841daef1a0d136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision <code>dtype</code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> will contain <code>false</code>.  <a href="#a16d269210347c80b2a841daef1a0d136">More...</a><br /></td></tr>
<tr class="separator:a16d269210347c80b2a841daef1a0d136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a65546aa9c42e87334fb5e1e3f274bc6b">scan</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *input, <a class="el" href="structgdf__column__.html">gdf_column</a> *output, gdf_scan_op op, bool inclusive)</td></tr>
<tr class="memdesc:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null.  <a href="#a65546aa9c42e87334fb5e1e3f274bc6b">More...</a><br /></td></tr>
<tr class="separator:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e93b1c814e07e108ad015d27ca2372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a68e93b1c814e07e108ad015d27ca2372">find_and_replace_all</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input_col, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;values_to_replace, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;replacement_values)</td></tr>
<tr class="memdesc:a68e93b1c814e07e108ad015d27ca2372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements from <code>input_col</code> according to the mapping <code>values_to_replace</code> to <code>replacement_values</code>, that is, replace all <code>values_to_replace[i]</code> present in <code>input_col</code> with <code>replacement_values[i]</code>.  <a href="#a68e93b1c814e07e108ad015d27ca2372">More...</a><br /></td></tr>
<tr class="separator:a68e93b1c814e07e108ad015d27ca2372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85645250c7ada0b73a61e9a691931b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a85645250c7ada0b73a61e9a691931b36">replace_nulls</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;replacement)</td></tr>
<tr class="memdesc:a85645250c7ada0b73a61e9a691931b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with corresponding values of another column.  <a href="#a85645250c7ada0b73a61e9a691931b36">More...</a><br /></td></tr>
<tr class="separator:a85645250c7ada0b73a61e9a691931b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad66cc66793473e7fc90ad3ed4cd1b450">replace_nulls</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input, const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;replacement)</td></tr>
<tr class="memdesc:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with a scalar.  <a href="#ad66cc66793473e7fc90ad3ed4cd1b450">More...</a><br /></td></tr>
<tr class="separator:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d88717a2c068bbfac0f10352296c09"><td class="memItemLeft" align="right" valign="top"><a id="aa9d88717a2c068bbfac0f10352296c09"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rolling_window</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input_col, gdf_size_type window, gdf_size_type min_periods, gdf_size_type forward_window, gdf_agg_op agg_type, const gdf_size_type *window_col, const gdf_size_type *min_periods_col, const gdf_size_type *forward_window_col)</td></tr>
<tr class="separator:aa9d88717a2c068bbfac0f10352296c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fba636792abcf96032c639873d14870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5fba636792abcf96032c639873d14870">apply_boolean_mask</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;boolean_mask)</td></tr>
<tr class="memdesc:a5fba636792abcf96032c639873d14870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a column using a column of boolean values as a mask.  <a href="#a5fba636792abcf96032c639873d14870">More...</a><br /></td></tr>
<tr class="separator:a5fba636792abcf96032c639873d14870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb8b53ebafc4439711c5fbb4d31a89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a2cb8b53ebafc4439711c5fbb4d31a89b">drop_nulls</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input)</td></tr>
<tr class="memdesc:a2cb8b53ebafc4439711c5fbb4d31a89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a column to remove null elements.  <a href="#a2cb8b53ebafc4439711c5fbb4d31a89b">More...</a><br /></td></tr>
<tr class="separator:a2cb8b53ebafc4439711c5fbb4d31a89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33dca48e0e06d182698cefb81b14be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad33dca48e0e06d182698cefb81b14be2">drop_duplicates</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;input_table, const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;key_columns, const <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep, const bool nulls_are_equal=true)</td></tr>
<tr class="memdesc:ad33dca48e0e06d182698cefb81b14be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table without duplicate rows.  <a href="#ad33dca48e0e06d182698cefb81b14be2">More...</a><br /></td></tr>
<tr class="separator:ad33dca48e0e06d182698cefb81b14be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gdf_dtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad2f973d94c67ab3dc1a183c5adb3753d">column_dtypes</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of the dtypes of the columns in a table.  <a href="#ad2f973d94c67ab3dc1a183c5adb3753d">More...</a><br /></td></tr>
<tr class="separator:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada393acb565321d740f2b9950ffe2941"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ada393acb565321d740f2b9950ffe2941">has_nulls</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ada393acb565321d740f2b9950ffe2941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a table contains any null values.  <a href="#ada393acb565321d740f2b9950ffe2941">More...</a><br /></td></tr>
<tr class="separator:ada393acb565321d740f2b9950ffe2941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;column)</td></tr>
<tr class="memdesc:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures a gdf_column is valid, i.e. that its fields are consistent with each other, and logical in themselves, in representing a proper column.  <a href="#afa70e889e2b83eba15ed8e8e864dd3ff">More...</a><br /></td></tr>
<tr class="separator:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9985a7fc88fb9b13d429e29405e12ae"><td class="memItemLeft" align="right" valign="top"><a id="ab9985a7fc88fb9b13d429e29405e12ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *column_ptr)</td></tr>
<tr class="separator:ab9985a7fc88fb9b13d429e29405e12ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d288a83fd8de580d2274f825997cbf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0d288a83fd8de580d2274f825997cbf3">have_same_type</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;validated_column_1, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;validated_column_2, bool ignore_extra_type_info=false) noexcept</td></tr>
<tr class="memdesc:a0d288a83fd8de580d2274f825997cbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures two (valid!) columns have the same type.  <a href="#a0d288a83fd8de580d2274f825997cbf3">More...</a><br /></td></tr>
<tr class="separator:a0d288a83fd8de580d2274f825997cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11851549cdd993a7a09c280a6d015135"><td class="memItemLeft" align="right" valign="top"><a id="a11851549cdd993a7a09c280a6d015135"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>have_same_type</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *validated_column_ptr_1, const <a class="el" href="structgdf__column__.html">gdf_column</a> *validated_column_ptr_2, bool ignore_extra_type_info) noexcept</td></tr>
<tr class="separator:a11851549cdd993a7a09c280a6d015135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f193177256b121627a35887dc9f816"><td class="memTemplParams" colspan="2"><a id="a40f193177256b121627a35887dc9f816"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40f193177256b121627a35887dc9f816"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_data</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;column) noexcept</td></tr>
<tr class="separator:a40f193177256b121627a35887dc9f816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b3e096195676e94b7c8398747459ff"><td class="memTemplParams" colspan="2"><a id="a52b3e096195676e94b7c8398747459ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52b3e096195676e94b7c8398747459ff"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_data</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *column) noexcept</td></tr>
<tr class="separator:a52b3e096195676e94b7c8398747459ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571f2362be95df8c2348bcce96fc522b"><td class="memItemLeft" align="right" valign="top"><a id="a571f2362be95df8c2348bcce96fc522b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_an_integer</b> (gdf_dtype element_type) noexcept</td></tr>
<tr class="separator:a571f2362be95df8c2348bcce96fc522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1090d2083c2700bef73bb07b29f8eb"><td class="memItemLeft" align="right" valign="top"><a id="a8d1090d2083c2700bef73bb07b29f8eb"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_integral</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;column) noexcept</td></tr>
<tr class="separator:a8d1090d2083c2700bef73bb07b29f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a3589a60ac4e16c069ae1852d80264"><td class="memItemLeft" align="right" valign="top"><a id="a49a3589a60ac4e16c069ae1852d80264"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_integral</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *column) noexcept</td></tr>
<tr class="separator:a49a3589a60ac4e16c069ae1852d80264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"><td class="memItemLeft" align="right" valign="top"><a id="a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_nullable</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;column) noexcept</td></tr>
<tr class="separator:a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a4a65a257d9746a9d65f8a8a6de1a5"><td class="memItemLeft" align="right" valign="top"><a id="a83a4a65a257d9746a9d65f8a8a6de1a5"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_nulls</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;column) noexcept</td></tr>
<tr class="separator:a83a4a65a257d9746a9d65f8a8a6de1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="memItemLeft" align="right" valign="top"><a id="aea3dfde6d57f821aa1825a90a8cdddcb"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aea3dfde6d57f821aa1825a90a8cdddcb">size_of</a> (gdf_dtype element_type)</td></tr>
<tr class="memdesc:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of values of a column element type. <br /></td></tr>
<tr class="separator:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="memItemLeft" align="right" valign="top"><a id="aaf37d87f3ef5bb0736ad2dfeeac3e766"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaf37d87f3ef5bb0736ad2dfeeac3e766">byte_width</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;col) noexcept</td></tr>
<tr class="memdesc:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of each element of a column (a.k.a. the column's width) <br /></td></tr>
<tr class="separator:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62151c46119cd04dc146c9e4175375f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:ae62151c46119cd04dc146c9e4175375f"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae62151c46119cd04dc146c9e4175375f">genericAtomicOperation</a> (T *address, T const &amp;update_value, BinaryOp op)</td></tr>
<tr class="memdesc:ae62151c46119cd04dc146c9e4175375f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction.  <a href="#ae62151c46119cd04dc146c9e4175375f">More...</a><br /></td></tr>
<tr class="separator:ae62151c46119cd04dc146c9e4175375f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memTemplParams" colspan="2"><a id="acafbd5dbae09b26c92b964e0122d5fc9"></a>
template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genericAtomicOperation</b> (<a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a> *address, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a> const &amp;update_value, BinaryOp op)</td></tr>
<tr class="separator:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d210161ecb8636ef5a5fca8cdcee3c9"><td class="memTemplParams" colspan="2"><a id="a0d210161ecb8636ef5a5fca8cdcee3c9"></a>
template&lt;class functor_t , typename... Ts&gt; </td></tr>
<tr class="memitem:a0d210161ecb8636ef5a5fca8cdcee3c9"><td class="memTemplItemLeft" align="right" valign="top">CUDA_HOST_DEVICE_CALLABLEdecltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_dispatcher</b> (gdf_dtype dtype, functor_t f, Ts &amp;&amp;... args)</td></tr>
<tr class="separator:a0d210161ecb8636ef5a5fca8cdcee3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad7b0f1bc518e47eaa2cfdd0ec88e3989">gdf_dtype_of</a> ()</td></tr>
<tr class="memdesc:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to it's corresponding gdf_dtype.  <a href="#ad7b0f1bc518e47eaa2cfdd0ec88e3989">More...</a><br /></td></tr>
<tr class="separator:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memTemplParams" colspan="2"><a id="ad0a0a98fdfe7a302afb2dfcaeb536412"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int8_t &gt;</b> ()</td></tr>
<tr class="separator:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d"><td class="memTemplParams" colspan="2"><a id="ae3d9564b2dc03eee3515499cae68827d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int16_t &gt;</b> ()</td></tr>
<tr class="separator:ae3d9564b2dc03eee3515499cae68827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memTemplParams" colspan="2"><a id="ae5ac9bfed0ac9684cc5c201271d4bca5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int32_t &gt;</b> ()</td></tr>
<tr class="separator:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memTemplParams" colspan="2"><a id="a17d6aab829fdfa0a8e805693fe6d0682"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int64_t &gt;</b> ()</td></tr>
<tr class="separator:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124"><td class="memTemplParams" colspan="2"><a id="aef0bacd5dab94476140d35bd1a44c124"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; float &gt;</b> ()</td></tr>
<tr class="separator:aef0bacd5dab94476140d35bd1a44c124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac"><td class="memTemplParams" colspan="2"><a id="aa02973e71d09dc7a3636d2a836968dac"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; double &gt;</b> ()</td></tr>
<tr class="separator:aa02973e71d09dc7a3636d2a836968dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5"><td class="memTemplParams" colspan="2"><a id="ab49efe66b146dc87425669653bde18f5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::bool8 &gt;</b> ()</td></tr>
<tr class="separator:ab49efe66b146dc87425669653bde18f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memTemplParams" colspan="2"><a id="a1e1b828c8f1b2b46e015afb85902ba52"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::date32 &gt;</b> ()</td></tr>
<tr class="separator:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c"><td class="memTemplParams" colspan="2"><a id="adb20c98631c4c203372547135f13732c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::date64 &gt;</b> ()</td></tr>
<tr class="separator:adb20c98631c4c203372547135f13732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memTemplParams" colspan="2"><a id="ad2576f3b441a5f87a0d5b67b7d21b854"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::timestamp &gt;</b> ()</td></tr>
<tr class="separator:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memTemplParams" colspan="2"><a id="a4e807d272b4582ff4d2a0dd9c6b8b309"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::category &gt;</b> ()</td></tr>
<tr class="separator:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919"><td class="memTemplParams" colspan="2"><a id="a0f831e82c6b13cd54c940e74fc46b919"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::nvstring_category &gt;</b> ()</td></tr>
<tr class="separator:a0f831e82c6b13cd54c940e74fc46b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606"><td class="memTemplParams" colspan="2"><a id="a5d1e00fa2d40d07ed6114dc064582606"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; NVStrings &gt;</b> ()</td></tr>
<tr class="separator:a5d1e00fa2d40d07ed6114dc064582606"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Invokes an instance of a functor template with the appropriate type determined by a gdf_dtype enum value. </p>
<p>This helper function accepts any object with an "operator()" template, e.g., a functor. It will invoke an instance of the template by passing in as the template argument an appropriate type determined by the value of the gdf_dtype argument.</p>
<p>The template may have 1 or more template parameters, but the first parameter must be the type dispatched from the gdf_dtype enum. The remaining template parameters must be able to be automatically deduced.</p>
<p>There is a 1-to-1 mapping of gdf_dtype enum values and dispatched types. However, different gdf_dtype values may have the same underlying type. Therefore, in order to provide the 1-to-1 mapping, a wrapper struct may be dispatched for certain gdf_dtype enum values in order to emulate a "strong
typedef".</p>
<p>A strong typedef provides a new, concrete type unlike a normal C++ typedef which is simply a type alias. These "strong typedef" structs simply wrap a single member variable of a fundamental type called 'value'.</p>
<p>The standard arithmetic operators are defined for the wrapper structs and therefore the wrapper struct types can be used as if they were fundamental types.</p>
<p>See <a class="el" href="wrapper__types_8hpp.html" title="Wrapper structs for for the non-fundamental gdf_dtype types. ">wrapper_types.hpp</a> for more detail.</p>
<p>Example usage with a functor that returns the size of the dispatched type:</p>
<p>struct example_functor{ template &lt;typename t&gt;=""&gt; int operator()(){ return sizeof(T); } };</p>
<p>cudf::type_dispatcher(GDF_INT8, example_functor); // returns 1 cudf::type_dispatcher(GDF_INT64, example_functor); // returns 8</p>
<p>Example usage of a functor for checking if element "i" in column "lhs" is equal to element "j" in column "rhs":</p>
<p>struct elements_are_equal{ template &lt;typename columntype&gt;=""&gt; bool operator()(void const * lhs, int i, void const * rhs, int j) { // Cast the void* data buffer to the dispatched type and retrieve elements // "i" and "j" from the respective columns ColumnType const i_elem = static_cast&lt;ColumnType const*&gt;(lhs)[i]; ColumnType const j_elem = static_cast&lt;ColumnType const*&gt;(rhs)[j];</p>
<p>// operator== is defined for wrapper structs such that it performs the // operator== on the underlying values. Therefore, the wrapper structs // can be used as if they were fundamental arithmetic types return i_elem == j_elem; } };</p>
<p>The return type for all template instantiations of the functor's "operator()" lambda must be the same, else there will be a compiler error as you would be trying to return different types from the same function.</p>
<p>NOTE: It is undefined behavior if an unsupported or invalid <code>gdf_dtype</code> is supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The gdf_dtype enum that determines which type will be dispatched </td></tr>
    <tr><td class="paramname">f</td><td>The functor with a templated "operator()" that will be invoked with the dispatched type </td></tr>
    <tr><td class="paramname">args</td><td>A parameter-pack (i.e., arbitrary number of arguments) that will be perfectly-forwarded as the arguments of the functor's "operator()".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whatever is returned by the functor's "operator()". </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a69091647ea1f9c9d4cdcf7c8876bea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69091647ea1f9c9d4cdcf7c8876bea3a">&#9670;&nbsp;</a></span>duplicate_keep_option</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">cudf::duplicate_keep_option</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choices for drop_duplicates API for retainment of duplicate rows. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa86ea4bfd2b3121412b0a63a3697926ec"></a>KEEP_FIRST&#160;</td><td class="fielddoc"><p>Keeps first duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa1d1398f646d74e801389737f07d89d1c"></a>KEEP_LAST&#160;</td><td class="fielddoc"><p>Keeps last duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa6fb3154b77231184b596b4add407aa2a"></a>KEEP_NONE&#160;</td><td class="fielddoc"><p>Don't keep any duplicate rows, Keeps only unique rows. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae08cb8501fe52a732913af1ac7b25ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08cb8501fe52a732913af1ac7b25ace">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocate_mask_if_exists</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new column of the same size and type as the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to emulate </td></tr>
    <tr><td class="paramname">allocate_mask_if_exists</td><td>Optional whether or not to allocate bitmask if it exists in input </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column An allocated column of same size and type of input </dd></dl>

</div>
</div>
<a id="af3a1a6bea8f1e1dd224f4316bbd23fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a1a6bea8f1e1dd224f4316bbd23fbc">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocate_mask_if_exists</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns with the same type and allocation size as the input. </p>
<p>Creates the <code>gdf_column</code> objects, and allocates underlying device memory for each column matching the input columns</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to emulate </td></tr>
    <tr><td class="paramname">allocate_mask_if_exists</td><td>Optional whether or not to allocate the bitmask for each column if it exists in the corresponding input column </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table of columns with same type and allocation size as input </dd></dl>

</div>
</div>
<a id="a5fba636792abcf96032c639873d14870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fba636792abcf96032c639873d14870">&#9670;&nbsp;</a></span>apply_boolean_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::apply_boolean_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a column using a column of boolean values as a mask. </p>
<p>Given an input column and a mask column, an element <code>i</code> from the input column is copied to the output if the corresponding element <code>i</code> in the mask is non-null and <code>true</code>. This operation is stable: the input order is preserved.</p>
<p>The input and mask columns must be of equal size.</p>
<p>The output column has size equal to the number of elements in boolean_mask that are both non-null and <code>true</code>. Note that the output column memory is allocated by this function but must be freed by the caller when finished.</p>
<dl class="section note"><dt>Note</dt><dd>that the <code>boolean_mask</code> may have just boolean data (no valid bitmask), or just a valid bitmask (no boolean data), or it may have both. The filter adapts to these three situations.</dd>
<dd>
if <code>input.size</code> is zero, there is no error, and an empty column is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>A column of type GDF_BOOL8 used as a mask to filter the input column corresponding index passes the filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column containing copy of all elements of <code>input</code> passing the filter defined by <code>boolean_mask</code>. </dd></dl>

</div>
</div>
<a id="ae942e9a8d320f23d61bee22ddc06df55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae942e9a8d320f23d61bee22ddc06df55">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> and a gdf_column. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid mask of rhs gdf_column and is_valid bool of lhs <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a>) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa02af1454978d7d7f7b9f651437b3ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02af1454978d7d7f7b9f651437b3ab5">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a gdf_column and a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a>. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid mask of lhs gdf_column and is_valid bool of rhs <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a>) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad01e2e81bc2b671dfb8963a7be22e3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01e2e81bc2b671dfb8963a7be22e3b0">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two gdf_columns. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid masks of lhs and rhs gdf_columns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8dbda70c1dee5bfd3cf2f5424fd4ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8dbda70c1dee5bfd3cf2f5424fd4ad0">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ptx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two gdf_columns using a user-defined PTX function. </p>
<p>Accepts a user-defined PTX function to apply between the <code>lhs</code> and <code>rhs</code>.</p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid masks of lhs and rhs gdf_columns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ptx</td><td>String containing the PTX of a binary function to apply between <code>lhs</code> and <code>rhs</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2f973d94c67ab3dc1a183c5adb3753d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f973d94c67ab3dc1a183c5adb3753d">&#9670;&nbsp;</a></span>column_dtypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gdf_dtype &gt; cudf::column_dtypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of the dtypes of the columns in a table. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to get the column dtypes from <h2>std::vector&lt;gdf_dtype&gt; </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7e6bf39cb5dd5cdb370d0a562675922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e6bf39cb5dd5cdb370d0a562675922">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column that is a copy of input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to copy </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column A copy of input </dd></dl>

</div>
</div>
<a id="a9fae65b5e23d13aec03edef7a8aeacb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae65b5e23d13aec03edef7a8aeacb0">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns and deep copies the data from an input table. </p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to copy </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations and copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table that is an exact copy of <code>t</code> </dd></dl>

</div>
</div>
<a id="ab67996c2986be62de33c6685e1702755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67996c2986be62de33c6685e1702755">&#9670;&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>in_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>out_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>out_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>in_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements from one column to another. </p>
<p>Copies N elements of <code>in_column</code> starting at <code>in_begin</code> to the N elements of <code>out_column</code> starting at <code>out_begin</code>, where N = (<code>out_end</code> - <code>out_begin</code>)</p>
<p>The datatypes of in_column and out_column must be the same.</p>
<p>If the input and output columns are the same and ranges overlap, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out_column</td><td>The preallocated column to copy into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_column</td><td>The column to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_begin</td><td>The starting index of the output range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_end</td><td>The index one past the end of the output range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_begin</td><td>The starting index of the input range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ad33dca48e0e06d182698cefb81b14be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33dca48e0e06d182698cefb81b14be2">&#9670;&nbsp;</a></span>drop_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::drop_duplicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>input_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>key_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a>&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>nulls_are_equal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table without duplicate rows. </p>
<p>Given an input table, each row is copied to output table if the corresponding row of key column table is unique, where the definition of unique depends on the value of <code>keep:</code> </p><ul>
<li>KEEP_FIRST: only the first of a sequence of duplicate rows is copied</li>
<li>KEEP_LAST: only the last of a sequence of duplicate rows is copied</li>
<li>KEEP_NONE: no duplicate rows are copied</li>
</ul>
<p>The input table and key columns table should have same number of rows. Note that the memory for the output table columns is allocated by this function, so it must be freed by the caller when finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_table</td><td>input table to copy only unique rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_columns</td><td>columns to consider to identify duplicate rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>keep first entry, last entry, or no entries if duplicates found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_are_equal</td><td>flag to denote nulls are equal if true, nulls are not equal if false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>out_table with only unique rows </dd></dl>

</div>
</div>
<a id="a2cb8b53ebafc4439711c5fbb4d31a89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb8b53ebafc4439711c5fbb4d31a89b">&#9670;&nbsp;</a></span>drop_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::drop_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a column to remove null elements. </p>
<p>Given an input column an element <code>i</code> from the input column is copied to the output if the corresponding element <code>i</code> in the input's valid bitmask is non-null.</p>
<p>The output column has size equal to the number of elements in boolean_mask that are both non-null and <code>true</code>. Note that the output column memory is allocated by this function but must be freed by the caller when finished.</p>
<p>If the input column is not nullable, this function just copies the input to the output.</p>
<ul>
<li><dl class="section note"><dt>Note</dt><dd>if <code>input.size</code> is zero, there is no error, and an empty column is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column to filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column containing copy of all non-null elements of <code>input</code>. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a3588fc0b833a8f2d7213651a05f48c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3588fc0b833a8f2d7213651a05f48c80">&#9670;&nbsp;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of empty columns with the same types as the inputs. </p>
<p>Creates the <code>gdf_column</code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to delete the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input table to emulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table of empty columns of same type as input </dd></dl>

</div>
</div>
<a id="a0fdaf17cbac0f8976b27199b4aed31f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdaf17cbac0f8976b27199b4aed31f5">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in a column with a scalar value. </p>
<p>Fills N elements of <code>column</code> starting at <code>begin</code> with <code>value</code>, where N = (<code>end</code> - <code>begin</code>)</p>
<p>The datatypes of <code>column</code> and <code>value</code> must be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">column</td><td>The preallocated column to fill into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The scalar value to fill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The starting index of the fill range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The index one past the end of the fill range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a68e93b1c814e07e108ad015d27ca2372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e93b1c814e07e108ad015d27ca2372">&#9670;&nbsp;</a></span>find_and_replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::find_and_replace_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>values_to_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements from <code>input_col</code> according to the mapping <code>values_to_replace</code> to <code>replacement_values</code>, that is, replace all <code>values_to_replace[i]</code> present in <code>input_col</code> with <code>replacement_values[i]</code>. </p>
<p>Replace elements from <code>input_col</code> according to the mapping <code>old_values</code> to <code>new_values</code>, that is, replace all <code>old_values[i]</code> present in <code>col</code> with <code>new_values[i]</code> and return a new gdf_column <code>output</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>gdf_column with the data to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_to_replace</td><td>gdf_column with the old values to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement_values</td><td>gdf_column with the new values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output gdf_column with the modified data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>gdf_column with the data to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_to_replace</td><td>gdf_column with the old values to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement_values</td><td>gdf_column with the new replacement values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output gdf_column with the modified data </dd></dl>

</div>
</div>
<a id="a03f762fbe22ea8e824e426d3880b085a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f762fbe22ea8e824e426d3880b085a">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const&#160;</td>
          <td class="paramname"><em>gather_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> *&#160;</td>
          <td class="paramname"><em>destination_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the rows (including null values) of a set of source columns into a set of destination columns. </p>
<p>The two sets of columns must have equal numbers of columns.</p>
<p>Gathers the rows of the source columns into the destination columns according to a gather map such that row "i" in the destination columns will contain row "gather_map[i]" from the source columns.</p>
<p>The datatypes between coresponding columns in the source and destination columns must be the same.</p>
<p>The number of elements in the gather_map must equal the number of rows in the destination columns.</p>
<p>If any index in the gather_map is outside the range [0, num rows in source_columns), the result is undefined.</p>
<p>If the same index appears more than once in gather_map, the result is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>An array of indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination_table</td><td>A preallocated set of columns with a number of rows equal in size to the number of elements in the gather_map that will contain the rearrangement of the source columns based on the mapping. Can be the same as <code>source_table</code> (in-place gather).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon successful completion </dd></dl>

</div>
</div>
<a id="ad7b0f1bc518e47eaa2cfdd0ec88e3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b0f1bc518e47eaa2cfdd0ec88e3989">&#9670;&nbsp;</a></span>gdf_dtype_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr gdf_dtype cudf::gdf_dtype_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a C++ type to it's corresponding gdf_dtype. </p>
<p>------------------------------------------------------------------------&mdash;* When explicitly passed a template argument of a given type, returns the appropriate <code>gdf_dtype</code> for the specified C++ type.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> gdf_dtype_of&lt;int32_t&gt;();        <span class="comment">// Returns GDF_INT32</span></div><div class="line"><span class="keywordflow">return</span> gdf_dtype_of&lt;cudf::category&gt;(); <span class="comment">// Returns GDF_CATEGORY</span></div></div><!-- fragment --><h2>T The type to map to a <code>gdf_dtype</code> </h2>

</div>
</div>
<a id="ae62151c46119cd04dc146c9e4175375f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62151c46119cd04dc146c9e4175375f">&#9670;&nbsp;</a></span>genericAtomicOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __device__ T cudf::genericAtomicOperation </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>update_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. </p>
<p>----------------------------------------------------------------------&mdash;* The supported cudf types for <code>genericAtomicOperation</code> are: int8_t, int16_t, int32_t, int64_t, float, double, cudf::date32, cudf::date64, cudf::timestamp, cudf::category, cudf::nvstring_category, cudf::bool8</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address of old value in global or shared memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The binary operator used for compute</td></tr>
  </table>
  </dd>
</dl>
<h2>The old value at <code>address</code> </h2>

</div>
</div>
<a id="ada393acb565321d740f2b9950ffe2941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada393acb565321d740f2b9950ffe2941">&#9670;&nbsp;</a></span>has_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::has_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a table contains any null values. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to check for null values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the table contains one or more null values <h2>false If the table contains zero null values </h2>
</dd></dl>

</div>
</div>
<a id="a0d288a83fd8de580d2274f825997cbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d288a83fd8de580d2274f825997cbf3">&#9670;&nbsp;</a></span>have_same_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::have_same_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>validated_column_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>validated_column_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_extra_type_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures two (valid!) columns have the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validated_column_1</td><td>A column which would pass <a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate()</a> . </td></tr>
    <tr><td class="paramname">validated_column_2</td><td>A column which would pass <a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate()</a> . </td></tr>
    <tr><td class="paramname">ignore_extra_type_info</td><td>For some column element types, a column carries some qualifying information which applies to all elements (and thus not repeated for each one). Generally, this information should not be ignored, so that for two columns to have the same type, they must also share it. However, for potential practical reasons (with this being a utility rather than an API function), we allow the extra information to be ignored by setting this parameter to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb570307357da1e8c28cee58d653b5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb570307357da1e8c28cee58d653b5cb">&#9670;&nbsp;</a></span>inferCompressionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cudf::inferCompressionType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compression_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_input_type&#160;</td>
          <td class="paramname"><em>source_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ext_to_compression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the compression type from the compression parameter and the input data. </p>
<p>Infer the compression type from the compression parameter and the input file extension.</p>
<p>------------------------------------------------------------------------&mdash;* Returns "none" if the input is not compressed. Throws if the input is not not valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compression_arg</td><td>Input string that is potentially describing the compression type. Can also be "none" or "infer". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_type</td><td>Enum describing the type of the data source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>If source_type is FILE_PATH, contains the filepath. If source_type is HOST_BUFFER, contains the input JSON data.</td></tr>
  </table>
  </dd>
</dl>
<h2>string representing the compression type. </h2>
<p>------------------------------------------------------------------------&mdash;* Returns "none" if the input is not compressed. Throws if the input is not valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compression_arg</td><td>Input string that is potentially describing the compression type. Can also be "none" or "infer". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_type</td><td>Enum describing the type of the data source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>If source_type is FILE_PATH, contains the filepath. If source_type is HOST_BUFFER, contains the input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext_to_compression</td><td>Map between file extensions and compression types.</td></tr>
  </table>
  </dd>
</dl>
<h2>string representing the compression type. </h2>

</div>
</div>
<a id="a5315ca38e017e2ed42a400483bba3b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5315ca38e017e2ed42a400483bba3b56">&#9670;&nbsp;</a></span>make_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cudf::make_iterator </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_mask::bit_mask_t *&#160;</td>
          <td class="paramname"><em>valid</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>identity</em> = <code>ResultType{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator_Index const&#160;</td>
          <td class="paramname"><em>it</em> = <code>Iterator_Index(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an iterator over the elements of a column. </p>
<p>----------------------------------------------------------------------&mdash;* If the column contains no null values (indicated by <code>has_nulls == false</code>) then dereferencing an iterator <code>it</code> returned by this function as <code>*(it + n)</code> will return <code>ResultType{ static_cast&lt;ElementType*&gt;(data)[n] }</code>.</p>
<p>If the column contains null values (indicated by <code>has_nulls == true</code>) then the result of de-referencing an iterator <code>it</code> returned by this function as <code>*(it+n)</code> will depend if element is valid or null. If the element is valid, it will return <code>ResultType{ static_cast&lt;ElementType*&gt;(data)[n] }</code>. If the element is null, it will return <code>ResultType{identity}</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">has_nulls</td><td>Indicates if the column contains null values (<code>null_count &gt; 0</code>) </td></tr>
    <tr><td class="paramname">ElementType</td><td>The cudf data type of input array </td></tr>
    <tr><td class="paramname">ResultType</td><td>cudf data type of output and <code>identity</code> value which is used when null bitmaps flag is false. </td></tr>
    <tr><td class="paramname">Iterator_Index</td><td>The base iterator which gives the index of array. The default is <code>thrust::counting_iterator</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The pointer of column data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid</td><td>The pointer of null bitmask of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>The identity value used when the mask value is false <h2>it The index iterator, <code>thrust::counting_iterator</code> by default </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b11ec1348ab46ae20792ea4e2c0ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b11ec1348ab46ae20792ea4e2c0ca4">&#9670;&nbsp;</a></span>make_pair_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;gdf_index_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cudf::make_pair_iterator </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_mask::bit_mask_t *&#160;</td>
          <td class="paramname"><em>valid</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>identity</em> = <code>ResultType{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator_Index const&#160;</td>
          <td class="paramname"><em>it</em> = <code>Iterator_Index(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an iterator over the elements of a column Input iterator which can be used for cub and thrust. </p>
<p>----------------------------------------------------------------------&mdash;* The iterator returns thrust::pair&lt;ResultType, bool&gt; This is useful for more complex logic that depends on the validity. e.g. group_by.count, mean_var, sort algorism.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">has_nulls</td><td>True if the data has valid bit mask, False else </td></tr>
    <tr><td class="paramname">ElementType</td><td>The cudf data type of input array </td></tr>
    <tr><td class="paramname">ResultType</td><td>cudf data type of output and <code>identity</code> value which is used when null bitmaps flag is false. </td></tr>
    <tr><td class="paramname">Iterator_Index</td><td>The base iterator which gives the index of array. The default is <code>thrust::counting_iterator</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The pointer of column data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid</td><td>The pointer of null bitmask of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>The identity value used when the mask value is false <h2>it The index iterator, <code>thrust::counting_iterator</code> by default </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30c6e502e3755eefe9a720cdf0f3ed5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c6e502e3755eefe9a720cdf0f3ed5e">&#9670;&nbsp;</a></span>point_in_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::point_in_polygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>polygon_latitudes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>polygon_longitudes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>query_point_latitudes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>query_point_longitudes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether or not coordinates (query points) are completely inside a static polygon. </p>
<p>Note: The polygon must not have holes or intersect with itself, but it is not required to be convex.</p>
<p>The polygon is defined by a set of coordinates (latitudes and longitudes), where the first and last coordinates must have the same value (closed).</p>
<p>This function supports clockwise and counter-clockwise polygons.</p>
<p>If a query point is colinear with two contiguous polygon coordinates then this query point isn't inside.</p>
<p>polygon_latitudes and polygon_longitudes must have equal size.</p>
<p>point_latitudes and point_longitudes must have equal size.</p>
<p>All input params must have equal datatypes (for numeric operations).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon_latitudes</td><td>column with latitudes of a polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polygon_longitudes</td><td>column with longitudes of a polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">query_point_latitudes</td><td>column with latitudes of query points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">query_point_longitudes</td><td>column with longitudes of query points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column of type GDF_BOOL8 indicating whether the i-th query point is inside (true) or not (false) </dd></dl>

</div>
</div>
<a id="a16d269210347c80b2a841daef1a0d136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d269210347c80b2a841daef1a0d136">&#9670;&nbsp;</a></span>reduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> cudf::reduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_reduction_op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>output_dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision <code>dtype</code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> will contain <code>false</code>. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>Input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operator applied by the reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtype</td><td>The computation and output precision. <code>dtype</code> must be a data type that is convertible from the input dtype. If the input column has arithmetic type, any arithmetic type can be specified. If the input column has non-arithmetic type (date32, timestamp, category...), the same type must be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> the result value If the reduction fails, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> <h2>will contain <code>false</code>. </h2>
</dd></dl>

</div>
</div>
<a id="a85645250c7ada0b73a61e9a691931b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85645250c7ada0b73a61e9a691931b36">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::replace_nulls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with corresponding values of another column. </p>
<p>Returns a column <code>output</code> such that if <code>input[i]</code> is valid, its value will be copied to <code>output[i]</code>. Otherwise, <code>replacements[i]</code> will be copied to <code>output[i]</code>.</p>
<p>The <code>input</code> and <code>replacement</code> columns must be of same size and have the same data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A gdf_column containing null values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A gdf_column whose values will replace null values in input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column with nulls replaced </dd></dl>

</div>
</div>
<a id="ad66cc66793473e7fc90ad3ed4cd1b450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66cc66793473e7fc90ad3ed4cd1b450">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::replace_nulls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with a scalar. </p>
<p>Returns a column <code>output</code> such that if <code>input[i]</code> is valid, its value will be copied to <code>output[i]</code>. Otherise, <code>replacement</code> will be coped to <code>output[i]</code>.</p>
<p><code>replacement</code> must have the same data type as <code>input</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A gdf_column containing null values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> whose value will replace null values in input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column with nulls replaced </dd></dl>

</div>
</div>
<a id="aec006bc00092dd8ec47f2c7ca6fe01d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec006bc00092dd8ec47f2c7ca6fe01d4">&#9670;&nbsp;</a></span>row_bitmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_vector&lt; bit_mask::bit_mask_t &gt; cudf::row_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a bitmask indicating the presence of NULL values in rows of a table. </p>
<p>------------------------------------------------------------------------&mdash;* If a row <code>i</code> in <code>table</code> contains one or more NULL values, then bit <code>i</code> in the returned bitmask will be 0.</p>
<p>Otherwise, bit <code>i</code> will be 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to compute the row bitmask of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bit_mask::bit_mask_t* The bitmask indicating the presence of NULLs in <h2>a row </h2>
</dd></dl>

</div>
</div>
<a id="a65546aa9c42e87334fb5e1e3f274bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65546aa9c42e87334fb5e1e3f274bc6b">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_scan_op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column for the san </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The pre-allocated output column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation of the scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inclusive</td><td>The flag for applying an inclusive scan if true, <h2>an exclusive scan if false. </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac30995b318ebee41f1ab8e79dc2527c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30995b318ebee41f1ab8e79dc2527c0">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const&#160;</td>
          <td class="paramname"><em>scatter_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> *&#160;</td>
          <td class="paramname"><em>destination_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows (including null values) of a set of source columns into a set of destination columns. </p>
<p>The two sets of columns must have equal numbers of columns.</p>
<p>Scatters the rows of the source columns into the destination columns according to a scatter map such that row "i" from the source columns will be scattered to row "scatter_map[i]" in the destination columns.</p>
<p>The datatypes between coresponding columns in the source and destination columns must be the same.</p>
<p>The number of elements in the scatter_map must equal the number of rows in the source columns.</p>
<p>If any index in scatter_map is outside the range of [0, num rows in destination_columns), the result is undefined.</p>
<p>If the same index appears more than once in scatter_map, the result is undefined.</p>
<p>[in] source_table The columns whose rows will be scattered [in] scatter_map An array that maps rows in the input columns to rows in the output columns. [out] destination_table A preallocated set of columns with a number of rows equal in size to the maximum index contained in scatter_map</p>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon successful completion </dd></dl>

</div>
</div>
<a id="a31f4a85729765c154b21d8102be5a9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f4a85729765c154b21d8102be5a9d5">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt; cudf::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>num_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a column (including null values) into a set of columns according to a set of indices. </p>
<p>The "slice" function divides part of the input column into multiple intervals of rows using the indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.</p>
<p>The pairs of indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.</p>
<p>Exceptional cases for the indices array are: When the values in the pair are equal, the function returns an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.</p>
<p>The output columns will be allocated by the function.</p>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} indices: {1, 3, 5, 9, 2, 4, 8, 8} output: {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_column</td><td>The input column whose rows will be sliced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>An device array of indices that are used to take 'slices' of the input column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of gdf_column*, each of which may have a different number of rows. a different number of rows that are equal to the difference of two consecutive indices in the indices array. </dd></dl>

</div>
</div>
<a id="a69299f48fdcd25864a2f560e55d18ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69299f48fdcd25864a2f560e55d18ea9">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt; cudf::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>num_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a column (including null values) into a set of columns according to a set of indices. </p>
<p>The "split" function divides the input column into multiple intervals of rows using the indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.</p>
<p>The indices array ('indices') is require to be a monotonic non-decreasing set. The indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.</p>
<p>The split function will take a pair of indices from the indices array ('indices') in a consecutive manner. For the first pair, the function will take the value 0 and the first element of the indices array. For the last pair, the function will take the last element of the indices array and the size of the input column.</p>
<p>Exceptional cases for the indices array are: When the values in the pair are equal, the function return an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.</p>
<p>It is required that the output columns will be preallocated. The size of each of the columns can be of different value. The number of columns must be equal to the number of indices in the array plus one. The datatypes of the input column and the output columns must be the same.</p>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} indices: {2, 5, 9} output: {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_column</td><td>The input column whose rows will be split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>An device array of indices that are used to divide the input column into multiple columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of gdf_column*, each of which may have a different size a different number of rows. </dd></dl>

</div>
</div>
<a id="afa70e889e2b83eba15ed8e8e864dd3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa70e889e2b83eba15ed8e8e864dd3ff">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures a gdf_column is valid, i.e. that its fields are consistent with each other, and logical in themselves, in representing a proper column. </p>
<p>Ensure the input is in a valid state representing a proper column. Specifically, ensures all fields have valid (rather than junk, uninitialized or declared-invalid values), and that they are consistent with each other. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
