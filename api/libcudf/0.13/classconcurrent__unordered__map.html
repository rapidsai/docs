<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: concurrent_unordered_map&lt; Key, Element, Hasher, Equality, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.13</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classconcurrent__unordered__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">concurrent_unordered_map&lt; Key, Element, Hasher, Equality, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a15be29ac740fda141e8db2c2c33bda00"><td class="memItemLeft" align="right" valign="top"><a id="a15be29ac740fda141e8db2c2c33bda00"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = size_t</td></tr>
<tr class="separator:a15be29ac740fda141e8db2c2c33bda00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581d5d4256989cb8ee22ca6983d5d860"><td class="memItemLeft" align="right" valign="top"><a id="a581d5d4256989cb8ee22ca6983d5d860"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = Hasher</td></tr>
<tr class="separator:a581d5d4256989cb8ee22ca6983d5d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d85ffe2842b9e32418b8e30a6fec4de"><td class="memItemLeft" align="right" valign="top"><a id="a9d85ffe2842b9e32418b8e30a6fec4de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = Equality</td></tr>
<tr class="separator:a9d85ffe2842b9e32418b8e30a6fec4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6b4a1962aecb5a1d53074851d61083"><td class="memItemLeft" align="right" valign="top"><a id="a2f6b4a1962aecb5a1d53074851d61083"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:a2f6b4a1962aecb5a1d53074851d61083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e0978afbb7bfedcbada46715edb0a4"><td class="memItemLeft" align="right" valign="top"><a id="a31e0978afbb7bfedcbada46715edb0a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="separator:a31e0978afbb7bfedcbada46715edb0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5546371534d14be85dbb1a0e5500684"><td class="memItemLeft" align="right" valign="top"><a id="af5546371534d14be85dbb1a0e5500684"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = Element</td></tr>
<tr class="separator:af5546371534d14be85dbb1a0e5500684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c704efc0d8856231691500b60833013"><td class="memItemLeft" align="right" valign="top"><a id="a8c704efc0d8856231691500b60833013"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = thrust::pair&lt; Key, Element &gt;</td></tr>
<tr class="separator:a8c704efc0d8856231691500b60833013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b61d6437f8b2005bc106bf8fe7051"><td class="memItemLeft" align="right" valign="top"><a id="ae27b61d6437f8b2005bc106bf8fe7051"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classcycle__iterator__adapter.html">cycle_iterator_adapter</a>&lt; value_type * &gt;</td></tr>
<tr class="separator:ae27b61d6437f8b2005bc106bf8fe7051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc79382c07bb16ed8f7dceb8e864ee44"><td class="memItemLeft" align="right" valign="top"><a id="acc79382c07bb16ed8f7dceb8e864ee44"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = const <a class="el" href="classcycle__iterator__adapter.html">cycle_iterator_adapter</a>&lt; value_type * &gt;</td></tr>
<tr class="separator:acc79382c07bb16ed8f7dceb8e864ee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10bd43ed2cf6c7dff722e2a41ac4c6a1"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#a10bd43ed2cf6c7dff722e2a41ac4c6a1">begin</a> ()</td></tr>
<tr class="memdesc:a10bd43ed2cf6c7dff722e2a41ac4c6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element in the map.  <a href="classconcurrent__unordered__map.html#a10bd43ed2cf6c7dff722e2a41ac4c6a1">More...</a><br /></td></tr>
<tr class="separator:a10bd43ed2cf6c7dff722e2a41ac4c6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fa4a74a9a0a560a22b60daa6bc1d58"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#a39fa4a74a9a0a560a22b60daa6bc1d58">begin</a> () const</td></tr>
<tr class="memdesc:a39fa4a74a9a0a560a22b60daa6bc1d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element in the map.  <a href="classconcurrent__unordered__map.html#a39fa4a74a9a0a560a22b60daa6bc1d58">More...</a><br /></td></tr>
<tr class="separator:a39fa4a74a9a0a560a22b60daa6bc1d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c37fe63c20c8bd3fcf78e426750c0f7"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#a4c37fe63c20c8bd3fcf78e426750c0f7">end</a> ()</td></tr>
<tr class="memdesc:a4c37fe63c20c8bd3fcf78e426750c0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the one past the last element in the map.  <a href="classconcurrent__unordered__map.html#a4c37fe63c20c8bd3fcf78e426750c0f7">More...</a><br /></td></tr>
<tr class="separator:a4c37fe63c20c8bd3fcf78e426750c0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9835c42f992c4d32fc3aa43747e3a2"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#a0a9835c42f992c4d32fc3aa43747e3a2">end</a> () const</td></tr>
<tr class="memdesc:a0a9835c42f992c4d32fc3aa43747e3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the one past the last element in the map.  <a href="classconcurrent__unordered__map.html#a0a9835c42f992c4d32fc3aa43747e3a2">More...</a><br /></td></tr>
<tr class="separator:a0a9835c42f992c4d32fc3aa43747e3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1bb85456d9ee8da36cf16c72090316"><td class="memItemLeft" align="right" valign="top"><a id="a2e1bb85456d9ee8da36cf16c72090316"></a>
__host__ __device__ value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="separator:a2e1bb85456d9ee8da36cf16c72090316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386cfcc96eddb8a7bfe2cc5f44fdf08f"><td class="memItemLeft" align="right" valign="top"><a id="a386cfcc96eddb8a7bfe2cc5f44fdf08f"></a>
__host__ __device__ key_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_unused_key</b> () const</td></tr>
<tr class="separator:a386cfcc96eddb8a7bfe2cc5f44fdf08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c3f013fc274cc4d1019db12a25615b"><td class="memItemLeft" align="right" valign="top"><a id="a90c3f013fc274cc4d1019db12a25615b"></a>
__host__ __device__ mapped_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_unused_element</b> () const</td></tr>
<tr class="separator:a90c3f013fc274cc4d1019db12a25615b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260897d53dc9e5d3188b4d0d110af072"><td class="memItemLeft" align="right" valign="top"><a id="a260897d53dc9e5d3188b4d0d110af072"></a>
__host__ __device__ size_type&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const</td></tr>
<tr class="separator:a260897d53dc9e5d3188b4d0d110af072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc67451d9ec7643eb22d9a06703974e3"><td class="memItemLeft" align="right" valign="top">__device__ thrust::pair&lt; <a class="el" href="classcycle__iterator__adapter.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#afc67451d9ec7643eb22d9a06703974e3">insert</a> (value_type const &amp;insert_pair)</td></tr>
<tr class="memdesc:afc67451d9ec7643eb22d9a06703974e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert a key, value pair into the map.  <a href="classconcurrent__unordered__map.html#afc67451d9ec7643eb22d9a06703974e3">More...</a><br /></td></tr>
<tr class="separator:afc67451d9ec7643eb22d9a06703974e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0639cdcc2dbd60d21393b642073275b"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#af0639cdcc2dbd60d21393b642073275b">find</a> (key_type const &amp;k) const</td></tr>
<tr class="memdesc:af0639cdcc2dbd60d21393b642073275b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the map for the specified key.  <a href="classconcurrent__unordered__map.html#af0639cdcc2dbd60d21393b642073275b">More...</a><br /></td></tr>
<tr class="separator:af0639cdcc2dbd60d21393b642073275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff6a168974f29bfff690496f1fc1b3e"><td class="memTemplParams" colspan="2">template&lt;typename find_hasher , typename find_key_equal &gt; </td></tr>
<tr class="memitem:a7ff6a168974f29bfff690496f1fc1b3e"><td class="memTemplItemLeft" align="right" valign="top">__device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#a7ff6a168974f29bfff690496f1fc1b3e">find</a> (key_type const &amp;k, find_hasher f_hash, find_key_equal f_equal) const</td></tr>
<tr class="memdesc:a7ff6a168974f29bfff690496f1fc1b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the map for the specified key.  <a href="classconcurrent__unordered__map.html#a7ff6a168974f29bfff690496f1fc1b3e">More...</a><br /></td></tr>
<tr class="separator:a7ff6a168974f29bfff690496f1fc1b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a0322180d742a5a360232de945d14"><td class="memItemLeft" align="right" valign="top"><a id="abf7a0322180d742a5a360232de945d14"></a>
gdf_error&#160;</td><td class="memItemRight" valign="bottom"><b>assign_async</b> (const <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a> &amp;other, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="separator:abf7a0322180d742a5a360232de945d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108ec53968255d1b2c9b02a8ec94e18a"><td class="memItemLeft" align="right" valign="top"><a id="a108ec53968255d1b2c9b02a8ec94e18a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_async</b> (<a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="separator:a108ec53968255d1b2c9b02a8ec94e18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87b556b261f140df1ac4906ec10d1f7"><td class="memItemLeft" align="right" valign="top"><a id="ad87b556b261f140df1ac4906ec10d1f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> ()</td></tr>
<tr class="separator:ad87b556b261f140df1ac4906ec10d1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12873068796732a1a39eeea34125c6e"><td class="memItemLeft" align="right" valign="top"><a id="ab12873068796732a1a39eeea34125c6e"></a>
gdf_error&#160;</td><td class="memItemRight" valign="bottom"><b>prefetch</b> (const int dev_id, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="separator:ab12873068796732a1a39eeea34125c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b44f3983e78757ef025363c9544a4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#a1b44f3983e78757ef025363c9544a4fb">destroy</a> (<a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a1b44f3983e78757ef025363c9544a4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the contents of the map and destroys the map object.  <a href="classconcurrent__unordered__map.html#a1b44f3983e78757ef025363c9544a4fb">More...</a><br /></td></tr>
<tr class="separator:a1b44f3983e78757ef025363c9544a4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16fc1881a921163b6932fcf564a04b5"><td class="memItemLeft" align="right" valign="top"><a id="ab16fc1881a921163b6932fcf564a04b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>concurrent_unordered_map</b> (<a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a> const &amp;)=default</td></tr>
<tr class="separator:ab16fc1881a921163b6932fcf564a04b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727ae80425fb08ed2a9f5fb5ce793570"><td class="memItemLeft" align="right" valign="top"><a id="a727ae80425fb08ed2a9f5fb5ce793570"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>concurrent_unordered_map</b> (<a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a727ae80425fb08ed2a9f5fb5ce793570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcab99dd415139db877a9d1de8d07311"><td class="memItemLeft" align="right" valign="top"><a id="adcab99dd415139db877a9d1de8d07311"></a>
<a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a> const &amp;)=default</td></tr>
<tr class="separator:adcab99dd415139db877a9d1de8d07311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789bd02db6047618b74fba276bba0437"><td class="memItemLeft" align="right" valign="top"><a id="a789bd02db6047618b74fba276bba0437"></a>
<a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a789bd02db6047618b74fba276bba0437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4ec2ebb3baca5a6c8c3744bec40845bf"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf">create</a> (size_type capacity, const mapped_type unused_element=std::numeric_limits&lt; key_type &gt;::max(), const key_type unused_key=std::numeric_limits&lt; key_type &gt;::max(), const Hasher &amp;hash_function=hasher(), const Equality &amp;equal=key_equal(), const allocator_type &amp;allocator=allocator_type(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a4ec2ebb3baca5a6c8c3744bec40845bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to construct a new concurrent unordered map.  <a href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf">More...</a><br /></td></tr>
<tr class="separator:a4ec2ebb3baca5a6c8c3744bec40845bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Element, typename Hasher = default_hash&lt;Key&gt;, typename Equality = equal_to&lt;Key&gt;, typename Allocator = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt;<br />
class concurrent_unordered_map&lt; Key, Element, Hasher, Equality, Allocator &gt;</h3>

<p>Supports concurrent insert, but not concurrent insert and find.</p>
<dl class="section note"><dt>Note</dt><dd>The user is responsible for the following stream semantics:<ul>
<li>Either the same stream should be used to create the map as is used by the kernels that access it, or</li>
<li>the stream used to create the map should be synchronized before it is accessed from a different stream or from host code.</li>
</ul>
</dd></dl>
<p>TODO:</p><ul>
<li>add constructor that takes pointer to hash_table to avoid allocations </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a10bd43ed2cf6c7dff722e2a41ac4c6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bd43ed2cf6c7dff722e2a41ac4c6a1">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a> <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element in the map. </p>
<dl class="section note"><dt>Note</dt><dd><code>__device__</code> code that calls this function should either run in the same stream as <code><a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf" title="Factory to construct a new concurrent unordered map.">create()</a></code>, or the accessing stream either be running on the same stream as <a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf" title="Factory to construct a new concurrent unordered map.">create()</a>, or the accessing stream should be appropriately synchronized with the creating stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element in the map. </dd></dl>

</div>
</div>
<a id="a39fa4a74a9a0a560a22b60daa6bc1d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fa4a74a9a0a560a22b60daa6bc1d58">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a> <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element in the map. </p>
<dl class="section note"><dt>Note</dt><dd><code>__device__</code> code that calls this function should either run in the same stream as <code><a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf" title="Factory to construct a new concurrent unordered map.">create()</a></code>, or the accessing stream either be running on the same stream as <a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf" title="Factory to construct a new concurrent unordered map.">create()</a>, or the accessing stream should be appropriately synchronized with the creating stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>constant iterator to the first element in the map. </dd></dl>

</div>
</div>
<a id="a4ec2ebb3baca5a6c8c3744bec40845bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec2ebb3baca5a6c8c3744bec40845bf">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::create </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mapped_type&#160;</td>
          <td class="paramname"><em>unused_element</em> = <code>std::numeric_limits&lt;key_type&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type&#160;</td>
          <td class="paramname"><em>unused_key</em> = <code>std::numeric_limits&lt;key_type&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hasher &amp;&#160;</td>
          <td class="paramname"><em>hash_function</em> = <code>hasher()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Equality &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>key_equal()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>allocator_type()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory to construct a new concurrent unordered map. </p>
<p>------------------------------------------------------------------------&mdash;* Returns a <code>std::unique_ptr</code> to a new concurrent unordered map object. The map is non-owning and trivially copyable and should be passed by value into kernels. The <code>unique_ptr</code> contains a custom deleter that will free the map's contents.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of this unordered_map uses sentinel values to indicate an entry in the hash table that is empty, i.e., if a hash bucket is empty, the pair residing there will be equal to (unused_key, unused_element). As a result, attempting to insert a key equal to <code>unused_key</code> results in undefined behavior.</dd>
<dd>
All allocations, kernels and copies in the constructor take place on stream but the constructor does not synchronize the stream. It is the user's responsibility to synchronize or use the same stream to access the map.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The maximum number of pairs the map may hold </td></tr>
    <tr><td class="paramname">unused_element</td><td>The sentinel value to use for an empty value </td></tr>
    <tr><td class="paramname">unused_key</td><td>The sentinel value to use for an empty key </td></tr>
    <tr><td class="paramname">hash_function</td><td>The hash function to use for hashing keys </td></tr>
    <tr><td class="paramname">equal</td><td>The equality comparison function for comparing if two keys are equal </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for allocation the hash table's storage </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md57"></a>
@param stream CUDA stream to use for device operations.</h2>

</div>
</div>
<a id="a1b44f3983e78757ef025363c9544a4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b44f3983e78757ef025363c9544a4fb">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the contents of the map and destroys the map object. </p>
<p>------------------------------------------------------------------------&mdash;* This function is invoked as the deleter of the <code>std::unique_ptr</code> returned from the <code><a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf" title="Factory to construct a new concurrent unordered map.">create()</a></code> factory function.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
@param stream CUDA stream to use for device operations.</h2>

</div>
</div>
<a id="a4c37fe63c20c8bd3fcf78e426750c0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c37fe63c20c8bd3fcf78e426750c0f7">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a> <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the one past the last element in the map. </p>
<dl class="section note"><dt>Note</dt><dd><code>__device__</code> code that calls this function should either run in the same stream as <code><a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf" title="Factory to construct a new concurrent unordered map.">create()</a></code>, or the accessing stream either be running on the same stream as <a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf" title="Factory to construct a new concurrent unordered map.">create()</a>, or the accessing stream should be appropriately synchronized with the creating stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the one past the last element in the map. </dd></dl>

</div>
</div>
<a id="a0a9835c42f992c4d32fc3aa43747e3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9835c42f992c4d32fc3aa43747e3a2">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a> <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the one past the last element in the map. </p>
<dl class="section note"><dt>Note</dt><dd>When called in a device code, user should make sure that it should either be running on the same stream as <a class="el" href="classconcurrent__unordered__map.html#a4ec2ebb3baca5a6c8c3744bec40845bf" title="Factory to construct a new concurrent unordered map.">create()</a>, or the accessing stream should be appropriately synchronized with the creating stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>constant iterator to the one past the last element in the map. </dd></dl>

</div>
</div>
<a id="af0639cdcc2dbd60d21393b642073275b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0639cdcc2dbd60d21393b642073275b">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a> <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">key_type const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the map for the specified key. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="section note"><dt>Note</dt><dd><code>find</code> is not threadsafe with <code>insert</code>. I.e., it is not safe to do concurrent <code>insert</code> and <code>find</code> operations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md62"></a>
@return An iterator to the key if it exists, else map.end()</h2>

</div>
</div>
<a id="a7ff6a168974f29bfff690496f1fc1b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff6a168974f29bfff690496f1fc1b3e">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename find_hasher , typename find_key_equal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a> <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">key_type const &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">find_hasher&#160;</td>
          <td class="paramname"><em>f_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">find_key_equal&#160;</td>
          <td class="paramname"><em>f_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the map for the specified key. </p>
<p>------------------------------------------------------------------------&mdash;* This version of the find function specifies a hashing function and an equality comparison. This allows the caller to use different functions for insert and find (for example, when you want to insert keys from one table and use find to match keys from a different table with the keys from the first table).</p>
<dl class="section note"><dt>Note</dt><dd><code>find</code> is not threadsafe with <code>insert</code>. I.e., it is not safe to do concurrent <code>insert</code> and <code>find</code> operations.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">find_hasher</td><td>Type of hashing function </td></tr>
    <tr><td class="paramname">find_key_equal</td><td>Type of equality comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for </td></tr>
    <tr><td class="paramname">f_hash</td><td>The hashing function to use to hash this key </td></tr>
    <tr><td class="paramname">f_equal</td><td>The equality function to use to compare this key with the contents of the hash table </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md63"></a>
@return An iterator to the key if it exists, else map.end()</h2>

</div>
</div>
<a id="afc67451d9ec7643eb22d9a06703974e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc67451d9ec7643eb22d9a06703974e3">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = default_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ thrust::pair&lt;<a class="el" href="classcycle__iterator__adapter.html">iterator</a>, bool&gt; <a class="el" href="classconcurrent__unordered__map.html">concurrent_unordered_map</a>&lt; Key, Element, Hasher, Equality, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>insert_pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a key, value pair into the map. </p>
<p>------------------------------------------------------------------------&mdash;* Returns an iterator, boolean pair.</p>
<p>If the new key already present in the map, the iterator points to the location of the existing key and the boolean is <code>false</code> indicating that the insert did not succeed.</p>
<p>If the new key was not present, the iterator points to the location where the insert occured and the boolean is <code>true</code> indicating that the insert succeeded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_pair</td><td>The key and value pair to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator, Boolean pair. Iterator is to the location of the newly inserted pair, or the existing pair that prevented the insert. </dd></dl>
<h2><a class="anchor" id="autotoc_md61"></a>
Boolean indicates insert success.</h2>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>concurrent_unordered_map.cuh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
