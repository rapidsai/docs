<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcudf: Copying</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (22.12)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (23.04)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (23.02)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/legacy/namespacecudf.html">legacy (22.12)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> |
<a href="#files">Files</a> |
<a href="#nested-classes">Classes</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Copying<div class="ingroups"><a class="el" href="group__column__apis.html">Column and Table</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__copy__concatenate"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__concatenate.html">Concatenating</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:group__copy__gather"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__gather.html">Gathering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:group__copy__scatter"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__scatter.html">Scattering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:group__copy__slice"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__slice.html">Slicing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:group__copy__split"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__split.html">Splitting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:group__copy__shift"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__shift.html">Shifting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:copying_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="copying_8hpp.html">copying.hpp</a></td></tr>
<tr class="memdesc:copying_8hpp"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Column APIs for gather, scatter, split, slice, etc. <br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1packed__columns.html">cudf::packed_columns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Column data in a serialized format.  <a href="structcudf_1_1packed__columns.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1packed__table.html">cudf::packed_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The result(s) of a <a class="el" href="group__copy__split.html#gac18c9d14c64d737598fc4276915b482e" title="Performs a deep-copy split of a table_view into a set of table_views into a single contiguous block o...">cudf::contiguous_split</a>.  <a href="structcudf_1_1packed__table.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae3ba74951558bc7966aae86abc6af5df"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">cudf::out_of_bounds_policy</a> : bool { <a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfacac2cdaff9b4ab3bcda3b538a86f9edb">cudf::out_of_bounds_policy::NULLIFY</a>, 
<a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d">cudf::out_of_bounds_policy::DONT_CHECK</a>
 }</td></tr>
<tr class="memdesc:gae3ba74951558bc7966aae86abc6af5df"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy to account for possible out-of-bounds indices.  <a href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">More...</a><br></td></tr>
<tr class="separator:gae3ba74951558bc7966aae86abc6af5df"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga267e03474dcfd85242d2fdc6e5846ec6"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">cudf::mask_allocation_policy</a> { <a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a443475558f0168dff92ecde26b98ae5a">cudf::mask_allocation_policy::NEVER</a>, 
<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">cudf::mask_allocation_policy::RETAIN</a>, 
<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6af3fc827ade4b968e50406496907ef962">cudf::mask_allocation_policy::ALWAYS</a>
 }</td></tr>
<tr class="memdesc:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates when to allocate a mask, based on an existing mask.  <a href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">More...</a><br></td></tr>
<tr class="separator:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gae7607cde56cb602ab1b198b5bebf7cba"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">cudf::sample_with_replacement</a> : bool { <a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc">cudf::sample_with_replacement::FALSE</a>, 
<a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaac0d83f0b82a6b30de8811e69e6d95c61">cudf::sample_with_replacement::TRUE</a>
 }</td></tr>
<tr class="memdesc:gae7607cde56cb602ab1b198b5bebf7cba"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether a row can be sampled more than once.  <a href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">More...</a><br></td></tr>
<tr class="separator:gae7607cde56cb602ab1b198b5bebf7cba"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga88cdbe94ceaa7683562315e524f3cb21"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga88cdbe94ceaa7683562315e524f3cb21">cudf::reverse</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source_table, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga88cdbe94ceaa7683562315e524f3cb21"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverses the rows within a table.  <a href="group__column__copy.html#ga88cdbe94ceaa7683562315e524f3cb21">More...</a><br></td></tr>
<tr class="separator:ga88cdbe94ceaa7683562315e524f3cb21"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga684cd03cda3c33a42de7e37e4231401a"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga684cd03cda3c33a42de7e37e4231401a">cudf::reverse</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source_column, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga684cd03cda3c33a42de7e37e4231401a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverses the elements of a column.  <a href="group__column__copy.html#ga684cd03cda3c33a42de7e37e4231401a">More...</a><br></td></tr>
<tr class="separator:ga684cd03cda3c33a42de7e37e4231401a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga0e09ded998662935b453cf161c752e5c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga0e09ded998662935b453cf161c752e5c">cudf::empty_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga0e09ded998662935b453cf161c752e5c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes and returns an empty column of the same type as the <code>input</code>.  <a href="group__column__copy.html#ga0e09ded998662935b453cf161c752e5c">More...</a><br></td></tr>
<tr class="separator:ga0e09ded998662935b453cf161c752e5c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gadc1f5097200632d94c63bf50f04a367c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gadc1f5097200632d94c63bf50f04a367c">cudf::empty_like</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;input)</td></tr>
<tr class="memdesc:gadc1f5097200632d94c63bf50f04a367c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes and returns an empty column of the same type as the <code>input</code>.  <a href="group__column__copy.html#gadc1f5097200632d94c63bf50f04a367c">More...</a><br></td></tr>
<tr class="separator:gadc1f5097200632d94c63bf50f04a367c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga11bdde9e4782a83845ff97a0da5d6894"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga11bdde9e4782a83845ff97a0da5d6894">cudf::allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=mask_allocation_policy::RETAIN, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga11bdde9e4782a83845ff97a0da5d6894"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an uninitialized new column of the same size and type as the <code>input</code>.  <a href="group__column__copy.html#ga11bdde9e4782a83845ff97a0da5d6894">More...</a><br></td></tr>
<tr class="separator:ga11bdde9e4782a83845ff97a0da5d6894"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga735c8dd32ebfbf05638095afa51eba9d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga735c8dd32ebfbf05638095afa51eba9d">cudf::allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=mask_allocation_policy::RETAIN, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga735c8dd32ebfbf05638095afa51eba9d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an uninitialized new column of the specified size and same type as the <code>input</code>.  <a href="group__column__copy.html#ga735c8dd32ebfbf05638095afa51eba9d">More...</a><br></td></tr>
<tr class="separator:ga735c8dd32ebfbf05638095afa51eba9d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf882e46ff3f8447ec3cf315d74fe180f"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf882e46ff3f8447ec3cf315d74fe180f">cudf::empty_like</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table)</td></tr>
<tr class="memdesc:gaf882e46ff3f8447ec3cf315d74fe180f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a table of empty columns with the same types as the <code>input_table</code>  <a href="group__column__copy.html#gaf882e46ff3f8447ec3cf315d74fe180f">More...</a><br></td></tr>
<tr class="separator:gaf882e46ff3f8447ec3cf315d74fe180f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf7453a32aa49fd9a55287a776f2b4b2f"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf7453a32aa49fd9a55287a776f2b4b2f">cudf::copy_range_in_place</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source, <a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;target, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_end, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> target_begin)</td></tr>
<tr class="memdesc:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a range of elements in-place from one column to another.  <a href="group__column__copy.html#gaf7453a32aa49fd9a55287a776f2b4b2f">More...</a><br></td></tr>
<tr class="separator:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaac8fd5edd4c310f32b455244eb3a69e4"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaac8fd5edd4c310f32b455244eb3a69e4">cudf::copy_range</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;target, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_end, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> target_begin, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gaac8fd5edd4c310f32b455244eb3a69e4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a range of elements out-of-place from one column to another.  <a href="group__column__copy.html#gaac8fd5edd4c310f32b455244eb3a69e4">More...</a><br></td></tr>
<tr class="separator:gaac8fd5edd4c310f32b455244eb3a69e4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaeb39dd8301fb76bfec9e777820bda3f2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2">cudf::pack</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gaeb39dd8301fb76bfec9e777820bda3f2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep-copy a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> into a serialized contiguous memory format.  <a href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2">More...</a><br></td></tr>
<tr class="separator:gaeb39dd8301fb76bfec9e777820bda3f2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gab28fc2d2294f2840df37814e7a4aa582"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structcudf_1_1packed__columns_1_1metadata.html">packed_columns::metadata</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab28fc2d2294f2840df37814e7a4aa582">cudf::pack_metadata</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;<a class="el" href="classcudf_1_1table.html">table</a>, uint8_t const *contiguous_buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:gab28fc2d2294f2840df37814e7a4aa582"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produce the metadata used for packing a table stored in a contiguous buffer.  <a href="group__column__copy.html#gab28fc2d2294f2840df37814e7a4aa582">More...</a><br></td></tr>
<tr class="separator:gab28fc2d2294f2840df37814e7a4aa582"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga1d62a18c2e6f087a92289c63693762cc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga1d62a18c2e6f087a92289c63693762cc">cudf::unpack</a> (<a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a> const &amp;input)</td></tr>
<tr class="memdesc:ga1d62a18c2e6f087a92289c63693762cc"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format.">cudf::pack</a></code>  <a href="group__column__copy.html#ga1d62a18c2e6f087a92289c63693762cc">More...</a><br></td></tr>
<tr class="separator:ga1d62a18c2e6f087a92289c63693762cc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaaaebfb6742c09cccda8fb8a78e19fbd6">cudf::unpack</a> (uint8_t const *metadata, uint8_t const *gpu_data)</td></tr>
<tr class="memdesc:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format.">cudf::pack</a></code>  <a href="group__column__copy.html#gaaaebfb6742c09cccda8fb8a78e19fbd6">More...</a><br></td></tr>
<tr class="separator:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gab08aeaceb95ca962b4ddb5b4a471da4c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab08aeaceb95ca962b4ddb5b4a471da4c">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gab08aeaceb95ca962b4ddb5b4a471da4c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="group__column__copy.html#gab08aeaceb95ca962b4ddb5b4a471da4c">More...</a><br></td></tr>
<tr class="separator:gab08aeaceb95ca962b4ddb5b4a471da4c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga3e0d11f978be0b2e9a95b0252fe8fd17"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga3e0d11f978be0b2e9a95b0252fe8fd17">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga3e0d11f978be0b2e9a95b0252fe8fd17"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="group__column__copy.html#ga3e0d11f978be0b2e9a95b0252fe8fd17">More...</a><br></td></tr>
<tr class="separator:ga3e0d11f978be0b2e9a95b0252fe8fd17"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaa1787664ecc9439c5a8b963d334491ab"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaa1787664ecc9439c5a8b963d334491ab">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gaa1787664ecc9439c5a8b963d334491ab"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="group__column__copy.html#gaa1787664ecc9439c5a8b963d334491ab">More...</a><br></td></tr>
<tr class="separator:gaa1787664ecc9439c5a8b963d334491ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gafc7251a332092ac4506b1da4448e686d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gafc7251a332092ac4506b1da4448e686d">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gafc7251a332092ac4506b1da4448e686d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="group__column__copy.html#gafc7251a332092ac4506b1da4448e686d">More...</a><br></td></tr>
<tr class="separator:gafc7251a332092ac4506b1da4448e686d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gafdb8ce94112a0353af61119497c1b6ee"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gafdb8ce94112a0353af61119497c1b6ee">cudf::get_element</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> index, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gafdb8ce94112a0353af61119497c1b6ee"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the element at specified index from a column.  <a href="group__column__copy.html#gafdb8ce94112a0353af61119497c1b6ee">More...</a><br></td></tr>
<tr class="separator:gafdb8ce94112a0353af61119497c1b6ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gaf2c879c97a852fdf113781d63a303aa7"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf2c879c97a852fdf113781d63a303aa7">cudf::sample</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const n, <a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a> replacement=sample_with_replacement::FALSE, int64_t const seed=0, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gaf2c879c97a852fdf113781d63a303aa7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gather <code>n</code> samples from given <code>input</code> randomly.  <a href="group__column__copy.html#gaf2c879c97a852fdf113781d63a303aa7">More...</a><br></td></tr>
<tr class="separator:gaf2c879c97a852fdf113781d63a303aa7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga0c61528cb588874f9c07c6f766f232db"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga0c61528cb588874f9c07c6f766f232db">cudf::has_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga0c61528cb588874f9c07c6f766f232db"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a column or its descendants have non-empty null rows.  <a href="group__column__copy.html#ga0c61528cb588874f9c07c6f766f232db">More...</a><br></td></tr>
<tr class="separator:ga0c61528cb588874f9c07c6f766f232db"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga9a9c46582ed07509d4bfe24e50d59bf2"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9a9c46582ed07509d4bfe24e50d59bf2">cudf::may_have_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga9a9c46582ed07509d4bfe24e50d59bf2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximates if a column or its descendants <em>may</em> have non-empty null elements.  <a href="group__column__copy.html#ga9a9c46582ed07509d4bfe24e50d59bf2">More...</a><br></td></tr>
<tr class="separator:ga9a9c46582ed07509d4bfe24e50d59bf2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gad82144bc75451067a2a8718b8d6cc03a"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gad82144bc75451067a2a8718b8d6cc03a">cudf::purge_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gad82144bc75451067a2a8718b8d6cc03a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy <code>input</code> into output while purging any non-empty null rows in the column or its descendants.  <a href="group__column__copy.html#gad82144bc75451067a2a8718b8d6cc03a">More...</a><br></td></tr>
<tr class="separator:gad82144bc75451067a2a8718b8d6cc03a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga267e03474dcfd85242d2fdc6e5846ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267e03474dcfd85242d2fdc6e5846ec6">◆&nbsp;</a></span>mask_allocation_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">cudf::mask_allocation_policy</a></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Indicates when to allocate a mask, based on an existing mask. </p>
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6a443475558f0168dff92ecde26b98ae5a"></a>NEVER&nbsp;</td><td class="fielddoc"><p>Do not allocate a null mask, regardless of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4"></a>RETAIN&nbsp;</td><td class="fielddoc"><p>Allocate a null mask if the input contains one. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6af3fc827ade4b968e50406496907ef962"></a>ALWAYS&nbsp;</td><td class="fielddoc"><p>Allocate a null mask, regardless of input. </p>
</td></tr>
</tbody></table>

<p class="definition">Definition at line <a class="el" href="copying_8hpp_source.html#l00204">204</a> of file <a class="el" href="copying_8hpp_source.html">copying.hpp</a>.</p>

</div>
</div>
<a id="gae3ba74951558bc7966aae86abc6af5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ba74951558bc7966aae86abc6af5df">◆&nbsp;</a></span>out_of_bounds_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">cudf::out_of_bounds_policy</a> : bool</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Policy to account for possible out-of-bounds indices. </p>
<p><code>NULLIFY</code> means to nullify output values corresponding to out-of-bounds gather_map values. <code>DONT_CHECK</code> means do not check whether the indices are out-of-bounds, for better performance. </p>
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae3ba74951558bc7966aae86abc6af5dfacac2cdaff9b4ab3bcda3b538a86f9edb"></a>NULLIFY&nbsp;</td><td class="fielddoc"><p>Output values corresponding to out-of-bounds indices are null. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d"></a>DONT_CHECK&nbsp;</td><td class="fielddoc"><p>No bounds checking is performed, better performance. </p>
</td></tr>
</tbody></table>

<p class="definition">Definition at line <a class="el" href="copying_8hpp_source.html#l00048">48</a> of file <a class="el" href="copying_8hpp_source.html">copying.hpp</a>.</p>

</div>
</div>
<a id="gae7607cde56cb602ab1b198b5bebf7cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7607cde56cb602ab1b198b5bebf7cba">◆&nbsp;</a></span>sample_with_replacement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">cudf::sample_with_replacement</a> : bool</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Indicates whether a row can be sampled more than once. </p>
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc"></a>FALSE&nbsp;</td><td class="fielddoc"><p>A row can be sampled only once. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7607cde56cb602ab1b198b5bebf7cbaac0d83f0b82a6b30de8811e69e6d95c61"></a>TRUE&nbsp;</td><td class="fielddoc"><p>A row can be sampled more than once. </p>
</td></tr>
</tbody></table>

<p class="definition">Definition at line <a class="el" href="copying_8hpp_source.html#l00933">933</a> of file <a class="el" href="copying_8hpp_source.html">copying.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga11bdde9e4782a83845ff97a0da5d6894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11bdde9e4782a83845ff97a0da5d6894">◆&nbsp;</a></span>allocate_like() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&nbsp;</td>
          <td class="paramname"><em>mask_alloc</em> = <code>mask_allocation_policy::RETAIN</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the same size and type as the <code>input</code>. </p>
<p>Supports only fixed-width types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A column with sufficient uninitialized capacity to hold the same number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>

</div>
</div>
<a id="ga735c8dd32ebfbf05638095afa51eba9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga735c8dd32ebfbf05638095afa51eba9d">◆&nbsp;</a></span>allocate_like() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&nbsp;</td>
          <td class="paramname"><em>mask_alloc</em> = <code>mask_allocation_policy::RETAIN</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the specified size and same type as the <code>input</code>. </p>
<p>Supports only fixed-width types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The desired number of elements that the new column should have capacity for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A column with sufficient uninitialized capacity to hold the specified number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>

</div>
</div>
<a id="gab08aeaceb95ca962b4ddb5b4a471da4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab08aeaceb95ca962b4ddb5b4a471da4c">◆&nbsp;</a></span>copy_if_else() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs[i] : rhs[i]</code></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same length </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs and rhs </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code>type_id::BOOL8</code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="gaa1787664ecc9439c5a8b963d334491ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1787664ecc9439c5a8b963d334491ab">◆&nbsp;</a></span>copy_if_else() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs[i] : rhs</code></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code>type_id::BOOL8</code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="ga3e0d11f978be0b2e9a95b0252fe8fd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e0d11f978be0b2e9a95b0252fe8fd17">◆&nbsp;</a></span>copy_if_else() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs : rhs[i]</code></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as rhs </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code>type_id::BOOL8</code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="gafc7251a332092ac4506b1da4448e686d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7251a332092ac4506b1da4448e686d">◆&nbsp;</a></span>copy_if_else() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs : rhs</code></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code>type_id::BOOL8</code> representing "left (true) / right (false)" boolean for each element. null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="gaac8fd5edd4c310f32b455244eb3a69e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac8fd5edd4c310f32b455244eb3a69e4">◆&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>target_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies a range of elements out-of-place from one column to another. </p>
<p>Creates a new column as if an in-place copy was performed into <code>target</code>. A copy of <code>target</code> is created first and then the elements indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) were copied from the elements indicated by the indices [<code>source_begin</code>, <code>source_end</code>) of <code>source</code> (where N = (<code>source_end</code> - <code>source_begin</code>)). Elements outside the range are copied from <code>target</code> into the returned new column target.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>target</code> and <code>source</code> have different types.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">source</td><td>The column to copy from inside the range </td></tr>
    <tr><td class="paramname">target</td><td>The column to copy from outside the range </td></tr>
    <tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
    <tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
    <tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; The result target column </dd></dl>

</div>
</div>
<a id="gaf7453a32aa49fd9a55287a776f2b4b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7453a32aa49fd9a55287a776f2b4b2f">◆&nbsp;</a></span>copy_range_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void cudf::copy_range_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;&nbsp;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>target_begin</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copies a range of elements in-place from one column to another. </p>
<p>Overwrites the range of elements in <code>target</code> indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) with the elements from <code>source</code> indicated by the indices [<code>source_begin</code>, <code>source_end</code>) (where N = (<code>source_end</code> - <code>source_begin</code>)). Use the out-of-place copy function returning std::unique_ptr&lt;column&gt; for uses cases requiring memory reallocation. For example for strings columns and other variable-width types.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if memory reallocation is required (e.g. for variable width types). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>target</code> and <code>source</code> have different types. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>source</code> has null values and <code>target</code> is not nullable.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">source</td><td>The column to copy from </td></tr>
    <tr><td class="paramname">target</td><td>The preallocated column to copy into </td></tr>
    <tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
    <tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
    <tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e09ded998662935b453cf161c752e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e09ded998662935b453cf161c752e5c">◆&nbsp;</a></span>empty_like() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Initializes and returns an empty column of the same type as the <code>input</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; An empty column of same type as <code>input</code> </dd></dl>

</div>
</div>
<a id="gadc1f5097200632d94c63bf50f04a367c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc1f5097200632d94c63bf50f04a367c">◆&nbsp;</a></span>empty_like() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Initializes and returns an empty column of the same type as the <code>input</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Scalar to emulate </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; An empty column of same type as <code>input</code> </dd></dl>

</div>
</div>
<a id="gaf882e46ff3f8447ec3cf315d74fe180f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf882e46ff3f8447ec3cf315d74fe180f">◆&nbsp;</a></span>empty_like() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1table.html">table</a>&gt; cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input_table</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a table of empty columns with the same types as the <code>input_table</code> </p>
<p>Creates the <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">input_table</td><td>Immutable view of input table to emulate </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;table&gt; A table of empty columns with the same types as the columns in <code>input_table</code> </dd></dl>

</div>
</div>
<a id="gafdb8ce94112a0353af61119497c1b6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb8ce94112a0353af61119497c1b6ee">◆&nbsp;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1scalar.html">scalar</a>&gt; cudf::get_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Get the element at specified index from a column. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is expensive (invokes a kernel launch). So, it is not recommended to be used in performance sensitive code or inside a loop.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>index</code> is not within the range <code>[0, input.size())</code></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">input</td><td>Column view to get the element from </td></tr>
    <tr><td class="paramname">index</td><td>Index into <code>input</code> to get the element at </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned scalar's device memory </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;scalar&gt; Scalar containing the single value </dd></dl>

</div>
</div>
<a id="ga0c61528cb588874f9c07c6f766f232db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c61528cb588874f9c07c6f766f232db">◆&nbsp;</a></span>has_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool cudf::has_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Checks if a column or its descendants have non-empty null rows. </p>
<dl class="section note"><dt>Note</dt><dd>This function is exact. If it returns <code>true</code>, there exists one or more non-empty null elements.</dd></dl>
<p>A LIST or STRING column might have non-empty rows that are marked as null. A STRUCT OR LIST column might have child columns that have non-empty null rows. Other types of columns are deemed incapable of having non-empty null rows. E.g. Fixed width columns have no concept of an "empty" row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">input</td><td>The column which is (and whose descendants are) to be checked for non-empty null rows. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If either the column or its descendants have non-empty null rows </dd>
<dd>
false If neither the column or its descendants have non-empty null rows </dd></dl>

</div>
</div>
<a id="ga9a9c46582ed07509d4bfe24e50d59bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a9c46582ed07509d4bfe24e50d59bf2">◆&nbsp;</a></span>may_have_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool cudf::may_have_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Approximates if a column or its descendants <em>may</em> have non-empty null elements. </p>
<dl class="section note"><dt>Note</dt><dd>This function is approximate.<ul>
<li><code>true</code>: Non-empty null elements could exist</li>
<li><code>false</code>: Non-empty null elements definitely do not exist</li>
</ul>
</dd></dl>
<p>False positives are possible, but false negatives are not.</p>
<p>Compared to the exact <code><a class="el" href="group__column__copy.html#ga0c61528cb588874f9c07c6f766f232db" title="Checks if a column or its descendants have non-empty null rows.">has_nonempty_nulls()</a></code> function, this function is typically more efficient.</p>
<p>Complexity:</p><ul>
<li>Best case: <code>O(count_descendants(input))</code></li>
<li>Worst case: <code>O(count_descendants(input)) * m</code>, where <code>m</code> is the number of rows in the largest descendant</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">input</td><td>The column which is (and whose descendants are) to be checked for non-empty null rows </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If either the column or its descendants have null rows </dd>
<dd>
false If neither the column nor its descendants have null rows </dd></dl>

</div>
</div>
<a id="gaeb39dd8301fb76bfec9e777820bda3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb39dd8301fb76bfec9e777820bda3f2">◆&nbsp;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a> cudf::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Deep-copy a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> into a serialized contiguous memory format. </p>
<p>The metadata from the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> is copied into a host vector of bytes and the data from the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> is copied into a <code>device_buffer</code>. Pass the output of this function into <code><a class="el" href="group__column__copy.html#ga1d62a18c2e6f087a92289c63693762cc" title="Deserialize the result of cudf::pack">cudf::unpack</a></code> to deserialize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir"></td><td class="paramname">input</td><td>View of the table to pack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all returned device allocations </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1packed__columns.html" title="Column data in a serialized format.">packed_columns</a> A struct containing the serialized metadata and data in contiguous host and device memory respectively </dd></dl>

</div>
</div>
<a id="gab28fc2d2294f2840df37814e7a4aa582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28fc2d2294f2840df37814e7a4aa582">◆&nbsp;</a></span>pack_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structcudf_1_1packed__columns_1_1metadata.html">packed_columns::metadata</a> cudf::pack_metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&nbsp;</td>
          <td class="paramname"><em>contiguous_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>buffer_size</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Produce the metadata used for packing a table stored in a contiguous buffer. </p>
<p>The metadata from the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> is copied into a host vector of bytes which can be used to construct a <code><a class="el" href="structcudf_1_1packed__columns.html" title="Column data in a serialized format.">packed_columns</a></code> or <code><a class="el" href="structcudf_1_1packed__table.html" title="The result(s) of a cudf::contiguous_split.">packed_table</a></code> structure. The caller is responsible for guaranteeing that that all of the columns in the table point into <code>contiguous_buffer</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">table</td><td>View of the table to pack </td></tr>
    <tr><td class="paramname">contiguous_buffer</td><td>A contiguous buffer of device memory which contains the data referenced by the columns in <code>table</code> </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The size of <code>contiguous_buffer</code> </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of bytes representing the metadata used to <code>unpack</code> a <a class="el" href="structcudf_1_1packed__columns.html" title="Column data in a serialized format.">packed_columns</a> struct </dd></dl>

</div>
</div>
<a id="gad82144bc75451067a2a8718b8d6cc03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82144bc75451067a2a8718b8d6cc03a">◆&nbsp;</a></span>purge_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::purge_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Copy <code>input</code> into output while purging any non-empty null rows in the column or its descendants. </p>
<p>If the input column is not of compound type (LIST/STRING/STRUCT/DICTIONARY), the output will be the same as input.</p>
<p>The purge operation only applies directly to LIST and STRING columns, but it applies indirectly to STRUCT/DICTIONARY columns as well, since these columns may have child columns that are LIST or STRING.</p>
<p>Examples:</p>
<div class="fragment"><div class="line">auto const lists   = lists_column_wrapper&lt;int32_t&gt;{ {0,1}, {2,3}, {4,5} }.release();</div>
<div class="line">cudf::detail::set_null_mask(lists-&gt;null_mask(), 1, 2, false);</div>
<div class="line"> </div>
<div class="line">lists[1] is now null, but the lists child column still stores `{2,3}`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [0, 1, 2, 3, 4, 5]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list's null rows, the column's contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [0, 1, 4, 5]</div>
</div><!-- fragment --><div class="fragment"><div class="line">auto const strings = strings_column_wrapper{ "AB", "CD", "EF" }.release();</div>
<div class="line">cudf::detail::set_null_mask(strings-&gt;null_mask(), 1, 2, false);</div>
<div class="line"> </div>
<div class="line">strings[1] is now null, but the strings column still stores `"CD"`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [A, B, C, D, E, F]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list's null rows, the column's contents</div>
<div class="line">will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [A, B, E, F]</div>
</div><!-- fragment --><div class="fragment"><div class="line">auto const lists   = lists_column_wrapper&lt;int32_t&gt;{ {0,1}, {2,3}, {4,5} };</div>
<div class="line">auto const structs = structs_column_wrapper{ {lists}, null_at(1) };</div>
<div class="line"> </div>
<div class="line">structs[1].child is now null, but the lists column still stores `{2,3}`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [0, 1, 2, 3, 4, 5]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list's null rows, the column's contents</div>
<div class="line">will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [0, 1, 4, 5]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">input</td><td>The column whose null rows are to be checked and purged </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new column with equivalent contents to <code>input</code>, but with null rows purged </dd></dl>

</div>
</div>
<a id="ga684cd03cda3c33a42de7e37e4231401a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga684cd03cda3c33a42de7e37e4231401a">◆&nbsp;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>source_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Reverses the elements of a column. </p>
<p>Creates a new column that is the reverse of <code>source_column</code>. Example: </p><div class="fragment"><div class="line">source = [4,5,6]</div>
<div class="line"><span class="keywordflow">return</span> = [6,5,4]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">source_column</td><td>Column that will be reversed </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reversed column </dd></dl>

</div>
</div>
<a id="ga88cdbe94ceaa7683562315e524f3cb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88cdbe94ceaa7683562315e524f3cb21">◆&nbsp;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1table.html">table</a>&gt; cudf::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Reverses the rows within a table. </p>
<p>Creates a new table that is the reverse of <code>source_table</code>. Example: </p><div class="fragment"><div class="line">source = [[4,5,6], [7,8,9], [10,11,12]]</div>
<div class="line"><span class="keywordflow">return</span> = [[6,5,4], [9,8,7], [12,11,10]]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">source_table</td><td>Table that will be reversed </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reversed table </dd></dl>

</div>
</div>
<a id="gaf2c879c97a852fdf113781d63a303aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2c879c97a852fdf113781d63a303aa7">◆&nbsp;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1table.html">table</a>&gt; cudf::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a>&nbsp;</td>
          <td class="paramname"><em>replacement</em> = <code>sample_with_replacement::FALSE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t const&nbsp;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Gather <code>n</code> samples from given <code>input</code> randomly. </p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input: {col1: {1, 2, 3, 4, 5}, col2: {6, 7, 8, 9, 10}}</div>
<div class="line">n: 3</div>
<div class="line">replacement: false</div>
<div class="line"> </div>
<div class="line">output:       {col1: {3, 1, 4}, col2: {8, 6, 9}}</div>
<div class="line"> </div>
<div class="line">replacement: true</div>
<div class="line"> </div>
<div class="line">output:       {col1: {3, 1, 1}, col2: {8, 6, 6}}</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>n</code> &gt; <code>input.num_rows()</code> and <code>replacement</code> == FALSE. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>n</code> &lt; 0.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">input</td><td>View of a table to sample </td></tr>
    <tr><td class="paramname">n</td><td>non-negative number of samples expected from <code>input</code> </td></tr>
    <tr><td class="paramname">replacement</td><td>Allow or disallow sampling of the same row more than once </td></tr>
    <tr><td class="paramname">seed</td><td>Seed value to initiate random number generator </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;table&gt; Table containing samples from <code>input</code> </dd></dl>

</div>
</div>
<a id="ga1d62a18c2e6f087a92289c63693762cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d62a18c2e6f087a92289c63693762cc">◆&nbsp;</a></span>unpack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classcudf_1_1table__view.html">table_view</a> cudf::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format.">cudf::pack</a></code> </p>
<p>Converts the result of a serialized table into a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> that points to the data stored in the contiguous device buffer contained in <code>input</code>.</p>
<p>It is the caller's responsibility to ensure that the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> in the output does not outlive the data in the input.</p>
<p>No new device memory is allocated in this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">input</td><td>The packed columns to unpack </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unpacked <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> </dd></dl>

</div>
</div>
<a id="gaaaebfb6742c09cccda8fb8a78e19fbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaebfb6742c09cccda8fb8a78e19fbd6">◆&nbsp;</a></span>unpack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classcudf_1_1table__view.html">table_view</a> cudf::unpack </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&nbsp;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&nbsp;</td>
          <td class="paramname"><em>gpu_data</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format.">cudf::pack</a></code> </p>
<p>Converts the result of a serialized table into a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> that points to the data stored in the contiguous device buffer contained in <code>gpu_data</code> using the metadata contained in the host buffer <code>metadata</code>.</p>
<p>It is the caller's responsibility to ensure that the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> in the output does not outlive the data in the input.</p>
<p>No new device memory is allocated in this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">metadata</td><td>The host-side metadata buffer resulting from the initial <a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format.">pack()</a> call </td></tr>
    <tr><td class="paramname">gpu_data</td><td>The device-side contiguous buffer storing the data that will be referenced by the resulting <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unpacked <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view's of the same size.">table_view</a></code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>