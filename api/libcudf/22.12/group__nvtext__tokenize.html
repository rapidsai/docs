<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libcudf: Tokenizing</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (22.12)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (23.04)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (23.02)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/legacy/namespacecudf.html">legacy (22.12)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> |
<a href="#nested-classes">Classes</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tokenizing<div class="ingroups"><a class="el" href="group__nvtext__apis.html">NVText</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:bpe__tokenize_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpe__tokenize_8hpp.html">bpe_tokenize.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:subword__tokenize_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="subword__tokenize_8hpp.html">subword_tokenize.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:tokenize_8hpp"><td align="right" class="memItemLeft" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tokenize_8hpp.html">tokenize.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtext_1_1bpe__merge__pairs.html">nvtext::bpe_merge_pairs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The table of merge pairs for the BPE encoder.  <a href="structnvtext_1_1bpe__merge__pairs.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtext_1_1hashed__vocabulary.html">nvtext::hashed_vocabulary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The vocabulary data for use with the subword_tokenize function.  <a href="structnvtext_1_1hashed__vocabulary.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtext_1_1tokenizer__result.html">nvtext::tokenizer_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Result object for the subword_tokenize functions.  <a href="structnvtext_1_1tokenizer__result.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9781112d13d8da436472113028b7ee28"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="structnvtext_1_1bpe__merge__pairs.html">bpe_merge_pairs</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga9781112d13d8da436472113028b7ee28">nvtext::load_merge_pairs_file</a> (std::string const &amp;filename_merges, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga9781112d13d8da436472113028b7ee28"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="structnvtext_1_1bpe__merge__pairs.html" title="The table of merge pairs for the BPE encoder.">nvtext::bpe_merge_pairs</a> from an input file.  <a href="group__nvtext__tokenize.html#ga9781112d13d8da436472113028b7ee28">More...</a><br></td></tr>
<tr class="separator:ga9781112d13d8da436472113028b7ee28"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga608bfdd0f8875464a51173a2059f185a"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga608bfdd0f8875464a51173a2059f185a">nvtext::byte_pair_encoding</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;input, <a class="el" href="structnvtext_1_1bpe__merge__pairs.html">bpe_merge_pairs</a> const &amp;merges_pairs, <a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;separator=<a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>(" "), <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga608bfdd0f8875464a51173a2059f185a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Byte pair encode the input strings.  <a href="group__nvtext__tokenize.html#ga608bfdd0f8875464a51173a2059f185a">More...</a><br></td></tr>
<tr class="separator:ga608bfdd0f8875464a51173a2059f185a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga8287e208970dc9651960abe3fbe6a436"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="structnvtext_1_1hashed__vocabulary.html">hashed_vocabulary</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga8287e208970dc9651960abe3fbe6a436">nvtext::load_vocabulary_file</a> (std::string const &amp;filename_hashed_vocabulary, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga8287e208970dc9651960abe3fbe6a436"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load the hashed vocabulary file into device memory.  <a href="group__nvtext__tokenize.html#ga8287e208970dc9651960abe3fbe6a436">More...</a><br></td></tr>
<tr class="separator:ga8287e208970dc9651960abe3fbe6a436"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gae1254ce616dad2611c61b84b8ff5c03c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structnvtext_1_1tokenizer__result.html">tokenizer_result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#gae1254ce616dad2611c61b84b8ff5c03c">nvtext::subword_tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="structnvtext_1_1hashed__vocabulary.html">hashed_vocabulary</a> const &amp;vocabulary_table, uint32_t max_sequence_length, uint32_t stride, bool do_lower_case, bool do_truncate, uint32_t max_rows_tensor, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:gae1254ce616dad2611c61b84b8ff5c03c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a tokenizer that cleans the text, splits it into tokens and returns token-ids from an input vocabulary.  <a href="group__nvtext__tokenize.html#gae1254ce616dad2611c61b84b8ff5c03c">More...</a><br></td></tr>
<tr class="separator:gae1254ce616dad2611c61b84b8ff5c03c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga64c2806c398ce476fa5174f3155ea0fb"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga64c2806c398ce476fa5174f3155ea0fb">nvtext::tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;delimiter=<a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>{""}, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga64c2806c398ce476fa5174f3155ea0fb"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a single column of strings by tokenizing the input strings column using the provided characters as delimiters.  <a href="group__nvtext__tokenize.html#ga64c2806c398ce476fa5174f3155ea0fb">More...</a><br></td></tr>
<tr class="separator:ga64c2806c398ce476fa5174f3155ea0fb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga807d8c798bf2cb614202ca2cfabb940c"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga807d8c798bf2cb614202ca2cfabb940c">nvtext::tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;delimiters, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga807d8c798bf2cb614202ca2cfabb940c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a single column of strings by tokenizing the input strings column using multiple strings as delimiters.  <a href="group__nvtext__tokenize.html#ga807d8c798bf2cb614202ca2cfabb940c">More...</a><br></td></tr>
<tr class="separator:ga807d8c798bf2cb614202ca2cfabb940c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga5323d94dac99bf42f0cbb07c4fcd7242"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga5323d94dac99bf42f0cbb07c4fcd7242">nvtext::count_tokens</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;delimiter=<a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>{""}, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga5323d94dac99bf42f0cbb07c4fcd7242"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of tokens in each string of a strings column.  <a href="group__nvtext__tokenize.html#ga5323d94dac99bf42f0cbb07c4fcd7242">More...</a><br></td></tr>
<tr class="separator:ga5323d94dac99bf42f0cbb07c4fcd7242"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga540d215cff7ce6c209dcda5a0a4d28ce"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga540d215cff7ce6c209dcda5a0a4d28ce">nvtext::count_tokens</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;delimiters, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga540d215cff7ce6c209dcda5a0a4d28ce"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of tokens in each string of a strings column by using multiple strings delimiters to identify tokens in each string.  <a href="group__nvtext__tokenize.html#ga540d215cff7ce6c209dcda5a0a4d28ce">More...</a><br></td></tr>
<tr class="separator:ga540d215cff7ce6c209dcda5a0a4d28ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga276c98f2ede96996eefa33be5473f8a4"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga276c98f2ede96996eefa33be5473f8a4">nvtext::character_tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga276c98f2ede96996eefa33be5473f8a4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a single column of strings by converting each character to a string.  <a href="group__nvtext__tokenize.html#ga276c98f2ede96996eefa33be5473f8a4">More...</a><br></td></tr>
<tr class="separator:ga276c98f2ede96996eefa33be5473f8a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga8364f17dcc11e370be3086a1c6882fcb"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga8364f17dcc11e370be3086a1c6882fcb">nvtext::detokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;row_indices, <a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;separator=<a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>(" "), <a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=<a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>())</td></tr>
<tr class="memdesc:ga8364f17dcc11e370be3086a1c6882fcb"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a strings column from a strings column of tokens and an associated column of row ids.  <a href="group__nvtext__tokenize.html#ga8364f17dcc11e370be3086a1c6882fcb">More...</a><br></td></tr>
<tr class="separator:ga8364f17dcc11e370be3086a1c6882fcb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga608bfdd0f8875464a51173a2059f185a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga608bfdd0f8875464a51173a2059f185a">◆&nbsp;</a></span>byte_pair_encoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::byte_pair_encoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtext_1_1bpe__merge__pairs.html">bpe_merge_pairs</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>merges_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>("&nbsp;")</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Byte pair encode the input strings. </p>
<p>This will split each string on whitespace, perform the encoding, and then build the output column using the given <code>separator</code>.</p>
<p>The encoding algorithm rebuilds each string by matching substrings in the <code>merge_pairs</code> table and iteratively removing the minimum ranked pair until no pairs are left. Then, a space is inserted between the remaining pairs before the result is joined to make the output string.</p>
<div class="fragment"><div class="line">mps = load_merges_file("merges.txt") // see doxygen for example contents</div>
<div class="line">input = ["test sentence", "thisis test"]</div>
<div class="line">result = byte_pair_encoding(input, mps)</div>
<div class="line">result is now ["test sent ence", "this is test"]</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>merge_pairs</code> is empty </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>separator</code> is invalid</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">input</td><td>Strings to encode. </td></tr>
    <tr><td class="paramname">merges_pairs</td><td>Created by a call to <a class="el" href="group__nvtext__tokenize.html#ga9781112d13d8da436472113028b7ee28">nvtext::load_merge_pairs_file</a>. </td></tr>
    <tr><td class="paramname">separator</td><td>String used to build the output after encoding. Default is a space. </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate any returned objects. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An encoded column of strings. </dd></dl>

</div>
</div>
<a id="ga276c98f2ede96996eefa33be5473f8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga276c98f2ede96996eefa33be5473f8a4">◆&nbsp;</a></span>character_tokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::character_tokenize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns a single column of strings by converting each character to a string. </p>
<p>Each string is converted to multiple strings &ndash; one for each character. Note that a character maybe more than one byte.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["hello world", null, "goodbye"]</div>
<div class="line">t = character_tokenize(s)</div>
<div class="line">t is now ["h","e","l","l","o"," ","w","o","r","l","d","g","o","o","d","b","y","e"]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">strings</td><td>Strings column to tokenize. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings columns of tokens. </dd></dl>

</div>
</div>
<a id="ga5323d94dac99bf42f0cbb07c4fcd7242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5323d94dac99bf42f0cbb07c4fcd7242">◆&nbsp;</a></span>count_tokens() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::count_tokens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>{""}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the number of tokens in each string of a strings column. </p>
<p>The <code>delimiter</code> may be zero or more characters. If the <code>delimiter</code> is empty, whitespace (character code-point &lt;= ' ') is used for identifying tokens. Also, any consecutive delimiters found in a string are ignored. This means that only empty strings or null rows will result in a token count of 0.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["a", "b c", " ", "d e f"]</div>
<div class="line">t = count_tokens(s)</div>
<div class="line">t is now [1, 2, 0, 3]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows. The number of tokens for a null element is set to 0 in the output column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">strings</td><td>Strings column to use for this operation. </td></tr>
    <tr><td class="paramname">delimiter</td><td>Strings used to separate each string into tokens. The default of empty string will separate tokens using whitespace. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New INT32 column of token counts. </dd></dl>

</div>
</div>
<a id="ga540d215cff7ce6c209dcda5a0a4d28ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga540d215cff7ce6c209dcda5a0a4d28ce">◆&nbsp;</a></span>count_tokens() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::count_tokens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns the number of tokens in each string of a strings column by using multiple strings delimiters to identify tokens in each string. </p>
<p>Also, any consecutive delimiters found in a string are ignored. This means that only empty strings or null rows will result in a token count of 0.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["a", "b c", "d.e:f;"]</div>
<div class="line">d = [".", ":", ";"]</div>
<div class="line">t = count_tokens(s,d)</div>
<div class="line">t is now [1, 1, 3]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows. The number of tokens for a null element is set to 0 in the output column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the delimiters column is empty or contains nulls.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">strings</td><td>Strings column to use for this operation. </td></tr>
    <tr><td class="paramname">delimiters</td><td>Strings used to separate each string into tokens. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New INT32 column of token counts. </dd></dl>

</div>
</div>
<a id="ga8364f17dcc11e370be3086a1c6882fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8364f17dcc11e370be3086a1c6882fcb">◆&nbsp;</a></span>detokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::detokenize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>separator</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>("&nbsp;")</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a strings column from a strings column of tokens and an associated column of row ids. </p>
<p>Multiple tokens from the input column may be combined into a single row (string) in the output column. The tokens are concatenated along with the <code>separator</code> string in the order in which they appear in the <code>row_indices</code> column.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["hello", "world", "one", "two", "three"]</div>
<div class="line">r = [0, 0, 1, 1, 1]</div>
<div class="line">s1 = detokenize(s,r)</div>
<div class="line">s1 is now ["hello world", "one two three"]</div>
<div class="line">r = [0, 2, 1, 1, 0]</div>
<div class="line">s2 = detokenize(s,r)</div>
<div class="line">s2 is now ["hello three", "one two", "world"]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows. The values in <code>row_indices</code> are expected to have positive, sequential values without any missing row indices otherwise the output is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>is <code>separator</code> is invalid </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>row_indices.size() != strings.size()</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>row_indices</code> contains nulls</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">strings</td><td>Strings column to detokenize. </td></tr>
    <tr><td class="paramname">row_indices</td><td>The relative output row index assigned for each token in the input column. </td></tr>
    <tr><td class="paramname">separator</td><td>String to append after concatenating each token to the proper output row. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings columns of tokens. </dd></dl>

</div>
</div>
<a id="ga9781112d13d8da436472113028b7ee28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9781112d13d8da436472113028b7ee28">◆&nbsp;</a></span>load_merge_pairs_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structnvtext_1_1bpe__merge__pairs.html">bpe_merge_pairs</a>&gt; nvtext::load_merge_pairs_file </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"><em>filename_merges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structnvtext_1_1bpe__merge__pairs.html" title="The table of merge pairs for the BPE encoder.">nvtext::bpe_merge_pairs</a> from an input file. </p>
<p>The file should contain a pair of strings per line separated by a single space.</p>
<p>Example: </p><div class="fragment"><div class="line">e n</div>
<div class="line">i t</div>
<div class="line">i s</div>
<div class="line">e s</div>
<div class="line">en t</div>
<div class="line">c e</div>
<div class="line">es t</div>
<div class="line">en ce</div>
<div class="line">T h</div>
<div class="line">Th is</div>
<div class="line">t est</div>
<div class="line">s ent</div>
<div class="line">...</div>
</div><!-- fragment --><p>The pairs are expected to be ordered in the file by their rank relative to each other. A pair earlier in the file has priority over any pairs below it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">filename_merges</td><td>Local file path of pairs encoded in UTF-8. </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate any returned objects. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structnvtext_1_1bpe__merge__pairs.html" title="The table of merge pairs for the BPE encoder.">nvtext::bpe_merge_pairs</a> object </dd></dl>

</div>
</div>
<a id="ga8287e208970dc9651960abe3fbe6a436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8287e208970dc9651960abe3fbe6a436">◆&nbsp;</a></span>load_vocabulary_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structnvtext_1_1hashed__vocabulary.html">hashed_vocabulary</a>&gt; nvtext::load_vocabulary_file </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"><em>filename_hashed_vocabulary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Load the hashed vocabulary file into device memory. </p>
<p>The object here can be used to call the subword_tokenize without incurring the cost of loading the same file each time.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the <code>filename_hashed_vocabulary</code> could not be opened.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">filename_hashed_vocabulary</td><td>A path to the preprocessed vocab.txt file. Note that this is the file AFTER python/perfect_hash.py has been used for preprocessing. </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate any returned objects. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vocabulary hash-table elements </dd></dl>

</div>
</div>
<a id="gae1254ce616dad2611c61b84b8ff5c03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1254ce616dad2611c61b84b8ff5c03c">◆&nbsp;</a></span>subword_tokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structnvtext_1_1tokenizer__result.html">tokenizer_result</a> nvtext::subword_tokenize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtext_1_1hashed__vocabulary.html">hashed_vocabulary</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>vocabulary_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"><em>max_sequence_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_lower_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>do_truncate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"><em>max_rows_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Creates a tokenizer that cleans the text, splits it into tokens and returns token-ids from an input vocabulary. </p>
<p>The strings are first normalized by converting to lower-case, removing punctuation, replacing a select set of multi-byte characters and whitespace characters.</p>
<p>The strings are then tokenized by using whitespace as a delimiter. Consecutive delimiters are ignored. Each token is then assigned a 4-byte token-id mapped from the provided vocabulary table.</p>
<p>Essentially each string is converted into one or more vectors of token-ids in the output column. The total number of these vectors times <code>max_sequence_length</code> is the size of the <code>tensor_token_ids</code> output column. For <code>do_truncate==true</code>: </p><div class="fragment"><div class="line">size of tensor_token_ids = max_sequence_length * strings.size()</div>
<div class="line">size of tensor_attention_mask = max_sequence_length * strings.size()</div>
<div class="line">size of tensor_metadata = 3 * strings.size()</div>
</div><!-- fragment --><p>For <code>do_truncate==false</code> the number of rows per output string depends on the number of tokens resolved and the <code>stride</code> value which may repeat tokens in subsequent overflow rows.</p>
<p>This function requires about 21x the number of character bytes in the input strings column as working memory.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>stride &gt; max_sequence_length</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>max_sequence_length * max_rows_tensor</code> is larger than the max value for <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9" title="Row index type for columns and tables.">cudf::size_type</a></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">strings</td><td>The input strings to tokenize. </td></tr>
    <tr><td class="paramname">vocabulary_table</td><td>The vocabulary table pre-loaded into this object. </td></tr>
    <tr><td class="paramname">max_sequence_length</td><td>Limit of the number of token-ids per row in final tensor for each string. </td></tr>
    <tr><td class="paramname">stride</td><td>Each row in the output token-ids will replicate <code>max_sequence_length - stride</code> the token-ids from the previous row, unless it is the first string. </td></tr>
    <tr><td class="paramname">do_lower_case</td><td>If true, the tokenizer will convert uppercase characters in the input stream to lower-case and strip accents from those characters. If false, accented and uppercase characters are not transformed. </td></tr>
    <tr><td class="paramname">do_truncate</td><td>If true, the tokenizer will discard all the token-ids after <code>max_sequence_length</code> for each input string. If false, it will use a new row in the output token-ids to continue generating the output. </td></tr>
    <tr><td class="paramname">max_rows_tensor</td><td>Maximum number of rows for the output token-ids expected to be generated by the tokenizer. Used for allocating temporary working memory on the GPU device. If the output generates a larger number of rows, behavior is undefined. </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate any returned objects. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token-ids, attention-mask, and metadata </dd></dl>

</div>
</div>
<a id="ga64c2806c398ce476fa5174f3155ea0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c2806c398ce476fa5174f3155ea0fb">◆&nbsp;</a></span>tokenize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::tokenize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>{""}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns a single column of strings by tokenizing the input strings column using the provided characters as delimiters. </p>
<p>The <code>delimiter</code> may be zero or more characters. If the <code>delimiter</code> is empty, whitespace (character code-point &lt;= ' ') is used for identifying tokens. Also, any consecutive delimiters found in a string are ignored. This means only non-empty tokens are returned.</p>
<p>Tokens are found by locating delimiter(s) starting at the beginning of each string. As each string is tokenized, the tokens are appended using input column row order to build the output column. That is, tokens found in input row[i] will be placed in the output column directly before tokens found in input row[i+1].</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["a", "b c", "d  e f "]</div>
<div class="line">t = tokenize(s)</div>
<div class="line">t is now ["a", "b", "c", "d", "e", "f"]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">strings</td><td>Strings column tokenize. </td></tr>
    <tr><td class="paramname">delimiter</td><td>UTF-8 characters used to separate each string into tokens. The default of empty string will separate tokens using whitespace. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings columns of tokens. </dd></dl>

</div>
</div>
<a id="ga807d8c798bf2cb614202ca2cfabb940c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga807d8c798bf2cb614202ca2cfabb940c">◆&nbsp;</a></span>tokenize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::tokenize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
          <td class="paramname"><em>mr</em> = <code><a class="elRef" href="https://docs.rapids.ai/api/librmm/22.12/per__device__resource_8hpp.html#a95bf69637b8f3d29b13b33562370fc8f">rmm::mr::get_current_device_resource</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Returns a single column of strings by tokenizing the input strings column using multiple strings as delimiters. </p>
<p>Tokens are found by locating delimiter(s) starting at the beginning of each string. Any consecutive delimiters found in a string are ignored. This means only non-empty tokens are returned.</p>
<p>As each string is tokenized, the tokens are appended using input column row order to build the output column. That is, tokens found in input row[i] will be placed in the output column directly before tokens found in input row[i+1].</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["a", "b c", "d.e:f;"]</div>
<div class="line">d = [".", ":", ";"]</div>
<div class="line">t = tokenize(s,d)</div>
<div class="line">t is now ["a", "b c", "d", "e", "f"]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the delimiters column is empty or contains nulls.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">strings</td><td>Strings column to tokenize. </td></tr>
    <tr><td class="paramname">delimiters</td><td>Strings used to separate individual strings into tokens. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings columns of tokens. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>