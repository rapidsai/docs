<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: cudf::experimental Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecudf.html">cudf</a></li><li class="navelem"><a class="el" href="namespacecudf_1_1experimental.html">experimental</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cudf::experimental Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>In-development features.  
<a href="namespacecudf_1_1experimental.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecudf_1_1experimental_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental_1_1io.html">io</a></td></tr>
<tr class="memdesc:namespacecudf_1_1experimental_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">IO interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for specifying the desired aggregation in an <code>aggregation_request</code>.  <a href="classcudf_1_1experimental_1_1aggregation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1bool8.html">bool8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1element__equality__comparator.html">element_equality_comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an equality comparison between two elements in two columns.  <a href="classcudf_1_1experimental_1_1element__equality__comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1element__hasher.html">element_hasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of an element in the given column.  <a href="classcudf_1_1experimental_1_1element__hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1element__relational__comparator.html">element_relational_comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a relational comparison between two elements in two columns.  <a href="classcudf_1_1experimental_1_1element__relational__comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1id__to__type__impl.html">id_to_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1row__equality__comparator.html">row_equality_comparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1row__hasher.html">row_hasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of a row in the given table.  <a href="classcudf_1_1experimental_1_1row__hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1row__hasher__initial__values.html">row_hasher_initial_values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of a row in the given table, combined with an initial hash value for each column.  <a href="classcudf_1_1experimental_1_1row__hasher__initial__values.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1row__lexicographic__comparator.html">row_lexicographic_comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes whether one row is lexicographically <em>less</em> than another row.  <a href="classcudf_1_1experimental_1_1row__lexicographic__comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1table.html">table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1type__to__name.html">type_to_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl_3_01cudf_1_1string__view_01_4.html">type_to_scalar_type_impl&lt; cudf::string_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a09ff9b3055486ff508a88bf2d891bce8"><td class="memTemplParams" colspan="2">template&lt;cudf::type_id Id&gt; </td></tr>
<tr class="memitem:a09ff9b3055486ff508a88bf2d891bce8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a09ff9b3055486ff508a88bf2d891bce8">id_to_type</a> = typename <a class="el" href="structcudf_1_1experimental_1_1id__to__type__impl.html">id_to_type_impl</a>&lt; Id &gt;::type</td></tr>
<tr class="memdesc:a09ff9b3055486ff508a88bf2d891bce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code> to it's corresponding concrete C++ type.  <a href="namespacecudf_1_1experimental.html#a09ff9b3055486ff508a88bf2d891bce8">More...</a><br /></td></tr>
<tr class="separator:a09ff9b3055486ff508a88bf2d891bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3198f71aa690ddfcd12b70245838c78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3198f71aa690ddfcd12b70245838c78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ab3198f71aa690ddfcd12b70245838c78">scalar_type_t</a> = typename <a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a>&lt; T &gt;::ScalarType</td></tr>
<tr class="memdesc:ab3198f71aa690ddfcd12b70245838c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to the scalar type required to hold its value.  <a href="namespacecudf_1_1experimental.html#ab3198f71aa690ddfcd12b70245838c78">More...</a><br /></td></tr>
<tr class="separator:ab3198f71aa690ddfcd12b70245838c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13b7818063c9611a7cc83bedd435174"><td class="memTemplParams" colspan="2"><a id="ad13b7818063c9611a7cc83bedd435174"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad13b7818063c9611a7cc83bedd435174"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scalar_device_type_t</b> = typename <a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a>&lt; T &gt;::ScalarDeviceType</td></tr>
<tr class="separator:ad13b7818063c9611a7cc83bedd435174"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad483c874f6010437111325063b87daef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a> { <a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa443475558f0168dff92ecde26b98ae5a">mask_allocation_policy::NEVER</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefaf3fc827ade4b968e50406496907ef962">mask_allocation_policy::ALWAYS</a>
 }</td></tr>
<tr class="separator:ad483c874f6010437111325063b87daef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dd75929a008df2311021ba0753c22a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22aa6970bdc2201030b9c03fbdcf3973858a">rolling_operator::SUM</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22aace31e2a082d17e038fcc6e3006166653">rolling_operator::MIN</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22aa26a4b44a837bf97b972628509912b4a5">rolling_operator::MAX</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22aa4ea6d1161ea24d7599365f574aff6610">rolling_operator::MEAN</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22aa4905ac9d6a22bdfc1ae096094ce6248d">rolling_operator::COUNT</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22aa4a0dd49d9250ae06cebde3075e441df9">rolling_operator::NUMBA_UDF</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22aa67f303e1658c4b438f74b2f02e626d92">rolling_operator::CUDA_UDF</a>
<br />
 }</td></tr>
<tr class="memdesc:a86dd75929a008df2311021ba0753c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolling window aggregation operations.  <a href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">More...</a><br /></td></tr>
<tr class="separator:a86dd75929a008df2311021ba0753c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b073c676d07d514a051888b2b753cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">duplicate_keep_option</a> { <a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cda5968b12bf2e72e702a998c7fa6c83b1e">duplicate_keep_option::KEEP_FIRST</a> = 0, 
<a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cda4583fc151efe5098dd96eeec8cf74699">duplicate_keep_option::KEEP_LAST</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cda40c4abe57c2fda3e580eee916b9e0558">duplicate_keep_option::KEEP_NONE</a>
 }</td></tr>
<tr class="memdesc:a43b073c676d07d514a051888b2b753cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choices for drop_duplicates API for retainment of duplicate rows.  <a href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">More...</a><br /></td></tr>
<tr class="separator:a43b073c676d07d514a051888b2b753cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a49aef820830d7830862408645b8c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">weak_ordering</a> { <a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7a1798e8c3621ca53d9e3a80d257306000">weak_ordering::LESS</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7acd1908d025919ff975513ff143c3e34c">weak_ordering::EQUIVALENT</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7ae7e72355289e404b762d4cf88824d23b">weak_ordering::GREATER</a>
 }</td></tr>
<tr class="memdesc:a57a49aef820830d7830862408645b8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type of the <code>element_relational_comparator</code> function object.  <a href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">More...</a><br /></td></tr>
<tr class="separator:a57a49aef820830d7830862408645b8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4f0e0f1bfa906673bf5c2a2b13b151"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">interpolation</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aaac544aacc3615aada24897a215f5046">interpolation::LINEAR</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aa7c48ba367e019d004bfb0239b85f2b3">interpolation::LOWER</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151a5bc0a7ce2c77ccd49169277e9289e5d1">interpolation::HIGHER</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aafa8fd4b90a3f8123b4bd30446518a7e">interpolation::MIDPOINT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aad135772d7cf93dd0ccf9d2474b34e6a">interpolation::NEAREST</a>
<br />
 }</td></tr>
<tr class="memdesc:a5f4f0e0f1bfa906673bf5c2a2b13b151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolation method to use when the desired quantile lies between two data points i and j.  <a href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">More...</a><br /></td></tr>
<tr class="separator:a5f4f0e0f1bfa906673bf5c2a2b13b151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cecb2a8c2faaf3ef84cd9046881237"><td class="memItemLeft" align="right" valign="top"><a id="af7cecb2a8c2faaf3ef84cd9046881237"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>unary_op</b> { <br />
&#160;&#160;<b>SIN</b>, 
<b>COS</b>, 
<b>TAN</b>, 
<b>ARCSIN</b>, 
<br />
&#160;&#160;<b>ARCCOS</b>, 
<b>ARCTAN</b>, 
<b>EXP</b>, 
<b>LOG</b>, 
<br />
&#160;&#160;<b>SQRT</b>, 
<b>CEIL</b>, 
<b>FLOOR</b>, 
<b>ABS</b>, 
<br />
&#160;&#160;<b>BIT_INVERT</b>, 
<b>NOT</b>
<br />
 }</td></tr>
<tr class="separator:af7cecb2a8c2faaf3ef84cd9046881237"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a765b473355d4b4668b73cd7583d7d2d0"><td class="memItemLeft" align="right" valign="top"><a id="a765b473355d4b4668b73cd7583d7d2d0"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a765b473355d4b4668b73cd7583d7d2d0">make_sum_aggregation</a> ()</td></tr>
<tr class="memdesc:a765b473355d4b4668b73cd7583d7d2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a SUM aggregation. <br /></td></tr>
<tr class="separator:a765b473355d4b4668b73cd7583d7d2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e27dcd8a7e8b115a5b20d83cfa30e2"><td class="memItemLeft" align="right" valign="top"><a id="ac5e27dcd8a7e8b115a5b20d83cfa30e2"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ac5e27dcd8a7e8b115a5b20d83cfa30e2">make_min_aggregation</a> ()</td></tr>
<tr class="memdesc:ac5e27dcd8a7e8b115a5b20d83cfa30e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MIN aggregation. <br /></td></tr>
<tr class="separator:ac5e27dcd8a7e8b115a5b20d83cfa30e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc2befe60625f484eb0e7493e91776c"><td class="memItemLeft" align="right" valign="top"><a id="a9fc2befe60625f484eb0e7493e91776c"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9fc2befe60625f484eb0e7493e91776c">make_max_aggregation</a> ()</td></tr>
<tr class="memdesc:a9fc2befe60625f484eb0e7493e91776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MAX aggregation. <br /></td></tr>
<tr class="separator:a9fc2befe60625f484eb0e7493e91776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1e3cd40fdf74ae3fde3ae60b63b95c"><td class="memItemLeft" align="right" valign="top"><a id="abc1e3cd40fdf74ae3fde3ae60b63b95c"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#abc1e3cd40fdf74ae3fde3ae60b63b95c">make_count_aggregation</a> ()</td></tr>
<tr class="memdesc:abc1e3cd40fdf74ae3fde3ae60b63b95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a COUNT aggregation. <br /></td></tr>
<tr class="separator:abc1e3cd40fdf74ae3fde3ae60b63b95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba9d5acd317b74a27bd53e4eb300e3"><td class="memItemLeft" align="right" valign="top"><a id="a65ba9d5acd317b74a27bd53e4eb300e3"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a65ba9d5acd317b74a27bd53e4eb300e3">make_mean_aggregation</a> ()</td></tr>
<tr class="memdesc:a65ba9d5acd317b74a27bd53e4eb300e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MEAN aggregation. <br /></td></tr>
<tr class="separator:a65ba9d5acd317b74a27bd53e4eb300e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91939f7355190ba94e08ceb3fd802041"><td class="memItemLeft" align="right" valign="top"><a id="a91939f7355190ba94e08ceb3fd802041"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a91939f7355190ba94e08ceb3fd802041">make_median_aggregation</a> ()</td></tr>
<tr class="memdesc:a91939f7355190ba94e08ceb3fd802041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MEDIAN aggregation. <br /></td></tr>
<tr class="separator:a91939f7355190ba94e08ceb3fd802041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf5751f91dd4da5c76b0b54fc2dc9ee"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#afdf5751f91dd4da5c76b0b54fc2dc9ee">make_quantile_aggregation</a> (std::vector&lt; double &gt; const &amp;q, <a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">interpolation</a> i)</td></tr>
<tr class="memdesc:afdf5751f91dd4da5c76b0b54fc2dc9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a QUANTILE aggregation.  <a href="namespacecudf_1_1experimental.html#afdf5751f91dd4da5c76b0b54fc2dc9ee">More...</a><br /></td></tr>
<tr class="separator:afdf5751f91dd4da5c76b0b54fc2dc9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6f5965e67b78f9068bfbaab1f26db6"><td class="memItemLeft" align="right" valign="top"><a id="a7d6f5965e67b78f9068bfbaab1f26db6"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>empty_like</b> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="separator:a7d6f5965e67b78f9068bfbaab1f26db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadf20c2bcd430f728769d1bcd050ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9fadf20c2bcd430f728769d1bcd050ec">empty_like</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input_table)</td></tr>
<tr class="memdesc:a9fadf20c2bcd430f728769d1bcd050ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of empty columns with the same types as the <code>input_table</code>  <a href="namespacecudf_1_1experimental.html#a9fadf20c2bcd430f728769d1bcd050ec">More...</a><br /></td></tr>
<tr class="separator:a9fadf20c2bcd430f728769d1bcd050ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ce6302e4458066d832420207ea7a02"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a20ce6302e4458066d832420207ea7a02">allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a20ce6302e4458066d832420207ea7a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the same size and type as the <code>input</code>. Supports only fixed-width types.  <a href="namespacecudf_1_1experimental.html#a20ce6302e4458066d832420207ea7a02">More...</a><br /></td></tr>
<tr class="separator:a20ce6302e4458066d832420207ea7a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721801079c0de1398a1e089a39995ce8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a721801079c0de1398a1e089a39995ce8">allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, size_type size, <a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a721801079c0de1398a1e089a39995ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the specified size and same type as the <code>input</code>. Supports only fixed-width types.  <a href="namespacecudf_1_1experimental.html#a721801079c0de1398a1e089a39995ce8">More...</a><br /></td></tr>
<tr class="separator:a721801079c0de1398a1e089a39995ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11643d0378285cf1d7b17826fbb35bb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad11643d0378285cf1d7b17826fbb35bb">copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ad11643d0378285cf1d7b17826fbb35bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="namespacecudf_1_1experimental.html#ad11643d0378285cf1d7b17826fbb35bb">More...</a><br /></td></tr>
<tr class="separator:ad11643d0378285cf1d7b17826fbb35bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649c525d788647c5d6bf3b6b4cedb87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ac649c525d788647c5d6bf3b6b4cedb87">copy_range</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;source, <a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;target, size_type source_begin, size_type source_end, size_type target_begin)</td></tr>
<tr class="memdesc:ac649c525d788647c5d6bf3b6b4cedb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements in-place from one column to another.  <a href="namespacecudf_1_1experimental.html#ac649c525d788647c5d6bf3b6b4cedb87">More...</a><br /></td></tr>
<tr class="separator:ac649c525d788647c5d6bf3b6b4cedb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b5739505c21058c97d6f29c996c16f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a77b5739505c21058c97d6f29c996c16f">copy_range</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;target, size_type source_begin, size_type source_end, size_type target_begin, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a77b5739505c21058c97d6f29c996c16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements out-of-place from one column to another.  <a href="namespacecudf_1_1experimental.html#a77b5739505c21058c97d6f29c996c16f">More...</a><br /></td></tr>
<tr class="separator:a77b5739505c21058c97d6f29c996c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edcfa60adcae62ead9197feeaf87ba0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1edcfa60adcae62ead9197feeaf87ba0">gather</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;source_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;gather_map, bool check_bounds=false, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a1edcfa60adcae62ead9197feeaf87ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows (including null values) of a set of columns.  <a href="namespacecudf_1_1experimental.html#a1edcfa60adcae62ead9197feeaf87ba0">More...</a><br /></td></tr>
<tr class="separator:a1edcfa60adcae62ead9197feeaf87ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e9825f07db3744b175c518c687b537"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a66e9825f07db3744b175c518c687b537">scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;scatter_map, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;target, bool check_bounds=false, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a66e9825f07db3744b175c518c687b537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of the source table into a copy of the target table according to a scatter map.  <a href="namespacecudf_1_1experimental.html#a66e9825f07db3744b175c518c687b537">More...</a><br /></td></tr>
<tr class="separator:a66e9825f07db3744b175c518c687b537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c7d359043b804ba7b6b0c38606c8d9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a71c7d359043b804ba7b6b0c38606c8d9">scatter</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&gt; const  &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;indices, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;target, bool check_bounds=false, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a71c7d359043b804ba7b6b0c38606c8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters a row of scalar values into a copy of the target table according to a scatter map.  <a href="namespacecudf_1_1experimental.html#a71c7d359043b804ba7b6b0c38606c8d9">More...</a><br /></td></tr>
<tr class="separator:a71c7d359043b804ba7b6b0c38606c8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab89c9919455c060e0ab7b435d772a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1ab89c9919455c060e0ab7b435d772a1">scatter_to_tables</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;partition_map, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a1ab89c9919455c060e0ab7b435d772a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of a table to <code>n</code> tables according to a partition map.  <a href="namespacecudf_1_1experimental.html#a1ab89c9919455c060e0ab7b435d772a1">More...</a><br /></td></tr>
<tr class="separator:a1ab89c9919455c060e0ab7b435d772a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdcbe43fbe08248f14d1db5411b1336"><td class="memItemLeft" align="right" valign="top"><a id="a5bdcbe43fbe08248f14d1db5411b1336"></a>
std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slice</b> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, std::vector&lt; size_type &gt; const &amp;indices)</td></tr>
<tr class="separator:a5bdcbe43fbe08248f14d1db5411b1336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08f61e372c72069f45fcd2bcf9936e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aa08f61e372c72069f45fcd2bcf9936e8">split</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, std::vector&lt; size_type &gt; const  &amp;splits)</td></tr>
<tr class="memdesc:aa08f61e372c72069f45fcd2bcf9936e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits.  <a href="namespacecudf_1_1experimental.html#aa08f61e372c72069f45fcd2bcf9936e8">More...</a><br /></td></tr>
<tr class="separator:aa08f61e372c72069f45fcd2bcf9936e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcc600a269f9142df29f43dd61d6521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#abdcc600a269f9142df29f43dd61d6521">fill</a> (<a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;destination, size_type begin, size_type end, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;value)</td></tr>
<tr class="memdesc:abdcc600a269f9142df29f43dd61d6521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in-place in a column with a scalar value.  <a href="namespacecudf_1_1experimental.html#abdcc600a269f9142df29f43dd61d6521">More...</a><br /></td></tr>
<tr class="separator:abdcc600a269f9142df29f43dd61d6521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae713ac30fdf8c5f5b37f9f4612180f8b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ae713ac30fdf8c5f5b37f9f4612180f8b">fill</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, size_type begin, size_type end, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;value, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ae713ac30fdf8c5f5b37f9f4612180f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in a column out-of-place with a scalar value.  <a href="namespacecudf_1_1experimental.html#ae713ac30fdf8c5f5b37f9f4612180f8b">More...</a><br /></td></tr>
<tr class="separator:ae713ac30fdf8c5f5b37f9f4612180f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821183b38dc84793cf9ccc43abd3c86a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a821183b38dc84793cf9ccc43abd3c86a">repeat</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;count, bool check_count=false, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a821183b38dc84793cf9ccc43abd3c86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <a href="namespacecudf_1_1experimental.html#a821183b38dc84793cf9ccc43abd3c86a">More...</a><br /></td></tr>
<tr class="separator:a821183b38dc84793cf9ccc43abd3c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536b3d7781bb64ae0d9b8a64a0328be7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a536b3d7781bb64ae0d9b8a64a0328be7">repeat</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input_table, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;count, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a536b3d7781bb64ae0d9b8a64a0328be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <a href="namespacecudf_1_1experimental.html#a536b3d7781bb64ae0d9b8a64a0328be7">More...</a><br /></td></tr>
<tr class="separator:a536b3d7781bb64ae0d9b8a64a0328be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d54d902dca3ba2fda445aa97c3fd76"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a99d54d902dca3ba2fda445aa97c3fd76">merge</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;left_table, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;right_table, std::vector&lt; cudf::size_type &gt; const  &amp;key_cols, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">cudf::order</a> &gt; const  &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> &gt; const  &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a99d54d902dca3ba2fda445aa97c3fd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted tables.  <a href="namespacecudf_1_1experimental.html#a99d54d902dca3ba2fda445aa97c3fd76">More...</a><br /></td></tr>
<tr class="separator:a99d54d902dca3ba2fda445aa97c3fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785dc5fa5540c9b0e6329847216ac89b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a785dc5fa5540c9b0e6329847216ac89b">find_and_replace_all</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input_col, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;values_to_replace, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;replacement_values, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a785dc5fa5540c9b0e6329847216ac89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements from <code>input_col</code> according to the mapping <code>old_values</code> to.  <a href="namespacecudf_1_1experimental.html#a785dc5fa5540c9b0e6329847216ac89b">More...</a><br /></td></tr>
<tr class="separator:a785dc5fa5540c9b0e6329847216ac89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d7d63257ec8b61f4b5c5662dea8e5f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad2d7d63257ec8b61f4b5c5662dea8e5f">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;replacement, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ad2d7d63257ec8b61f4b5c5662dea8e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with corresponding values of another column.  <a href="namespacecudf_1_1experimental.html#ad2d7d63257ec8b61f4b5c5662dea8e5f">More...</a><br /></td></tr>
<tr class="separator:ad2d7d63257ec8b61f4b5c5662dea8e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4485649fdaa0a76de6b7fd2a90a5ffd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ac4485649fdaa0a76de6b7fd2a90a5ffd">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;replacement, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ac4485649fdaa0a76de6b7fd2a90a5ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with a scalar.  <a href="namespacecudf_1_1experimental.html#ac4485649fdaa0a76de6b7fd2a90a5ffd">More...</a><br /></td></tr>
<tr class="separator:ac4485649fdaa0a76de6b7fd2a90a5ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f3992f2b8b1d39234de4854a9e245f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a37f3992f2b8b1d39234de4854a9e245f">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, size_type preceding_window, size_type following_window, size_type min_periods, <a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a> op, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a37f3992f2b8b1d39234de4854a9e245f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.  <a href="namespacecudf_1_1experimental.html#a37f3992f2b8b1d39234de4854a9e245f">More...</a><br /></td></tr>
<tr class="separator:a37f3992f2b8b1d39234de4854a9e245f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb700f25d3bba6a9eefed85aab47fec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a2cb700f25d3bba6a9eefed85aab47fec">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;preceding_window, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;following_window, size_type min_periods, <a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a> op, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a2cb700f25d3bba6a9eefed85aab47fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a variable-size rolling window function to the values in a column.  <a href="namespacecudf_1_1experimental.html#a2cb700f25d3bba6a9eefed85aab47fec">More...</a><br /></td></tr>
<tr class="separator:a2cb700f25d3bba6a9eefed85aab47fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6440d8b1727cd90cdfaa0f01a1760dbd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a6440d8b1727cd90cdfaa0f01a1760dbd">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, size_type preceding_window, size_type following_window, size_type min_periods, std::string const  &amp;udf, <a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a6440d8b1727cd90cdfaa0f01a1760dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a fixed-size user-defined rolling window function to the values in a column.  <a href="namespacecudf_1_1experimental.html#a6440d8b1727cd90cdfaa0f01a1760dbd">More...</a><br /></td></tr>
<tr class="separator:a6440d8b1727cd90cdfaa0f01a1760dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3ce1e1b142b9b0c4a4e6772dd2f56b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a7e3ce1e1b142b9b0c4a4e6772dd2f56b">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;preceding_window, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;following_window, size_type min_periods, std::string const  &amp;udf, <a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a7e3ce1e1b142b9b0c4a4e6772dd2f56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a variable-size user-defined rolling window function to the values in a column.  <a href="namespacecudf_1_1experimental.html#a7e3ce1e1b142b9b0c4a4e6772dd2f56b">More...</a><br /></td></tr>
<tr class="separator:a7e3ce1e1b142b9b0c4a4e6772dd2f56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da07e36844255fd5bc535c5718a155a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9da07e36844255fd5bc535c5718a155a">lower_bound</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;t, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;values, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a9da07e36844255fd5bc535c5718a155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find smallest indices in a sorted table where values should be inserted to maintain order.  <a href="namespacecudf_1_1experimental.html#a9da07e36844255fd5bc535c5718a155a">More...</a><br /></td></tr>
<tr class="separator:a9da07e36844255fd5bc535c5718a155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3dfeef33f906f5d41725ca9abbd96"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a49f3dfeef33f906f5d41725ca9abbd96">upper_bound</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;t, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;values, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a49f3dfeef33f906f5d41725ca9abbd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find largest indices in a sorted table where values should be inserted to maintain order.  <a href="namespacecudf_1_1experimental.html#a49f3dfeef33f906f5d41725ca9abbd96">More...</a><br /></td></tr>
<tr class="separator:a49f3dfeef33f906f5d41725ca9abbd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebe78ecc15d10b4a5e3645d87624a28"><td class="memItemLeft" align="right" valign="top"><a id="aeebe78ecc15d10b4a5e3645d87624a28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;col, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;value, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:aeebe78ecc15d10b4a5e3645d87624a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a556203babe80f559453f18b5e4fd4"><td class="memItemLeft" align="right" valign="top"><a id="ae1a556203babe80f559453f18b5e4fd4"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;needles, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ae1a556203babe80f559453f18b5e4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac969ee758bff8ff7c0df765f5bd10bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aac969ee758bff8ff7c0df765f5bd10bd">is_sorted</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const  &amp;<a class="el" href="classcudf_1_1experimental_1_1table.html">table</a>, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence)</td></tr>
<tr class="memdesc:aac969ee758bff8ff7c0df765f5bd10bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the rows of a <code>table</code> are sorted in a lexicographical order.  <a href="namespacecudf_1_1experimental.html#aac969ee758bff8ff7c0df765f5bd10bd">More...</a><br /></td></tr>
<tr class="separator:aac969ee758bff8ff7c0df765f5bd10bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b484f1dcc0f825e04929974481811ee"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a0b484f1dcc0f825e04929974481811ee">sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> input, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order={}, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a0b484f1dcc0f825e04929974481811ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the row indices that would produce <code>input</code> in a lexicographical sorted order.  <a href="namespacecudf_1_1experimental.html#a0b484f1dcc0f825e04929974481811ee">More...</a><br /></td></tr>
<tr class="separator:a0b484f1dcc0f825e04929974481811ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefad034a999eb89006a326e42d1d6060"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aefad034a999eb89006a326e42d1d6060">apply_boolean_mask</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:aefad034a999eb89006a326e42d1d6060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters <code>input</code> using <code>boolean_mask</code> of boolean values as a mask.  <a href="namespacecudf_1_1experimental.html#aefad034a999eb89006a326e42d1d6060">More...</a><br /></td></tr>
<tr class="separator:aefad034a999eb89006a326e42d1d6060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051cdf96b8c340add8fe1416909d06e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a051cdf96b8c340add8fe1416909d06e7">drop_duplicates</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, std::vector&lt; size_type &gt; const  &amp;keys, <a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">duplicate_keep_option</a> const  &amp;keep, bool const  &amp;nulls_are_equal=true, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a051cdf96b8c340add8fe1416909d06e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table without duplicate rows.  <a href="namespacecudf_1_1experimental.html#a051cdf96b8c340add8fe1416909d06e7">More...</a><br /></td></tr>
<tr class="separator:a051cdf96b8c340add8fe1416909d06e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dceec176e91e0f709beaf6d93dbf07"><td class="memItemLeft" align="right" valign="top">cudf::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a49dceec176e91e0f709beaf6d93dbf07">unique_count</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, bool const  &amp;ignore_nulls, bool const  &amp;nan_as_null, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a49dceec176e91e0f709beaf6d93dbf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the unique elements in the <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>.  <a href="namespacecudf_1_1experimental.html#a49dceec176e91e0f709beaf6d93dbf07">More...</a><br /></td></tr>
<tr class="separator:a49dceec176e91e0f709beaf6d93dbf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac629d1af51251653c77f5da2d35551ac"><td class="memItemLeft" align="right" valign="top"><a id="ac629d1af51251653c77f5da2d35551ac"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>drop_nulls</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; size_type &gt; const &amp;keys, cudf::size_type keep_threshold, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ac629d1af51251653c77f5da2d35551ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7934432d5ebe72540d3362dd4e5dea3"><td class="memItemLeft" align="right" valign="top"><a id="ae7934432d5ebe72540d3362dd4e5dea3"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>drop_nulls</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; size_type &gt; const &amp;keys, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ae7934432d5ebe72540d3362dd4e5dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b56089ab0490194a96cdfd249a72181"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1b56089ab0490194a96cdfd249a72181">concatenate</a> (std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; const  &amp;tables_to_concat, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a1b56089ab0490194a96cdfd249a72181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Columns of <code>tables_to_concat</code> are concatenated vertically to return a single <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a>.  <a href="namespacecudf_1_1experimental.html#a1b56089ab0490194a96cdfd249a72181">More...</a><br /></td></tr>
<tr class="separator:a1b56089ab0490194a96cdfd249a72181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf88ec3542f2af93dfd48fbd38976c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9cf88ec3542f2af93dfd48fbd38976c1">transform</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, std::string const  &amp;unary_udf, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, bool is_ptx, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a9cf88ec3542f2af93dfd48fbd38976c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by applying a unary function against every element of an input column.  <a href="namespacecudf_1_1experimental.html#a9cf88ec3542f2af93dfd48fbd38976c1">More...</a><br /></td></tr>
<tr class="separator:a9cf88ec3542f2af93dfd48fbd38976c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fc07ab285374a3c0227870f10a86ce"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad3fc07ab285374a3c0227870f10a86ce">cast</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1data__type.html">data_type</a> out_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ad3fc07ab285374a3c0227870f10a86ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts data from dtype specified in input to dtype specified in output. Supports only fixed-width types.  <a href="namespacecudf_1_1experimental.html#ad3fc07ab285374a3c0227870f10a86ce">More...</a><br /></td></tr>
<tr class="separator:ad3fc07ab285374a3c0227870f10a86ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6145e96e588da5d0795b16b723d561"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#acc6145e96e588da5d0795b16b723d561">unary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const  &amp;input, cudf::experimental::unary_op op, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:acc6145e96e588da5d0795b16b723d561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unary op on all values in column.  <a href="namespacecudf_1_1experimental.html#acc6145e96e588da5d0795b16b723d561">More...</a><br /></td></tr>
<tr class="separator:acc6145e96e588da5d0795b16b723d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02f12f93710b16e26d1f9854f7700e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1b02f12f93710b16e26d1f9854f7700e">is_null</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const  &amp;input)</td></tr>
<tr class="memdesc:a1b02f12f93710b16e26d1f9854f7700e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code>BOOL8</code> elements where for every element in <code>input</code> <code>true</code> indicates the value is null and <code>false</code> indicates the value is valid.  <a href="namespacecudf_1_1experimental.html#a1b02f12f93710b16e26d1f9854f7700e">More...</a><br /></td></tr>
<tr class="separator:a1b02f12f93710b16e26d1f9854f7700e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d63048cdec020a53e53c9759a6d1c5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aa5d63048cdec020a53e53c9759a6d1c5">is_valid</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const  &amp;input)</td></tr>
<tr class="memdesc:aa5d63048cdec020a53e53c9759a6d1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code>BOOL8</code> elements where for every element in <code>input</code> <code>true</code> indicates the value is valid and <code>false</code> indicates the value is null.  <a href="namespacecudf_1_1experimental.html#aa5d63048cdec020a53e53c9759a6d1c5">More...</a><br /></td></tr>
<tr class="separator:aa5d63048cdec020a53e53c9759a6d1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9616e7fc22050601796328dfa9b4bb8c"><td class="memTemplParams" colspan="2">template&lt;typename Element , std::enable_if_t&lt; std::is_floating_point&lt; Element &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9616e7fc22050601796328dfa9b4bb8c"><td class="memTemplItemLeft" align="right" valign="top">__device__ <a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">weak_ordering</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9616e7fc22050601796328dfa9b4bb8c">relational_compare</a> (Element lhs, Element rhs)</td></tr>
<tr class="memdesc:a9616e7fc22050601796328dfa9b4bb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization for floating-point <code>Element</code> type rerlational comparison to derive the order of the elements with respect to <code>lhs</code>. Specialization is to handle <code>nan</code> in the order shown below. <code>[-Inf, -ve, 0, -0, +ve, +Inf, NaN, NaN, null] (for <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb" title="NULL values ordered after all other values.">null_order::AFTER</a>)</code> <code>[null, -Inf, -ve, 0, -0, +ve, +Inf, NaN, NaN] (for <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a>)</code>  <a href="namespacecudf_1_1experimental.html#a9616e7fc22050601796328dfa9b4bb8c">More...</a><br /></td></tr>
<tr class="separator:a9616e7fc22050601796328dfa9b4bb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4b9e142e2a1fd804dc76d76b260473"><td class="memTemplParams" colspan="2">template&lt;typename Element , std::enable_if_t&lt; std::is_floating_point&lt; Element &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1b4b9e142e2a1fd804dc76d76b260473"><td class="memTemplItemLeft" align="right" valign="top">__device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1b4b9e142e2a1fd804dc76d76b260473">equality_compare</a> (Element lhs, Element rhs)</td></tr>
<tr class="memdesc:a1b4b9e142e2a1fd804dc76d76b260473"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization for floating-point <code>Element</code> type to check if <code>lhs</code> is equivalent to <code>rhs</code>. <code>nan == nan</code>.  <a href="namespacecudf_1_1experimental.html#a1b4b9e142e2a1fd804dc76d76b260473">More...</a><br /></td></tr>
<tr class="separator:a1b4b9e142e2a1fd804dc76d76b260473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5b8575cc88f64e4462769d31a1f6b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b5b8575cc88f64e4462769d31a1f6b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">type_id</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a2b5b8575cc88f64e4462769d31a1f6b1">type_to_id</a> ()</td></tr>
<tr class="memdesc:a2b5b8575cc88f64e4462769d31a1f6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to it's corresponding <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code>  <a href="namespacecudf_1_1experimental.html#a2b5b8575cc88f64e4462769d31a1f6b1">More...</a><br /></td></tr>
<tr class="separator:a2b5b8575cc88f64e4462769d31a1f6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f3553fd1261d377365d94c676fff9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad9f3553fd1261d377365d94c676fff9d">CUDF_TYPE_MAPPING</a> (<a class="el" href="structcudf_1_1experimental_1_1bool8.html">cudf::experimental::bool8</a>, type_id::BOOL8)</td></tr>
<tr class="memdesc:ad9f3553fd1261d377365d94c676fff9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all of the mappings between C++ types and their corresponding.  <a href="namespacecudf_1_1experimental.html#ad9f3553fd1261d377365d94c676fff9d">More...</a><br /></td></tr>
<tr class="separator:ad9f3553fd1261d377365d94c676fff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff6e0b5db7196157adfb5faa011f1b7"><td class="memItemLeft" align="right" valign="top"><a id="a3ff6e0b5db7196157adfb5faa011f1b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (int8_t, type_id::INT8)</td></tr>
<tr class="separator:a3ff6e0b5db7196157adfb5faa011f1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489fd1f060cf737cb26e4744026733c8"><td class="memItemLeft" align="right" valign="top"><a id="a489fd1f060cf737cb26e4744026733c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (int16_t, type_id::INT16)</td></tr>
<tr class="separator:a489fd1f060cf737cb26e4744026733c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5785ebd158419d354bf667df484f362"><td class="memItemLeft" align="right" valign="top"><a id="ad5785ebd158419d354bf667df484f362"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (int32_t, type_id::INT32)</td></tr>
<tr class="separator:ad5785ebd158419d354bf667df484f362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e0b25771c047dc39840f34595809ce"><td class="memItemLeft" align="right" valign="top"><a id="a46e0b25771c047dc39840f34595809ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (int64_t, type_id::INT64)</td></tr>
<tr class="separator:a46e0b25771c047dc39840f34595809ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949aeffd308db900470760e1fc033639"><td class="memItemLeft" align="right" valign="top"><a id="a949aeffd308db900470760e1fc033639"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (float, type_id::FLOAT32)</td></tr>
<tr class="separator:a949aeffd308db900470760e1fc033639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81660d9cad03d5b63b4e337e4de787f0"><td class="memItemLeft" align="right" valign="top"><a id="a81660d9cad03d5b63b4e337e4de787f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (double, type_id::FLOAT64)</td></tr>
<tr class="separator:a81660d9cad03d5b63b4e337e4de787f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad993a174da1d622843a28a8eb1b12c1a"><td class="memItemLeft" align="right" valign="top"><a id="ad993a174da1d622843a28a8eb1b12c1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="classcudf_1_1string__view.html">cudf::string_view</a>, type_id::STRING)</td></tr>
<tr class="separator:ad993a174da1d622843a28a8eb1b12c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2bc82a400ae03c22f319b38cb8327a"><td class="memItemLeft" align="right" valign="top"><a id="aff2bc82a400ae03c22f319b38cb8327a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a177c346e93407722169284f15d260687">timestamp_D</a>, type_id::TIMESTAMP_DAYS)</td></tr>
<tr class="separator:aff2bc82a400ae03c22f319b38cb8327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1071906cfe415ec0daa049b0315ccf5c"><td class="memItemLeft" align="right" valign="top"><a id="a1071906cfe415ec0daa049b0315ccf5c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a3eb94ae284a4ec44c14765633fd6f0de">timestamp_s</a>, type_id::TIMESTAMP_SECONDS)</td></tr>
<tr class="separator:a1071906cfe415ec0daa049b0315ccf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642e3519279ed50228361b8b4d019ce7"><td class="memItemLeft" align="right" valign="top"><a id="a642e3519279ed50228361b8b4d019ce7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a1e65b98c47669295653e4fe59b66fe34">timestamp_ms</a>, type_id::TIMESTAMP_MILLISECONDS)</td></tr>
<tr class="separator:a642e3519279ed50228361b8b4d019ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2219be85dd02650f5ef1bf66e7e1f2cf"><td class="memItemLeft" align="right" valign="top"><a id="a2219be85dd02650f5ef1bf66e7e1f2cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a0455750f053fbc9234bd7f1478a8b8a2">timestamp_us</a>, type_id::TIMESTAMP_MICROSECONDS)</td></tr>
<tr class="separator:a2219be85dd02650f5ef1bf66e7e1f2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603c8e8302179754cdc7c4faa1b869c3"><td class="memItemLeft" align="right" valign="top"><a id="a603c8e8302179754cdc7c4faa1b869c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a8090bb1d4eb05e199337b8e98fcdddbf">timestamp_ns</a>, type_id::TIMESTAMP_NANOSECONDS)</td></tr>
<tr class="separator:a603c8e8302179754cdc7c4faa1b869c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b272ff7f81fde5d649dd75fd72144c"><td class="memTemplParams" colspan="2">template&lt;template&lt; cudf::type_id &gt; typename IdTypeMap = id_to_type_impl, typename Functor , typename... Ts&gt; </td></tr>
<tr class="memitem:a06b272ff7f81fde5d649dd75fd72144c"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto) CUDA_HOST_DEVICE_CALLABLE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a06b272ff7f81fde5d649dd75fd72144c">type_dispatcher</a> (<a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a> dtype, Functor f, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a06b272ff7f81fde5d649dd75fd72144c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes an <code>operator()</code> template with the type instantiation based on the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code>'s <code>id()</code>.  <a href="namespacecudf_1_1experimental.html#a06b272ff7f81fde5d649dd75fd72144c">More...</a><br /></td></tr>
<tr class="separator:a06b272ff7f81fde5d649dd75fd72144c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>In-development features. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a09ff9b3055486ff508a88bf2d891bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ff9b3055486ff508a88bf2d891bce8">&#9670;&nbsp;</a></span>id_to_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cudf::type_id Id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1experimental.html#a09ff9b3055486ff508a88bf2d891bce8">cudf::experimental::id_to_type</a> = typedef typename <a class="el" href="structcudf_1_1experimental_1_1id__to__type__impl.html">id_to_type_impl</a>&lt;Id&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code> to it's corresponding concrete C++ type. </p>
<p>------------------------------------------------------------------------&mdash;* Example: </p><div class="fragment"><div class="line">static_assert(std::is_same&lt;int32_t, id_to_type&lt;INT32&gt;);</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md540"></a>
@tparam t The &lt;tt&gt;cudf::type_id&lt;/tt&gt; to map</h2>

</div>
</div>
<a id="ab3198f71aa690ddfcd12b70245838c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3198f71aa690ddfcd12b70245838c78">&#9670;&nbsp;</a></span>scalar_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1experimental.html#ab3198f71aa690ddfcd12b70245838c78">cudf::experimental::scalar_type_t</a> = typedef typename <a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a>&lt;T&gt;::ScalarType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a C++ type to the scalar type required to hold its value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The concrete C++ type to map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a43b073c676d07d514a051888b2b753cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b073c676d07d514a051888b2b753cd">&#9670;&nbsp;</a></span>duplicate_keep_option</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">cudf::experimental::duplicate_keep_option</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choices for drop_duplicates API for retainment of duplicate rows. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43b073c676d07d514a051888b2b753cda5968b12bf2e72e702a998c7fa6c83b1e"></a>KEEP_FIRST&#160;</td><td class="fielddoc"><p>Keeps first duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b073c676d07d514a051888b2b753cda4583fc151efe5098dd96eeec8cf74699"></a>KEEP_LAST&#160;</td><td class="fielddoc"><p>Keeps last duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b073c676d07d514a051888b2b753cda40c4abe57c2fda3e580eee916b9e0558"></a>KEEP_NONE&#160;</td><td class="fielddoc"><p>Keeps only unique rows are kept. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5f4f0e0f1bfa906673bf5c2a2b13b151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4f0e0f1bfa906673bf5c2a2b13b151">&#9670;&nbsp;</a></span>interpolation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">cudf::experimental::interpolation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolation method to use when the desired quantile lies between two data points i and j. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151aaac544aacc3615aada24897a215f5046"></a>LINEAR&#160;</td><td class="fielddoc"><p>Linear interpolation between i and j. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151aa7c48ba367e019d004bfb0239b85f2b3"></a>LOWER&#160;</td><td class="fielddoc"><p>Lower data point (i) </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151a5bc0a7ce2c77ccd49169277e9289e5d1"></a>HIGHER&#160;</td><td class="fielddoc"><p>Higher data point (j) </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151aafa8fd4b90a3f8123b4bd30446518a7e"></a>MIDPOINT&#160;</td><td class="fielddoc"><p>(i + j)/2 </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151aad135772d7cf93dd0ccf9d2474b34e6a"></a>NEAREST&#160;</td><td class="fielddoc"><p>i or j, whichever is nearest </p>
</td></tr>
</table>

</div>
</div>
<a id="ad483c874f6010437111325063b87daef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad483c874f6010437111325063b87daef">&#9670;&nbsp;</a></span>mask_allocation_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">cudf::experimental::mask_allocation_policy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md279"></a>
@brief Indicates when to allocate a mask, based on an existing mask.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad483c874f6010437111325063b87daefa443475558f0168dff92ecde26b98ae5a"></a>NEVER&#160;</td><td class="fielddoc"><p>Do not allocate a null mask, regardless of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4"></a>RETAIN&#160;</td><td class="fielddoc"><p>Allocate a null mask if the input contains one. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad483c874f6010437111325063b87daefaf3fc827ade4b968e50406496907ef962"></a>ALWAYS&#160;</td><td class="fielddoc"><p>Allocate a null mask, regardless of input. </p>
</td></tr>
</table>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a3">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a86dd75929a008df2311021ba0753c22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dd75929a008df2311021ba0753c22a">&#9670;&nbsp;</a></span>rolling_operator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">cudf::experimental::rolling_operator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rolling window aggregation operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a86dd75929a008df2311021ba0753c22aa6970bdc2201030b9c03fbdcf3973858a"></a>SUM&#160;</td><td class="fielddoc"><p>Computes the sum of all values in the window. </p>
</td></tr>
<tr><td class="fieldname"><a id="a86dd75929a008df2311021ba0753c22aace31e2a082d17e038fcc6e3006166653"></a>MIN&#160;</td><td class="fielddoc"><p>Computes minimum value in the window. </p>
</td></tr>
<tr><td class="fieldname"><a id="a86dd75929a008df2311021ba0753c22aa26a4b44a837bf97b972628509912b4a5"></a>MAX&#160;</td><td class="fielddoc"><p>Computes maximum value in the window. </p>
</td></tr>
<tr><td class="fieldname"><a id="a86dd75929a008df2311021ba0753c22aa4ea6d1161ea24d7599365f574aff6610"></a>MEAN&#160;</td><td class="fielddoc"><p>Computes arithmetic mean of all values in the window. </p>
</td></tr>
<tr><td class="fieldname"><a id="a86dd75929a008df2311021ba0753c22aa4905ac9d6a22bdfc1ae096094ce6248d"></a>COUNT&#160;</td><td class="fielddoc"><p>Computes the number of values in the window. </p>
</td></tr>
<tr><td class="fieldname"><a id="a86dd75929a008df2311021ba0753c22aa4a0dd49d9250ae06cebde3075e441df9"></a>NUMBA_UDF&#160;</td><td class="fielddoc"><p>A user-defined aggregation operation defined in PTX code generated by <code>numba</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a86dd75929a008df2311021ba0753c22aa67f303e1658c4b438f74b2f02e626d92"></a>CUDA_UDF&#160;</td><td class="fielddoc"><p>A generic aggregation operation defined in CUDA code. </p>
</td></tr>
</table>

</div>
</div>
<a id="a57a49aef820830d7830862408645b8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a49aef820830d7830862408645b8c7">&#9670;&nbsp;</a></span>weak_ordering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">cudf::experimental::weak_ordering</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Result type of the <code><a class="el" href="classcudf_1_1experimental_1_1element__relational__comparator.html" title="Performs a relational comparison between two elements in two columns.">element_relational_comparator</a></code> function object. </p>
<p>------------------------------------------------------------------------&mdash;* Indicates how two elements <code>a</code> and <code>b</code> compare with one and another.</p>
<p>Equivalence is defined as <code>not (a&lt;b) and not (b&lt;a)</code>. Elements that are EQUIVALENT may not necessarily be <em>equal</em>.</p>
<hr  />
 <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a57a49aef820830d7830862408645b8c7a1798e8c3621ca53d9e3a80d257306000"></a>LESS&#160;</td><td class="fielddoc"><p>Indicates <code>a</code> is less than (ordered before) <code>b</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a57a49aef820830d7830862408645b8c7acd1908d025919ff975513ff143c3e34c"></a>EQUIVALENT&#160;</td><td class="fielddoc"><p>Indicates <code>a</code> is ordered neither before nor after <code>b</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a57a49aef820830d7830862408645b8c7ae7e72355289e404b762d4cf88824d23b"></a>GREATER&#160;</td><td class="fielddoc"><p>Indicates <code>a</code> is greater than (ordered after) <code>b</code> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a20ce6302e4458066d832420207ea7a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ce6302e4458066d832420207ea7a02">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the same size and type as the <code>input</code>. Supports only fixed-width types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A column with sufficient uninitialized capacity to hold the same number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a7">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a721801079c0de1398a1e089a39995ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721801079c0de1398a1e089a39995ce8">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the specified size and same type as the <code>input</code>. Supports only fixed-width types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The desired number of elements that the new column should have capacity for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A column with sufficient uninitialized capacity to hold the specified number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>

</div>
</div>
<a id="aefad034a999eb89006a326e42d1d6060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefad034a999eb89006a326e42d1d6060">&#9670;&nbsp;</a></span>apply_boolean_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt; cudf::experimental::apply_boolean_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters <code>input</code> using <code>boolean_mask</code> of boolean values as a mask. </p>
<p>Given an input <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code> and a mask <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>, an element <code>i</code> from each <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> of the <code>input</code> is copied to the corresponding output column if the corresponding element <code>i</code> in the mask is non-null and <code>true</code>. This operation is stable: the input order is preserved.</p>
<dl class="section note"><dt>Note</dt><dd>if <code>input.num_rows()</code> is zero, there is no error, and an empty table is returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if The <code>input</code> size and <code>boolean_mask</code> size mismatches. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>boolean_mask</code> is not <code>BOOL8</code> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a> to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>A nullable <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> of type BOOL8 used as a mask to filter the <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr<table class="doxtable">
</table>
containing copy of all rows of <code>input</code> passing the filter defined by <code>boolean_mask</code>. </dd></dl>

</div>
</div>
<a id="ad3fc07ab285374a3c0227870f10a86ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fc07ab285374a3c0227870f10a86ce">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>out_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts data from dtype specified in input to dtype specified in output. Supports only fixed-width types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></td><td>Input column </td></tr>
    <tr><td class="paramname">out_type</td><td>Desired datatype of output column</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;column&gt; Result of the cast operation </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>out_type</code> is not a fixed-width type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b56089ab0490194a96cdfd249a72181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b56089ab0490194a96cdfd249a72181">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::concatenate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tables_to_concat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Columns of <code>tables_to_concat</code> are concatenated vertically to return a single <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a>. </p>
<p>------------------------------------------------------------------------&mdash;* example: </p><div class="fragment"><div class="line">column_view c0; <span class="comment">//Contains {0,1,2,3}</span></div>
<div class="line">column_view c1; <span class="comment">//Contains {4,5,6,7}</span></div>
<div class="line">table_view t0{{c0, c0}};</div>
<div class="line">table_view t1{{c1, c1}};</div>
<div class="line">...</div>
<div class="line">auto t = <a class="code" href="namespacecudf_1_1experimental.html#a1b56089ab0490194a96cdfd249a72181">concatenate</a>({t0.view(), t1.view()});</div>
<div class="line">column_view tc0 = (t-&gt;view()).column(0); <span class="comment">//Contains {0,1,2,3,4,5,6,7}</span></div>
<div class="line">column_view tc1 = (t-&gt;view()).column(1); <span class="comment">//Contains {0,1,2,3,4,5,6,7}</span></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If number of columns mismatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables_to_concat</td><td>The table views to be concatenated into a single table </td></tr>
    <tr><td class="paramname">mr</td><td>Optional The resource to use for all allocations </td></tr>
    <tr><td class="paramname">stream</td><td>Optional The stream on which to execute all allocations and copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to a single table having all the rows from the </dd></dl>
<h2><a class="anchor" id="autotoc_md459"></a>
elements of &lt;tt&gt;tables_to_concat&lt;/tt&gt; respectively in the same order.</h2>

</div>
</div>
<a id="ad11643d0378285cf1d7b17826fbb35bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11643d0378285cf1d7b17826fbb35bb">&#9670;&nbsp;</a></span>copy_if_else()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: output[i] = (boolean_mask[i]) ? lhs[i] : rhs[i]</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same length </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean_mask contains nulls </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type <a class="el" href="structcudf_1_1experimental_1_1bool8.html">bool8</a> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs and rhs <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left-hand</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right-hand</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Non-nullable</td><td>column of <code>BOOL8</code> elements that control selection from <code>lhs</code> or <code>rhs</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>resource for allocating device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a10">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a77b5739505c21058c97d6f29c996c16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b5739505c21058c97d6f29c996c16f">&#9670;&nbsp;</a></span>copy_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>target_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements out-of-place from one column to another. </p>
<p>Creates a new column as if an in-place copy was performed into <code>target</code>. A copy of <code>target</code> is created first and then the elements indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) were copied from the elements indicated by the indices [<code>source_begin</code>, <code>source_end</code>) of <code>source</code> (where N = (<code>source_end</code> - <code>source_begin</code>)). Elements outside the range are copied from <code>target</code> into the returned new column target.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>target</code> and <code>source</code> have different types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The column to copy from inside the range. </td></tr>
    <tr><td class="paramname">target</td><td>The column to copy from outside the range. </td></tr>
    <tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
    <tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
    <tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate the result target column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; The result target column </dd></dl>

</div>
</div>
<a id="ac649c525d788647c5d6bf3b6b4cedb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac649c525d788647c5d6bf3b6b4cedb87">&#9670;&nbsp;</a></span>copy_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::experimental::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements in-place from one column to another. </p>
<p>Overwrites the range of elements in <code>target</code> indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) with the elements from <code>source</code> indicated by the indices [<code>source_begin</code>, <code>source_end</code>) (where N = (<code>source_end</code> - <code>source_begin</code>)). Use the out-of-place copy function returning std::unique_ptr&lt;column&gt; for uses cases requiring memory reallocation. For example for strings columns and other variable-width types.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if memory reallocation is required (e.g. for variable width types). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>target</code> and <code>source</code> have different types. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>source</code> has null values and <code>target</code> is not nullable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The column to copy from </td></tr>
    <tr><td class="paramname">target</td><td>The preallocated column to copy into </td></tr>
    <tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
    <tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
    <tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a8">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad9f3553fd1261d377365d94c676fff9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f3553fd1261d377365d94c676fff9d">&#9670;&nbsp;</a></span>CUDF_TYPE_MAPPING()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::experimental::CUDF_TYPE_MAPPING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1experimental_1_1bool8.html">cudf::experimental::bool8</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_id::BOOL8&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines all of the mappings between C++ types and their corresponding. </p>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md542"></a>
&lt;tt&gt;cudf::type_id&lt;/tt&gt; values.</h2>

</div>
</div>
<a id="a051cdf96b8c340add8fe1416909d06e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051cdf96b8c340add8fe1416909d06e7">&#9670;&nbsp;</a></span>drop_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt; cudf::experimental::drop_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">duplicate_keep_option</a> const &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&#160;</td>
          <td class="paramname"><em>nulls_are_equal</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table without duplicate rows. </p>
<p>Given an <code>input</code> <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a>, each row is copied to output table if the corresponding row of <code>keys</code> columns is unique, where the definition of unique depends on the value of <code>keep:</code> </p><ul>
<li>KEEP_FIRST: only the first of a sequence of duplicate rows is copied</li>
<li>KEEP_LAST: only the last of a sequence of duplicate rows is copied</li>
<li>KEEP_NONE: no duplicate rows are copied</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if The <code>input</code> row size mismatches with <code>keys</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>input <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a> to copy only unique rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>vector of indices representing key columns from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>keep first entry, last entry, or no entries if duplicates found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_are_equal</td><td>flag to denote nulls are equal if true, nulls are not equal if false </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr<table class="doxtable">
</table>
with unique rows as per specified <code>keep</code>. </dd></dl>

</div>
</div>
<a id="a9fadf20c2bcd430f728769d1bcd050ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fadf20c2bcd430f728769d1bcd050ec">&#9670;&nbsp;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of empty columns with the same types as the <code>input_table</code> </p>
<p>Creates the <code><a class="el" href="classcudf_1_1column.html">cudf::column</a></code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_table</td><td>Immutable view of input table to emulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;table&gt; A table of empty columns with the same types as the columns in <code>input_table</code> </dd></dl>

</div>
</div>
<a id="a1b4b9e142e2a1fd804dc76d76b260473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4b9e142e2a1fd804dc76d76b260473">&#9670;&nbsp;</a></span>equality_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , std::enable_if_t&lt; std::is_floating_point&lt; Element &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ bool cudf::experimental::equality_compare </td>
          <td>(</td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization for floating-point <code>Element</code> type to check if <code>lhs</code> is equivalent to <code>rhs</code>. <code>nan == nan</code>. </p>
<p>A specialization for non-floating-point <code>Element</code> type to check if <code>lhs</code> is equivalent to <code>rhs</code>.</p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second element </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md444"></a>
@return bool &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;lhs&lt;/tt&gt; == &lt;tt&gt;rhs&lt;/tt&gt; else &lt;tt&gt;false&lt;/tt&gt;.</h2>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second element </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md445"></a>
@return bool &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;lhs&lt;/tt&gt; == &lt;tt&gt;rhs&lt;/tt&gt; else &lt;tt&gt;false&lt;/tt&gt;.</h2>

</div>
</div>
<a id="ae713ac30fdf8c5f5b37f9f4612180f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae713ac30fdf8c5f5b37f9f4612180f8b">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in a column out-of-place with a scalar value. </p>
<p>------------------------------------------------------------------------&mdash;* Creates a new column as-if an in-place fill was performed into <code>input</code>; i.e. it is as if a copy of <code>input</code> was created first and then the elements indicated by the indices [<code>begin</code>, <code>end</code>) were overwritten by <code>value</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>for invalid range (if <code>begin</code> &lt; 0, <code>begin</code> &gt; <code>end</code>, <code>begin</code> &gt;= <code>destination.size()</code>, or <code>end</code> &gt; <code>destination.size()</code>). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>destination</code> and <code>value</code> have different types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column used to create a new column. The new column is created by replacing the values of <code>input</code> in the specified range with <code>value</code>. </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the fill range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>The index of the last element in the fill range (exclusive) </td></tr>
    <tr><td class="paramname">value</td><td>The scalar value to fill </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate the result output column </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md325"></a>
@return std::unique_ptr&lt;column&gt; The result output column</h2>

</div>
</div>
<a id="abdcc600a269f9142df29f43dd61d6521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcc600a269f9142df29f43dd61d6521">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::experimental::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in-place in a column with a scalar value. </p>
<p>------------------------------------------------------------------------&mdash;* Fills N elements of <code>destination</code> starting at <code>begin</code> with <code>value</code>, where N = (<code>end</code> - <code>begin</code>).</p>
<p>Overwrites the range of elements in <code>destination</code> indicated by the indices [<code>begin</code>, <code>end</code>) with <code>value</code>. Use the out-of-place fill function returning std::unique_ptr&lt;column&gt; for use cases requiring memory reallocation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if memory reallocation is required (e.g. for variable width types). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>for invalid range (if <code>begin</code> &lt; 0, <code>begin</code> &gt; <code>end</code>, <code>begin</code> &gt;= <code>destination.size()</code>, or <code>end</code> &gt; <code>destination.size()</code>). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>destination</code> and <code>value</code> have different types. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>value</code> is invalid but <code>destination</code> is not nullable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The preallocated column to fill into </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the fill range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>The index of the last element in the fill range (exclusive) </td></tr>
    <tr><td class="paramname">value</td><td>The scalar value to fill </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md324"></a>
@return void</h2>

</div>
</div>
<a id="a785dc5fa5540c9b0e6329847216ac89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785dc5fa5540c9b0e6329847216ac89b">&#9670;&nbsp;</a></span>find_and_replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::find_and_replace_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values_to_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements from <code>input_col</code> according to the mapping <code>old_values</code> to. </p>
<p>Return a copy of <code>input_col</code> replacing all <code>old_values[i]</code> present with <code>new_values[i]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_col</td><td>The column to find and replace values in. </td></tr>
    <tr><td class="paramname">values_to_replace</td><td>The values to replace </td></tr>
    <tr><td class="paramname">replacement_values</td><td>The values to replace with </td></tr>
    <tr><td class="paramname">mr</td><td>Optional device_memory_resource to use for allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of <code>input</code> with specified values replaced. </dd></dl>

</div>
</div>
<a id="a1edcfa60adcae62ead9197feeaf87ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edcfa60adcae62ead9197feeaf87ba0">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the specified rows (including null values) of a set of columns. </p>
<p>Gathers the rows of the source columns according to <code>gather_map</code> such that row "i" in the resulting table's columns will contain row "gather_map[i]" from the source columns. The number of rows in the result table will be equal to the number of elements in <code>gather_map</code>.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>View into a non-nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>gather_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;table&gt; Result of the gather </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a0">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1b02f12f93710b16e26d1f9854f7700e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b02f12f93710b16e26d1f9854f7700e">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::experimental::is_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code>BOOL8</code> elements where for every element in <code>input</code> <code>true</code> indicates the value is null and <code>false</code> indicates the value is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> as input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;cudf::column&gt; A non-nulalble column of <code>BOOL8</code> elements with <code>true</code> representing <code>null</code> values. </dd></dl>

</div>
</div>
<a id="aac969ee758bff8ff7c0df765f5bd10bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac969ee758bff8ff7c0df765f5bd10bd">&#9670;&nbsp;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::experimental::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the rows of a <code>table</code> are sorted in a lexicographical order. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>table whose rows need to be compared for ordering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column_order</td><td>The expected sort order for each column. Size must be equal to <code>in.num_columns()</code> or empty. If empty, it is expected all columns are in ascending order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_precedence</td><td>The desired order of null compared to other elements for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, <code><a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a></code> is assumed for all columns.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md438"></a>
@returns bool                true if sorted as expected, false if not.</h2>

</div>
</div>
<a id="aa5d63048cdec020a53e53c9759a6d1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d63048cdec020a53e53c9759a6d1c5">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::experimental::is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code>BOOL8</code> elements where for every element in <code>input</code> <code>true</code> indicates the value is valid and <code>false</code> indicates the value is null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> as input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;cudf::column&gt; A non-nulalble column of <code>BOOL8</code> elements with <code>false</code> representing <code>null</code> values. </dd></dl>

</div>
</div>
<a id="a9da07e36844255fd5bc535c5718a155a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da07e36844255fd5bc535c5718a155a">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find smallest indices in a sorted table where values should be inserted to maintain order. </p>
<p>For each row v in <code>values</code>, find the first index in <code>t</code> where inserting the row will maintain the sort order of <code>t</code> </p>
<p>Example:</p>
<p>Single column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 1 }</p>
<p>Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 3 }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Table to search </td></tr>
    <tr><td class="paramname">values</td><td>Find insert locations for these values </td></tr>
    <tr><td class="paramname">column_order</td><td>Vector of column sort order </td></tr>
    <tr><td class="paramname">null_precedence</td><td>Vector of null_precedence enums values </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to use for device memory allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A non-nullable column of cudf::size_type elements containing the insertion points. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2search_8hpp-example.html#a0">/rapids/cudf/cpp/include/cudf/search.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="afdf5751f91dd4da5c76b0b54fc2dc9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf5751f91dd4da5c76b0b54fc2dc9ee">&#9670;&nbsp;</a></span>make_quantile_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; cudf::experimental::make_quantile_aggregation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">interpolation</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory to create a QUANTILE aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantiles</td><td>The desired quantiles </td></tr>
    <tr><td class="paramname">interpolation</td><td>The desired interpolation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99d54d902dca3ba2fda445aa97c3fd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d54d902dca3ba2fda445aa97c3fd76">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt; cudf::experimental::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>left_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>right_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cudf::size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>key_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">cudf::order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted tables. </p>
<p>Merges two sorted tables into one sorted table containing data from both tables.</p>
<p>Example 1: input: table 1 =&gt; col 1 {0, 1, 2, 3} col 2 {4, 5, 6, 7} table 2 =&gt; col 1 {1, 2} col 2 {8, 9} output: table =&gt; col 1 {0, 1, 1, 2, 2, 3} col 2 {4, 5, 8, 6, 9, 7}</p>
<p>Example 2: input: table 1 =&gt; col 0 {1, 0} col 1 {'c', 'b'} col 2 {RED, GREEN}</p>
<p>table 2 =&gt; col 0 {1} col 1 {'a'} col 2 {NULL}</p>
<p>with key_cols[] = {0,1} and asc_desc[] = {ASC, ASC};</p>
<p>Lex-sorting is on columns {0,1}; hence, lex-sorting of ((L0 x L1) V (R0 x R1)) is: (0,'b', GREEN), (1,'a', NULL), (1,'c', RED)</p>
<p>(third column, the "color", just "goes along for the ride"; meaning is permutted according to the data movements dictated by lexicographic ordering of columns 0 and 1);</p>
<p>with result columns:</p>
<p>Res0 = {0,1,1} Res1 = {'b', 'a', 'c'} Res2 = {GREEN, NULL, RED}</p>
<p>@Param[in] left_table A sorted table to be merged @Param[in] right_table A sorted table to be merged @Param[in] key_cols Indices of left_cols and right_cols to be used for comparison criteria @Param[in] column_order Sort order types of columns indexed by key_cols @Param[in] null_precedence Array indicating the order of nulls with respect to non-nulls for the indexing columns (key_cols)</p>
<p>@Returns A table containing sorted data from left_table and right_table </p>

</div>
</div>
<a id="a9616e7fc22050601796328dfa9b4bb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9616e7fc22050601796328dfa9b4bb8c">&#9670;&nbsp;</a></span>relational_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , std::enable_if_t&lt; std::is_floating_point&lt; Element &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">weak_ordering</a> cudf::experimental::relational_compare </td>
          <td>(</td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization for floating-point <code>Element</code> type rerlational comparison to derive the order of the elements with respect to <code>lhs</code>. Specialization is to handle <code>nan</code> in the order shown below. <code>[-Inf, -ve, 0, -0, +ve, +Inf, NaN, NaN, null] (for <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb" title="NULL values ordered after all other values.">null_order::AFTER</a>)</code> <code>[null, -Inf, -ve, 0, -0, +ve, +Inf, NaN, NaN] (for <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a>)</code> </p>
<p>A specialization for non-floating-point <code>Element</code> type relational comparison to derive the order of the elements with respect to <code>lhs</code>.</p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weak_ordering Indicates the relationship between the elements in </dd></dl>
<h2><a class="anchor" id="autotoc_md442"></a>
the &lt;tt&gt;lhs&lt;/tt&gt; and &lt;tt&gt;rhs&lt;/tt&gt; columns.</h2>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weak_ordering Indicates the relationship between the elements in </dd></dl>
<h2><a class="anchor" id="autotoc_md443"></a>
the &lt;tt&gt;lhs&lt;/tt&gt; and &lt;tt&gt;rhs&lt;/tt&gt; columns.</h2>

</div>
</div>
<a id="a821183b38dc84793cf9ccc43abd3c86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821183b38dc84793cf9ccc43abd3c86a">&#9670;&nbsp;</a></span>repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_count</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table. </p>
<p>------------------------------------------------------------------------&mdash;* Creates a new table by repeating the rows of <code>input_table</code>. The number of repetitions of each element is defined by the value at the corresponding index of <code>count</code> Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = [1,2,3]</div>
<div class="line"><span class="keywordflow">return</span> = [4,5,5,6,6,6]</div>
</div><!-- fragment --><p> <code>count</code> should not have null values; should not contain negative values; and the sum of count elements should not overflow the size_type's limit. It is undefined behavior if <code>count</code> has negative values or the sum overflows and <code>check_count</code> is set to false.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if the data type of <code>count</code> is not size_type. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>input_table</code> and <code>count</code> have different number of rows. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>count</code> has null values. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_count</code> is set to true and <code>count</code> has negative values or the sum of <code>count</code> elements overflows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_table</td><td>Input table </td></tr>
    <tr><td class="paramname">count</td><td>Non-nullable column of a integral type </td></tr>
    <tr><td class="paramname">check_count</td><td>Whether to check count (negative values and overflow) </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate the result output table </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md326"></a>
@return std::unique_ptr&lt;table&gt; The result table containing the repetitions</h2>

</div>
</div>
<a id="a536b3d7781bb64ae0d9b8a64a0328be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536b3d7781bb64ae0d9b8a64a0328be7">&#9670;&nbsp;</a></span>repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table. </p>
<p>------------------------------------------------------------------------&mdash;* Creates a new table by repeating <code>count</code> times the rows of <code>input_table</code>. Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = 2</div>
<div class="line"><span class="keywordflow">return</span> = [4,4,5,5,6,6]</div>
</div><!-- fragment --> <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if the data type of <code>count</code> is not size_type. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>count</code> is invalid or <code>count</code> is negative. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>input_table.num_rows()</code> * <code>count</code> overflows size_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_table</td><td>Input table </td></tr>
    <tr><td class="paramname">count</td><td>Non-null scalar of a integral type </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate the result output table </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md327"></a>
@return std::unique_ptr&lt;table&gt; The result table containing the repetitions</h2>

</div>
</div>
<a id="ad2d7d63257ec8b61f4b5c5662dea8e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d7d63257ec8b61f4b5c5662dea8e5f">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::replace_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with corresponding values of another column. </p>
<p>If <code>input[i]</code> is NULL, then <code>output[i]</code> will contain <code>replacement[i]</code>. <code>input</code> and <code>replacement</code> must be of the same type and size. must be of the same type and same size as the first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A column whose null values will be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A <a class="el" href="classcudf_1_1column.html">cudf::column</a> whose values will replace null values in input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional device_memory_resource to use for allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <code>input</code> with the null values replaced with corresponding values from <code>replacement</code>. </dd></dl>

</div>
</div>
<a id="ac4485649fdaa0a76de6b7fd2a90a5ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4485649fdaa0a76de6b7fd2a90a5ffd">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::replace_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with a scalar. </p>
<p>If <code>input[i]</code> is NULL, then <code>output[i]</code> will contain <code>replacement</code>. <code>input</code> and <code>replacement</code> must have the same type. a <a class="el" href="classcudf_1_1scalar.html" title="An owning class to represent a singular value.">cudf::scalar</a> of the same data type as the column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A column whose null values will be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>Scalar used to replace null values in <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional device_memory_resource to use for allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of <code>input</code> with null values replaced by <code>replacement</code>. </dd></dl>

</div>
</div>
<a id="a2cb700f25d3bba6a9eefed85aab47fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb700f25d3bba6a9eefed85aab47fec">&#9670;&nbsp;</a></span>rolling_window() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a variable-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is dynamic (varying for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window + 1</code>. Element <code>i</code> uses elements <code>[i-preceding_window, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
<li>support for dynamic rolling windows, i.e. window size can be specified for each element using an additional array.</li>
</ul>
<p>The returned column for <code>op == COUNT</code> always has INT32 type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if window column type is not INT32</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_col</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>A non-nullable column of INT32 window sizes in the forward direction. <code>preceding_window[i]</code> specifies preceding window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>A non-nullable column of INT32 window sizes in the backward direction. <code>following_window[i]</code> specifies following window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The rolling window aggregation type (sum, max, min, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="a7e3ce1e1b142b9b0c4a4e6772dd2f56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3ce1e1b142b9b0c4a4e6772dd2f56b">&#9670;&nbsp;</a></span>rolling_window() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>udf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a variable-size user-defined rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column with a user defined aggregator, and invalidates the bit mask for element i if there are not enough observations. The window size is dynamic (varying for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window + 1</code>. Element <code>i</code> uses elements <code>[i-preceding_window, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>This function is asynchronous with respect to the GPU, i.e. the call will return before the operation is completed on the GPU (unless built in debug).</p>
<p>Currently the handling of the null values is only partially implemented: it acts as if every element of the input column is valid, i.e. the validity of the individual elements in the input column is not checked when the number of (valid) observations are counted and the aggregator is applied.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if window column type is not INT32</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_col</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>A non-nullable column of INT32 window sizes in the forward direction. <code>preceding_window[i]</code> specifies preceding window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>A non-nullable column of INT32 window sizes in the backward direction. <code>following_window[i]</code> specifies following window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">udf</td><td>A CUDA string or a PTX string compiled by numba that contains the implementation of the user defined aggregator function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The user-defined rolling window aggregation type: NUMBA_UDF (PTX string compiled by numba) or CUDA_UDF (CUDA string) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_type</td><td>Output type of the user-defined aggregator (only used for NUMBA_UDF)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="a37f3992f2b8b1d39234de4854a9e245f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f3992f2b8b1d39234de4854a9e245f">&#9670;&nbsp;</a></span>rolling_window() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a fixed-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is static (the same for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window + 1</code>. Element <code>i</code> uses elements <code>[i-preceding_window, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_col</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="a6440d8b1727cd90cdfaa0f01a1760dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6440d8b1727cd90cdfaa0f01a1760dbd">&#9670;&nbsp;</a></span>rolling_window() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>udf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#a86dd75929a008df2311021ba0753c22a">rolling_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a fixed-size user-defined rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column with a user defined aggregator, and invalidates the bit mask for element i if there are not enough observations. The window size is static (the same for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window + 1</code>. Element <code>i</code> uses elements <code>[i-preceding_window, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>This function is asynchronous with respect to the GPU, i.e. the call will return before the operation is completed on the GPU (unless built in debug).</p>
<p>Currently the handling of the null values is only partially implemented: it acts as if every element of the input column is valid, i.e. the validity of the individual elements in the input column is not checked when the number of (valid) observations are counted and the aggregator is applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_col</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">udf</td><td>A CUDA string or a PTX string compiled by numba that contains the implementation of the user defined aggregator function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The user-defined rolling window aggregation type: NUMBA_UDF (PTX string compiled by numba) or CUDA_UDF (CUDA string) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_type</td><td>Output type of the user-defined aggregator (only used for NUMBA_UDF)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="a71c7d359043b804ba7b6b0c38606c8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c7d359043b804ba7b6b0c38606c8d9">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::scatter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters a row of scalar values into a copy of the target table according to a scatter map. </p>
<p>Scatters values from the source row into the target table out-of-place, returning a "destination table". The scatter is performed according to a scatter map such that row <code>scatter_map[i]</code> of the destination table is replaced by the source row. All other rows of the destination table equal corresponding rows of the target table.</p>
<p>The number of elements in source must match the number of columns in target and their corresponding datatypes must be the same.</p>
<p>If the same index appears more than once in the scatter map, the result is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>scatter_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the target table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input scalars containing values to be scattered into the target columns </td></tr>
    <tr><td class="paramname">indices</td><td>A non-nullable column of integral indices that indicate the rows in the target table to be replaced by source. </td></tr>
    <tr><td class="paramname">target</td><td>The set of columns into which values from the source_table are to be scattered </td></tr>
    <tr><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>scatter_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramname">mr</td><td>The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md278"></a>
@return Result of scattering values from source to target</h2>

</div>
</div>
<a id="a66e9825f07db3744b175c518c687b537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e9825f07db3744b175c518c687b537">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>scatter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows of the source table into a copy of the target table according to a scatter map. </p>
<p>Scatters values from the source table into the target table out-of-place, returning a "destination table". The scatter is performed according to a scatter map such that row <code>scatter_map[i]</code> of the destination table gets row <code>i</code> of the source table. All other rows of the destination table equal corresponding rows of the target table.</p>
<p>The number of columns in source must match the number of columns in target and their corresponding datatypes must be the same.</p>
<p>If the same index appears more than once in the scatter map, the result is undefined.</p>
<p>A negative value <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>target</code> table.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>scatter_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the target table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input columns containing values to be scattered into the target columns </td></tr>
    <tr><td class="paramname">scatter_map</td><td>A non-nullable column of integral indices that maps the rows in the source table to rows in the target table. The size must be equal to or less than the number of elements in the source columns. </td></tr>
    <tr><td class="paramname">target</td><td>The set of columns into which values from the source_table are to be scattered </td></tr>
    <tr><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>scatter_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramname">mr</td><td>The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md277"></a>
@return Result of scattering values from source to target</h2>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a1">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1ab89c9919455c060e0ab7b435d772a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab89c9919455c060e0ab7b435d772a1">&#9670;&nbsp;</a></span>scatter_to_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; &gt; cudf::experimental::scatter_to_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>partition_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows of a table to <code>n</code> tables according to a partition map. </p>
<p>Copies the rows from the input table to new tables according to the table indices given by partition_map. The number of output tables is one more than the maximum value in <code>partition_map</code>.</p>
<p>Output table <code>i</code> in [0, n] is empty if <code>i</code> does not appear in partition_map. output table will be empty.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when partition_map is a non-integer type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when partition_map is larger than input </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when partition_map has nulls</td></tr>
  </table>
  </dd>
</dl>
<p>Example: input: [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28}, { 1, 2, 3, 4, null, 0, 2, 4, 6, 2}] partition_map: {3, 4, 3, 1, 4, 4, 0, 1, 1, 1} output: {[{22}, {2}], [{16, 24, 26, 28}, {4, 4, 6, 2}], [{}, {}], [{10, 14}, {1, 3}], [{12, 18, 20}, {2, null, 0}]}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Table of rows to be partitioned into a set of tables tables according to <code>partition_map</code> </td></tr>
    <tr><td class="paramname">partition_map</td><td>Non-null column of integer values that map each row in <code>input</code> table into one of the output tables </td></tr>
    <tr><td class="paramname">mr</td><td>The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of tables containing the scattered rows of <code>input</code>. <code>table</code> <code>i</code> contains all rows <code>j</code> from <code>input</code> where <code>partition_map[j] == i</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a2">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0b484f1dcc0f825e04929974481811ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b484f1dcc0f825e04929974481811ee">&#9670;&nbsp;</a></span>sorted_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::sorted_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the row indices that would produce <code>input</code> in a lexicographical sorted order. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to sort </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired sort order for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of null compared to other elements for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted in <code><a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A non-nullable column of INT32 elements </dd></dl>
<h2><a class="anchor" id="autotoc_md437"></a>
containing the permuted row indices of &lt;tt&gt;input&lt;/tt&gt; if it were sorted</h2>

</div>
</div>
<a id="aa08f61e372c72069f45fcd2bcf9936e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08f61e372c72069f45fcd2bcf9936e8">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::experimental::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits. </p>
<p>The returned view's of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>splits[i] != input.size()</code>, or <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code></p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to ensure that the returned view does not outlive the viewed device memory.</dd></dl>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} splits: {2, 5, 9} output: {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to split </td></tr>
    <tr><td class="paramname">splits</td><td>A vector of indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a9">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9cf88ec3542f2af93dfd48fbd38976c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf88ec3542f2af93dfd48fbd38976c1">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>unary_udf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_ptx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column by applying a unary function against every element of an input column. </p>
<p>Computes: <code>out[i] = F(in[i])</code></p>
<p>The output null mask is the same is the input null mask so if input[i] is null then output[i] is also null</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>An immutable view of the input column to transform </td></tr>
    <tr><td class="paramname">unary_udf</td><td>The PTX/CUDA string of the unary function to apply </td></tr>
    <tr><td class="paramname">outout_type</td><td>The output type that is compatible with the output type in the UDF </td></tr>
    <tr><td class="paramname">is_ptx</td><td>true: the UDF is treated as PTX code; false: the UDF is treated as CUDA code </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for for all device allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcudf_1_1column.html">cudf::column</a> The column resulting from applying the unary function to every element of the input </dd></dl>

</div>
</div>
<a id="a06b272ff7f81fde5d649dd75fd72144c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b272ff7f81fde5d649dd75fd72144c">&#9670;&nbsp;</a></span>type_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; cudf::type_id &gt; typename IdTypeMap = id_to_type_impl, typename Functor , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) CUDA_HOST_DEVICE_CALLABLE cudf::experimental::type_dispatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes an <code>operator()</code> template with the type instantiation based on the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code>'s <code>id()</code>. </p>
<p>------------------------------------------------------------------------&mdash;* Example usage with a functor that returns the size of the dispatched type:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>size_of_functor{</div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"> <span class="keywordtype">int</span> operator()(){</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(T);</div>
<div class="line"> }</div>
<div class="line">};</div>
<div class="line"><a class="code" href="classcudf_1_1data__type.html">cudf::data_type</a> t{<a class="code" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae">INT32</a>};</div>
<div class="line">cudf::type_dispatcher(t, size_of_functor{});  <span class="comment">// returns 4</span></div>
</div><!-- fragment --><p>The <code>type_dispatcher</code> uses <code>cudf::type_to_id&lt;t&gt;</code> to provide a default mapping of <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code>s to dispatched C++ types. However, this mapping may be customized by explicitly specifying a user-defined trait struct for the <code>IdTypeMap</code>. For example, to always dispatch <code>int32_t</code></p>
<p>``` template&lt;cudf::type_id t&gt; struct always_int{ using type = int32_t; }</p>
<p>// This will always invoke <code>operator()&lt;int32_t&gt;</code> cudf::type_dispatcher&lt;always_int&gt;(data_type, f); </p><div class="fragment"><div class="line">It is sometimes necessary to customize the dispatched functor<span class="stringliteral">&#39;s</span></div>
<div class="line"><span class="stringliteral">`operator()` for different types.  This can be done in several ways.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">The first method is to use explicit template specialization. This is useful</span></div>
<div class="line"><span class="stringliteral">for specializing behavior for single types. For example, a functor that</span></div>
<div class="line"><span class="stringliteral">prints `int32_t` or `double` when invoked with either of those types, else it</span></div>
<div class="line"><span class="stringliteral">prints `unhandled type`:</span></div>
</div><!-- fragment --><p> struct type_printer { template &lt;typename columntype&gt;=""&gt; void operator()() { std::cout &lt;&lt; "unhandled type\n"; } };</p>
<p>// Due to a bug in g++, explicit member function specializations need to be // defined outside of the class definition template &lt;&gt; void type_printer::operator()&lt;int32_t&gt;() { std::cout &lt;&lt; "int32_t\n"; }</p>
<p>template &lt;&gt; void type_printer::operator()&lt;double&gt;() { std::cout &lt;&lt; "double\n"; } </p><div class="fragment"><div class="line">A second method is to use SFINAE with `std::enable_if_t`. This is useful <span class="keywordflow">for</span></div>
<div class="line">specializing <span class="keywordflow">for</span> a set of types that share some <span class="keyword">property</span>. For example, a</div>
<div class="line">functor that prints `integral` or `floating point` <span class="keywordflow">for</span> integral or floating</div>
<div class="line">point types:</div>
</div><!-- fragment --><p> struct integral_or_floating_point { template &lt;typename ColumnType, std::enable_if_t&lt;not std::is_integral&lt;ColumnType&gt;::value and not std::is_floating_point&lt;ColumnType&gt;::value&gt;* *= nullptr&gt; void operator()() { std::cout &lt;&lt; "neither integral nor floating
*point\n"; } </p><pre class="fragment">template &lt;typename ColumnType,
          std::enable_if_t&lt;std::is_integral&lt;ColumnType&gt;::value&gt;* = nullptr&gt;
void operator()() { std::cout &lt;&lt; "integral\n"; }

template &lt; typename ColumnType,
           std::enable_if_t&lt;std::is_floating_point&lt;ColumnType&gt;::value&gt;* =
</pre><p> *nullptr&gt; void operator()() { std::cout &lt;&lt; "floating point\n"; } }; ```</p>
<p>For more info on SFINAE and <code>std::enable_if</code>, see <a href="https://eli.thegreenplace.net/2014/sfinae-and-enable_if/">https://eli.thegreenplace.net/2014/sfinae-and-enable_if/</a></p>
<p>The return type for all template instantiations of the functor's "operator()" lambda must be the same, else there will be a compiler error as you would be trying to return different types from the same function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1experimental_1_1id__to__type__impl.html">id_to_type_impl</a></td><td>Maps a <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code> its dispatched C++ type </td></tr>
    <tr><td class="paramname">Functor</td><td>The callable object's type </td></tr>
    <tr><td class="paramname">Ts</td><td>Variadic parameter pack type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code> whose <code>id()</code> determines which template instantiation is invoked </td></tr>
    <tr><td class="paramname">f</td><td>The callable whose <code>operator()</code> template is invoked </td></tr>
    <tr><td class="paramname">args</td><td>Parameter pack of arguments forwarded to the <code>operator()</code> invocation </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md543"></a>
@return Whatever is returned by the callable's &lt;tt&gt;operator()&lt;/tt&gt;</h2>

</div>
</div>
<a id="a2b5b8575cc88f64e4462769d31a1f6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5b8575cc88f64e4462769d31a1f6b1">&#9670;&nbsp;</a></span>type_to_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">type_id</a> cudf::experimental::type_to_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a C++ type to it's corresponding <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code> </p>
<p>------------------------------------------------------------------------&mdash;* When explicitly passed a template argument of a given type, returns the appropriate <code>type_id</code> enum for the specified C++ type.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> cudf::type_to_id&lt;int32_t&gt;();        <span class="comment">// Returns INT32</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md539"></a>
@tparam T The type to map to a &lt;tt&gt;cudf::type_id&lt;/tt&gt;</h2>

</div>
</div>
<a id="acc6145e96e588da5d0795b16b723d561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6145e96e588da5d0795b16b723d561">&#9670;&nbsp;</a></span>unary_operation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::experimental::unary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::experimental::unary_op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs unary op on all values in column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> as input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>operation to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;cudf::column&gt; Result of the operation </dd></dl>

</div>
</div>
<a id="a49dceec176e91e0f709beaf6d93dbf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dceec176e91e0f709beaf6d93dbf07">&#9670;&nbsp;</a></span>unique_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::size_type cudf::experimental::unique_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&#160;</td>
          <td class="paramname"><em>ignore_nulls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&#160;</td>
          <td class="paramname"><em>nan_as_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the unique elements in the <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>. </p>
<p>Given an input <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>, number of unique elements in this <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> is returned</p>
<p>If both <code>ignore_nulls</code> and <code>nan_as_null</code> are true, both <code>NaN</code> and <code>null</code> values are ignored. If <code>ignore_nulls</code> is true and <code>nan_as_null</code> is false, only <code>null</code> is ignored, <code>NaN</code> is considered in unique count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> whose unique elements will be counted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_nulls</td><td>flag to ignore <code>null</code> in unique count if true </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nan_as_null</td><td>flag to consider <code>NaN==null</code> if true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unique elements </dd></dl>

</div>
</div>
<a id="a49f3dfeef33f906f5d41725ca9abbd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f3dfeef33f906f5d41725ca9abbd96">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find largest indices in a sorted table where values should be inserted to maintain order. </p>
<p>For each row v in <code>values</code>, find the last index in <code>t</code> where inserting the row will maintain the sort order of <code>t</code> </p>
<p>Example:</p>
<p>Single Column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 3 }</p>
<p>Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 5 * * </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>Table to search </td></tr>
    <tr><td class="paramname">values</td><td>Find insert locations for these values </td></tr>
    <tr><td class="paramname">column_order</td><td>Vector of column sort order </td></tr>
    <tr><td class="paramname">null_precedence</td><td>Vector of null_precedence enums values </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to use for device memory allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A non-nullable column of cudf::size_type elements containing the insertion points. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2search_8hpp-example.html#a1">/rapids/cudf/cpp/include/cudf/search.hpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacecudf_1_1experimental_html_a1b56089ab0490194a96cdfd249a72181"><div class="ttname"><a href="namespacecudf_1_1experimental.html#a1b56089ab0490194a96cdfd249a72181">cudf::experimental::concatenate</a></div><div class="ttdeci">std::unique_ptr&lt; table &gt; concatenate(std::vector&lt; table_view &gt; const &amp;tables_to_concat, rmm::mr::device_memory_resource *mr, cudaStream_t stream)</div><div class="ttdoc">Columns of tables_to_concat are concatenated vertically to return a single table_view.</div><div class="ttdef"><b>Definition:</b> table.cpp:92</div></div>
<div class="ttc" id="aclasscudf_1_1data__type_html"><div class="ttname"><a href="classcudf_1_1data__type.html">cudf::data_type</a></div><div class="ttdoc">Indicator for the logical data type of an element in a column.</div><div class="ttdef"><b>Definition:</b> types.hpp:164</div></div>
<div class="ttc" id="anamespacecudf_html_acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae"><div class="ttname"><a href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae">cudf::INT32</a></div><div class="ttdoc">4 byte signed integer</div><div class="ttdef"><b>Definition:</b> types.hpp:142</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
