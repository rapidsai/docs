<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: NVStrings Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classNVStrings-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NVStrings Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class manages a list of strings stored in device memory. An instance of this class is a CPU (host) object whose methods run on all the strings it manages in parallel on the GPU.  
 <a href="classNVStrings.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="NVStrings_8h_source.html">NVStrings.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a48a22848cee202e59b5a1ba22c8c3831"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a> { <a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831a0b5479f46e32a0b52419271376591269">none</a> =0, 
<a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831a744462e227edbd3642f8baf46d35b4ca">length</a> =1, 
<a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831a2f5d336f9e795adab8ed537aa190ff23">name</a> =2
 }</td></tr>
<tr class="memdesc:a48a22848cee202e59b5a1ba22c8c3831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorting by attributes.  <a href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">More...</a><br /></td></tr>
<tr class="separator:a48a22848cee202e59b5a1ba22c8c3831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae632539abce4f345d9c6995cc407281e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ae632539abce4f345d9c6995cc407281e">padside</a> { <a class="el" href="classNVStrings.html#ae632539abce4f345d9c6995cc407281ea27a6f390cacbee032b9099765c3277dd">left</a>, 
<a class="el" href="classNVStrings.html#ae632539abce4f345d9c6995cc407281ea410c51e93c57cfd4df319a7b925a2dec">right</a>, 
<a class="el" href="classNVStrings.html#ae632539abce4f345d9c6995cc407281ea5b01f59b3412cfffe0dab5fc41d3e46f">both</a>
 }</td></tr>
<tr class="memdesc:ae632539abce4f345d9c6995cc407281e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding placement points. Used in the <a class="el" href="classNVStrings.html#aefbe772d7e225d41e2837280edc8cd08" title="Add padding to each string using a provided character.">pad()</a> method.  <a href="classNVStrings.html#ae632539abce4f345d9c6995cc407281e">More...</a><br /></td></tr>
<tr class="separator:ae632539abce4f345d9c6995cc407281e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac845d8278c06a59a3dd9b7c05d81b049"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049">timestamp_units</a> { <br />
&#160;&#160;<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049a8667ec773f6dbfafbbfe0d0b9deecd14">years</a>, 
<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049aeed9e40cde5808e62979d57dbc381f51">months</a>, 
<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049a4ba1905c4ab3c8ae7094614084649d39">days</a>, 
<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049a046925b9e4b8b8bb927942bc4648f981">hours</a>, 
<br />
&#160;&#160;<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049a4262801072819bc89e488b9a111135f9">minutes</a>, 
<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049ad305a26f0c3deec9fa4bf14d8f778a40">seconds</a>, 
<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049a03457e192cd793d83b4553f1a3822e71">ms</a>, 
<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049abc729d3656e7635668dcacdd7f5b68d9">us</a>, 
<br />
&#160;&#160;<a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049a4d185b3b79bf8f4cf83d5eb349427294">ns</a>
<br />
 }</td></tr>
<tr class="memdesc:ac845d8278c06a59a3dd9b7c05d81b049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Units for timestamp conversion.  <a href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049">More...</a><br /></td></tr>
<tr class="separator:ac845d8278c06a59a3dd9b7c05d81b049"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30dbfbbb531a5354c398d3701d521332"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a30dbfbbb531a5354c398d3701d521332">memsize</a> () const</td></tr>
<tr class="memdesc:a30dbfbbb531a5354c398d3701d521332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of device bytes used by this instance.  <a href="classNVStrings.html#a30dbfbbb531a5354c398d3701d521332">More...</a><br /></td></tr>
<tr class="separator:a30dbfbbb531a5354c398d3701d521332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e454d488b47498f7171acf4980990a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a">size</a> () const</td></tr>
<tr class="memdesc:ac0e454d488b47498f7171acf4980990a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of strings managed by this instance.  <a href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a">More...</a><br /></td></tr>
<tr class="separator:ac0e454d488b47498f7171acf4980990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f4f0afb3ce81b689af581610c52e9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ad3f4f0afb3ce81b689af581610c52e9f">create_index</a> (std::pair&lt; const char *, size_t &gt; *strs, bool devmem=true)</td></tr>
<tr class="memdesc:ad3f4f0afb3ce81b689af581610c52e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an index for the device strings contained in this instance.  <a href="classNVStrings.html#ad3f4f0afb3ce81b689af581610c52e9f">More...</a><br /></td></tr>
<tr class="separator:ad3f4f0afb3ce81b689af581610c52e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f4b15664c2ea580584f3cdea219499"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a54f4b15664c2ea580584f3cdea219499">create_custring_index</a> (custring_view **strs, bool devmem=true) const</td></tr>
<tr class="memdesc:a54f4b15664c2ea580584f3cdea219499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list to the internal <code>custring_view</code> pointers for this instance.  <a href="classNVStrings.html#a54f4b15664c2ea580584f3cdea219499">More...</a><br /></td></tr>
<tr class="separator:a54f4b15664c2ea580584f3cdea219499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec46344fcc2f2f6a5b068716b9ee4b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a6ec46344fcc2f2f6a5b068716b9ee4b9">create_offsets</a> (char *strs, int *offsets, unsigned char *nullbitmask=0, bool devmem=true)</td></tr>
<tr class="memdesc:a6ec46344fcc2f2f6a5b068716b9ee4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy strings into single memory buffer provided.  <a href="classNVStrings.html#a6ec46344fcc2f2f6a5b068716b9ee4b9">More...</a><br /></td></tr>
<tr class="separator:a6ec46344fcc2f2f6a5b068716b9ee4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1de85578e794a315f189d42b2235033"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aa1de85578e794a315f189d42b2235033">create_ipc_transfer</a> (<a class="el" href="structnvstrings__ipc__transfer.html">nvstrings_ipc_transfer</a> &amp;ipc)</td></tr>
<tr class="memdesc:aa1de85578e794a315f189d42b2235033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create IPC-transfer data from this instance.  <a href="classNVStrings.html#aa1de85578e794a315f189d42b2235033">More...</a><br /></td></tr>
<tr class="separator:aa1de85578e794a315f189d42b2235033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13cc0d4eae84b8c11393c2a6f40251f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#af13cc0d4eae84b8c11393c2a6f40251f">set_null_bitarray</a> (unsigned char *bitarray, bool emptyIsNull=false, bool devmem=true)</td></tr>
<tr class="memdesc:af13cc0d4eae84b8c11393c2a6f40251f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit-array identifying the null strings.  <a href="classNVStrings.html#af13cc0d4eae84b8c11393c2a6f40251f">More...</a><br /></td></tr>
<tr class="separator:af13cc0d4eae84b8c11393c2a6f40251f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaa1f3326fb1a25d3193d16d4fdb336"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#adaaa1f3326fb1a25d3193d16d4fdb336">get_nulls</a> (unsigned int *pos, bool emptyIsNull=false, bool devmem=true)</td></tr>
<tr class="memdesc:adaaa1f3326fb1a25d3193d16d4fdb336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set int array with position of null strings.  <a href="classNVStrings.html#adaaa1f3326fb1a25d3193d16d4fdb336">More...</a><br /></td></tr>
<tr class="separator:adaaa1f3326fb1a25d3193d16d4fdb336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4504cca8fc5594f3813ac86f2b4e156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac4504cca8fc5594f3813ac86f2b4e156">copy</a> () const</td></tr>
<tr class="memdesc:ac4504cca8fc5594f3813ac86f2b4e156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance from this instance.  <a href="classNVStrings.html#ac4504cca8fc5594f3813ac86f2b4e156">More...</a><br /></td></tr>
<tr class="separator:ac4504cca8fc5594f3813ac86f2b4e156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b45be9b52d01835d510245cf4a0f10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a11b45be9b52d01835d510245cf4a0f10">to_host</a> (char **list, int start, int end)</td></tr>
<tr class="memdesc:a11b45be9b52d01835d510245cf4a0f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the list of strings into the provided host memory.  <a href="classNVStrings.html#a11b45be9b52d01835d510245cf4a0f10">More...</a><br /></td></tr>
<tr class="separator:a11b45be9b52d01835d510245cf4a0f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828b11920c0a9da7313a267c7946affc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a828b11920c0a9da7313a267c7946affc">sublist</a> (unsigned int start, unsigned int end, int step=0)</td></tr>
<tr class="memdesc:a828b11920c0a9da7313a267c7946affc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance containing only the strings in the specified range.  <a href="classNVStrings.html#a828b11920c0a9da7313a267c7946affc">More...</a><br /></td></tr>
<tr class="separator:a828b11920c0a9da7313a267c7946affc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55264aa46a79ae924850a4d1a29e3cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a55264aa46a79ae924850a4d1a29e3cce">gather</a> (const int *pos, unsigned int count, bool devmem=true)</td></tr>
<tr class="memdesc:a55264aa46a79ae924850a4d1a29e3cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new instance using the order of the specified index values for this instance.  <a href="classNVStrings.html#a55264aa46a79ae924850a4d1a29e3cce">More...</a><br /></td></tr>
<tr class="separator:a55264aa46a79ae924850a4d1a29e3cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12bdc59898ac6a8094c971fdf565923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ad12bdc59898ac6a8094c971fdf565923">gather</a> (const bool *mask, bool devmem=true)</td></tr>
<tr class="memdesc:ad12bdc59898ac6a8094c971fdf565923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new instance where the corresponding boolean array values are true.  <a href="classNVStrings.html#ad12bdc59898ac6a8094c971fdf565923">More...</a><br /></td></tr>
<tr class="separator:ad12bdc59898ac6a8094c971fdf565923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22d0d1d8105e8bbffcf64d457810737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ae22d0d1d8105e8bbffcf64d457810737">scatter</a> (<a class="el" href="classNVStrings.html">NVStrings</a> &amp;strs, const int *pos, bool devmem=true)</td></tr>
<tr class="memdesc:ae22d0d1d8105e8bbffcf64d457810737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new instance using the provided index values and strings instance. The position values specify the location in the new strings instance. Missing values pass through from this instance at those positions.  <a href="classNVStrings.html#ae22d0d1d8105e8bbffcf64d457810737">More...</a><br /></td></tr>
<tr class="separator:ae22d0d1d8105e8bbffcf64d457810737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eedb3c2baa8762e140c386c499892a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a2eedb3c2baa8762e140c386c499892a5">scatter</a> (const char *str, const int *pos, unsigned int count, bool devmem=true)</td></tr>
<tr class="memdesc:a2eedb3c2baa8762e140c386c499892a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new instance using the provided index values and strings instance. The position values specify the location in the new strings instance. Missing values pass through from this instance at those positions.  <a href="classNVStrings.html#a2eedb3c2baa8762e140c386c499892a5">More...</a><br /></td></tr>
<tr class="separator:a2eedb3c2baa8762e140c386c499892a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a02cf5cdc90361aecbc1602f96a47d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a1a02cf5cdc90361aecbc1602f96a47d4">remove_strings</a> (const int *pos, unsigned int count, bool devmem=true)</td></tr>
<tr class="memdesc:a1a02cf5cdc90361aecbc1602f96a47d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new instance without the specified strings.  <a href="classNVStrings.html#a1a02cf5cdc90361aecbc1602f96a47d4">More...</a><br /></td></tr>
<tr class="separator:a1a02cf5cdc90361aecbc1602f96a47d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f982345feb2bb6c313cb465d68a4e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a3f982345feb2bb6c313cb465d68a4e58">sort</a> (<a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a> stype=sorttype::name, bool ascending=true, bool nullfirst=true)</td></tr>
<tr class="memdesc:a3f982345feb2bb6c313cb465d68a4e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sorted copy of the strings managed by this instance.  <a href="classNVStrings.html#a3f982345feb2bb6c313cb465d68a4e58">More...</a><br /></td></tr>
<tr class="separator:a3f982345feb2bb6c313cb465d68a4e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47e5bf838dfe8f75620ad539d90cfc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#af47e5bf838dfe8f75620ad539d90cfc8">order</a> (<a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a> stype, bool ascending, unsigned int *indexes, bool nullfirst=true, bool devmem=true)</td></tr>
<tr class="memdesc:af47e5bf838dfe8f75620ad539d90cfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new row index positions for strings sorted in this instance.  <a href="classNVStrings.html#af47e5bf838dfe8f75620ad539d90cfc8">More...</a><br /></td></tr>
<tr class="separator:af47e5bf838dfe8f75620ad539d90cfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e22a977c3d75aa43923fee20c49a194"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a3e22a977c3d75aa43923fee20c49a194">len</a> (int *lengths, bool devmem=true) const</td></tr>
<tr class="memdesc:a3e22a977c3d75aa43923fee20c49a194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of characters in each string.  <a href="classNVStrings.html#a3e22a977c3d75aa43923fee20c49a194">More...</a><br /></td></tr>
<tr class="separator:a3e22a977c3d75aa43923fee20c49a194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0079100118fa07b92d98b4f32a881e47"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a0079100118fa07b92d98b4f32a881e47">byte_count</a> (int *lengths, bool devmem=true)</td></tr>
<tr class="memdesc:a0079100118fa07b92d98b4f32a881e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of bytes for each string.  <a href="classNVStrings.html#a0079100118fa07b92d98b4f32a881e47">More...</a><br /></td></tr>
<tr class="separator:a0079100118fa07b92d98b4f32a881e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6188f6c25e88285f0f3b74e89a69e7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#abc6188f6c25e88285f0f3b74e89a69e7">isalnum</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:abc6188f6c25e88285f0f3b74e89a69e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for strings that have only alphanumeric characters.  <a href="classNVStrings.html#abc6188f6c25e88285f0f3b74e89a69e7">More...</a><br /></td></tr>
<tr class="separator:abc6188f6c25e88285f0f3b74e89a69e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fc29eda8762cda8923dd212dca9e2e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a01fc29eda8762cda8923dd212dca9e2e">isalpha</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a01fc29eda8762cda8923dd212dca9e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for strings that have only alphabetic characters.  <a href="classNVStrings.html#a01fc29eda8762cda8923dd212dca9e2e">More...</a><br /></td></tr>
<tr class="separator:a01fc29eda8762cda8923dd212dca9e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78aef1b3075909a11f84ad2f5dccb0e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac78aef1b3075909a11f84ad2f5dccb0e">isdigit</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:ac78aef1b3075909a11f84ad2f5dccb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for strings that have only digit characters.  <a href="classNVStrings.html#ac78aef1b3075909a11f84ad2f5dccb0e">More...</a><br /></td></tr>
<tr class="separator:ac78aef1b3075909a11f84ad2f5dccb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70de98cde6c24aaf5eb826003bbbf9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a3c70de98cde6c24aaf5eb826003bbbf9">isspace</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a3c70de98cde6c24aaf5eb826003bbbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for strings that have only whitespace characters.  <a href="classNVStrings.html#a3c70de98cde6c24aaf5eb826003bbbf9">More...</a><br /></td></tr>
<tr class="separator:a3c70de98cde6c24aaf5eb826003bbbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6cf67f7686d0e1b01516e69223729c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a6c6cf67f7686d0e1b01516e69223729c">isdecimal</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a6c6cf67f7686d0e1b01516e69223729c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for strings that have only decimal characters. Characters that can be used to extract base10 numbers.  <a href="classNVStrings.html#a6c6cf67f7686d0e1b01516e69223729c">More...</a><br /></td></tr>
<tr class="separator:a6c6cf67f7686d0e1b01516e69223729c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644ffbe8fe1be46730ceaf481d1c0232"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a644ffbe8fe1be46730ceaf481d1c0232">isnumeric</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a644ffbe8fe1be46730ceaf481d1c0232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for strings that have only numeric characters.  <a href="classNVStrings.html#a644ffbe8fe1be46730ceaf481d1c0232">More...</a><br /></td></tr>
<tr class="separator:a644ffbe8fe1be46730ceaf481d1c0232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d17dc7d991fe3d585414d3754d21a3d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a7d17dc7d991fe3d585414d3754d21a3d">islower</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a7d17dc7d991fe3d585414d3754d21a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for strings that have only lowercase characters.  <a href="classNVStrings.html#a7d17dc7d991fe3d585414d3754d21a3d">More...</a><br /></td></tr>
<tr class="separator:a7d17dc7d991fe3d585414d3754d21a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950670f0c70493834a70a47d6a24cbc2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a950670f0c70493834a70a47d6a24cbc2">isupper</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a950670f0c70493834a70a47d6a24cbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for strings that have only uppercase characters.  <a href="classNVStrings.html#a950670f0c70493834a70a47d6a24cbc2">More...</a><br /></td></tr>
<tr class="separator:a950670f0c70493834a70a47d6a24cbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ddd6f471bcc6dda1dcf110bda896be"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aa0ddd6f471bcc6dda1dcf110bda896be">is_empty</a> (bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:aa0ddd6f471bcc6dda1dcf110bda896be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for non-empty strings &ndash; non-null strings with at least one character.  <a href="classNVStrings.html#aa0ddd6f471bcc6dda1dcf110bda896be">More...</a><br /></td></tr>
<tr class="separator:aa0ddd6f471bcc6dda1dcf110bda896be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026bcba91ab86fd8ce8c9469e772e21c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a026bcba91ab86fd8ce8c9469e772e21c">code_points</a> (unsigned int *results)</td></tr>
<tr class="memdesc:a026bcba91ab86fd8ce8c9469e772e21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills in matrix with code point values (integers) for each string. A code point is the integer value representation of a character. For example, in UTF-8 the code point value for the character 'A' is 65.  <a href="classNVStrings.html#a026bcba91ab86fd8ce8c9469e772e21c">More...</a><br /></td></tr>
<tr class="separator:a026bcba91ab86fd8ce8c9469e772e21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60b00b99fe38631ab3889b1aebe7080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aa60b00b99fe38631ab3889b1aebe7080">cat</a> (<a class="el" href="classNVStrings.html">NVStrings</a> *others, const char *separator, const char *narep=nullptr)</td></tr>
<tr class="memdesc:aa60b00b99fe38631ab3889b1aebe7080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the given strings to this instance of strings and returns as new instance.  <a href="classNVStrings.html#aa60b00b99fe38631ab3889b1aebe7080">More...</a><br /></td></tr>
<tr class="separator:aa60b00b99fe38631ab3889b1aebe7080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c65f7a045838210fb0bd7f27a3cd91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a09c65f7a045838210fb0bd7f27a3cd91">cat</a> (std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;others, const char *separator, const char *narep=nullptr)</td></tr>
<tr class="memdesc:a09c65f7a045838210fb0bd7f27a3cd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the given list of strings to this instance of strings and returns as new instance.  <a href="classNVStrings.html#a09c65f7a045838210fb0bd7f27a3cd91">More...</a><br /></td></tr>
<tr class="separator:a09c65f7a045838210fb0bd7f27a3cd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd55ca9dc9f0ebb381114423c9993961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#acd55ca9dc9f0ebb381114423c9993961">join</a> (const char *separator=&quot;&quot;, const char *narep=nullptr)</td></tr>
<tr class="memdesc:acd55ca9dc9f0ebb381114423c9993961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates all strings into one new string.  <a href="classNVStrings.html#acd55ca9dc9f0ebb381114423c9993961">More...</a><br /></td></tr>
<tr class="separator:acd55ca9dc9f0ebb381114423c9993961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7936e82eda42aa477fcd91e472ffe7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a9c7936e82eda42aa477fcd91e472ffe7">split_record</a> (const char *delimiter, int maxsplit, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a9c7936e82eda42aa477fcd91e472ffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each string is split into a list of new strings.  <a href="classNVStrings.html#a9c7936e82eda42aa477fcd91e472ffe7">More...</a><br /></td></tr>
<tr class="separator:a9c7936e82eda42aa477fcd91e472ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ee93a3dd55f274096e203d7653d86b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ab4ee93a3dd55f274096e203d7653d86b">rsplit_record</a> (const char *delimiter, int maxsplit, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:ab4ee93a3dd55f274096e203d7653d86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each string is split into a list of new strings.  <a href="classNVStrings.html#ab4ee93a3dd55f274096e203d7653d86b">More...</a><br /></td></tr>
<tr class="separator:ab4ee93a3dd55f274096e203d7653d86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca92a602aeb64e680b018c21a0fe777b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aca92a602aeb64e680b018c21a0fe777b">split_record</a> (int maxsplit, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:aca92a602aeb64e680b018c21a0fe777b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each string is split on whitespace into a list of new strings.  <a href="classNVStrings.html#aca92a602aeb64e680b018c21a0fe777b">More...</a><br /></td></tr>
<tr class="separator:aca92a602aeb64e680b018c21a0fe777b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873688d9db9c9c399d6d1d28f3d8eedf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a873688d9db9c9c399d6d1d28f3d8eedf">rsplit_record</a> (int maxsplit, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a873688d9db9c9c399d6d1d28f3d8eedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each string is split on whitespace into a list of new strings.  <a href="classNVStrings.html#a873688d9db9c9c399d6d1d28f3d8eedf">More...</a><br /></td></tr>
<tr class="separator:a873688d9db9c9c399d6d1d28f3d8eedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479236d25afda556adb1b2ef18538ba2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a479236d25afda556adb1b2ef18538ba2">split</a> (const char *delimiter, int maxsplit, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a479236d25afda556adb1b2ef18538ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split strings vertically creating new columns of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances.  <a href="classNVStrings.html#a479236d25afda556adb1b2ef18538ba2">More...</a><br /></td></tr>
<tr class="separator:a479236d25afda556adb1b2ef18538ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb32def515db3216d68cfb66e75f700"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a2eb32def515db3216d68cfb66e75f700">rsplit</a> (const char *delimiter, int maxsplit, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a2eb32def515db3216d68cfb66e75f700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split strings vertically creating new columns of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances.  <a href="classNVStrings.html#a2eb32def515db3216d68cfb66e75f700">More...</a><br /></td></tr>
<tr class="separator:a2eb32def515db3216d68cfb66e75f700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a8eb06f5829042e35fc64b4b7913c7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ab3a8eb06f5829042e35fc64b4b7913c7">split</a> (int maxsplit, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:ab3a8eb06f5829042e35fc64b4b7913c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split strings on whitespace vertically creating new columns of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances.  <a href="classNVStrings.html#ab3a8eb06f5829042e35fc64b4b7913c7">More...</a><br /></td></tr>
<tr class="separator:ab3a8eb06f5829042e35fc64b4b7913c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f69fb932460d23f10dd4f2231ccac4a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a1f69fb932460d23f10dd4f2231ccac4a">rsplit</a> (int maxsplit, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a1f69fb932460d23f10dd4f2231ccac4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split strings on whitespace vertically creating new columns of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances.  <a href="classNVStrings.html#a1f69fb932460d23f10dd4f2231ccac4a">More...</a><br /></td></tr>
<tr class="separator:a1f69fb932460d23f10dd4f2231ccac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f18538ef786a0599246e0ea4324d4b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a1f18538ef786a0599246e0ea4324d4b5">partition</a> (const char *delimiter, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a1f18538ef786a0599246e0ea4324d4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each string is split into two strings on the first delimiter found.  <a href="classNVStrings.html#a1f18538ef786a0599246e0ea4324d4b5">More...</a><br /></td></tr>
<tr class="separator:a1f18538ef786a0599246e0ea4324d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eb3443b15cd2d3d81a67cab756eeef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a04eb3443b15cd2d3d81a67cab756eeef">rpartition</a> (const char *delimiter, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a04eb3443b15cd2d3d81a67cab756eeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each string is split into two strings on the last delimiter found.  <a href="classNVStrings.html#a04eb3443b15cd2d3d81a67cab756eeef">More...</a><br /></td></tr>
<tr class="separator:a04eb3443b15cd2d3d81a67cab756eeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c07a995b85e55290f2d564ff128ca8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a7c07a995b85e55290f2d564ff128ca8f">repeat</a> (unsigned int count)</td></tr>
<tr class="memdesc:a7c07a995b85e55290f2d564ff128ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate each string with itself the number of times specified.  <a href="classNVStrings.html#a7c07a995b85e55290f2d564ff128ca8f">More...</a><br /></td></tr>
<tr class="separator:a7c07a995b85e55290f2d564ff128ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbe772d7e225d41e2837280edc8cd08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aefbe772d7e225d41e2837280edc8cd08">pad</a> (unsigned int width, <a class="el" href="classNVStrings.html#ae632539abce4f345d9c6995cc407281e">padside</a> side, const char *fillchar=nullptr)</td></tr>
<tr class="memdesc:aefbe772d7e225d41e2837280edc8cd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add padding to each string using a provided character.  <a href="classNVStrings.html#aefbe772d7e225d41e2837280edc8cd08">More...</a><br /></td></tr>
<tr class="separator:aefbe772d7e225d41e2837280edc8cd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcbff99c3478dfb316619fecc22a7f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a9bcbff99c3478dfb316619fecc22a7f5">ljust</a> (unsigned int width, const char *fillchar=nullptr)</td></tr>
<tr class="memdesc:a9bcbff99c3478dfb316619fecc22a7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add padding to the left of each string using a provided character.  <a href="classNVStrings.html#a9bcbff99c3478dfb316619fecc22a7f5">More...</a><br /></td></tr>
<tr class="separator:a9bcbff99c3478dfb316619fecc22a7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9824a09656fc666f451842a3641334d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a9824a09656fc666f451842a3641334d0">center</a> (unsigned int width, const char *fillchar=nullptr)</td></tr>
<tr class="memdesc:a9824a09656fc666f451842a3641334d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add padding to the left and right of each string using a provided character.  <a href="classNVStrings.html#a9824a09656fc666f451842a3641334d0">More...</a><br /></td></tr>
<tr class="separator:a9824a09656fc666f451842a3641334d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201e235b531e52c251b41207124ee08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac201e235b531e52c251b41207124ee08">rjust</a> (unsigned int width, const char *fillchar=nullptr)</td></tr>
<tr class="memdesc:ac201e235b531e52c251b41207124ee08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add padding to the right of each string using a provided character.  <a href="classNVStrings.html#ac201e235b531e52c251b41207124ee08">More...</a><br /></td></tr>
<tr class="separator:ac201e235b531e52c251b41207124ee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3c6bba409f5ed42911c9c45fd1a491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a7b3c6bba409f5ed42911c9c45fd1a491">zfill</a> (unsigned int width)</td></tr>
<tr class="memdesc:a7b3c6bba409f5ed42911c9c45fd1a491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads strings with leading zeros.  <a href="classNVStrings.html#a7b3c6bba409f5ed42911c9c45fd1a491">More...</a><br /></td></tr>
<tr class="separator:a7b3c6bba409f5ed42911c9c45fd1a491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b63041edf7e30cdbe8676c75f38635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac7b63041edf7e30cdbe8676c75f38635">wrap</a> (unsigned int width)</td></tr>
<tr class="memdesc:ac7b63041edf7e30cdbe8676c75f38635"><td class="mdescLeft">&#160;</td><td class="mdescRight">This inserts new-line characters (ASCII 0x0A) into each string in place of spaces.  <a href="classNVStrings.html#ac7b63041edf7e30cdbe8676c75f38635">More...</a><br /></td></tr>
<tr class="separator:ac7b63041edf7e30cdbe8676c75f38635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3929aecfa0fb85980858c5ba5ec8f8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ae3929aecfa0fb85980858c5ba5ec8f8b">get</a> (unsigned int pos)</td></tr>
<tr class="memdesc:ae3929aecfa0fb85980858c5ba5ec8f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a specific character (as a string) by position for each string.  <a href="classNVStrings.html#ae3929aecfa0fb85980858c5ba5ec8f8b">More...</a><br /></td></tr>
<tr class="separator:ae3929aecfa0fb85980858c5ba5ec8f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6c28d2717be7f596031b492335b3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a3b6c28d2717be7f596031b492335b3b0">slice</a> (int start=0, int stop=-1, int step=1)</td></tr>
<tr class="memdesc:a3b6c28d2717be7f596031b492335b3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring of each string.  <a href="classNVStrings.html#a3b6c28d2717be7f596031b492335b3b0">More...</a><br /></td></tr>
<tr class="separator:a3b6c28d2717be7f596031b492335b3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f967a5409d75e09b3d410b8f04b3dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a5f967a5409d75e09b3d410b8f04b3dd1">slice_from</a> (const int *starts=nullptr, const int *ends=nullptr)</td></tr>
<tr class="memdesc:a5f967a5409d75e09b3d410b8f04b3dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring of each string.  <a href="classNVStrings.html#a5f967a5409d75e09b3d410b8f04b3dd1">More...</a><br /></td></tr>
<tr class="separator:a5f967a5409d75e09b3d410b8f04b3dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f1eefde58d4bba9f020e16ed105e8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a69f1eefde58d4bba9f020e16ed105e8a">extract</a> (const char *pattern, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a69f1eefde58d4bba9f020e16ed105e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of strings for each group specified in the given regular expression pattern.  <a href="classNVStrings.html#a69f1eefde58d4bba9f020e16ed105e8a">More...</a><br /></td></tr>
<tr class="separator:a69f1eefde58d4bba9f020e16ed105e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ca4fa55925f7bd107b0c5c9011b034"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a38ca4fa55925f7bd107b0c5c9011b034">extract_record</a> (const char *pattern, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a38ca4fa55925f7bd107b0c5c9011b034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of strings for each group specified in the given regular expression pattern.  <a href="classNVStrings.html#a38ca4fa55925f7bd107b0c5c9011b034">More...</a><br /></td></tr>
<tr class="separator:a38ca4fa55925f7bd107b0c5c9011b034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80257b75625b7abfa472269c1f73bfb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a80257b75625b7abfa472269c1f73bfb9">slice_replace</a> (const char *repl, int start=0, int stop=-1)</td></tr>
<tr class="memdesc:a80257b75625b7abfa472269c1f73bfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified string (repl) into each string at the specified position.  <a href="classNVStrings.html#a80257b75625b7abfa472269c1f73bfb9">More...</a><br /></td></tr>
<tr class="separator:a80257b75625b7abfa472269c1f73bfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aa1f37e857e94cc6cf1872b26871ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#af8aa1f37e857e94cc6cf1872b26871ca">replace</a> (const char *str, const char *repl, int maxrepl=-1)</td></tr>
<tr class="memdesc:af8aa1f37e857e94cc6cf1872b26871ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences found of one string with another string in each string of this instance.  <a href="classNVStrings.html#af8aa1f37e857e94cc6cf1872b26871ca">More...</a><br /></td></tr>
<tr class="separator:af8aa1f37e857e94cc6cf1872b26871ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25c5698dbe796cf893ffbfdd4b118a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ae25c5698dbe796cf893ffbfdd4b118a7">replace</a> (<a class="el" href="classNVStrings.html">NVStrings</a> &amp;strs, <a class="el" href="classNVStrings.html">NVStrings</a> &amp;repls)</td></tr>
<tr class="memdesc:ae25c5698dbe796cf893ffbfdd4b118a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces any occurrences found in list of strings with corresponding string in each string of this instance.  <a href="classNVStrings.html#ae25c5698dbe796cf893ffbfdd4b118a7">More...</a><br /></td></tr>
<tr class="separator:ae25c5698dbe796cf893ffbfdd4b118a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34e909ac1aa285a8270937a74f9b8df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ae34e909ac1aa285a8270937a74f9b8df">translate</a> (std::pair&lt; unsigned, unsigned &gt; *table, unsigned int count)</td></tr>
<tr class="memdesc:ae34e909ac1aa285a8270937a74f9b8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate characters in each string using the character-mapping table provided.  <a href="classNVStrings.html#ae34e909ac1aa285a8270937a74f9b8df">More...</a><br /></td></tr>
<tr class="separator:ae34e909ac1aa285a8270937a74f9b8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07de84032a829382d538b0ef981e04af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a07de84032a829382d538b0ef981e04af">fillna</a> (const char *str)</td></tr>
<tr class="memdesc:a07de84032a829382d538b0ef981e04af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace null strings with specified string.  <a href="classNVStrings.html#a07de84032a829382d538b0ef981e04af">More...</a><br /></td></tr>
<tr class="separator:a07de84032a829382d538b0ef981e04af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43bcf2a31c8c819ec4802ca7a5d18d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aa43bcf2a31c8c819ec4802ca7a5d18d0">fillna</a> (<a class="el" href="classNVStrings.html">NVStrings</a> &amp;strs)</td></tr>
<tr class="memdesc:aa43bcf2a31c8c819ec4802ca7a5d18d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace null strings with corresponding strings from the parameter.  <a href="classNVStrings.html#aa43bcf2a31c8c819ec4802ca7a5d18d0">More...</a><br /></td></tr>
<tr class="separator:aa43bcf2a31c8c819ec4802ca7a5d18d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed11757452f23fd403d2f0881563a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#afed11757452f23fd403d2f0881563a81">insert</a> (const char *repl, int pos=0)</td></tr>
<tr class="memdesc:afed11757452f23fd403d2f0881563a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified string (repl) into each string at the specified position.  <a href="classNVStrings.html#afed11757452f23fd403d2f0881563a81">More...</a><br /></td></tr>
<tr class="separator:afed11757452f23fd403d2f0881563a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e1cfa591b4a1acda2f4ca0da6a630b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a90e1cfa591b4a1acda2f4ca0da6a630b">replace_re</a> (const char *pattern, const char *repl, int maxrepl=-1)</td></tr>
<tr class="memdesc:a90e1cfa591b4a1acda2f4ca0da6a630b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences found of one string with another string in each string of this instance.  <a href="classNVStrings.html#a90e1cfa591b4a1acda2f4ca0da6a630b">More...</a><br /></td></tr>
<tr class="separator:a90e1cfa591b4a1acda2f4ca0da6a630b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbbe83e7e5232e6ecf98888fcf73e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a8bbbe83e7e5232e6ecf98888fcf73e73">replace_re</a> (std::vector&lt; const char * &gt; &amp;patterns, <a class="el" href="classNVStrings.html">NVStrings</a> &amp;repls)</td></tr>
<tr class="memdesc:a8bbbe83e7e5232e6ecf98888fcf73e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences found of string list with corresponding strings in each string of this instance.  <a href="classNVStrings.html#a8bbbe83e7e5232e6ecf98888fcf73e73">More...</a><br /></td></tr>
<tr class="separator:a8bbbe83e7e5232e6ecf98888fcf73e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cdca3b0e21df2a987942571b253dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a52cdca3b0e21df2a987942571b253dca">replace_with_backrefs</a> (const char *pattern, const char *repl)</td></tr>
<tr class="memdesc:a52cdca3b0e21df2a987942571b253dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract values using pattern and place them repl as indicated by backref indicators.  <a href="classNVStrings.html#a52cdca3b0e21df2a987942571b253dca">More...</a><br /></td></tr>
<tr class="separator:a52cdca3b0e21df2a987942571b253dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48723ac170508171145dc862c95c7bbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a48723ac170508171145dc862c95c7bbb">lstrip</a> (const char *to_strip)</td></tr>
<tr class="memdesc:a48723ac170508171145dc862c95c7bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified character(s) if found at the beginning of each string.  <a href="classNVStrings.html#a48723ac170508171145dc862c95c7bbb">More...</a><br /></td></tr>
<tr class="separator:a48723ac170508171145dc862c95c7bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a895ecaf473e04c363b389262e270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a8c7a895ecaf473e04c363b389262e270">strip</a> (const char *to_strip)</td></tr>
<tr class="memdesc:a8c7a895ecaf473e04c363b389262e270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified character(s) if found at the beginning or end of each string.  <a href="classNVStrings.html#a8c7a895ecaf473e04c363b389262e270">More...</a><br /></td></tr>
<tr class="separator:a8c7a895ecaf473e04c363b389262e270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae252878ec60b38dca90f9ed421c7a17f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ae252878ec60b38dca90f9ed421c7a17f">rstrip</a> (const char *to_strip)</td></tr>
<tr class="memdesc:ae252878ec60b38dca90f9ed421c7a17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified character(s) if found at the end of each string.  <a href="classNVStrings.html#ae252878ec60b38dca90f9ed421c7a17f">More...</a><br /></td></tr>
<tr class="separator:ae252878ec60b38dca90f9ed421c7a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97f8a71d6c2709f02dc9c14ee645f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ab97f8a71d6c2709f02dc9c14ee645f20">lower</a> ()</td></tr>
<tr class="memdesc:ab97f8a71d6c2709f02dc9c14ee645f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return new instance modifying uppercase characters to lowercase.  <a href="classNVStrings.html#ab97f8a71d6c2709f02dc9c14ee645f20">More...</a><br /></td></tr>
<tr class="separator:ab97f8a71d6c2709f02dc9c14ee645f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e8c904ff48d0543e3b39fee7eca081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac3e8c904ff48d0543e3b39fee7eca081">upper</a> ()</td></tr>
<tr class="memdesc:ac3e8c904ff48d0543e3b39fee7eca081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return new instance modifying lowercase characters to uppercase.  <a href="classNVStrings.html#ac3e8c904ff48d0543e3b39fee7eca081">More...</a><br /></td></tr>
<tr class="separator:ac3e8c904ff48d0543e3b39fee7eca081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c71da05b27c0df1488a55ca5985f266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a2c71da05b27c0df1488a55ca5985f266">capitalize</a> ()</td></tr>
<tr class="memdesc:a2c71da05b27c0df1488a55ca5985f266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return new instance modifying the first character to uppercase and lower-casing the rest.  <a href="classNVStrings.html#a2c71da05b27c0df1488a55ca5985f266">More...</a><br /></td></tr>
<tr class="separator:a2c71da05b27c0df1488a55ca5985f266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9bfd3ad6ad33d97db8cf99c4768d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a2a9bfd3ad6ad33d97db8cf99c4768d22">swapcase</a> ()</td></tr>
<tr class="memdesc:a2a9bfd3ad6ad33d97db8cf99c4768d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return new instance modifying uppercase characters to lowercase and vice versa.  <a href="classNVStrings.html#a2a9bfd3ad6ad33d97db8cf99c4768d22">More...</a><br /></td></tr>
<tr class="separator:a2a9bfd3ad6ad33d97db8cf99c4768d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c802b3e2fbd2710490ab19dbd988756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a0c802b3e2fbd2710490ab19dbd988756">title</a> ()</td></tr>
<tr class="memdesc:a0c802b3e2fbd2710490ab19dbd988756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return new instance modifying first characters after space to uppercase and lower-casing the rest.  <a href="classNVStrings.html#a0c802b3e2fbd2710490ab19dbd988756">More...</a><br /></td></tr>
<tr class="separator:a0c802b3e2fbd2710490ab19dbd988756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f105ecf0e8ecc2f9b1a2b8f2df99e6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a97f105ecf0e8ecc2f9b1a2b8f2df99e6">compare</a> (const char *str, int *results, bool devmem=true)</td></tr>
<tr class="memdesc:a97f105ecf0e8ecc2f9b1a2b8f2df99e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string to all the strings in this instance.  <a href="classNVStrings.html#a97f105ecf0e8ecc2f9b1a2b8f2df99e6">More...</a><br /></td></tr>
<tr class="separator:a97f105ecf0e8ecc2f9b1a2b8f2df99e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4050453544ea26af4da7876f71bd76"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a5e4050453544ea26af4da7876f71bd76">find</a> (const char *str, int start, int end, int *results, bool devmem=true)</td></tr>
<tr class="memdesc:a5e4050453544ea26af4da7876f71bd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a string within each string in this instance.  <a href="classNVStrings.html#a5e4050453544ea26af4da7876f71bd76">More...</a><br /></td></tr>
<tr class="separator:a5e4050453544ea26af4da7876f71bd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c542e1cc5e026aa63c2eca7d788b06"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ab6c542e1cc5e026aa63c2eca7d788b06">rfind</a> (const char *str, int start, int end, int *results, bool devmem=true)</td></tr>
<tr class="memdesc:ab6c542e1cc5e026aa63c2eca7d788b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search from the end for a string within each string in this instance.  <a href="classNVStrings.html#ab6c542e1cc5e026aa63c2eca7d788b06">More...</a><br /></td></tr>
<tr class="separator:ab6c542e1cc5e026aa63c2eca7d788b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d968127b2e4c9b8fa788fe013fa497"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac5d968127b2e4c9b8fa788fe013fa497">find_from</a> (const char *str, int *starts, int *ends, int *results, bool devmem=true)</td></tr>
<tr class="memdesc:ac5d968127b2e4c9b8fa788fe013fa497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a string within each string in this instance.  <a href="classNVStrings.html#ac5d968127b2e4c9b8fa788fe013fa497">More...</a><br /></td></tr>
<tr class="separator:ac5d968127b2e4c9b8fa788fe013fa497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1915b944e3c49ecf9011f9ab24737f21"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a1915b944e3c49ecf9011f9ab24737f21">find_multiple</a> (<a class="el" href="classNVStrings.html">NVStrings</a> &amp;strs, int *results, bool devmem=true)</td></tr>
<tr class="memdesc:a1915b944e3c49ecf9011f9ab24737f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search multiple strings.  <a href="classNVStrings.html#a1915b944e3c49ecf9011f9ab24737f21">More...</a><br /></td></tr>
<tr class="separator:a1915b944e3c49ecf9011f9ab24737f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaf5bdc198726eabe0adaf6b1269b6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aeeaf5bdc198726eabe0adaf6b1269b6a">contains</a> (const char *str, bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:aeeaf5bdc198726eabe0adaf6b1269b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for string within each string of this instance.  <a href="classNVStrings.html#aeeaf5bdc198726eabe0adaf6b1269b6a">More...</a><br /></td></tr>
<tr class="separator:aeeaf5bdc198726eabe0adaf6b1269b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26657d350ce4d30b5a44aa7ffc3e841e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a26657d350ce4d30b5a44aa7ffc3e841e">match_strings</a> (<a class="el" href="classNVStrings.html">NVStrings</a> &amp;strs, bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a26657d350ce4d30b5a44aa7ffc3e841e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check each argument string matches with the corresponding strings in this list.  <a href="classNVStrings.html#a26657d350ce4d30b5a44aa7ffc3e841e">More...</a><br /></td></tr>
<tr class="separator:a26657d350ce4d30b5a44aa7ffc3e841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af3b11947700864f7d815a2ee4c004a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a1af3b11947700864f7d815a2ee4c004a">startswith</a> (const char *str, bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a1af3b11947700864f7d815a2ee4c004a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the beginning of each string with the specified string.  <a href="classNVStrings.html#a1af3b11947700864f7d815a2ee4c004a">More...</a><br /></td></tr>
<tr class="separator:a1af3b11947700864f7d815a2ee4c004a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57164c5ef32b51cb8044f71aaa774217"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a57164c5ef32b51cb8044f71aaa774217">endswith</a> (const char *str, bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:a57164c5ef32b51cb8044f71aaa774217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the end of each string with the specified string.  <a href="classNVStrings.html#a57164c5ef32b51cb8044f71aaa774217">More...</a><br /></td></tr>
<tr class="separator:a57164c5ef32b51cb8044f71aaa774217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac119eda114134c0e8c018f4dc65b6885"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac119eda114134c0e8c018f4dc65b6885">findall</a> (const char *pattern, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:ac119eda114134c0e8c018f4dc65b6885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all occurrences of the specified regular expression pattern in each string.  <a href="classNVStrings.html#ac119eda114134c0e8c018f4dc65b6885">More...</a><br /></td></tr>
<tr class="separator:ac119eda114134c0e8c018f4dc65b6885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f7e8b012dc69785e61417c4cfcd915"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac3f7e8b012dc69785e61417c4cfcd915">findall_record</a> (const char *pattern, std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:ac3f7e8b012dc69785e61417c4cfcd915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all occurrences of the specified regular expression pattern in each string.  <a href="classNVStrings.html#ac3f7e8b012dc69785e61417c4cfcd915">More...</a><br /></td></tr>
<tr class="separator:ac3f7e8b012dc69785e61417c4cfcd915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b07e9d224079e6a61be84430c86217"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ae5b07e9d224079e6a61be84430c86217">contains_re</a> (const char *pattern, bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:ae5b07e9d224079e6a61be84430c86217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for regular expression pattern within each string of this instance.  <a href="classNVStrings.html#ae5b07e9d224079e6a61be84430c86217">More...</a><br /></td></tr>
<tr class="separator:ae5b07e9d224079e6a61be84430c86217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51f8af6388f11f7bb3978147981bfdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ab51f8af6388f11f7bb3978147981bfdb">match</a> (const char *pattern, bool *results, bool devmem=true)</td></tr>
<tr class="memdesc:ab51f8af6388f11f7bb3978147981bfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for regular expression pattern match at the beginning of each string.  <a href="classNVStrings.html#ab51f8af6388f11f7bb3978147981bfdb">More...</a><br /></td></tr>
<tr class="separator:ab51f8af6388f11f7bb3978147981bfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d30089eb87e6ae497d0a9fa6bb03a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a89d30089eb87e6ae497d0a9fa6bb03a4">count_re</a> (const char *pattern, int *results, bool devmem=true)</td></tr>
<tr class="memdesc:a89d30089eb87e6ae497d0a9fa6bb03a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for regular expression pattern match and count their occurrences for each string.  <a href="classNVStrings.html#a89d30089eb87e6ae497d0a9fa6bb03a4">More...</a><br /></td></tr>
<tr class="separator:a89d30089eb87e6ae497d0a9fa6bb03a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f84e3447db24477570dd52628d65d1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a3f84e3447db24477570dd52628d65d1a">stoi</a> (int *results, bool devmem=true)</td></tr>
<tr class="memdesc:a3f84e3447db24477570dd52628d65d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns integer values represented by each string.  <a href="classNVStrings.html#a3f84e3447db24477570dd52628d65d1a">More...</a><br /></td></tr>
<tr class="separator:a3f84e3447db24477570dd52628d65d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a36ddb8fa59ae0a41b845fb314995c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a5a36ddb8fa59ae0a41b845fb314995c5">stol</a> (long *results, bool devmem=true)</td></tr>
<tr class="memdesc:a5a36ddb8fa59ae0a41b845fb314995c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns long integer values represented by each string.  <a href="classNVStrings.html#a5a36ddb8fa59ae0a41b845fb314995c5">More...</a><br /></td></tr>
<tr class="separator:a5a36ddb8fa59ae0a41b845fb314995c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ed622ceb8e1c34afbafbca627608e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#af6ed622ceb8e1c34afbafbca627608e3">htoi</a> (unsigned int *results, bool devmem=true)</td></tr>
<tr class="memdesc:af6ed622ceb8e1c34afbafbca627608e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns integer values represented by each string assuming hex characters.  <a href="classNVStrings.html#af6ed622ceb8e1c34afbafbca627608e3">More...</a><br /></td></tr>
<tr class="separator:af6ed622ceb8e1c34afbafbca627608e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1624acbce418c9dee3852ea0fbf6950a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a1624acbce418c9dee3852ea0fbf6950a">stof</a> (float *results, bool devmem=true)</td></tr>
<tr class="memdesc:a1624acbce418c9dee3852ea0fbf6950a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns float values represented by each string.  <a href="classNVStrings.html#a1624acbce418c9dee3852ea0fbf6950a">More...</a><br /></td></tr>
<tr class="separator:a1624acbce418c9dee3852ea0fbf6950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add81fde809d50f3f71df74338d75c28b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#add81fde809d50f3f71df74338d75c28b">stod</a> (double *results, bool devmem=true)</td></tr>
<tr class="memdesc:add81fde809d50f3f71df74338d75c28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns double values represented by each string.  <a href="classNVStrings.html#add81fde809d50f3f71df74338d75c28b">More...</a><br /></td></tr>
<tr class="separator:add81fde809d50f3f71df74338d75c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7b19264d7b912ca236636d4b200c81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aec7b19264d7b912ca236636d4b200c81">hash</a> (unsigned int *results, bool devmem=true)</td></tr>
<tr class="memdesc:aec7b19264d7b912ca236636d4b200c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns unsigned 32-bit hash value for each string.  <a href="classNVStrings.html#aec7b19264d7b912ca236636d4b200c81">More...</a><br /></td></tr>
<tr class="separator:aec7b19264d7b912ca236636d4b200c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca29c037d2eb9041b9c56d983fd6490"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a3ca29c037d2eb9041b9c56d983fd6490">to_bools</a> (bool *results, const char *true_string, bool devmem=true)</td></tr>
<tr class="memdesc:a3ca29c037d2eb9041b9c56d983fd6490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean representation of the strings in this instance.  <a href="classNVStrings.html#a3ca29c037d2eb9041b9c56d983fd6490">More...</a><br /></td></tr>
<tr class="separator:a3ca29c037d2eb9041b9c56d983fd6490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881c5e067b5e91129c881c2b85986f93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a881c5e067b5e91129c881c2b85986f93">ip2int</a> (unsigned int *results, bool devmem=true)</td></tr>
<tr class="memdesc:a881c5e067b5e91129c881c2b85986f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns integer representation of IPv4 address.  <a href="classNVStrings.html#a881c5e067b5e91129c881c2b85986f93">More...</a><br /></td></tr>
<tr class="separator:a881c5e067b5e91129c881c2b85986f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f17c4f9079f1e45625c8bea7509b29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a75f17c4f9079f1e45625c8bea7509b29">timestamp2long</a> (const char *format, <a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049">timestamp_units</a> units, unsigned long *results, bool devmem=true)</td></tr>
<tr class="memdesc:a75f17c4f9079f1e45625c8bea7509b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns integer representation date-time string.  <a href="classNVStrings.html#a75f17c4f9079f1e45625c8bea7509b29">More...</a><br /></td></tr>
<tr class="separator:a75f17c4f9079f1e45625c8bea7509b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0245cbaa1eb7ff32e823d537983a125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#af0245cbaa1eb7ff32e823d537983a125">url_encode</a> ()</td></tr>
<tr class="memdesc:af0245cbaa1eb7ff32e823d537983a125"><td class="mdescLeft">&#160;</td><td class="mdescRight">URL-encodes each string and returns the new instance. This uses UTF-8 encoding style and does no error checking on the strings. All letters and digits are not encoded as well as characters '.','_','~','-'.  <a href="classNVStrings.html#af0245cbaa1eb7ff32e823d537983a125">More...</a><br /></td></tr>
<tr class="separator:af0245cbaa1eb7ff32e823d537983a125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae81d5c990a2362a2e2c5f4315c19a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#aae81d5c990a2362a2e2c5f4315c19a5f">url_decode</a> ()</td></tr>
<tr class="memdesc:aae81d5c990a2362a2e2c5f4315c19a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">URL-decodes each string and returns the new instance. This expects UTF-8 encoding style and does no error checking on the strings.  <a href="classNVStrings.html#aae81d5c990a2362a2e2c5f4315c19a5f">More...</a><br /></td></tr>
<tr class="separator:aae81d5c990a2362a2e2c5f4315c19a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0846b760037f5282428ae80b57471b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a0846b760037f5282428ae80b57471b2f">print</a> (int pos=0, int end=-1, int maxwidth=-1, const char *delimiter=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a0846b760037f5282428ae80b57471b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output strings to stdout.  <a href="classNVStrings.html#a0846b760037f5282428ae80b57471b2f">More...</a><br /></td></tr>
<tr class="separator:a0846b760037f5282428ae80b57471b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6efee15f3cbc7cf2f433c60326e86e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#add6efee15f3cbc7cf2f433c60326e86e">compute_statistics</a> (<a class="el" href="structStringsStatistics.html">StringsStatistics</a> &amp;stats)</td></tr>
<tr class="memdesc:add6efee15f3cbc7cf2f433c60326e86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a variety of statistics for the strings/characters in this instance.  <a href="classNVStrings.html#add6efee15f3cbc7cf2f433c60326e86e">More...</a><br /></td></tr>
<tr class="separator:add6efee15f3cbc7cf2f433c60326e86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab110619a2a265bddd7d1b8795e10d069"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ab110619a2a265bddd7d1b8795e10d069">destroy</a> (<a class="el" href="classNVStrings.html">NVStrings</a> *inst)</td></tr>
<tr class="memdesc:ab110619a2a265bddd7d1b8795e10d069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to free any instance created by methods in this class.  <a href="classNVStrings.html#ab110619a2a265bddd7d1b8795e10d069">More...</a><br /></td></tr>
<tr class="separator:ab110619a2a265bddd7d1b8795e10d069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef46c36bf1e941b4817dfbf02cb944"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ae4ef46c36bf1e941b4817dfbf02cb944">itos</a> (const int *values, unsigned int count, const unsigned char *nullbitmask=nullptr, bool devmem=true)</td></tr>
<tr class="memdesc:ae4ef46c36bf1e941b4817dfbf02cb944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation for the provided integers.  <a href="classNVStrings.html#ae4ef46c36bf1e941b4817dfbf02cb944">More...</a><br /></td></tr>
<tr class="separator:ae4ef46c36bf1e941b4817dfbf02cb944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d56e410c4fcac467199c74a518b0191"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a7d56e410c4fcac467199c74a518b0191">ltos</a> (const long *values, unsigned int count, const unsigned char *nullbitmask=nullptr, bool devmem=true)</td></tr>
<tr class="memdesc:a7d56e410c4fcac467199c74a518b0191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation for the provided long integers.  <a href="classNVStrings.html#a7d56e410c4fcac467199c74a518b0191">More...</a><br /></td></tr>
<tr class="separator:a7d56e410c4fcac467199c74a518b0191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4151197106a18de97c4b5a2eac1e88a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a4151197106a18de97c4b5a2eac1e88a4">ftos</a> (const float *values, unsigned int count, const unsigned char *nullbitmask=nullptr, bool devmem=true)</td></tr>
<tr class="memdesc:a4151197106a18de97c4b5a2eac1e88a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation for the provided float values.  <a href="classNVStrings.html#a4151197106a18de97c4b5a2eac1e88a4">More...</a><br /></td></tr>
<tr class="separator:a4151197106a18de97c4b5a2eac1e88a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52e80817c8bbfe5069c303033842777"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#ac52e80817c8bbfe5069c303033842777">dtos</a> (const double *values, unsigned int count, const unsigned char *nullbitmask=nullptr, bool devmem=true)</td></tr>
<tr class="memdesc:ac52e80817c8bbfe5069c303033842777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation for the provided double float values.  <a href="classNVStrings.html#ac52e80817c8bbfe5069c303033842777">More...</a><br /></td></tr>
<tr class="separator:ac52e80817c8bbfe5069c303033842777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d5f80ad3c34cb311fe449ed0e655cf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a83d5f80ad3c34cb311fe449ed0e655cf">create_from_bools</a> (const bool *values, unsigned int count, const char *true_string, const char *false_string, const unsigned char *nullbitmask=nullptr, bool devmem=true)</td></tr>
<tr class="memdesc:a83d5f80ad3c34cb311fe449ed0e655cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation for the provided booleans.  <a href="classNVStrings.html#a83d5f80ad3c34cb311fe449ed0e655cf">More...</a><br /></td></tr>
<tr class="separator:a83d5f80ad3c34cb311fe449ed0e655cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec179783365d48bda52c21b5d7efd0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a62ec179783365d48bda52c21b5d7efd0">int2ip</a> (const unsigned int *values, unsigned int count, const unsigned char *nullbitmask=nullptr, bool devmem=true)</td></tr>
<tr class="memdesc:a62ec179783365d48bda52c21b5d7efd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation of IPv4 address (v4) for the provided integer values.  <a href="classNVStrings.html#a62ec179783365d48bda52c21b5d7efd0">More...</a><br /></td></tr>
<tr class="separator:a62ec179783365d48bda52c21b5d7efd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7371eaa7ddca3e72843adeb6787cb427"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a7371eaa7ddca3e72843adeb6787cb427">long2timestamp</a> (const unsigned long *values, unsigned int count, <a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049">timestamp_units</a> units, const char *format, const unsigned char *nullbitmask=nullptr, bool devmem=true)</td></tr>
<tr class="memdesc:a7371eaa7ddca3e72843adeb6787cb427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation of UTC timestamp in milliseconds from Epoch time.  <a href="classNVStrings.html#a7371eaa7ddca3e72843adeb6787cb427">More...</a><br /></td></tr>
<tr class="separator:a7371eaa7ddca3e72843adeb6787cb427"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Create NVStrings instance from strings</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp726f6e0b45852500218e5bde142ad992"></a>Use these static methods to create a new instance of this class given a list of character arrays encoded in UTF-8. These methods will make a copy of strings in host/device memory so sufficient storage must be available for them to succeed. Use the <code><a class="el" href="classNVStrings.html#ab110619a2a265bddd7d1b8795e10d069" title="Use this method to free any instance created by methods in this class.">destroy()</a></code> method to free any instance created by these methods. </p>
</td></tr>
<tr class="memitem:abdf94e76d98a14f33c80bb0533eda899"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#abdf94e76d98a14f33c80bb0533eda899">create_from_array</a> (const char **strs, unsigned int count)</td></tr>
<tr class="memdesc:abdf94e76d98a14f33c80bb0533eda899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance from an array of null-terminated host strings.  <a href="classNVStrings.html#abdf94e76d98a14f33c80bb0533eda899">More...</a><br /></td></tr>
<tr class="separator:abdf94e76d98a14f33c80bb0533eda899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cadd917f9e5a1336eb1ba7416abc988"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a8cadd917f9e5a1336eb1ba7416abc988">create_from_index</a> (std::pair&lt; const char *, size_t &gt; *strs, unsigned int count, bool devmem=true, <a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a> stype=<a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831a0b5479f46e32a0b52419271376591269">none</a>)</td></tr>
<tr class="memdesc:a8cadd917f9e5a1336eb1ba7416abc988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance from an array of string/length pairs.  <a href="classNVStrings.html#a8cadd917f9e5a1336eb1ba7416abc988">More...</a><br /></td></tr>
<tr class="separator:a8cadd917f9e5a1336eb1ba7416abc988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982c62faa84db45f5698966e7867fe1d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a982c62faa84db45f5698966e7867fe1d">create_from_offsets</a> (const char *strs, int count, const int *offsets, const unsigned char *nullbitmask=0, int nulls=0, bool devmem=true)</td></tr>
<tr class="memdesc:a982c62faa84db45f5698966e7867fe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance from single buffer of strings.  <a href="classNVStrings.html#a982c62faa84db45f5698966e7867fe1d">More...</a><br /></td></tr>
<tr class="separator:a982c62faa84db45f5698966e7867fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667b4438763ee82ca6921759b8eceba1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a667b4438763ee82ca6921759b8eceba1">create_from_strings</a> (std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; strs)</td></tr>
<tr class="memdesc:a667b4438763ee82ca6921759b8eceba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance from other <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances.  <a href="classNVStrings.html#a667b4438763ee82ca6921759b8eceba1">More...</a><br /></td></tr>
<tr class="separator:a667b4438763ee82ca6921759b8eceba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c3292e04f327176eaa9cfd961e673f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a33c3292e04f327176eaa9cfd961e673f">create_from_ipc</a> (<a class="el" href="structnvstrings__ipc__transfer.html">nvstrings_ipc_transfer</a> &amp;ipc)</td></tr>
<tr class="memdesc:a33c3292e04f327176eaa9cfd961e673f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance from an IPC-transfer object built from <a class="el" href="structnvstrings__ipc__transfer.html" title="This is used by the create_from_ipc and create_ipc_transfer methods.">nvstrings_ipc_transfer</a>.  <a href="classNVStrings.html#a33c3292e04f327176eaa9cfd961e673f">More...</a><br /></td></tr>
<tr class="separator:a33c3292e04f327176eaa9cfd961e673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c022a172bc0988862d1ebc09e099e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNVStrings.html#a91c022a172bc0988862d1ebc09e099e4">create_from_csv</a> (const char *csvfile, unsigned int column, unsigned int lines=0, <a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a> stype=<a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831a0b5479f46e32a0b52419271376591269">none</a>, bool nullIsEmpty=false)</td></tr>
<tr class="memdesc:a91c022a172bc0988862d1ebc09e099e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance from a specific column in a CSV file.  <a href="classNVStrings.html#a91c022a172bc0988862d1ebc09e099e4">More...</a><br /></td></tr>
<tr class="separator:a91c022a172bc0988862d1ebc09e099e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class manages a list of strings stored in device memory. An instance of this class is a CPU (host) object whose methods run on all the strings it manages in parallel on the GPU. </p>
<dl class="section user"><dt></dt><dd>The methods are meant to match more or less directly with its python counterpart, <code>nvstrings.py</code>. And the operations strive to mimic the behavoir of the equivalent Pandas strings methods. </dd></dl>
<dl class="section user"><dt></dt><dd>An instance of this class is immutable and operations that modify or create new strings will return a new instance. </dd></dl>
<dl class="section user"><dt></dt><dd>All methods accept and return only UTF-8 encoded strings. </dd></dl>
<dl class="section user"><dt></dt><dd>You can use the static <code>create</code> methods to instantiate from host strings &ndash; those that are stored in CPU memory. Use the <code><a class="el" href="classNVStrings.html#ab110619a2a265bddd7d1b8795e10d069" title="Use this method to free any instance created by methods in this class.">destroy()</a></code> method to free an instance of this class. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae632539abce4f345d9c6995cc407281e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae632539abce4f345d9c6995cc407281e">&#9670;&nbsp;</a></span>padside</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classNVStrings.html#ae632539abce4f345d9c6995cc407281e">NVStrings::padside</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Padding placement points. Used in the <a class="el" href="classNVStrings.html#aefbe772d7e225d41e2837280edc8cd08" title="Add padding to each string using a provided character.">pad()</a> method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae632539abce4f345d9c6995cc407281ea27a6f390cacbee032b9099765c3277dd"></a>left&#160;</td><td class="fielddoc"><p>Add padding to the left. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae632539abce4f345d9c6995cc407281ea410c51e93c57cfd4df319a7b925a2dec"></a>right&#160;</td><td class="fielddoc"><p>Add padding to the right. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae632539abce4f345d9c6995cc407281ea5b01f59b3412cfffe0dab5fc41d3e46f"></a>both&#160;</td><td class="fielddoc"><p>Add padding equally to the right and left. </p>
</td></tr>
</table>

</div>
</div>
<a id="a48a22848cee202e59b5a1ba22c8c3831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a22848cee202e59b5a1ba22c8c3831">&#9670;&nbsp;</a></span>sorttype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">NVStrings::sorttype</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorting by attributes. </p>
<p>Sorting by both length and characters is allowed and sorts by length first. Sorting could increase performance of other operations by reducing divergence. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a48a22848cee202e59b5a1ba22c8c3831a0b5479f46e32a0b52419271376591269"></a>none&#160;</td><td class="fielddoc"><p>no sorting </p>
</td></tr>
<tr><td class="fieldname"><a id="a48a22848cee202e59b5a1ba22c8c3831a744462e227edbd3642f8baf46d35b4ca"></a>length&#160;</td><td class="fielddoc"><p>sort by string length </p>
</td></tr>
<tr><td class="fieldname"><a id="a48a22848cee202e59b5a1ba22c8c3831a2f5d336f9e795adab8ed537aa190ff23"></a>name&#160;</td><td class="fielddoc"><p>sort by characters code-points </p>
</td></tr>
</table>

</div>
</div>
<a id="ac845d8278c06a59a3dd9b7c05d81b049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac845d8278c06a59a3dd9b7c05d81b049">&#9670;&nbsp;</a></span>timestamp_units</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049">NVStrings::timestamp_units</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Units for timestamp conversion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049a8667ec773f6dbfafbbfe0d0b9deecd14"></a>years&#160;</td><td class="fielddoc"><p>precision is years </p>
</td></tr>
<tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049aeed9e40cde5808e62979d57dbc381f51"></a>months&#160;</td><td class="fielddoc"><p>precision is months </p>
</td></tr>
<tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049a4ba1905c4ab3c8ae7094614084649d39"></a>days&#160;</td><td class="fielddoc"><p>precision is days </p>
</td></tr>
<tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049a046925b9e4b8b8bb927942bc4648f981"></a>hours&#160;</td><td class="fielddoc"><p>precision is hours </p>
</td></tr>
<tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049a4262801072819bc89e488b9a111135f9"></a>minutes&#160;</td><td class="fielddoc"><p>precision is minutes </p>
</td></tr>
<tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049ad305a26f0c3deec9fa4bf14d8f778a40"></a>seconds&#160;</td><td class="fielddoc"><p>precision is seconds </p>
</td></tr>
<tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049a03457e192cd793d83b4553f1a3822e71"></a>ms&#160;</td><td class="fielddoc"><p>precision is milliseconds </p>
</td></tr>
<tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049abc729d3656e7635668dcacdd7f5b68d9"></a>us&#160;</td><td class="fielddoc"><p>precision is microseconds </p>
</td></tr>
<tr><td class="fieldname"><a id="ac845d8278c06a59a3dd9b7c05d81b049a4d185b3b79bf8f4cf83d5eb349427294"></a>ns&#160;</td><td class="fielddoc"><p>precision is nanoseconds </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0079100118fa07b92d98b4f32a881e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0079100118fa07b92d98b4f32a881e47">&#9670;&nbsp;</a></span>byte_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NVStrings::byte_count </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of bytes for each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lengths</td><td>The length in bytes for each string. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. Null strings will have value -1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the indexes parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes. </dd></dl>

</div>
</div>
<a id="a2c71da05b27c0df1488a55ca5985f266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c71da05b27c0df1488a55ca5985f266">&#9670;&nbsp;</a></span>capitalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::capitalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return new instance modifying the first character to uppercase and lower-casing the rest. </p>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string case modified. </dd></dl>

</div>
</div>
<a id="aa60b00b99fe38631ab3889b1aebe7080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60b00b99fe38631ab3889b1aebe7080">&#9670;&nbsp;</a></span>cat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::cat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td>
          <td class="paramname"><em>others</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>narep</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the given strings to this instance of strings and returns as new instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">others</td><td>The number of strings must match this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>Null-terminated CPU string that should appear between each instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">narep</td><td>Null-terminated CPU string that should represent any null strings found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with this instance concatentated with the provided instance. </dd></dl>

</div>
</div>
<a id="a09c65f7a045838210fb0bd7f27a3cd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c65f7a045838210fb0bd7f27a3cd91">&#9670;&nbsp;</a></span>cat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::cat </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>others</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>narep</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the given list of strings to this instance of strings and returns as new instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">others</td><td>The number of strings in each item must match this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>Null-terminated CPU string that should appear between each instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">narep</td><td>Null-terminated CPU string that should represent any null strings found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with this instance concatentated with the provided instances. </dd></dl>

</div>
</div>
<a id="a9824a09656fc666f451842a3641334d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9824a09656fc666f451842a3641334d0">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::center </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add padding to the left and right of each string using a provided character. </p>
<p>If the string is already width or more characters, no padding is performed. No strings are truncated. Null strings result in null strings. If left/right split results in odd character padding the extra fill character will added to the right. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">width</td><td>The minimum number of characters for each string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillchar</td><td>Single character in CPU memory to use for padding. A UTF-8 encoded character array of single character may be provided. Default is the ASCII space character (0x20). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string padded appropriately. </dd></dl>

</div>
</div>
<a id="a026bcba91ab86fd8ce8c9469e772e21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026bcba91ab86fd8ce8c9469e772e21c">&#9670;&nbsp;</a></span>code_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::code_points </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills in matrix with code point values (integers) for each string. A code point is the integer value representation of a character. For example, in UTF-8 the code point value for the character 'A' is 65. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>Device array filled in by this method. This must point to device memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> integer arrays where each sub-array has the length of the number of characters for that string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of values written to results. </dd></dl>

</div>
</div>
<a id="a97f105ecf0e8ecc2f9b1a2b8f2df99e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f105ecf0e8ecc2f9b1a2b8f2df99e6">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare string to all the strings in this instance. </p>
<p>The returned values are 0 when the string matches and positive or negative depending the difference between the first non-matching characters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to compare each string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matches. </dd></dl>

</div>
</div>
<a id="add6efee15f3cbc7cf2f433c60326e86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6efee15f3cbc7cf2f433c60326e86e">&#9670;&nbsp;</a></span>compute_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NVStrings::compute_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStringsStatistics.html">StringsStatistics</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a variety of statistics for the strings/characters in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>Fills in this statistics structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeaf5bdc198726eabe0adaf6b1269b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeaf5bdc198726eabe0adaf6b1269b6a">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::contains </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for string within each string of this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to search for in each string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matches. </dd></dl>

</div>
</div>
<a id="ae5b07e9d224079e6a61be84430c86217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b07e9d224079e6a61be84430c86217">&#9670;&nbsp;</a></span>contains_re()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::contains_re </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for regular expression pattern within each string of this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>Null-terminated CPU string of regular expression. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matches. </dd></dl>

</div>
</div>
<a id="ac4504cca8fc5594f3813ac86f2b4e156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4504cca8fc5594f3813ac86f2b4e156">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance from this instance. </p>
<dl class="section return"><dt>Returns</dt><dd>New instance as duplicate of this instance. </dd></dl>

</div>
</div>
<a id="a89d30089eb87e6ae497d0a9fa6bb03a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d30089eb87e6ae497d0a9fa6bb03a4">&#9670;&nbsp;</a></span>count_re()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::count_re </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for regular expression pattern match and count their occurrences for each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>Null-terminated CPU string of regular expression. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matches. </dd></dl>

</div>
</div>
<a id="a54f4b15664c2ea580584f3cdea219499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f4b15664c2ea580584f3cdea219499">&#9670;&nbsp;</a></span>create_custring_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::create_custring_index </td>
          <td>(</td>
          <td class="paramtype">custring_view **&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list to the internal <code>custring_view</code> pointers for this instance. </p>
<p>The pointers returned are to the internal device memory and should not be modified or freed by the caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strs</td><td>An empty array of pointers. This array must hold at least <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> elements. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>If the <code>strs</code> array is in device memory or CPU memory. The resulting pointers are always to device memory regardless. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a id="abdf94e76d98a14f33c80bb0533eda899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf94e76d98a14f33c80bb0533eda899">&#9670;&nbsp;</a></span>create_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::create_from_array </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an instance from an array of null-terminated host strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>Array of character-array pointers to UTF-8 encoded strings. Null pointers identify null strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of pointers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance with the strings copied into device memory. </dd></dl>

</div>
</div>
<a id="a83d5f80ad3c34cb311fe449ed0e655cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d5f80ad3c34cb311fe449ed0e655cf">&#9670;&nbsp;</a></span>create_from_bools()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::create_from_bools </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>true_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>false_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string representation for the provided booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of booleans to convert to strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of elements in the values parameter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">true_string</td><td>What string to use for 'true'. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">false_string</td><td>What string to use for 'false'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullbitmask</td><td>Indicates which entries should result in a null string. If specified, this array should be at least (count+7)/8 bytes. The bits are expected to be organized in Arrow format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results and nullbitmask points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with string representation. </dd></dl>

</div>
</div>
<a id="a91c022a172bc0988862d1ebc09e099e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c022a172bc0988862d1ebc09e099e4">&#9670;&nbsp;</a></span>create_from_csv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::create_from_csv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>csvfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a>&#160;</td>
          <td class="paramname"><em>stype</em> = <code><a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831a0b5479f46e32a0b52419271376591269">none</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nullIsEmpty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an instance from a specific column in a CSV file. </p>
<p>This has very limited support for CSV formats is intended for experimentation only. Recommend using the cuDF read_csv method which has many more features.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">csvfile</td><td>Full-path to CSV file to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>0-based column index to retrieve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lines</td><td>Limit the number of lines read from the file. Default is all lines. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stype</td><td>Whether to sort the strings or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullIsEmpty</td><td>How to handle null entries. Set to true to treat nulls as empty strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of strings for the specified column. </dd></dl>

</div>
</div>
<a id="a8cadd917f9e5a1336eb1ba7416abc988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cadd917f9e5a1336eb1ba7416abc988">&#9670;&nbsp;</a></span>create_from_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::create_from_index </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; const char *, size_t &gt; *&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a>&#160;</td>
          <td class="paramname"><em>stype</em> = <code><a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831a0b5479f46e32a0b52419271376591269">none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an instance from an array of string/length pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>Array of pointer/length pairs to UTF-8 encoded strings. Lengths should be in bytes and should not include null-terminator. Null pointers identify null strings. Zero lengths identify empty strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of pairs in the <code>strs</code> array. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Set to true (default) if pointers are to device memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stype</td><td>Optionally sort the strings accordingly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance with the strings copied into device memory. </dd></dl>

</div>
</div>
<a id="a33c3292e04f327176eaa9cfd961e673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c3292e04f327176eaa9cfd961e673f">&#9670;&nbsp;</a></span>create_from_ipc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::create_from_ipc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvstrings__ipc__transfer.html">nvstrings_ipc_transfer</a> &amp;&#160;</td>
          <td class="paramname"><em>ipc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an instance from an IPC-transfer object built from <a class="el" href="structnvstrings__ipc__transfer.html" title="This is used by the create_from_ipc and create_ipc_transfer methods.">nvstrings_ipc_transfer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipc</td><td>Data needed to create a new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance with data provided. </dd></dl>

</div>
</div>
<a id="a982c62faa84db45f5698966e7867fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982c62faa84db45f5698966e7867fe1d">&#9670;&nbsp;</a></span>create_from_offsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::create_from_offsets </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nulls</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an instance from single buffer of strings. </p>
<p>Start of each string is identified by the offsets array. The size of each string is determined by computing adjacent offset differences so null-terminators are not allowed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>The pointer to the contiguous buffer of strings encoded in UTF-8. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The total number of strings in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Array of byte offsets to each string. This should be 1 more than the count value with the last value specifying the length of the buffer in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullbitmask</td><td>Each bit identifies which strings are to be considered null. The bits are organized as specified in the Arrow format. If no nulls, this parameter can be null. The size of this byte array should be at least (count+7)/8 bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nulls</td><td>The number of nulls identified by the <code>nullbitmask</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Set to true (default) if pointers are to device memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance with the strings copied into device memory. </dd></dl>

</div>
</div>
<a id="a667b4438763ee82ca6921759b8eceba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667b4438763ee82ca6921759b8eceba1">&#9670;&nbsp;</a></span>create_from_strings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::create_from_strings </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt;&#160;</td>
          <td class="paramname"><em>strs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an instance from other <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances. </p>
<p>This can be used to create a new instance from a collection of other instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>A vector of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instance pointers to use. These can be safely freed by the caller on return from this method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance with copy of the strings provided. </dd></dl>

</div>
</div>
<a id="ad3f4f0afb3ce81b689af581610c52e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f4f0afb3ce81b689af581610c52e9f">&#9670;&nbsp;</a></span>create_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::create_index </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; const char *, size_t &gt; *&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an index for the device strings contained in this instance. </p>
<p>The pointers returned are to the internal device memory and should not be modified or freed by the caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strs</td><td>An array of empty pairs to be filled in by this method. This array must hold at least <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> elements. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>If the <code>strs</code> array is in device memory or CPU memory. The resulting pointers are always to device memory regardless. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a id="aa1de85578e794a315f189d42b2235033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1de85578e794a315f189d42b2235033">&#9670;&nbsp;</a></span>create_ipc_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::create_ipc_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvstrings__ipc__transfer.html">nvstrings_ipc_transfer</a> &amp;&#160;</td>
          <td class="paramname"><em>ipc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create IPC-transfer data from this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ipc</td><td>Structure will be set with data needed by create_from_ipc method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a id="a6ec46344fcc2f2f6a5b068716b9ee4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec46344fcc2f2f6a5b068716b9ee4b9">&#9670;&nbsp;</a></span>create_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::create_offsets </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy strings into single memory buffer provided. </p>
<p>Start of each string is placed into the offsets array. Nulls will be specified in the nullbitmask if provided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">strs</td><td>The pointer to the contiguous buffer of strings encoded in UTF-8. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets</td><td>Array of 0-based byte offsets to each string. The number of values should be count+1 with the last value specifying the length of the <code>strs</code> buffer in bytes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nullbitmask</td><td>Byte array of bits identifies which strings are to be considered null. The bits are organized as specified in the Arrow format. If no nulls, this parameter can be null. The size of this byte array should be at least (count+7)/8 bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>If the <code>strs</code> array and <code>nullbitmask</code> array is in device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a id="ab110619a2a265bddd7d1b8795e10d069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab110619a2a265bddd7d1b8795e10d069">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void NVStrings::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this method to free any instance created by methods in this class. </p>
<p>All device and CPU memory used by this instance is freed. Caller should no longer use this instance after calling this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inst</td><td>The instance to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac52e80817c8bbfe5069c303033842777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52e80817c8bbfe5069c303033842777">&#9670;&nbsp;</a></span>dtos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::dtos </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string representation for the provided double float values. </p>
<p>Upto 10 significant digits are recorded. Numbers above 10^9 and numbers below 10^5 may be converted to scientific notation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of double float values to convert to strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of doiuble float values in the values parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullbitmask</td><td>Indicates which entries should result in a null string. If specified, this array should be at least (count+7)/8 bytes. The bits are expected to be organized in Arrow format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results and nullbitmask points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with string representation of the values as appropriate. </dd></dl>

</div>
</div>
<a id="a57164c5ef32b51cb8044f71aaa774217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57164c5ef32b51cb8044f71aaa774217">&#9670;&nbsp;</a></span>endswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::endswith </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the end of each string with the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to search for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matches. </dd></dl>

</div>
</div>
<a id="a69f1eefde58d4bba9f020e16ed105e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f1eefde58d4bba9f020e16ed105e8a">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::extract </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of strings for each group specified in the given regular expression pattern. </p>
<p>This will create an <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instance for each groups. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regular expression pattern with group indicators. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The instances containing the extract strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of instances returned in results. </dd></dl>

</div>
</div>
<a id="a38ca4fa55925f7bd107b0c5c9011b034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ca4fa55925f7bd107b0c5c9011b034">&#9670;&nbsp;</a></span>extract_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::extract_record </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of strings for each group specified in the given regular expression pattern. </p>
<p>This will return a new instance of this class for each string in this instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regular expression pattern with group indicators. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The instances containing the extract strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of instances returned in results. </dd></dl>

</div>
</div>
<a id="a07de84032a829382d538b0ef981e04af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07de84032a829382d538b0ef981e04af">&#9670;&nbsp;</a></span>fillna() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::fillna </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace null strings with specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to place instead of null strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of this instance with null strings replaced. </dd></dl>

</div>
</div>
<a id="aa43bcf2a31c8c819ec4802ca7a5d18d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43bcf2a31c8c819ec4802ca7a5d18d0">&#9670;&nbsp;</a></span>fillna() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::fillna </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> &amp;&#160;</td>
          <td class="paramname"><em>strs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace null strings with corresponding strings from the parameter. </p>
<p>Strings are matched by index. Strings that are not null are not replaced. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>Strings to replace nulls. The number of strings must match this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of this instance with null strings replaced. </dd></dl>

</div>
</div>
<a id="a5e4050453544ea26af4da7876f71bd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4050453544ea26af4da7876f71bd76">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a string within each string in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to search for. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>0-based character position to start search for each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>0-based character position to stop searching for each string. Value of -1 indicates search to the end of the string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of positive (&gt;=0) results. </dd></dl>

</div>
</div>
<a id="ac5d968127b2e4c9b8fa788fe013fa497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d968127b2e4c9b8fa788fe013fa497">&#9670;&nbsp;</a></span>find_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::find_from </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>starts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a string within each string in this instance. </p>
<p>This methods allows for searching in unique ranges for each string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">starts</td><td>Array of 0-based character position to start search for each string. This must have <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ends</td><td>Array of 0-based character position to stop searching for each string. This must have <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. Values of -1 indicate search to the end of that string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of positive (&gt;=0) results. </dd></dl>

</div>
</div>
<a id="a1915b944e3c49ecf9011f9ab24737f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1915b944e3c49ecf9011f9ab24737f21">&#9670;&nbsp;</a></span>find_multiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::find_multiple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> &amp;&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search multiple strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>List of strings to search for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of positive (&gt;=0) results. </dd></dl>

</div>
</div>
<a id="ac119eda114134c0e8c018f4dc65b6885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac119eda114134c0e8c018f4dc65b6885">&#9670;&nbsp;</a></span>findall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::findall </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all occurrences of the specified regular expression pattern in each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regulare expression pattern to search. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>List of instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="ac3f7e8b012dc69785e61417c4cfcd915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f7e8b012dc69785e61417c4cfcd915">&#9670;&nbsp;</a></span>findall_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::findall_record </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all occurrences of the specified regular expression pattern in each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The regular expression pattern to search. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>List of instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="a4151197106a18de97c4b5a2eac1e88a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4151197106a18de97c4b5a2eac1e88a4">&#9670;&nbsp;</a></span>ftos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::ftos </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string representation for the provided float values. </p>
<p>Upto 10 significant digits are recorded. Numbers above 10^9 and numbers below 10^5 may be converted to scientific notation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of float values to convert to strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of float values in the values parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullbitmask</td><td>Indicates which entries should result in a null string. If specified, this array should be at least (count+7)/8 bytes. The bits are expected to be organized in Arrow format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results and nullbitmask points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with string representation of the values as appropriate. </dd></dl>

</div>
</div>
<a id="ad12bdc59898ac6a8094c971fdf565923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12bdc59898ac6a8094c971fdf565923">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::gather </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new instance where the corresponding boolean array values are true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Must have the same number of elements as this instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the mask parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the indicated strings. </dd></dl>

</div>
</div>
<a id="a55264aa46a79ae924850a4d1a29e3cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55264aa46a79ae924850a4d1a29e3cce">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::gather </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new instance using the order of the specified index values for this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The 0-based index values to retrieve from this instance. Values may be repeated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of values in the pos array. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the pos parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the specified strings. </dd></dl>

</div>
</div>
<a id="ae3929aecfa0fb85980858c5ba5ec8f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3929aecfa0fb85980858c5ba5ec8f8b">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::get </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a specific character (as a string) by position for each string. </p>
<p>The return instance will have strings containing no more than 1 character each. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The 0-based index of the character location within each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance containing single-character strings. </dd></dl>

</div>
</div>
<a id="adaaa1f3326fb1a25d3193d16d4fdb336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaa1f3326fb1a25d3193d16d4fdb336">&#9670;&nbsp;</a></span>get_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::get_nulls </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emptyIsNull</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set int array with position of null strings. </p>
<p>Returns the 0-based index positions of strings that are null in this instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pos</td><td>Integer array to be filled in by this method. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">emptyIsNull</td><td>Set to true to specify empty strings as null strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Identifies the provided <code>pos</code> parameter points to device memory (default) or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nulls found. </dd></dl>

</div>
</div>
<a id="aec7b19264d7b912ca236636d4b200c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7b19264d7b912ca236636d4b200c81">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::hash </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns unsigned 32-bit hash value for each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero values. </dd></dl>

</div>
</div>
<a id="af6ed622ceb8e1c34afbafbca627608e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ed622ceb8e1c34afbafbca627608e3">&#9670;&nbsp;</a></span>htoi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::htoi </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns integer values represented by each string assuming hex characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero values. </dd></dl>

</div>
</div>
<a id="afed11757452f23fd403d2f0881563a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed11757452f23fd403d2f0881563a81">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::insert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the specified string (repl) into each string at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>Null-terminated CPU string to insert into each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>The 0-based character position in each string to start the replace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with updated strings. </dd></dl>

</div>
</div>
<a id="a62ec179783365d48bda52c21b5d7efd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ec179783365d48bda52c21b5d7efd0">&#9670;&nbsp;</a></span>int2ip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::int2ip </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string representation of IPv4 address (v4) for the provided integer values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of integers to convert to strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of integers in the values parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullbitmask</td><td>Indicates which entries should result in a null string. If specified, this array should be at least (count+7)/8 bytes. The bits are expected to be organized in Arrow format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with string representation of the integers as appropriate. </dd></dl>

</div>
</div>
<a id="a881c5e067b5e91129c881c2b85986f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881c5e067b5e91129c881c2b85986f93">&#9670;&nbsp;</a></span>ip2int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::ip2int </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns integer representation of IPv4 address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero values. </dd></dl>

</div>
</div>
<a id="aa0ddd6f471bcc6dda1dcf110bda896be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ddd6f471bcc6dda1dcf110bda896be">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::is_empty </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for non-empty strings &ndash; non-null strings with at least one character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="abc6188f6c25e88285f0f3b74e89a69e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6188f6c25e88285f0f3b74e89a69e7">&#9670;&nbsp;</a></span>isalnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::isalnum </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for strings that have only alphanumeric characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="a01fc29eda8762cda8923dd212dca9e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fc29eda8762cda8923dd212dca9e2e">&#9670;&nbsp;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::isalpha </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for strings that have only alphabetic characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="a6c6cf67f7686d0e1b01516e69223729c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6cf67f7686d0e1b01516e69223729c">&#9670;&nbsp;</a></span>isdecimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::isdecimal </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for strings that have only decimal characters. Characters that can be used to extract base10 numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="ac78aef1b3075909a11f84ad2f5dccb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78aef1b3075909a11f84ad2f5dccb0e">&#9670;&nbsp;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::isdigit </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for strings that have only digit characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="a7d17dc7d991fe3d585414d3754d21a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d17dc7d991fe3d585414d3754d21a3d">&#9670;&nbsp;</a></span>islower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::islower </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for strings that have only lowercase characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="a644ffbe8fe1be46730ceaf481d1c0232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644ffbe8fe1be46730ceaf481d1c0232">&#9670;&nbsp;</a></span>isnumeric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::isnumeric </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for strings that have only numeric characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="a3c70de98cde6c24aaf5eb826003bbbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c70de98cde6c24aaf5eb826003bbbf9">&#9670;&nbsp;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::isspace </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for strings that have only whitespace characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="a950670f0c70493834a70a47d6a24cbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950670f0c70493834a70a47d6a24cbc2">&#9670;&nbsp;</a></span>isupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::isupper </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true for strings that have only uppercase characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array filled in by this method. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the results parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of trues. </dd></dl>

</div>
</div>
<a id="ae4ef46c36bf1e941b4817dfbf02cb944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ef46c36bf1e941b4817dfbf02cb944">&#9670;&nbsp;</a></span>itos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::itos </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string representation for the provided integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of integers to convert to strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of integers in the values parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullbitmask</td><td>Indicates which entries should result in a null string. If specified, this array should be at least (count+7)/8 bytes. The bits are expected to be organized in Arrow format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results and nullbitmask points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with string representation of the values as appropriate. </dd></dl>

</div>
</div>
<a id="acd55ca9dc9f0ebb381114423c9993961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd55ca9dc9f0ebb381114423c9993961">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>narep</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates all strings into one new string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">separator</td><td>Null-terminated CPU string that should appear between each string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">narep</td><td>Null-terminated CPU string that should represent any null strings found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting instance with one string. </dd></dl>

</div>
</div>
<a id="a3e22a977c3d75aa43923fee20c49a194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e22a977c3d75aa43923fee20c49a194">&#9670;&nbsp;</a></span>len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::len </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of characters in each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lengths</td><td>The length in characters for each string. This parameter must be able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. Null strings will have value -1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the indexes parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of characters. </dd></dl>

</div>
</div>
<a id="a9bcbff99c3478dfb316619fecc22a7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcbff99c3478dfb316619fecc22a7f5">&#9670;&nbsp;</a></span>ljust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::ljust </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add padding to the left of each string using a provided character. </p>
<p>If the string is already width or more characters, no padding is performed. No strings are truncated. Null strings result in null strings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">width</td><td>The minimum number of characters for each string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillchar</td><td>Single character in CPU memory to use for padding. A UTF-8 encoded character array of single character may be provided. Default is the ASCII space character (0x20). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string padded appropriately. </dd></dl>

</div>
</div>
<a id="a7371eaa7ddca3e72843adeb6787cb427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7371eaa7ddca3e72843adeb6787cb427">&#9670;&nbsp;</a></span>long2timestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::long2timestamp </td>
          <td>(</td>
          <td class="paramtype">const unsigned long *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049">timestamp_units</a>&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string representation of UTC timestamp in milliseconds from Epoch time. </p>
<p>Each string will be created with the following format: YYYY-MM-DDThh:mm:ss.sssZ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of integers to convert to strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of integers in the values parameter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">units</td><td>Time units of the values array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format must include strftime format specifiers though only the following are supported: Y,y,m,d,H,I,p,M,S,f,z Default format is "%Y-%m-%dT%H:%M:%SZ" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullbitmask</td><td>Indicates which entries should result in a null string. If specified, this array should be at least (count+7)/8 bytes. The bits are expected to be organized in Arrow format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with string representation of the integers as appropriate. </dd></dl>

</div>
</div>
<a id="ab97f8a71d6c2709f02dc9c14ee645f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97f8a71d6c2709f02dc9c14ee645f20">&#9670;&nbsp;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::lower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return new instance modifying uppercase characters to lowercase. </p>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string case modified. </dd></dl>

</div>
</div>
<a id="a48723ac170508171145dc862c95c7bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48723ac170508171145dc862c95c7bbb">&#9670;&nbsp;</a></span>lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::lstrip </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_strip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified character(s) if found at the beginning of each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">to_strip</td><td>Null-terminated CPU string of characters (UTF-8 encoded) to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with characters removed from each string. </dd></dl>

</div>
</div>
<a id="a7d56e410c4fcac467199c74a518b0191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d56e410c4fcac467199c74a518b0191">&#9670;&nbsp;</a></span>ltos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::ltos </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>nullbitmask</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string representation for the provided long integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of long integers to convert to strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of long integers in the values parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nullbitmask</td><td>Indicates which entries should result in a null string. If specified, this array should be at least (count+7)/8 bytes. The bits are expected to be organized in Arrow format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results and nullbitmask points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with string representation of the values as appropriate. </dd></dl>

</div>
</div>
<a id="ab51f8af6388f11f7bb3978147981bfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51f8af6388f11f7bb3978147981bfdb">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for regular expression pattern match at the beginning of each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>Null-terminated CPU string of regular expression. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matches. </dd></dl>

</div>
</div>
<a id="a26657d350ce4d30b5a44aa7ffc3e841e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26657d350ce4d30b5a44aa7ffc3e841e">&#9670;&nbsp;</a></span>match_strings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::match_strings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> &amp;&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check each argument string matches with the corresponding strings in this list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>Strings to compare against. The number of strings must match with this instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matches. </dd></dl>

</div>
</div>
<a id="a30dbfbbb531a5354c398d3701d521332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dbfbbb531a5354c398d3701d521332">&#9670;&nbsp;</a></span>memsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NVStrings::memsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of device bytes used by this instance. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes. </dd></dl>

</div>
</div>
<a id="af47e5bf838dfe8f75620ad539d90cfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47e5bf838dfe8f75620ad539d90cfc8">&#9670;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a>&#160;</td>
          <td class="paramname"><em>stype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nullfirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new row index positions for strings sorted in this instance. </p>
<p>The strings in this instance are neither modified nor moved in position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">stype</td><td>Specify what attribute to srot: length or character code-points. Sorting by both length and characters is allowed. In this case, length is sorted first. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ascending</td><td>Set to true to sort logically lowest to highest. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">indexes</td><td>Pointer to array to be filled in by this method. This array must be able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nullfirst</td><td>Null strings are either always placed first or last regardless of ascending parameter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the pos parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a id="aefbe772d7e225d41e2837280edc8cd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbe772d7e225d41e2837280edc8cd08">&#9670;&nbsp;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::pad </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNVStrings.html#ae632539abce4f345d9c6995cc407281e">padside</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add padding to each string using a provided character. </p>
<p>If the string is already width or more characters, no padding is performed. No strings are truncated. Null strings result in null strings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">width</td><td>The minimum number of characters for each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">side</td><td>Where to place the padding characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillchar</td><td>Single character in CPU memory to use for padding. A UTF-8 encoded character array of single character may be provided. Default is the ASCII space character (0x20). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string padded appropriately. </dd></dl>

</div>
</div>
<a id="a1f18538ef786a0599246e0ea4324d4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18538ef786a0599246e0ea4324d4b5">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::partition </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each string is split into two strings on the first delimiter found. </p>
<p>Three strings are returned for each string: left-half, delimiter itself, right-half. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>Null-terminated CPU string identifying the split points within each string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list of instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="a0846b760037f5282428ae80b57471b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0846b760037f5282428ae80b57471b2f">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NVStrings::print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxwidth</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output strings to stdout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>First string to start printing. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>Last string to print. Default (-1) prints from pos to the last string in this instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxwidth</td><td>Strings longer than this are truncated in the output. Default (-1) prints the entire string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>Line separator character to use between each string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a02cf5cdc90361aecbc1602f96a47d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a02cf5cdc90361aecbc1602f96a47d4">&#9670;&nbsp;</a></span>remove_strings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::remove_strings </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new instance without the specified strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The 0-based index of the strings to be ignored when creating a copy of this instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of values in the pos array. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the pos parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance without the strings specified. </dd></dl>

</div>
</div>
<a id="a7c07a995b85e55290f2d564ff128ca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c07a995b85e55290f2d564ff128ca8f">&#9670;&nbsp;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::repeat </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate each string with itself the number of times specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of times to repeat each string. Values of 0 or 1 return a copy of this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string duplicated as specified. </dd></dl>

</div>
</div>
<a id="af8aa1f37e857e94cc6cf1872b26871ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8aa1f37e857e94cc6cf1872b26871ca">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::replace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxrepl</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces occurrences found of one string with another string in each string of this instance. </p>
<p>This method does not use regular expression to search for the target <code>str</code> to replace. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to search for replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>Null-terminated CPU string to replace any found strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxrepl</td><td>Maximum number of times to search and replace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the characters replaced appropriately. </dd></dl>

</div>
</div>
<a id="ae25c5698dbe796cf893ffbfdd4b118a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25c5698dbe796cf893ffbfdd4b118a7">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> &amp;&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> &amp;&#160;</td>
          <td class="paramname"><em>repls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces any occurrences found in list of strings with corresponding string in each string of this instance. </p>
<p>This method does not use regular expression to search for the target string to replace. All occurrences found of any of the specified strings are replaced. If only a single string is present in repls, it is used for replacement for all targets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>List of strings to search for replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repls</td><td>List of strings to substitute for the corresponding string in strs. Must have the same number of strings as strs or contain just a single string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the characters replaced appropriately. </dd></dl>

</div>
</div>
<a id="a90e1cfa591b4a1acda2f4ca0da6a630b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e1cfa591b4a1acda2f4ca0da6a630b">&#9670;&nbsp;</a></span>replace_re() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::replace_re </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxrepl</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces occurrences found of one string with another string in each string of this instance. </p>
<p>This method uses the given regular expression pattern to search for the target <code>str</code> to replace. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>Null-terminated CPU string with regular expression. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>Null-terminated CPU string to replace any found strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxrepl</td><td>Maximum number of times to search and replace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the characters replaced appropriately. </dd></dl>

</div>
</div>
<a id="a8bbbe83e7e5232e6ecf98888fcf73e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbbe83e7e5232e6ecf98888fcf73e73">&#9670;&nbsp;</a></span>replace_re() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::replace_re </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> &amp;&#160;</td>
          <td class="paramname"><em>repls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces occurrences found of string list with corresponding strings in each string of this instance. </p>
<p>This method uses the given regular expression patterns to search for the target <code>str</code> to replace. If only a single string is present in repls, it is used for replacement for all targets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patterns</td><td>Null-terminated CPU strings with regular expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repls</td><td>Strings to replace any found strings. Must have the same number of strings as strs or contain just a single string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the characters replaced appropriately. </dd></dl>

</div>
</div>
<a id="a52cdca3b0e21df2a987942571b253dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52cdca3b0e21df2a987942571b253dca">&#9670;&nbsp;</a></span>replace_with_backrefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::replace_with_backrefs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract values using pattern and place them repl as indicated by backref indicators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>Null-terminated CPU string with regular expression. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>Null-terminated CPU string with back-reference indicators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the characters replaced appropriately. </dd></dl>

</div>
</div>
<a id="ab6c542e1cc5e026aa63c2eca7d788b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c542e1cc5e026aa63c2eca7d788b06">&#9670;&nbsp;</a></span>rfind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::rfind </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search from the end for a string within each string in this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to search for. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>0-based character position to start search for each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>0-based character position to stop searching for each string. Value of -1 indicates search from the end of the string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of positive (&gt;=0) results. </dd></dl>

</div>
</div>
<a id="ac201e235b531e52c251b41207124ee08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201e235b531e52c251b41207124ee08">&#9670;&nbsp;</a></span>rjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::rjust </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fillchar</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add padding to the right of each string using a provided character. </p>
<p>If the string is already width or more characters, no padding is performed. No strings are truncated. Null strings result in null strings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">width</td><td>The minimum number of characters for each string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillchar</td><td>Single character in CPU memory to use for padding. A UTF-8 encoded character array of single character may be provided. Default is the ASCII space character (0x20). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string padded appropriately. </dd></dl>

</div>
</div>
<a id="a04eb3443b15cd2d3d81a67cab756eeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04eb3443b15cd2d3d81a67cab756eeef">&#9670;&nbsp;</a></span>rpartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::rpartition </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each string is split into two strings on the last delimiter found. </p>
<p>Three strings are returned for each string: left-half, delimiter itself, right-half. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>Null-terminated CPU string identifying the split points within each string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list of instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="a2eb32def515db3216d68cfb66e75f700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb32def515db3216d68cfb66e75f700">&#9670;&nbsp;</a></span>rsplit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::rsplit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split strings vertically creating new columns of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances. </p>
<p>The number of columns will be equal to the string with the most splits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>Null-terminated CPU string identifying the split points within each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxsplit</td><td>Maximum number of splits to perform searching right to left. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list of instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="a1f69fb932460d23f10dd4f2231ccac4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f69fb932460d23f10dd4f2231ccac4a">&#9670;&nbsp;</a></span>rsplit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::rsplit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split strings on whitespace vertically creating new columns of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances. </p>
<p>The number of columns will be equal to the string with the most splits. Whitespace is identified by any character code less than equal to ASCII space (0x20). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">maxsplit</td><td>Maximum number of splits to perform searching right to left. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list of instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="ab4ee93a3dd55f274096e203d7653d86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ee93a3dd55f274096e203d7653d86b">&#9670;&nbsp;</a></span>rsplit_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::rsplit_record </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each string is split into a list of new strings. </p>
<p>Each string results in a new instance of this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>Null-terminated CPU string identifying the split points within each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxsplit</td><td>Maximum number of splits to perform searching right to left. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list of instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="a873688d9db9c9c399d6d1d28f3d8eedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873688d9db9c9c399d6d1d28f3d8eedf">&#9670;&nbsp;</a></span>rsplit_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::rsplit_record </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each string is split on whitespace into a list of new strings. </p>
<p>Each string results in a new instance of this class. Whitespace is identified by any character code less than equal to ASCII space (0x20). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">maxsplit</td><td>Maximum number of splits to perform searching right to left. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list new instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="ae252878ec60b38dca90f9ed421c7a17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae252878ec60b38dca90f9ed421c7a17f">&#9670;&nbsp;</a></span>rstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::rstrip </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_strip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified character(s) if found at the end of each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">to_strip</td><td>Null-terminated CPU string of characters (UTF-8 encoded) to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with characters removed from each string. </dd></dl>

</div>
</div>
<a id="a2eedb3c2baa8762e140c386c499892a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eedb3c2baa8762e140c386c499892a5">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::scatter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new instance using the provided index values and strings instance. The position values specify the location in the new strings instance. Missing values pass through from this instance at those positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The instance for which to retrieve the values specified in pos array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The 0-based index values to replace with the given strings in this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of values in pos parameter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the pos parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the specified strings. </dd></dl>

</div>
</div>
<a id="ae22d0d1d8105e8bbffcf64d457810737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22d0d1d8105e8bbffcf64d457810737">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html">NVStrings</a> &amp;&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new instance using the provided index values and strings instance. The position values specify the location in the new strings instance. Missing values pass through from this instance at those positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strs</td><td>The instance for which to retrieve the values specified in pos array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The 0-based index values to retrieve from the provided instance. Number of values must equal the number of strings in strs pararameter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether the pos parameter points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the specified strings. </dd></dl>

</div>
</div>
<a id="af13cc0d4eae84b8c11393c2a6f40251f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13cc0d4eae84b8c11393c2a6f40251f">&#9670;&nbsp;</a></span>set_null_bitarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::set_null_bitarray </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bitarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emptyIsNull</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bit-array identifying the null strings. </p>
<p>The bits are arranged using the Arrow format for bitmask. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bitarray</td><td>Byte array to be filled in by this method. The array must be at least (<a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a>+7)/8 bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">emptyIsNull</td><td>Set to true to specify empty strings as null strings. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Identifies the provided <code>bitarray</code> parameter points to device memory (default) or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nulls found. </dd></dl>

</div>
</div>
<a id="ac0e454d488b47498f7171acf4980990a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e454d488b47498f7171acf4980990a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of strings managed by this instance. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of strings. </dd></dl>

</div>
</div>
<a id="a3b6c28d2717be7f596031b492335b3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6c28d2717be7f596031b492335b3b0">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a substring of each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>First position (0-based index of characters) to start retrieving. </td></tr>
    <tr><td class="paramname">stop</td><td>Last position (0-based index of characters) to stop retrieving. </td></tr>
    <tr><td class="paramname">step</td><td>This can be used to retrieve interval of characters between start and stop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance containing strings with characters only between start and stop. </dd></dl>

</div>
</div>
<a id="a5f967a5409d75e09b3d410b8f04b3dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f967a5409d75e09b3d410b8f04b3dd1">&#9670;&nbsp;</a></span>slice_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::slice_from </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>starts</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ends</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a substring of each string. </p>
<p>This method allows specifying unique start and end positions for each string. Use 0 to specify the start of any specific string. Use -1 to specify the end of any specific string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">starts</td><td>Array of positions to start retrieving. This must point to device memory of <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ends</td><td>Array of positions to stop retrieving. This must point to device memory of <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance containing strings with characters specified. </dd></dl>

</div>
</div>
<a id="a80257b75625b7abfa472269c1f73bfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80257b75625b7abfa472269c1f73bfb9">&#9670;&nbsp;</a></span>slice_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::slice_replace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the specified string (repl) into each string at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">repl</td><td>Null-terminated CPU string to insert into each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>The 0-based character position in each string to start the replace. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stop</td><td>The 0-based character position to complete the replace. The default (-1) indicates replace to the end of each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with updated strings. </dd></dl>

</div>
</div>
<a id="a3f982345feb2bb6c313cb465d68a4e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f982345feb2bb6c313cb465d68a4e58">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNVStrings.html#a48a22848cee202e59b5a1ba22c8c3831">sorttype</a>&#160;</td>
          <td class="paramname"><em>stype</em> = <code>sorttype::name</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascending</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nullfirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sorted copy of the strings managed by this instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stype</td><td>Specify what attribute to sort: length or character code-points. </td></tr>
    <tr><td class="paramname">ascending</td><td>Set to true (default) to sort logically lowest to highest. </td></tr>
    <tr><td class="paramname">nullfirst</td><td>Null strings are either always placed first or last regardless of ascending parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with sorted strings as specified. </dd></dl>

</div>
</div>
<a id="a479236d25afda556adb1b2ef18538ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479236d25afda556adb1b2ef18538ba2">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split strings vertically creating new columns of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances. </p>
<p>The number of columns will be equal to the string with the most splits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>Null-terminated CPU string identifying the split points within each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxsplit</td><td>Maximum number of splits to perform searching left to right. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list of instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="ab3a8eb06f5829042e35fc64b4b7913c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a8eb06f5829042e35fc64b4b7913c7">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split strings on whitespace vertically creating new columns of <a class="el" href="classNVStrings.html" title="This class manages a list of strings stored in device memory. An instance of this class is a CPU (hos...">NVStrings</a> instances. </p>
<p>The number of columns will be equal to the string with the most splits. Whitespace is identified by any character code less than equal to ASCII space (0x20). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">maxsplit</td><td>Maximum number of splits to perform searching left to right. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list of instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="a9c7936e82eda42aa477fcd91e472ffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7936e82eda42aa477fcd91e472ffe7">&#9670;&nbsp;</a></span>split_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::split_record </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each string is split into a list of new strings. </p>
<p>Each string results in a new instance of this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>Null-terminated CPU string identifying the split points within each string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxsplit</td><td>Maximum number of splits to perform searching left to right. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The list of instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="aca92a602aeb64e680b018c21a0fe777b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca92a602aeb64e680b018c21a0fe777b">&#9670;&nbsp;</a></span>split_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::split_record </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxsplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNVStrings.html">NVStrings</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each string is split on whitespace into a list of new strings. </p>
<p>Each string results in a new instance of this class. Whitespace is identified by any character code less than equal to ASCII space (0x20). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">maxsplit</td><td>Maximum number of splits to perform searching left to right. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>The resulting instances for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of strings returned in the results vector. </dd></dl>

</div>
</div>
<a id="a1af3b11947700864f7d815a2ee4c004a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af3b11947700864f7d815a2ee4c004a">&#9670;&nbsp;</a></span>startswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NVStrings::startswith </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the beginning of each string with the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Null-terminated CPU string to search for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matches. </dd></dl>

</div>
</div>
<a id="add81fde809d50f3f71df74338d75c28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add81fde809d50f3f71df74338d75c28b">&#9670;&nbsp;</a></span>stod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::stod </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns double values represented by each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero values. </dd></dl>

</div>
</div>
<a id="a1624acbce418c9dee3852ea0fbf6950a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1624acbce418c9dee3852ea0fbf6950a">&#9670;&nbsp;</a></span>stof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::stof </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns float values represented by each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero values. </dd></dl>

</div>
</div>
<a id="a3f84e3447db24477570dd52628d65d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f84e3447db24477570dd52628d65d1a">&#9670;&nbsp;</a></span>stoi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::stoi </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns integer values represented by each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero values. </dd></dl>

</div>
</div>
<a id="a5a36ddb8fa59ae0a41b845fb314995c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a36ddb8fa59ae0a41b845fb314995c5">&#9670;&nbsp;</a></span>stol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::stol </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns long integer values represented by each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero values. </dd></dl>

</div>
</div>
<a id="a8c7a895ecaf473e04c363b389262e270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7a895ecaf473e04c363b389262e270">&#9670;&nbsp;</a></span>strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::strip </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_strip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified character(s) if found at the beginning or end of each string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">to_strip</td><td>Null-terminated CPU string of characters (UTF-8 encoded) to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with characters removed from each string. </dd></dl>

</div>
</div>
<a id="a828b11920c0a9da7313a267c7946affc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828b11920c0a9da7313a267c7946affc">&#9670;&nbsp;</a></span>sublist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::sublist </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance containing only the strings in the specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>First 0-based index to capture from. </td></tr>
    <tr><td class="paramname">end</td><td>The last 0-based index to capture from. </td></tr>
    <tr><td class="paramname">step</td><td>This can be used to capture indexes in intervals. Default is all strings within start and end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the specified strings. </dd></dl>

</div>
</div>
<a id="a2a9bfd3ad6ad33d97db8cf99c4768d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9bfd3ad6ad33d97db8cf99c4768d22">&#9670;&nbsp;</a></span>swapcase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::swapcase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return new instance modifying uppercase characters to lowercase and vice versa. </p>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string case modified. </dd></dl>

</div>
</div>
<a id="a75f17c4f9079f1e45625c8bea7509b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f17c4f9079f1e45625c8bea7509b29">&#9670;&nbsp;</a></span>timestamp2long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::timestamp2long </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNVStrings.html#ac845d8278c06a59a3dd9b7c05d81b049">timestamp_units</a>&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns integer representation date-time string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format must include strptime format specifiers though only the following are supported: Y,y,m,d,H,I,p,M,S,f,z Default format is "%Y-%m-%dT%H:%M:%SZ" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">units</td><td>The values will be created in these units. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of non-zero values. </dd></dl>

</div>
</div>
<a id="a0c802b3e2fbd2710490ab19dbd988756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c802b3e2fbd2710490ab19dbd988756">&#9670;&nbsp;</a></span>title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::title </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return new instance modifying first characters after space to uppercase and lower-casing the rest. </p>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string case modified. </dd></dl>

</div>
</div>
<a id="a3ca29c037d2eb9041b9c56d983fd6490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca29c037d2eb9041b9c56d983fd6490">&#9670;&nbsp;</a></span>to_bools()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::to_bools </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>true_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devmem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns boolean representation of the strings in this instance. </p>
<p>This will do a compare of the target string and return true when matched and false when not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">true_string</td><td>What text to identify a string as 'true'. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Array this method will fill in with the results. This must point to memory able to hold <a class="el" href="classNVStrings.html#ac0e454d488b47498f7171acf4980990a" title="Returns the number of strings managed by this instance.">size()</a> values. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">devmem</td><td>Indicates whether results points to device memory or CPU memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of 'true' values. </dd></dl>

</div>
</div>
<a id="a11b45be9b52d01835d510245cf4a0f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b45be9b52d01835d510245cf4a0f10">&#9670;&nbsp;</a></span>to_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVStrings::to_host </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the list of strings into the provided host memory. </p>
<p>Each pointer must point to memory large enough to hold the bytes of each corresponding string. Null strings should be identified using the set_null_bitarray method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>The list of pointers to CPU memory to copy each string into. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>The 0-based index position of the string to copy first. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>The 0-based index position of the string to copy last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a id="ae34e909ac1aa285a8270937a74f9b8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34e909ac1aa285a8270937a74f9b8df">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::translate </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; unsigned, unsigned &gt; *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate characters in each string using the character-mapping table provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>Individual Unicode characters and their replacment counterparts. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>The number of entries in table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with the appropriate characters replace. </dd></dl>

</div>
</div>
<a id="ac3e8c904ff48d0543e3b39fee7eca081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e8c904ff48d0543e3b39fee7eca081">&#9670;&nbsp;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::upper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return new instance modifying lowercase characters to uppercase. </p>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string case modified. </dd></dl>

</div>
</div>
<a id="aae81d5c990a2362a2e2c5f4315c19a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae81d5c990a2362a2e2c5f4315c19a5f">&#9670;&nbsp;</a></span>url_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::url_decode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>URL-decodes each string and returns the new instance. This expects UTF-8 encoding style and does no error checking on the strings. </p>
<dl class="section return"><dt>Returns</dt><dd>New instance of url-encoded strings </dd></dl>

</div>
</div>
<a id="af0245cbaa1eb7ff32e823d537983a125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0245cbaa1eb7ff32e823d537983a125">&#9670;&nbsp;</a></span>url_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::url_encode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>URL-encodes each string and returns the new instance. This uses UTF-8 encoding style and does no error checking on the strings. All letters and digits are not encoded as well as characters '.','_','~','-'. </p>
<dl class="section return"><dt>Returns</dt><dd>New instance of url-encoded strings </dd></dl>

</div>
</div>
<a id="ac7b63041edf7e30cdbe8676c75f38635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b63041edf7e30cdbe8676c75f38635">&#9670;&nbsp;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::wrap </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This inserts new-line characters (ASCII 0x0A) into each string in place of spaces. </p>
<p>Attempts to make each line less than or equal to width characters. If a string or characters is longer than width, the line is split on the next closest space character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The minimum number of characters for a line in each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string added with new-line characters appropriately. </dd></dl>

</div>
</div>
<a id="a7b3c6bba409f5ed42911c9c45fd1a491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3c6bba409f5ed42911c9c45fd1a491">&#9670;&nbsp;</a></span>zfill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNVStrings.html">NVStrings</a>* NVStrings::zfill </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pads strings with leading zeros. </p>
<p>If the string is already width or more characters, no padding is performed. No strings are truncated. Null strings result in null strings. The zeros will be filled after '+' or '-' if found in the first character position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The minimum number of characters for each string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New instance with each string padded appropriately. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="NVStrings_8h_source.html">NVStrings.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
