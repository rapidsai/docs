<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: concurrent_unordered_multimap&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classconcurrent__unordered__multimap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">concurrent_unordered_multimap&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a723373330847c9774e9259fc971fca45"><td class="memItemLeft" align="right" valign="top"><a id="a723373330847c9774e9259fc971fca45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = Hasher</td></tr>
<tr class="separator:a723373330847c9774e9259fc971fca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bc2892a0f1a5e7aec89e8a773c413b"><td class="memItemLeft" align="right" valign="top"><a id="a40bc2892a0f1a5e7aec89e8a773c413b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = Equality</td></tr>
<tr class="separator:a40bc2892a0f1a5e7aec89e8a773c413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af851b424d413f899edf79da7c7837"><td class="memItemLeft" align="right" valign="top"><a id="ae9af851b424d413f899edf79da7c7837"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:ae9af851b424d413f899edf79da7c7837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabc9a28a0c0ac2de884e0efd8c156f1"><td class="memItemLeft" align="right" valign="top"><a id="aaabc9a28a0c0ac2de884e0efd8c156f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="separator:aaabc9a28a0c0ac2de884e0efd8c156f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05647c49f8467267971ce669398d1a5b"><td class="memItemLeft" align="right" valign="top"><a id="a05647c49f8467267971ce669398d1a5b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = thrust::pair&lt; Key, Element &gt;</td></tr>
<tr class="separator:a05647c49f8467267971ce669398d1a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0d2f3190f37fa86e842418ab3110e8"><td class="memItemLeft" align="right" valign="top"><a id="a9e0d2f3190f37fa86e842418ab3110e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = Element</td></tr>
<tr class="separator:a9e0d2f3190f37fa86e842418ab3110e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7aa7349ee626f718f633ed6007e3f81"><td class="memItemLeft" align="right" valign="top"><a id="ac7aa7349ee626f718f633ed6007e3f81"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classcycle__iterator__adapter.html">cycle_iterator_adapter</a>&lt; value_type * &gt;</td></tr>
<tr class="separator:ac7aa7349ee626f718f633ed6007e3f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3168b68163a91a04abd8199cc718f6e"><td class="memItemLeft" align="right" valign="top"><a id="ad3168b68163a91a04abd8199cc718f6e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = const <a class="el" href="classcycle__iterator__adapter.html">cycle_iterator_adapter</a>&lt; value_type * &gt;</td></tr>
<tr class="separator:ad3168b68163a91a04abd8199cc718f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a38a14d35fc3a13549518c691a79e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a2a38a14d35fc3a13549518c691a79e4b">destroy</a> (<a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a2a38a14d35fc3a13549518c691a79e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the contents of the map and destroys the map object.  <a href="classconcurrent__unordered__multimap.html#a2a38a14d35fc3a13549518c691a79e4b">More...</a><br /></td></tr>
<tr class="separator:a2a38a14d35fc3a13549518c691a79e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177b8d37df923061a61db75030d7aeea"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a177b8d37df923061a61db75030d7aeea">begin</a> ()</td></tr>
<tr class="memdesc:a177b8d37df923061a61db75030d7aeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element in the map.  <a href="classconcurrent__unordered__multimap.html#a177b8d37df923061a61db75030d7aeea">More...</a><br /></td></tr>
<tr class="separator:a177b8d37df923061a61db75030d7aeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d5ac9ffbe49eb07b4f963f4845e0db"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a50d5ac9ffbe49eb07b4f963f4845e0db">begin</a> () const</td></tr>
<tr class="memdesc:a50d5ac9ffbe49eb07b4f963f4845e0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element in the map.  <a href="classconcurrent__unordered__multimap.html#a50d5ac9ffbe49eb07b4f963f4845e0db">More...</a><br /></td></tr>
<tr class="separator:a50d5ac9ffbe49eb07b4f963f4845e0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b335134ce4d8d50b487b91b2c466140"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a6b335134ce4d8d50b487b91b2c466140">end</a> ()</td></tr>
<tr class="memdesc:a6b335134ce4d8d50b487b91b2c466140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the one past the last element in the map.  <a href="classconcurrent__unordered__multimap.html#a6b335134ce4d8d50b487b91b2c466140">More...</a><br /></td></tr>
<tr class="separator:a6b335134ce4d8d50b487b91b2c466140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990de374c2c5e857b0caca696062abf3"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a990de374c2c5e857b0caca696062abf3">end</a> () const</td></tr>
<tr class="memdesc:a990de374c2c5e857b0caca696062abf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the one past the last element in the map.  <a href="classconcurrent__unordered__multimap.html#a990de374c2c5e857b0caca696062abf3">More...</a><br /></td></tr>
<tr class="separator:a990de374c2c5e857b0caca696062abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7febd400b3cde90ea74581da354aa6"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type&gt; </td></tr>
<tr class="memitem:a9b7febd400b3cde90ea74581da354aa6"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __host__ __device__ hash_value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a9b7febd400b3cde90ea74581da354aa6">get_hash</a> (const key_type &amp;the_key) const</td></tr>
<tr class="memdesc:a9b7febd400b3cde90ea74581da354aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a hash value for a key.  <a href="classconcurrent__unordered__multimap.html#a9b7febd400b3cde90ea74581da354aa6">More...</a><br /></td></tr>
<tr class="separator:a9b7febd400b3cde90ea74581da354aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392b7f4bfeccc4d9565f15db2a648b8a"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type&gt; </td></tr>
<tr class="memitem:a392b7f4bfeccc4d9565f15db2a648b8a"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __host__ __device__ int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a392b7f4bfeccc4d9565f15db2a648b8a">get_partition</a> (const key_type &amp;the_key, const int num_parts=1, bool precomputed_hash=false, hash_value_type precomputed_hash_value=0) const</td></tr>
<tr class="memdesc:a392b7f4bfeccc4d9565f15db2a648b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the destination hash map partition for a key.  <a href="classconcurrent__unordered__multimap.html#a392b7f4bfeccc4d9565f15db2a648b8a">More...</a><br /></td></tr>
<tr class="separator:a392b7f4bfeccc4d9565f15db2a648b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6851b566c937c2a85c9703e66491d9aa"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </td></tr>
<tr class="memitem:a6851b566c937c2a85c9703e66491d9aa"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a6851b566c937c2a85c9703e66491d9aa">insert</a> (const value_type &amp;x, bool precomputed_hash=false, hash_value_type precomputed_hash_value=0, comparison_type keys_are_equal=key_equal())</td></tr>
<tr class="memdesc:a6851b566c937c2a85c9703e66491d9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a (key, value) pair into the hash map.  <a href="classconcurrent__unordered__multimap.html#a6851b566c937c2a85c9703e66491d9aa">More...</a><br /></td></tr>
<tr class="separator:a6851b566c937c2a85c9703e66491d9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d67762b3f22d37e28c38ca9c29322b9"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </td></tr>
<tr class="memitem:a4d67762b3f22d37e28c38ca9c29322b9"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#a4d67762b3f22d37e28c38ca9c29322b9">insert_part</a> (const value_type &amp;x, const int part=0, const int num_parts=1, bool precomputed_hash=false, hash_value_type precomputed_hash_value=0, comparison_type keys_are_equal=key_equal())</td></tr>
<tr class="memdesc:a4d67762b3f22d37e28c38ca9c29322b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a (key, value) pair into the hash map partition. This is useful when building the hash table in multiple passes, one contiguous partition at a time, or when building the hash table distributed between multiple devices.  <a href="classconcurrent__unordered__multimap.html#a4d67762b3f22d37e28c38ca9c29322b9">More...</a><br /></td></tr>
<tr class="separator:a4d67762b3f22d37e28c38ca9c29322b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83fe57fe7025326ecc6436f6f97e14f"><td class="memTemplParams" colspan="2">template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </td></tr>
<tr class="memitem:ad83fe57fe7025326ecc6436f6f97e14f"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#ad83fe57fe7025326ecc6436f6f97e14f">find</a> (const key_type &amp;the_key, bool precomputed_hash=false, hash_value_type precomputed_hash_value=0, comparison_type keys_are_equal=key_equal()) const</td></tr>
<tr class="memdesc:ad83fe57fe7025326ecc6436f6f97e14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a key in the hash map and returns an iterator to the first instance of the key in the map.  <a href="classconcurrent__unordered__multimap.html#ad83fe57fe7025326ecc6436f6f97e14f">More...</a><br /></td></tr>
<tr class="separator:ad83fe57fe7025326ecc6436f6f97e14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4182ad6b96e6b3fd5587673b4e6a7fe2"><td class="memItemLeft" align="right" valign="top"><a id="a4182ad6b96e6b3fd5587673b4e6a7fe2"></a>
gdf_error&#160;</td><td class="memItemRight" valign="bottom"><b>assign_async</b> (const <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> &amp;other, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="separator:a4182ad6b96e6b3fd5587673b4e6a7fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867ae8326ea2434fca52f10c87057b6"><td class="memItemLeft" align="right" valign="top"><a id="ae867ae8326ea2434fca52f10c87057b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_async</b> (<a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="separator:ae867ae8326ea2434fca52f10c87057b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a8424b76af290bb28fb2375cab2106"><td class="memItemLeft" align="right" valign="top"><a id="af7a8424b76af290bb28fb2375cab2106"></a>
unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_collisions</b> () const</td></tr>
<tr class="separator:af7a8424b76af290bb28fb2375cab2106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e3c3ec1a3be86c13691f3d8a574b61"><td class="memItemLeft" align="right" valign="top"><a id="a90e3c3ec1a3be86c13691f3d8a574b61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> ()</td></tr>
<tr class="separator:a90e3c3ec1a3be86c13691f3d8a574b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f1bb512172f41af6d00aabbee627ed"><td class="memItemLeft" align="right" valign="top"><a id="a40f1bb512172f41af6d00aabbee627ed"></a>
gdf_error&#160;</td><td class="memItemRight" valign="bottom"><b>prefetch</b> (const int dev_id, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="separator:a40f1bb512172f41af6d00aabbee627ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc0038c26e3cceeb19d3f39df298e8b"><td class="memItemLeft" align="right" valign="top"><a id="afbc0038c26e3cceeb19d3f39df298e8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>concurrent_unordered_multimap</b> (<a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> const &amp;)=default</td></tr>
<tr class="separator:afbc0038c26e3cceeb19d3f39df298e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce8125431c2db7d85eac9da8d1928dd"><td class="memItemLeft" align="right" valign="top"><a id="a0ce8125431c2db7d85eac9da8d1928dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>concurrent_unordered_multimap</b> (<a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a0ce8125431c2db7d85eac9da8d1928dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c26371acb7103e16bbc6274935757c2"><td class="memItemLeft" align="right" valign="top"><a id="a4c26371acb7103e16bbc6274935757c2"></a>
<a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> const &amp;)=default</td></tr>
<tr class="separator:a4c26371acb7103e16bbc6274935757c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d084c533276036c6b6dc54e7ce59671"><td class="memItemLeft" align="right" valign="top"><a id="a6d084c533276036c6b6dc54e7ce59671"></a>
<a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6d084c533276036c6b6dc54e7ce59671"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae4deb7961b9abdd51b9044b48db04d1f"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f">create</a> (size_type capacity, const bool init=true, const Hasher &amp;hash_function=hasher(), const Equality &amp;equal=key_equal(), const allocator_type &amp;allocator=allocator_type(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:ae4deb7961b9abdd51b9044b48db04d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to construct a new concurrent unordered multimap.  <a href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f">More...</a><br /></td></tr>
<tr class="separator:ae4deb7961b9abdd51b9044b48db04d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e04af80d4469efb961b7b05103c8297"><td class="memItemLeft" align="right" valign="top"><a id="a0e04af80d4469efb961b7b05103c8297"></a>
static constexpr __forceinline__ __host__ __device__ key_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_unused_key</b> ()</td></tr>
<tr class="separator:a0e04af80d4469efb961b7b05103c8297"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Element, typename size_type, Key unused_key, Element unused_element, typename Hasher = default_hash&lt;Key&gt;, typename Equality = equal_to&lt;Key&gt;, typename Allocator = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt;<br />
class concurrent_unordered_multimap&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;</h3>

<p>Does support concurrent insert, but not concurrent insert and probping.</p>
<dl class="section note"><dt>Note</dt><dd>The user is responsible for the following stream semantics:<ul>
<li>Either the same stream should be used to create the map as is used by the kernels that access it, or</li>
<li>the stream used to create the map should be synchronized before it is accessed from a different stream or from host code.</li>
</ul>
</dd></dl>
<p>TODO:</p><ul>
<li>add constructor that takes pointer to hash_table to avoid allocations </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a177b8d37df923061a61db75030d7aeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177b8d37df923061a61db75030d7aeea">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element in the map. </p>
<dl class="section note"><dt>Note</dt><dd>When using the managed allocator, host code that calls this function should ensure the stream used for <code><a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a></code> is appropriately synchronized.</dd>
<dd>
When called in a device code, user should make sure that it should either be running on the same stream as <a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a>, or the accessing stream should be appropriately synchronized with the creating stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element in the map. </dd></dl>

</div>
</div>
<a id="a50d5ac9ffbe49eb07b4f963f4845e0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d5ac9ffbe49eb07b4f963f4845e0db">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element in the map. </p>
<dl class="section note"><dt>Note</dt><dd>When using the managed allocator, host code that calls this function should ensure the stream used for <code><a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a></code> is appropriately synchronized.</dd>
<dd>
When called in a device code, user should make sure that it should either be running on the same stream as <a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a>, or the accessing stream should be appropriately synchronized with the creating stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>constant iterator to the first element in the map. </dd></dl>

</div>
</div>
<a id="ae4deb7961b9abdd51b9044b48db04d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4deb7961b9abdd51b9044b48db04d1f">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::create </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>init</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hasher &amp;&#160;</td>
          <td class="paramname"><em>hash_function</em> = <code>hasher()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Equality &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>key_equal()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>allocator_type()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory to construct a new concurrent unordered multimap. </p>
<p>------------------------------------------------------------------------&mdash;* Returns a <code>std::unique_ptr</code> to a new concurrent unordered multimap object. The map is non-owning and trivially copyable and should be passed by value into kernels. The <code>unique_ptr</code> contains a custom deleter that will free the map's contents.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of this multimap uses sentinel values to indicate an entry in the hash table that is empty, i.e., if a hash bucket is empty, the pair residing there will be equal to (unused_key, unused_element). As a result, attempting to insert a key equal to <code>unused_key</code> results in undefined behavior.</dd>
<dd>
All allocations, kernels and copies in the constructor take place on stream but the constructor does not synchronize the stream. It is the user's responsibility to synchronize or use the same stream to access the map.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The maximum number of pairs the map may hold. </td></tr>
    <tr><td class="paramname">init</td><td>Indicates if the map should be initialized with the unused key/values </td></tr>
    <tr><td class="paramname">hash_function</td><td>The hash function to use for hashing keys </td></tr>
    <tr><td class="paramname">equal</td><td>The equality comparison function for comparing if two keys are equal </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use for allocation of the map's storage </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md66"></a>
@param stream CUDA stream to use for device operations.</h2>

</div>
</div>
<a id="a2a38a14d35fc3a13549518c691a79e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a38a14d35fc3a13549518c691a79e4b">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the contents of the map and destroys the map object. </p>
<p>------------------------------------------------------------------------&mdash;* This function is invoked as the deleter of the <code>std::unique_ptr</code> returned from the <code><a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a></code> factory function.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
@param stream CUDA stream to use for device operations.</h2>

</div>
</div>
<a id="a6b335134ce4d8d50b487b91b2c466140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b335134ce4d8d50b487b91b2c466140">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the one past the last element in the map. </p>
<dl class="section note"><dt>Note</dt><dd>When using the managed allocator, host code that calls this function should ensure the stream used for <code><a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a></code> is appropriately synchronized.</dd>
<dd>
When called in a device code, user should make sure that it should either be running on the same stream as <a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a>, or the accessing stream should be appropriately synchronized with the creating stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the one past the last element in the map. </dd></dl>

</div>
</div>
<a id="a990de374c2c5e857b0caca696062abf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990de374c2c5e857b0caca696062abf3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the one past the last element in the map. </p>
<dl class="section note"><dt>Note</dt><dd>When using the managed allocator, host code that calls this function should ensure the stream used for <code><a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a></code> is appropriately synchronized.</dd>
<dd>
When called in a device code, user should make sure that it should either be running on the same stream as <a class="el" href="classconcurrent__unordered__multimap.html#ae4deb7961b9abdd51b9044b48db04d1f" title="Factory to construct a new concurrent unordered multimap.">create()</a>, or the accessing stream should be appropriately synchronized with the creating stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>constant iterator to the one past the last element in the map. </dd></dl>

</div>
</div>
<a id="ad83fe57fe7025326ecc6436f6f97e14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83fe57fe7025326ecc6436f6f97e14f">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __host__ __device__ <a class="el" href="classcycle__iterator__adapter.html">const_iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>the_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precomputed_hash</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_value_type&#160;</td>
          <td class="paramname"><em>precomputed_hash_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparison_type&#160;</td>
          <td class="paramname"><em>keys_are_equal</em> = <code>key_equal()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a key in the hash map and returns an iterator to the first instance of the key in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the_key</td><td>The key to search for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash</td><td>A flag indicating whether or not a precomputed hash value is passed in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash_value</td><td>A precomputed hash value to use for determing the write location of the key into the hash map instead of computing the the hash value directly from the key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys_are_equal</td><td>An optional functor for comparing if two keys are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value </td></tr>
    <tr><td class="paramname">comparison_type</td><td>The type of the key comparison functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the key in the map </dd></dl>

</div>
</div>
<a id="a9b7febd400b3cde90ea74581da354aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7febd400b3cde90ea74581da354aa6">&#9670;&nbsp;</a></span>get_hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __host__ __device__ hash_value_type <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::get_hash </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>the_key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a hash value for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the_key</td><td>The key to compute a hash for </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash value for the key </dd></dl>

</div>
</div>
<a id="a392b7f4bfeccc4d9565f15db2a648b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392b7f4bfeccc4d9565f15db2a648b8a">&#9670;&nbsp;</a></span>get_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __host__ __device__ int <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::get_partition </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>the_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_parts</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precomputed_hash</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_value_type&#160;</td>
          <td class="paramname"><em>precomputed_hash_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the destination hash map partition for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the_key</td><td>The key to search for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_parts</td><td>The total number of partitions in the partitioned hash table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash</td><td>A flag indicating whether or not a precomputed hash value is passed in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash_value</td><td>A precomputed hash value to use for determing the write location of the key into the hash map instead of computing the the hash value directly from the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The destination hash table partition for the specified key </dd></dl>

</div>
</div>
<a id="a6851b566c937c2a85c9703e66491d9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6851b566c937c2a85c9703e66491d9aa">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precomputed_hash</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_value_type&#160;</td>
          <td class="paramname"><em>precomputed_hash_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparison_type&#160;</td>
          <td class="paramname"><em>keys_are_equal</em> = <code>key_equal()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a (key, value) pair into the hash map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The (key, value) pair to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash</td><td>A flag indicating whether or not a precomputed hash value is passed in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash_value</td><td>A precomputed hash value to use for determing the write location of the key into the hash map instead of computing the the hash value directly from the key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys_are_equal</td><td>An optional functor for comparing if two keys are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value </td></tr>
    <tr><td class="paramname">comparison_type</td><td>The type of the key comparison functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the newly inserted (key, value) pair </dd></dl>

</div>
</div>
<a id="a4d67762b3f22d37e28c38ca9c29322b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d67762b3f22d37e28c38ca9c29322b9">&#9670;&nbsp;</a></span>insert_part()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Element , typename size_type , Key unused_key, Element unused_element, typename Hasher  = default_hash&lt;Key&gt;, typename Equality  = equal_to&lt;Key&gt;, typename Allocator  = managed_allocator&lt;thrust::pair&lt;Key, Element&gt;&gt;, bool count_collisions = false&gt; </div>
<div class="memtemplate">
template&lt;typename hash_value_type  = typename Hasher::result_type, typename comparison_type  = key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __device__ <a class="el" href="classcycle__iterator__adapter.html">iterator</a> <a class="el" href="classconcurrent__unordered__multimap.html">concurrent_unordered_multimap</a>&lt; Key, Element, size_type, unused_key, unused_element, Hasher, Equality, Allocator, count_collisions &gt;::insert_part </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>part</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_parts</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precomputed_hash</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_value_type&#160;</td>
          <td class="paramname"><em>precomputed_hash_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comparison_type&#160;</td>
          <td class="paramname"><em>keys_are_equal</em> = <code>key_equal()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a (key, value) pair into the hash map partition. This is useful when building the hash table in multiple passes, one contiguous partition at a time, or when building the hash table distributed between multiple devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The (key, value) pair to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">part</td><td>The partition number for the partitioned hash table build </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_parts</td><td>The total number of partitions in the partitioned hash table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash</td><td>A flag indicating whether or not a precomputed hash value is passed in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precomputed_hash_value</td><td>A precomputed hash value to use for determing the write location of the key into the hash map instead of computing the the hash value directly from the key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys_are_equal</td><td>An optional functor for comparing if two keys are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">hash_value_type</td><td>The datatype of the hash value </td></tr>
    <tr><td class="paramname">comparison_type</td><td>The type of the key comparison functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the newly inserted (key, value) pair </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>concurrent_unordered_multimap.cuh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
