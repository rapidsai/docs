<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: cudf::experimental Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecudf.html">cudf</a></li><li class="navelem"><a class="el" href="namespacecudf_1_1experimental.html">experimental</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cudf::experimental Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>In-development features.  
<a href="namespacecudf_1_1experimental.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecudf_1_1experimental_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental_1_1io.html">io</a></td></tr>
<tr class="memdesc:namespacecudf_1_1experimental_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">IO interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for specifying the desired aggregation in an <code>aggregation_request</code>.  <a href="classcudf_1_1experimental_1_1aggregation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1bool8.html">bool8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1contains__scalar__dispatch.html">contains_scalar_dispatch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1contiguous__split__result.html">contiguous_split_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result(s) of a <code>contiguous_split</code>  <a href="structcudf_1_1experimental_1_1contiguous__split__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1element__equality__comparator.html">element_equality_comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an equality comparison between two elements in two columns.  <a href="classcudf_1_1experimental_1_1element__equality__comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1element__hasher.html">element_hasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of an element in the given column.  <a href="classcudf_1_1experimental_1_1element__hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1element__relational__comparator.html">element_relational_comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a relational comparison between two elements in two columns.  <a href="classcudf_1_1experimental_1_1element__relational__comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1id__to__type__impl.html">id_to_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1row__equality__comparator.html">row_equality_comparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1row__hasher.html">row_hasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of a row in the given table.  <a href="classcudf_1_1experimental_1_1row__hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1row__hasher__initial__values.html">row_hasher_initial_values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of a row in the given table, combined with an initial hash value for each column.  <a href="classcudf_1_1experimental_1_1row__hasher__initial__values.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1row__lexicographic__comparator.html">row_lexicographic_comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes whether one row is lexicographically <em>less</em> than another row.  <a href="classcudf_1_1experimental_1_1row__lexicographic__comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1experimental_1_1table.html">table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1type__to__name.html">type_to_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl_3_01cudf_1_1string__view_01_4.html">type_to_scalar_type_impl&lt; cudf::string_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl_3_01std_1_1string_01_4.html">type_to_scalar_type_impl&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a09ff9b3055486ff508a88bf2d891bce8"><td class="memTemplParams" colspan="2">template&lt;cudf::type_id Id&gt; </td></tr>
<tr class="memitem:a09ff9b3055486ff508a88bf2d891bce8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a09ff9b3055486ff508a88bf2d891bce8">id_to_type</a> = typename <a class="el" href="structcudf_1_1experimental_1_1id__to__type__impl.html">id_to_type_impl</a>&lt; Id &gt;::type</td></tr>
<tr class="memdesc:a09ff9b3055486ff508a88bf2d891bce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code> to it's corresponding concrete C++ type.  <a href="namespacecudf_1_1experimental.html#a09ff9b3055486ff508a88bf2d891bce8">More...</a><br /></td></tr>
<tr class="separator:a09ff9b3055486ff508a88bf2d891bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3198f71aa690ddfcd12b70245838c78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3198f71aa690ddfcd12b70245838c78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ab3198f71aa690ddfcd12b70245838c78">scalar_type_t</a> = typename <a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a>&lt; T &gt;::ScalarType</td></tr>
<tr class="memdesc:ab3198f71aa690ddfcd12b70245838c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to the scalar type required to hold its value.  <a href="namespacecudf_1_1experimental.html#ab3198f71aa690ddfcd12b70245838c78">More...</a><br /></td></tr>
<tr class="separator:ab3198f71aa690ddfcd12b70245838c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13b7818063c9611a7cc83bedd435174"><td class="memTemplParams" colspan="2"><a id="ad13b7818063c9611a7cc83bedd435174"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad13b7818063c9611a7cc83bedd435174"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scalar_device_type_t</b> = typename <a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a>&lt; T &gt;::ScalarDeviceType</td></tr>
<tr class="separator:ad13b7818063c9611a7cc83bedd435174"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af3c5acc541194664ced90465dfd164f3"><td class="memItemLeft" align="right" valign="top"><a id="af3c5acc541194664ced90465dfd164f3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>udf_type</b> : bool { <b>CUDA</b>, 
<b>PTX</b>
 }</td></tr>
<tr class="separator:af3c5acc541194664ced90465dfd164f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98fab32c66e913a0096c1a3789c5701"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">binary_operator</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a9eeb52badb613229884838847294b90d">binary_operator::ADD</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a241dd841abade20fcb27b8a9f494e1eb">binary_operator::SUB</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a2cdf52a55876063ec93b7d18bc741f6c">binary_operator::MUL</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a29bbf66f7f8529ec47e394fb5a36c646">binary_operator::DIV</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701aa14fdfc1aa76e925151b566a67c99406">binary_operator::TRUE_DIV</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a77811fd0ec3d3ed2711a923332e8e69f">binary_operator::FLOOR_DIV</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701ac5a28f4b35a2884fa3277150ac5d0967">binary_operator::MOD</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a36aaf571a1008bd43f47509344cd13ad">binary_operator::PYMOD</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a17faf4e999b8cee4c36915c1f54ccffe">binary_operator::POW</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a969f331a87d8c958473c32b4d0e61a44">binary_operator::EQUAL</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a4ea2d378cdec20f59330f113297bc1ce">binary_operator::NOT_EQUAL</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a1798e8c3621ca53d9e3a80d257306000">binary_operator::LESS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701ae7e72355289e404b762d4cf88824d23b">binary_operator::GREATER</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a8b4a5cd69b217bf93b054ada7f49abd4">binary_operator::LESS_EQUAL</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a87e6b203bf40967d37a33f9a4438561a">binary_operator::GREATER_EQUAL</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701aaa5f2eafabf8fa18cbb708c657f37245">binary_operator::BITWISE_AND</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a0d89cfe1f2f7f0c2deb3d35455783ab9">binary_operator::BITWISE_OR</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a6d7cca7c0f0f278c56131a25e77c4a5c">binary_operator::BITWISE_XOR</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701aa770916377f618641eccd6783b13503a">binary_operator::LOGICAL_AND</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a0d0389dd347e259ac16a47fc9db81c18">binary_operator::LOGICAL_OR</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701ab139deebcee4d159eb0f185ee4ae5f6c">binary_operator::COALESCE</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a8949d722159e21bb5941af5b0e92aeb5">binary_operator::GENERIC_BINARY</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701a0b010d84b45dcb367a81c7c029d3f5bb">binary_operator::INVALID_BINARY</a>
<br />
 }</td></tr>
<tr class="memdesc:af98fab32c66e913a0096c1a3789c5701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of binary operations that can be performed on data.  <a href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">More...</a><br /></td></tr>
<tr class="separator:af98fab32c66e913a0096c1a3789c5701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad483c874f6010437111325063b87daef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a> { <a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa443475558f0168dff92ecde26b98ae5a">mask_allocation_policy::NEVER</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefaf3fc827ade4b968e50406496907ef962">mask_allocation_policy::ALWAYS</a>
 }</td></tr>
<tr class="separator:ad483c874f6010437111325063b87daef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44baaeea3ec9df2ee3029e515c713cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cf">scan_op</a> { <a class="el" href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cfa6970bdc2201030b9c03fbdcf3973858a">scan_op::SUM</a> = 0, 
<a class="el" href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cface31e2a082d17e038fcc6e3006166653">scan_op::MIN</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cfa26a4b44a837bf97b972628509912b4a5">scan_op::MAX</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cfa2544e5b1e7659a7ba6f06444cc03d066">scan_op::PRODUCT</a>
 }</td></tr>
<tr class="memdesc:af44baaeea3ec9df2ee3029e515c713cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">These enums indicate the supported operations of prefix scan that can be performed on a column.  <a href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cf">More...</a><br /></td></tr>
<tr class="separator:af44baaeea3ec9df2ee3029e515c713cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f314cd95af9fb330bfdfb735e42fb8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8">reduction_op</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8a6970bdc2201030b9c03fbdcf3973858a">reduction_op::SUM</a> = 0, 
<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8ace31e2a082d17e038fcc6e3006166653">reduction_op::MIN</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8a26a4b44a837bf97b972628509912b4a5">reduction_op::MAX</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8a2544e5b1e7659a7ba6f06444cc03d066">reduction_op::PRODUCT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8a82481d5e97d96d9cc385f34a4eb1555b">reduction_op::SUMOFSQUARES</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8a4ea6d1161ea24d7599365f574aff6610">reduction_op::MEAN</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8ad6f4440b8633f973d33c78928bdac2e1">reduction_op::VAR</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8ac6ce23be5d350ce18a665427d2d950f7">reduction_op::STD</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8a8e1bde3c3d303163521522cf1d62f21f">reduction_op::ANY</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8a5fb1f955b45e38e31789286a1790398d">reduction_op::ALL</a>
<br />
 }</td></tr>
<tr class="memdesc:ad7f314cd95af9fb330bfdfb735e42fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">These enums indicate the supported reduction operations that can be performed on a column.  <a href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8">More...</a><br /></td></tr>
<tr class="separator:ad7f314cd95af9fb330bfdfb735e42fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b073c676d07d514a051888b2b753cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">duplicate_keep_option</a> { <a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cda5968b12bf2e72e702a998c7fa6c83b1e">duplicate_keep_option::KEEP_FIRST</a> = 0, 
<a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cda4583fc151efe5098dd96eeec8cf74699">duplicate_keep_option::KEEP_LAST</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cda40c4abe57c2fda3e580eee916b9e0558">duplicate_keep_option::KEEP_NONE</a>
 }</td></tr>
<tr class="memdesc:a43b073c676d07d514a051888b2b753cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choices for drop_duplicates API for retainment of duplicate rows.  <a href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">More...</a><br /></td></tr>
<tr class="separator:a43b073c676d07d514a051888b2b753cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a49aef820830d7830862408645b8c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">weak_ordering</a> { <a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7a1798e8c3621ca53d9e3a80d257306000">weak_ordering::LESS</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7acd1908d025919ff975513ff143c3e34c">weak_ordering::EQUIVALENT</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7ae7e72355289e404b762d4cf88824d23b">weak_ordering::GREATER</a>
 }</td></tr>
<tr class="memdesc:a57a49aef820830d7830862408645b8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type of the <code>element_relational_comparator</code> function object.  <a href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">More...</a><br /></td></tr>
<tr class="separator:a57a49aef820830d7830862408645b8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4f0e0f1bfa906673bf5c2a2b13b151"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">interpolation</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aaac544aacc3615aada24897a215f5046">interpolation::LINEAR</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aa7c48ba367e019d004bfb0239b85f2b3">interpolation::LOWER</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151a5bc0a7ce2c77ccd49169277e9289e5d1">interpolation::HIGHER</a>, 
<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aafa8fd4b90a3f8123b4bd30446518a7e">interpolation::MIDPOINT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aad135772d7cf93dd0ccf9d2474b34e6a">interpolation::NEAREST</a>
<br />
 }</td></tr>
<tr class="memdesc:a5f4f0e0f1bfa906673bf5c2a2b13b151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolation method to use when the desired quantile lies between two data points i and j.  <a href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">More...</a><br /></td></tr>
<tr class="separator:a5f4f0e0f1bfa906673bf5c2a2b13b151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cecb2a8c2faaf3ef84cd9046881237"><td class="memItemLeft" align="right" valign="top"><a id="af7cecb2a8c2faaf3ef84cd9046881237"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>unary_op</b> { <br />
&#160;&#160;<b>SIN</b>, 
<b>COS</b>, 
<b>TAN</b>, 
<b>ARCSIN</b>, 
<br />
&#160;&#160;<b>ARCCOS</b>, 
<b>ARCTAN</b>, 
<b>EXP</b>, 
<b>LOG</b>, 
<br />
&#160;&#160;<b>SQRT</b>, 
<b>CEIL</b>, 
<b>FLOOR</b>, 
<b>ABS</b>, 
<br />
&#160;&#160;<b>BIT_INVERT</b>, 
<b>NOT</b>
<br />
 }</td></tr>
<tr class="separator:af7cecb2a8c2faaf3ef84cd9046881237"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a765b473355d4b4668b73cd7583d7d2d0"><td class="memItemLeft" align="right" valign="top"><a id="a765b473355d4b4668b73cd7583d7d2d0"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a765b473355d4b4668b73cd7583d7d2d0">make_sum_aggregation</a> ()</td></tr>
<tr class="memdesc:a765b473355d4b4668b73cd7583d7d2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a SUM aggregation. <br /></td></tr>
<tr class="separator:a765b473355d4b4668b73cd7583d7d2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e27dcd8a7e8b115a5b20d83cfa30e2"><td class="memItemLeft" align="right" valign="top"><a id="ac5e27dcd8a7e8b115a5b20d83cfa30e2"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ac5e27dcd8a7e8b115a5b20d83cfa30e2">make_min_aggregation</a> ()</td></tr>
<tr class="memdesc:ac5e27dcd8a7e8b115a5b20d83cfa30e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MIN aggregation. <br /></td></tr>
<tr class="separator:ac5e27dcd8a7e8b115a5b20d83cfa30e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc2befe60625f484eb0e7493e91776c"><td class="memItemLeft" align="right" valign="top"><a id="a9fc2befe60625f484eb0e7493e91776c"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9fc2befe60625f484eb0e7493e91776c">make_max_aggregation</a> ()</td></tr>
<tr class="memdesc:a9fc2befe60625f484eb0e7493e91776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MAX aggregation. <br /></td></tr>
<tr class="separator:a9fc2befe60625f484eb0e7493e91776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1e3cd40fdf74ae3fde3ae60b63b95c"><td class="memItemLeft" align="right" valign="top"><a id="abc1e3cd40fdf74ae3fde3ae60b63b95c"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#abc1e3cd40fdf74ae3fde3ae60b63b95c">make_count_aggregation</a> ()</td></tr>
<tr class="memdesc:abc1e3cd40fdf74ae3fde3ae60b63b95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a COUNT aggregation. <br /></td></tr>
<tr class="separator:abc1e3cd40fdf74ae3fde3ae60b63b95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba9d5acd317b74a27bd53e4eb300e3"><td class="memItemLeft" align="right" valign="top"><a id="a65ba9d5acd317b74a27bd53e4eb300e3"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a65ba9d5acd317b74a27bd53e4eb300e3">make_mean_aggregation</a> ()</td></tr>
<tr class="memdesc:a65ba9d5acd317b74a27bd53e4eb300e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MEAN aggregation. <br /></td></tr>
<tr class="separator:a65ba9d5acd317b74a27bd53e4eb300e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6378a7fb9a679f0eff3ac828d23d7aa4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a6378a7fb9a679f0eff3ac828d23d7aa4">make_variance_aggregation</a> (size_type ddof)</td></tr>
<tr class="memdesc:a6378a7fb9a679f0eff3ac828d23d7aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a VARIANCE aggregation.  <a href="namespacecudf_1_1experimental.html#a6378a7fb9a679f0eff3ac828d23d7aa4">More...</a><br /></td></tr>
<tr class="separator:a6378a7fb9a679f0eff3ac828d23d7aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f85485889732efb9510c2d2811bd08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aa0f85485889732efb9510c2d2811bd08">make_std_aggregation</a> (size_type ddof)</td></tr>
<tr class="memdesc:aa0f85485889732efb9510c2d2811bd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a STD aggregation.  <a href="namespacecudf_1_1experimental.html#aa0f85485889732efb9510c2d2811bd08">More...</a><br /></td></tr>
<tr class="separator:aa0f85485889732efb9510c2d2811bd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91939f7355190ba94e08ceb3fd802041"><td class="memItemLeft" align="right" valign="top"><a id="a91939f7355190ba94e08ceb3fd802041"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a91939f7355190ba94e08ceb3fd802041">make_median_aggregation</a> ()</td></tr>
<tr class="memdesc:a91939f7355190ba94e08ceb3fd802041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MEDIAN aggregation. <br /></td></tr>
<tr class="separator:a91939f7355190ba94e08ceb3fd802041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf5751f91dd4da5c76b0b54fc2dc9ee"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#afdf5751f91dd4da5c76b0b54fc2dc9ee">make_quantile_aggregation</a> (std::vector&lt; double &gt; const &amp;q, <a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">interpolation</a> i)</td></tr>
<tr class="memdesc:afdf5751f91dd4da5c76b0b54fc2dc9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a QUANTILE aggregation.  <a href="namespacecudf_1_1experimental.html#afdf5751f91dd4da5c76b0b54fc2dc9ee">More...</a><br /></td></tr>
<tr class="separator:afdf5751f91dd4da5c76b0b54fc2dc9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7994a4f7c22fb477a6f51ba5d2ffd0c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a7994a4f7c22fb477a6f51ba5d2ffd0c1">make_argmax_aggregation</a> ()</td></tr>
<tr class="memdesc:a7994a4f7c22fb477a6f51ba5d2ffd0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a ARGMAX aggregation.  <a href="namespacecudf_1_1experimental.html#a7994a4f7c22fb477a6f51ba5d2ffd0c1">More...</a><br /></td></tr>
<tr class="separator:a7994a4f7c22fb477a6f51ba5d2ffd0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87231ab8430ae7b296c3a0110096b26"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#af87231ab8430ae7b296c3a0110096b26">make_argmin_aggregation</a> ()</td></tr>
<tr class="memdesc:af87231ab8430ae7b296c3a0110096b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a ARGMIN aggregation.  <a href="namespacecudf_1_1experimental.html#af87231ab8430ae7b296c3a0110096b26">More...</a><br /></td></tr>
<tr class="separator:af87231ab8430ae7b296c3a0110096b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b177a3721692f887f0ec3386bc6ace"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a03b177a3721692f887f0ec3386bc6ace">make_udf_aggregation</a> (udf_type type, std::string const &amp;user_defined_aggregator, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type)</td></tr>
<tr class="memdesc:a03b177a3721692f887f0ec3386bc6ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a UDF aggregation.  <a href="namespacecudf_1_1experimental.html#a03b177a3721692f887f0ec3386bc6ace">More...</a><br /></td></tr>
<tr class="separator:a03b177a3721692f887f0ec3386bc6ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba197a98bdf5dec040d4bd275ad0450"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a5ba197a98bdf5dec040d4bd275ad0450">binary_operation</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;rhs, <a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a5ba197a98bdf5dec040d4bd275ad0450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a scalar and a column.  <a href="namespacecudf_1_1experimental.html#a5ba197a98bdf5dec040d4bd275ad0450">More...</a><br /></td></tr>
<tr class="separator:a5ba197a98bdf5dec040d4bd275ad0450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431c506497318aad70e2f4442bdb9e4e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a431c506497318aad70e2f4442bdb9e4e">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;rhs, <a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a431c506497318aad70e2f4442bdb9e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a column and a scalar.  <a href="namespacecudf_1_1experimental.html#a431c506497318aad70e2f4442bdb9e4e">More...</a><br /></td></tr>
<tr class="separator:a431c506497318aad70e2f4442bdb9e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f801601e66a4f87d2e5bb36d14d6ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aa7f801601e66a4f87d2e5bb36d14d6ae">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;rhs, <a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:aa7f801601e66a4f87d2e5bb36d14d6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two columns.  <a href="namespacecudf_1_1experimental.html#aa7f801601e66a4f87d2e5bb36d14d6ae">More...</a><br /></td></tr>
<tr class="separator:aa7f801601e66a4f87d2e5bb36d14d6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dcc219332f9b308133acedaf7ad301"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a92dcc219332f9b308133acedaf7ad301">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;rhs, std::string const  &amp;ptx, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a92dcc219332f9b308133acedaf7ad301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two columns using a user-defined PTX function.  <a href="namespacecudf_1_1experimental.html#a92dcc219332f9b308133acedaf7ad301">More...</a><br /></td></tr>
<tr class="separator:a92dcc219332f9b308133acedaf7ad301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5865ad6c683aa22832c7d74f36a52c1b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcudf_1_1experimental_1_1contiguous__split__result.html">contiguous_split_result</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a5865ad6c683aa22832c7d74f36a52c1b">contiguous_split</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const  &amp;input, std::vector&lt; size_type &gt; const  &amp;splits, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a5865ad6c683aa22832c7d74f36a52c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep-copy split of a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code>s into a single contiguous block of memory.  <a href="namespacecudf_1_1experimental.html#a5865ad6c683aa22832c7d74f36a52c1b">More...</a><br /></td></tr>
<tr class="separator:a5865ad6c683aa22832c7d74f36a52c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6f5965e67b78f9068bfbaab1f26db6"><td class="memItemLeft" align="right" valign="top"><a id="a7d6f5965e67b78f9068bfbaab1f26db6"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>empty_like</b> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="separator:a7d6f5965e67b78f9068bfbaab1f26db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadf20c2bcd430f728769d1bcd050ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9fadf20c2bcd430f728769d1bcd050ec">empty_like</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input_table)</td></tr>
<tr class="memdesc:a9fadf20c2bcd430f728769d1bcd050ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of empty columns with the same types as the <code>input_table</code>  <a href="namespacecudf_1_1experimental.html#a9fadf20c2bcd430f728769d1bcd050ec">More...</a><br /></td></tr>
<tr class="separator:a9fadf20c2bcd430f728769d1bcd050ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ce6302e4458066d832420207ea7a02"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a20ce6302e4458066d832420207ea7a02">allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a20ce6302e4458066d832420207ea7a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the same size and type as the <code>input</code>. Supports only fixed-width types.  <a href="namespacecudf_1_1experimental.html#a20ce6302e4458066d832420207ea7a02">More...</a><br /></td></tr>
<tr class="separator:a20ce6302e4458066d832420207ea7a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721801079c0de1398a1e089a39995ce8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a721801079c0de1398a1e089a39995ce8">allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, size_type size, <a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a721801079c0de1398a1e089a39995ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the specified size and same type as the <code>input</code>. Supports only fixed-width types.  <a href="namespacecudf_1_1experimental.html#a721801079c0de1398a1e089a39995ce8">More...</a><br /></td></tr>
<tr class="separator:a721801079c0de1398a1e089a39995ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11643d0378285cf1d7b17826fbb35bb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad11643d0378285cf1d7b17826fbb35bb">copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ad11643d0378285cf1d7b17826fbb35bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="namespacecudf_1_1experimental.html#ad11643d0378285cf1d7b17826fbb35bb">More...</a><br /></td></tr>
<tr class="separator:ad11643d0378285cf1d7b17826fbb35bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659eb118490384c27a3cf9802a56197e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a659eb118490384c27a3cf9802a56197e">copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a659eb118490384c27a3cf9802a56197e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="namespacecudf_1_1experimental.html#a659eb118490384c27a3cf9802a56197e">More...</a><br /></td></tr>
<tr class="separator:a659eb118490384c27a3cf9802a56197e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317d50ca96c4e8842947e991c19eccf9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a317d50ca96c4e8842947e991c19eccf9">copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a317d50ca96c4e8842947e991c19eccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="namespacecudf_1_1experimental.html#a317d50ca96c4e8842947e991c19eccf9">More...</a><br /></td></tr>
<tr class="separator:a317d50ca96c4e8842947e991c19eccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603125f72d0498da871083aa1495db7c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a603125f72d0498da871083aa1495db7c">copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a603125f72d0498da871083aa1495db7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>.  <a href="namespacecudf_1_1experimental.html#a603125f72d0498da871083aa1495db7c">More...</a><br /></td></tr>
<tr class="separator:a603125f72d0498da871083aa1495db7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649c525d788647c5d6bf3b6b4cedb87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ac649c525d788647c5d6bf3b6b4cedb87">copy_range</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;source, <a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;target, size_type source_begin, size_type source_end, size_type target_begin)</td></tr>
<tr class="memdesc:ac649c525d788647c5d6bf3b6b4cedb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements in-place from one column to another.  <a href="namespacecudf_1_1experimental.html#ac649c525d788647c5d6bf3b6b4cedb87">More...</a><br /></td></tr>
<tr class="separator:ac649c525d788647c5d6bf3b6b4cedb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b5739505c21058c97d6f29c996c16f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a77b5739505c21058c97d6f29c996c16f">copy_range</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;target, size_type source_begin, size_type source_end, size_type target_begin, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a77b5739505c21058c97d6f29c996c16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements out-of-place from one column to another.  <a href="namespacecudf_1_1experimental.html#a77b5739505c21058c97d6f29c996c16f">More...</a><br /></td></tr>
<tr class="separator:a77b5739505c21058c97d6f29c996c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edcfa60adcae62ead9197feeaf87ba0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1edcfa60adcae62ead9197feeaf87ba0">gather</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;source_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;gather_map, bool check_bounds=false, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a1edcfa60adcae62ead9197feeaf87ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows (including null values) of a set of columns.  <a href="namespacecudf_1_1experimental.html#a1edcfa60adcae62ead9197feeaf87ba0">More...</a><br /></td></tr>
<tr class="separator:a1edcfa60adcae62ead9197feeaf87ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e9825f07db3744b175c518c687b537"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a66e9825f07db3744b175c518c687b537">scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;scatter_map, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;target, bool check_bounds=false, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a66e9825f07db3744b175c518c687b537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of the source table into a copy of the target table according to a scatter map.  <a href="namespacecudf_1_1experimental.html#a66e9825f07db3744b175c518c687b537">More...</a><br /></td></tr>
<tr class="separator:a66e9825f07db3744b175c518c687b537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c7d359043b804ba7b6b0c38606c8d9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a71c7d359043b804ba7b6b0c38606c8d9">scatter</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&gt; const  &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;indices, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;target, bool check_bounds=false, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a71c7d359043b804ba7b6b0c38606c8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters a row of scalar values into a copy of the target table according to a scatter map.  <a href="namespacecudf_1_1experimental.html#a71c7d359043b804ba7b6b0c38606c8d9">More...</a><br /></td></tr>
<tr class="separator:a71c7d359043b804ba7b6b0c38606c8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab89c9919455c060e0ab7b435d772a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1ab89c9919455c060e0ab7b435d772a1">scatter_to_tables</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;partition_map, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a1ab89c9919455c060e0ab7b435d772a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of a table to <code>n</code> tables according to a partition map.  <a href="namespacecudf_1_1experimental.html#a1ab89c9919455c060e0ab7b435d772a1">More...</a><br /></td></tr>
<tr class="separator:a1ab89c9919455c060e0ab7b435d772a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdcbe43fbe08248f14d1db5411b1336"><td class="memItemLeft" align="right" valign="top"><a id="a5bdcbe43fbe08248f14d1db5411b1336"></a>
std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slice</b> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, std::vector&lt; size_type &gt; const &amp;indices)</td></tr>
<tr class="separator:a5bdcbe43fbe08248f14d1db5411b1336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f9436d374e5c3eddff079acdad94e4"><td class="memItemLeft" align="right" valign="top"><a id="ab1f9436d374e5c3eddff079acdad94e4"></a>
std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slice</b> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, std::vector&lt; size_type &gt; const &amp;indices)</td></tr>
<tr class="separator:ab1f9436d374e5c3eddff079acdad94e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08f61e372c72069f45fcd2bcf9936e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aa08f61e372c72069f45fcd2bcf9936e8">split</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, std::vector&lt; size_type &gt; const  &amp;splits)</td></tr>
<tr class="memdesc:aa08f61e372c72069f45fcd2bcf9936e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits.  <a href="namespacecudf_1_1experimental.html#aa08f61e372c72069f45fcd2bcf9936e8">More...</a><br /></td></tr>
<tr class="separator:aa08f61e372c72069f45fcd2bcf9936e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4bd1cfd9b40f54975494511a78a15e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a8f4bd1cfd9b40f54975494511a78a15e">split</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, std::vector&lt; size_type &gt; const  &amp;splits)</td></tr>
<tr class="memdesc:a8f4bd1cfd9b40f54975494511a78a15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code>s according to a set of indices derived from expected splits.  <a href="namespacecudf_1_1experimental.html#a8f4bd1cfd9b40f54975494511a78a15e">More...</a><br /></td></tr>
<tr class="separator:a8f4bd1cfd9b40f54975494511a78a15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcc600a269f9142df29f43dd61d6521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#abdcc600a269f9142df29f43dd61d6521">fill</a> (<a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;destination, size_type begin, size_type end, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;value)</td></tr>
<tr class="memdesc:abdcc600a269f9142df29f43dd61d6521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in-place in a column with a scalar value.  <a href="namespacecudf_1_1experimental.html#abdcc600a269f9142df29f43dd61d6521">More...</a><br /></td></tr>
<tr class="separator:abdcc600a269f9142df29f43dd61d6521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae713ac30fdf8c5f5b37f9f4612180f8b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ae713ac30fdf8c5f5b37f9f4612180f8b">fill</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, size_type begin, size_type end, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;value, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ae713ac30fdf8c5f5b37f9f4612180f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in a column out-of-place with a scalar value.  <a href="namespacecudf_1_1experimental.html#ae713ac30fdf8c5f5b37f9f4612180f8b">More...</a><br /></td></tr>
<tr class="separator:ae713ac30fdf8c5f5b37f9f4612180f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821183b38dc84793cf9ccc43abd3c86a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a821183b38dc84793cf9ccc43abd3c86a">repeat</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;count, bool check_count=false, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a821183b38dc84793cf9ccc43abd3c86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <a href="namespacecudf_1_1experimental.html#a821183b38dc84793cf9ccc43abd3c86a">More...</a><br /></td></tr>
<tr class="separator:a821183b38dc84793cf9ccc43abd3c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536b3d7781bb64ae0d9b8a64a0328be7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a536b3d7781bb64ae0d9b8a64a0328be7">repeat</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input_table, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;count, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a536b3d7781bb64ae0d9b8a64a0328be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <a href="namespacecudf_1_1experimental.html#a536b3d7781bb64ae0d9b8a64a0328be7">More...</a><br /></td></tr>
<tr class="separator:a536b3d7781bb64ae0d9b8a64a0328be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aad7d94e652c0cb345eb5cee0853eb"><td class="memItemLeft" align="right" valign="top"><a id="ae1aad7d94e652c0cb345eb5cee0853eb"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inner_join</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, std::vector&lt; size_type &gt; const &amp;left_on, std::vector&lt; size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; size_type, size_type &gt;&gt; const &amp;columns_in_common, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ae1aad7d94e652c0cb345eb5cee0853eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6f094ee534fb8b46674f0057b6e18f"><td class="memItemLeft" align="right" valign="top"><a id="a6e6f094ee534fb8b46674f0057b6e18f"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>left_join</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, std::vector&lt; size_type &gt; const &amp;left_on, std::vector&lt; size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; size_type, size_type &gt;&gt; const &amp;columns_in_common, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:a6e6f094ee534fb8b46674f0057b6e18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae64dd1a198aeff2328a40522ccdd48"><td class="memItemLeft" align="right" valign="top"><a id="a0ae64dd1a198aeff2328a40522ccdd48"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>full_join</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, std::vector&lt; size_type &gt; const &amp;left_on, std::vector&lt; size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; size_type, size_type &gt;&gt; const &amp;columns_in_common, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:a0ae64dd1a198aeff2328a40522ccdd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab855733b702c76043089abff7e90b928"><td class="memItemLeft" align="right" valign="top"><a id="ab855733b702c76043089abff7e90b928"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>left_semi_join</b> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; cudf::size_type &gt; const &amp;return_columns, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ab855733b702c76043089abff7e90b928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9873a477654fb22b02f6f6b35bb47e0b"><td class="memItemLeft" align="right" valign="top"><a id="a9873a477654fb22b02f6f6b35bb47e0b"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>left_anti_join</b> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; cudf::size_type &gt; const &amp;return_columns, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:a9873a477654fb22b02f6f6b35bb47e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d54d902dca3ba2fda445aa97c3fd76"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a99d54d902dca3ba2fda445aa97c3fd76">merge</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;left_table, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;right_table, std::vector&lt; cudf::size_type &gt; const  &amp;key_cols, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">cudf::order</a> &gt; const  &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> &gt; const  &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a99d54d902dca3ba2fda445aa97c3fd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted tables.  <a href="namespacecudf_1_1experimental.html#a99d54d902dca3ba2fda445aa97c3fd76">More...</a><br /></td></tr>
<tr class="separator:a99d54d902dca3ba2fda445aa97c3fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06984655da544208dcc2c58d44b91f9"><td class="memItemLeft" align="right" valign="top"><a id="ae06984655da544208dcc2c58d44b91f9"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>quantiles</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, double percent, <a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">interpolation</a> interp, std::vector&lt; <a class="el" href="structcudf_1_1order__info.html">order_info</a> &gt; column_order)</td></tr>
<tr class="separator:ae06984655da544208dcc2c58d44b91f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f25817755c09f6285bd9ea355cd9aa3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a3f25817755c09f6285bd9ea355cd9aa3">reduce</a> (const <a class="el" href="classcudf_1_1column__view.html">column_view</a> &amp;col, <a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8">reduction_op</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_dtype, cudf::size_type ddof=1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a3f25817755c09f6285bd9ea355cd9aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the reduction of the values in all rows of a column. This function does not detect overflows in reductions. Using a higher precision <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (timestamp, string...). The null values are skipped for the operation. If the column is empty, the member <code><a class="el" href="namespacecudf_1_1experimental.html#aeb3f89042ed2eb6a4a38a86919f526bc" title="Creates a column of BOOL8 elements where for every element in input true indicates the value is valid...">is_valid()</a></code> of the output scalar will contain <code>false</code>.  <a href="namespacecudf_1_1experimental.html#a3f25817755c09f6285bd9ea355cd9aa3">More...</a><br /></td></tr>
<tr class="separator:a3f25817755c09f6285bd9ea355cd9aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab402cbc5ae2de3e024abf2231d185e3e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ab402cbc5ae2de3e024abf2231d185e3e">scan</a> (const <a class="el" href="classcudf_1_1column__view.html">column_view</a> &amp;input, <a class="el" href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cf">scan_op</a> op, bool inclusive, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ab402cbc5ae2de3e024abf2231d185e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scan of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null.  <a href="namespacecudf_1_1experimental.html#ab402cbc5ae2de3e024abf2231d185e3e">More...</a><br /></td></tr>
<tr class="separator:ab402cbc5ae2de3e024abf2231d185e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59b75670715814a0280eafbf434129a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ab59b75670715814a0280eafbf434129a">clamp</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;lo, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;lo_replace, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;hi, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;hi_replace, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ab59b75670715814a0280eafbf434129a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces values less than <code>lo</code> in <code>input</code> with <code>lo_replace</code>, and values greater than <code>hi</code> with <code>hi_replace</code>.  <a href="namespacecudf_1_1experimental.html#ab59b75670715814a0280eafbf434129a">More...</a><br /></td></tr>
<tr class="separator:ab59b75670715814a0280eafbf434129a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8030184f1f28bc0bdced49f28f18cbcf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a8030184f1f28bc0bdced49f28f18cbcf">clamp</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;lo, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;hi, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a8030184f1f28bc0bdced49f28f18cbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces values less than <code>lo</code> in <code>input</code> with <code>lo</code>, and values greater than <code>hi</code> with <code>hi</code>.  <a href="namespacecudf_1_1experimental.html#a8030184f1f28bc0bdced49f28f18cbcf">More...</a><br /></td></tr>
<tr class="separator:a8030184f1f28bc0bdced49f28f18cbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785dc5fa5540c9b0e6329847216ac89b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a785dc5fa5540c9b0e6329847216ac89b">find_and_replace_all</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input_col, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;values_to_replace, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;replacement_values, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a785dc5fa5540c9b0e6329847216ac89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements from <code>input_col</code> according to the mapping <code>old_values</code> to.  <a href="namespacecudf_1_1experimental.html#a785dc5fa5540c9b0e6329847216ac89b">More...</a><br /></td></tr>
<tr class="separator:a785dc5fa5540c9b0e6329847216ac89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d7d63257ec8b61f4b5c5662dea8e5f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad2d7d63257ec8b61f4b5c5662dea8e5f">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;replacement, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ad2d7d63257ec8b61f4b5c5662dea8e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with corresponding values of another column.  <a href="namespacecudf_1_1experimental.html#ad2d7d63257ec8b61f4b5c5662dea8e5f">More...</a><br /></td></tr>
<tr class="separator:ad2d7d63257ec8b61f4b5c5662dea8e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4485649fdaa0a76de6b7fd2a90a5ffd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ac4485649fdaa0a76de6b7fd2a90a5ffd">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const  &amp;replacement, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ac4485649fdaa0a76de6b7fd2a90a5ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with a scalar.  <a href="namespacecudf_1_1experimental.html#ac4485649fdaa0a76de6b7fd2a90a5ffd">More...</a><br /></td></tr>
<tr class="separator:ac4485649fdaa0a76de6b7fd2a90a5ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4408bbab28c58c51404f2495fbff725d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a4408bbab28c58c51404f2495fbff725d">interleave_columns</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a4408bbab28c58c51404f2495fbff725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave columns of a table into a single column.  <a href="namespacecudf_1_1experimental.html#a4408bbab28c58c51404f2495fbff725d">More...</a><br /></td></tr>
<tr class="separator:a4408bbab28c58c51404f2495fbff725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e327e6aab2d670f7060ecf8f4dac9b3"><td class="memItemLeft" align="right" valign="top"><a id="a9e327e6aab2d670f7060ecf8f4dac9b3"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tile</b> (const <a class="el" href="classcudf_1_1table__view.html">table_view</a> &amp;in, size_type count, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:a9e327e6aab2d670f7060ecf8f4dac9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad634be1518c6ecc479ac1fe0dbda3a2a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad634be1518c6ecc479ac1fe0dbda3a2a">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, size_type preceding_window, size_type following_window, size_type min_periods, std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; const  &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ad634be1518c6ecc479ac1fe0dbda3a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.  <a href="namespacecudf_1_1experimental.html#ad634be1518c6ecc479ac1fe0dbda3a2a">More...</a><br /></td></tr>
<tr class="separator:ad634be1518c6ecc479ac1fe0dbda3a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae049fae22f3b0dc38c49cff63b00206c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ae049fae22f3b0dc38c49cff63b00206c">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;preceding_window, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;following_window, size_type min_periods, std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; const  &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ae049fae22f3b0dc38c49cff63b00206c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a variable-size rolling window function to the values in a column.  <a href="namespacecudf_1_1experimental.html#ae049fae22f3b0dc38c49cff63b00206c">More...</a><br /></td></tr>
<tr class="separator:ae049fae22f3b0dc38c49cff63b00206c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bca240b20effd38193266111604657"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;, std::vector&lt; cudf::size_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a12bca240b20effd38193266111604657">round_robin_partition</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, cudf::size_type num_partitions, cudf::size_type start_partition=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a12bca240b20effd38193266111604657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-robin partition.  <a href="namespacecudf_1_1experimental.html#a12bca240b20effd38193266111604657">More...</a><br /></td></tr>
<tr class="separator:a12bca240b20effd38193266111604657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94df7d69bec2f6205bbdb6ebeddc69e"><td class="memItemLeft" align="right" valign="top"><a id="aa94df7d69bec2f6205bbdb6ebeddc69e"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>search_ordered</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;t, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, bool find_first, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence, rmm::mr::device_memory_resource *mr, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="separator:aa94df7d69bec2f6205bbdb6ebeddc69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da07e36844255fd5bc535c5718a155a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9da07e36844255fd5bc535c5718a155a">lower_bound</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;t, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;values, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a9da07e36844255fd5bc535c5718a155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find smallest indices in a sorted table where values should be inserted to maintain order.  <a href="namespacecudf_1_1experimental.html#a9da07e36844255fd5bc535c5718a155a">More...</a><br /></td></tr>
<tr class="separator:a9da07e36844255fd5bc535c5718a155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3dfeef33f906f5d41725ca9abbd96"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a49f3dfeef33f906f5d41725ca9abbd96">upper_bound</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;t, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;values, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a49f3dfeef33f906f5d41725ca9abbd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find largest indices in a sorted table where values should be inserted to maintain order.  <a href="namespacecudf_1_1experimental.html#a49f3dfeef33f906f5d41725ca9abbd96">More...</a><br /></td></tr>
<tr class="separator:a49f3dfeef33f906f5d41725ca9abbd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebe78ecc15d10b4a5e3645d87624a28"><td class="memItemLeft" align="right" valign="top"><a id="aeebe78ecc15d10b4a5e3645d87624a28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;col, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;value, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:aeebe78ecc15d10b4a5e3645d87624a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a556203babe80f559453f18b5e4fd4"><td class="memItemLeft" align="right" valign="top"><a id="ae1a556203babe80f559453f18b5e4fd4"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;needles, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ae1a556203babe80f559453f18b5e4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac969ee758bff8ff7c0df765f5bd10bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aac969ee758bff8ff7c0df765f5bd10bd">is_sorted</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const  &amp;<a class="el" href="classcudf_1_1experimental_1_1table.html">table</a>, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence)</td></tr>
<tr class="memdesc:aac969ee758bff8ff7c0df765f5bd10bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the rows of a <code>table</code> are sorted in a lexicographical order.  <a href="namespacecudf_1_1experimental.html#aac969ee758bff8ff7c0df765f5bd10bd">More...</a><br /></td></tr>
<tr class="separator:aac969ee758bff8ff7c0df765f5bd10bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b484f1dcc0f825e04929974481811ee"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a0b484f1dcc0f825e04929974481811ee">sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> input, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order={}, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a0b484f1dcc0f825e04929974481811ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the row indices that would produce <code>input</code> in a lexicographical sorted order.  <a href="namespacecudf_1_1experimental.html#a0b484f1dcc0f825e04929974481811ee">More...</a><br /></td></tr>
<tr class="separator:a0b484f1dcc0f825e04929974481811ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa524c9b8616c57e3079161fa33f405c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aa524c9b8616c57e3079161fa33f405c7">sort</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> input, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order={}, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:aa524c9b8616c57e3079161fa33f405c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lexicographic sort of the rows of a table.  <a href="namespacecudf_1_1experimental.html#aa524c9b8616c57e3079161fa33f405c7">More...</a><br /></td></tr>
<tr class="separator:aa524c9b8616c57e3079161fa33f405c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f329aec79c6699e308ff9916e5a2f50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a6f329aec79c6699e308ff9916e5a2f50">sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;keys, std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const  &amp;column_order={}, std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const  &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a6f329aec79c6699e308ff9916e5a2f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a key-value sort.  <a href="namespacecudf_1_1experimental.html#a6f329aec79c6699e308ff9916e5a2f50">More...</a><br /></td></tr>
<tr class="separator:a6f329aec79c6699e308ff9916e5a2f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefad034a999eb89006a326e42d1d6060"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aefad034a999eb89006a326e42d1d6060">apply_boolean_mask</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:aefad034a999eb89006a326e42d1d6060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters <code>input</code> using <code>boolean_mask</code> of boolean values as a mask.  <a href="namespacecudf_1_1experimental.html#aefad034a999eb89006a326e42d1d6060">More...</a><br /></td></tr>
<tr class="separator:aefad034a999eb89006a326e42d1d6060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051cdf96b8c340add8fe1416909d06e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a051cdf96b8c340add8fe1416909d06e7">drop_duplicates</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, std::vector&lt; size_type &gt; const  &amp;keys, <a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">duplicate_keep_option</a> const  &amp;keep, bool const  &amp;nulls_are_equal=true, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a051cdf96b8c340add8fe1416909d06e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table without duplicate rows.  <a href="namespacecudf_1_1experimental.html#a051cdf96b8c340add8fe1416909d06e7">More...</a><br /></td></tr>
<tr class="separator:a051cdf96b8c340add8fe1416909d06e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dceec176e91e0f709beaf6d93dbf07"><td class="memItemLeft" align="right" valign="top">cudf::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a49dceec176e91e0f709beaf6d93dbf07">unique_count</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, bool const  &amp;ignore_nulls, bool const  &amp;nan_as_null, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a49dceec176e91e0f709beaf6d93dbf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the unique elements in the <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>.  <a href="namespacecudf_1_1experimental.html#a49dceec176e91e0f709beaf6d93dbf07">More...</a><br /></td></tr>
<tr class="separator:a49dceec176e91e0f709beaf6d93dbf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac629d1af51251653c77f5da2d35551ac"><td class="memItemLeft" align="right" valign="top"><a id="ac629d1af51251653c77f5da2d35551ac"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>drop_nulls</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; size_type &gt; const &amp;keys, cudf::size_type keep_threshold, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ac629d1af51251653c77f5da2d35551ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7934432d5ebe72540d3362dd4e5dea3"><td class="memItemLeft" align="right" valign="top"><a id="ae7934432d5ebe72540d3362dd4e5dea3"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>drop_nulls</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; size_type &gt; const &amp;keys, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:ae7934432d5ebe72540d3362dd4e5dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b56089ab0490194a96cdfd249a72181"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1b56089ab0490194a96cdfd249a72181">concatenate</a> (std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; const  &amp;tables_to_concat, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a1b56089ab0490194a96cdfd249a72181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Columns of <code>tables_to_concat</code> are concatenated vertically to return a single <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a>.  <a href="namespacecudf_1_1experimental.html#a1b56089ab0490194a96cdfd249a72181">More...</a><br /></td></tr>
<tr class="separator:a1b56089ab0490194a96cdfd249a72181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf23e8ea75238ff81d762d0d1e336a4c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, cudf::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#acf23e8ea75238ff81d762d0d1e336a4c">bools_to_mask</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:acf23e8ea75238ff81d762d0d1e336a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bitmask from a column of boolean elements.  <a href="namespacecudf_1_1experimental.html#acf23e8ea75238ff81d762d0d1e336a4c">More...</a><br /></td></tr>
<tr class="separator:acf23e8ea75238ff81d762d0d1e336a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2509a63c1180c2438c1feda1788e9539"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, cudf::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a2509a63c1180c2438c1feda1788e9539">nans_to_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a2509a63c1180c2438c1feda1788e9539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a null_mask from <code>input</code> by converting <code>NaN</code> to null and preserving existing null values and also returns new null_count.  <a href="namespacecudf_1_1experimental.html#a2509a63c1180c2438c1feda1788e9539">More...</a><br /></td></tr>
<tr class="separator:a2509a63c1180c2438c1feda1788e9539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf88ec3542f2af93dfd48fbd38976c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9cf88ec3542f2af93dfd48fbd38976c1">transform</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, std::string const  &amp;unary_udf, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, bool is_ptx, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a9cf88ec3542f2af93dfd48fbd38976c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by applying a unary function against every element of an input column.  <a href="namespacecudf_1_1experimental.html#a9cf88ec3542f2af93dfd48fbd38976c1">More...</a><br /></td></tr>
<tr class="separator:a9cf88ec3542f2af93dfd48fbd38976c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fc07ab285374a3c0227870f10a86ce"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad3fc07ab285374a3c0227870f10a86ce">cast</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, <a class="el" href="classcudf_1_1data__type.html">data_type</a> out_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ad3fc07ab285374a3c0227870f10a86ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts data from dtype specified in input to dtype specified in output. Supports only fixed-width types.  <a href="namespacecudf_1_1experimental.html#ad3fc07ab285374a3c0227870f10a86ce">More...</a><br /></td></tr>
<tr class="separator:ad3fc07ab285374a3c0227870f10a86ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6145e96e588da5d0795b16b723d561"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#acc6145e96e588da5d0795b16b723d561">unary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const  &amp;input, cudf::experimental::unary_op op, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:acc6145e96e588da5d0795b16b723d561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unary op on all values in column.  <a href="namespacecudf_1_1experimental.html#acc6145e96e588da5d0795b16b723d561">More...</a><br /></td></tr>
<tr class="separator:acc6145e96e588da5d0795b16b723d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee88668e664b238e3f6375c610539f8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aeee88668e664b238e3f6375c610539f8">is_nan</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:aeee88668e664b238e3f6375c610539f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code>BOOL8</code> elements indicating the presence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>true</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>false</code>  <a href="namespacecudf_1_1experimental.html#aeee88668e664b238e3f6375c610539f8">More...</a><br /></td></tr>
<tr class="separator:aeee88668e664b238e3f6375c610539f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4004d81e75a4398cc0742efa36e3ff04"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a4004d81e75a4398cc0742efa36e3ff04">is_not_nan</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a4004d81e75a4398cc0742efa36e3ff04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code>BOOL8</code> elements indicating the absence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>false</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>true</code>  <a href="namespacecudf_1_1experimental.html#a4004d81e75a4398cc0742efa36e3ff04">More...</a><br /></td></tr>
<tr class="separator:a4004d81e75a4398cc0742efa36e3ff04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8216839cc624ea3a69aa60943ccbde"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a7e8216839cc624ea3a69aa60943ccbde">is_null</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a7e8216839cc624ea3a69aa60943ccbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code>BOOL8</code> elements where for every element in <code>input</code> <code>true</code> indicates the value is null and <code>false</code> indicates the value is valid.  <a href="namespacecudf_1_1experimental.html#a7e8216839cc624ea3a69aa60943ccbde">More...</a><br /></td></tr>
<tr class="separator:a7e8216839cc624ea3a69aa60943ccbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3f89042ed2eb6a4a38a86919f526bc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#aeb3f89042ed2eb6a4a38a86919f526bc">is_valid</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:aeb3f89042ed2eb6a4a38a86919f526bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code>BOOL8</code> elements where for every element in <code>input</code> <code>true</code> indicates the value is valid and <code>false</code> indicates the value is null.  <a href="namespacecudf_1_1experimental.html#aeb3f89042ed2eb6a4a38a86919f526bc">More...</a><br /></td></tr>
<tr class="separator:aeb3f89042ed2eb6a4a38a86919f526bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbdfd07872de79548a1dc446fe151a"><td class="memItemLeft" align="right" valign="top"><a id="a79fbdfd07872de79548a1dc446fe151a"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inner_join</b> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;columns_in_common, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="separator:a79fbdfd07872de79548a1dc446fe151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7028cd34bdd8978d6dd23a47727263a0"><td class="memItemLeft" align="right" valign="top"><a id="a7028cd34bdd8978d6dd23a47727263a0"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>left_join</b> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;columns_in_common, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="separator:a7028cd34bdd8978d6dd23a47727263a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa785791b7ddcba280964ccf4a0d35f83"><td class="memItemLeft" align="right" valign="top"><a id="aa785791b7ddcba280964ccf4a0d35f83"></a>
std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>full_join</b> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;columns_in_common, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="separator:aa785791b7ddcba280964ccf4a0d35f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9616e7fc22050601796328dfa9b4bb8c"><td class="memTemplParams" colspan="2">template&lt;typename Element , std::enable_if_t&lt; std::is_floating_point&lt; Element &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9616e7fc22050601796328dfa9b4bb8c"><td class="memTemplItemLeft" align="right" valign="top">__device__ <a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">weak_ordering</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a9616e7fc22050601796328dfa9b4bb8c">relational_compare</a> (Element lhs, Element rhs)</td></tr>
<tr class="memdesc:a9616e7fc22050601796328dfa9b4bb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization for floating-point <code>Element</code> type rerlational comparison to derive the order of the elements with respect to <code>lhs</code>. Specialization is to handle <code>nan</code> in the order shown below. <code>[-Inf, -ve, 0, -0, +ve, +Inf, NaN, NaN, null] (for <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb" title="NULL values ordered after all other values.">null_order::AFTER</a>)</code> <code>[null, -Inf, -ve, 0, -0, +ve, +Inf, NaN, NaN] (for <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a>)</code>  <a href="namespacecudf_1_1experimental.html#a9616e7fc22050601796328dfa9b4bb8c">More...</a><br /></td></tr>
<tr class="separator:a9616e7fc22050601796328dfa9b4bb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4b9e142e2a1fd804dc76d76b260473"><td class="memTemplParams" colspan="2">template&lt;typename Element , std::enable_if_t&lt; std::is_floating_point&lt; Element &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1b4b9e142e2a1fd804dc76d76b260473"><td class="memTemplItemLeft" align="right" valign="top">__device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a1b4b9e142e2a1fd804dc76d76b260473">equality_compare</a> (Element lhs, Element rhs)</td></tr>
<tr class="memdesc:a1b4b9e142e2a1fd804dc76d76b260473"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization for floating-point <code>Element</code> type to check if <code>lhs</code> is equivalent to <code>rhs</code>. <code>nan == nan</code>.  <a href="namespacecudf_1_1experimental.html#a1b4b9e142e2a1fd804dc76d76b260473">More...</a><br /></td></tr>
<tr class="separator:a1b4b9e142e2a1fd804dc76d76b260473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5b8575cc88f64e4462769d31a1f6b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b5b8575cc88f64e4462769d31a1f6b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">type_id</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a2b5b8575cc88f64e4462769d31a1f6b1">type_to_id</a> ()</td></tr>
<tr class="memdesc:a2b5b8575cc88f64e4462769d31a1f6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to it's corresponding <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code>  <a href="namespacecudf_1_1experimental.html#a2b5b8575cc88f64e4462769d31a1f6b1">More...</a><br /></td></tr>
<tr class="separator:a2b5b8575cc88f64e4462769d31a1f6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f3553fd1261d377365d94c676fff9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#ad9f3553fd1261d377365d94c676fff9d">CUDF_TYPE_MAPPING</a> (<a class="el" href="structcudf_1_1experimental_1_1bool8.html">cudf::experimental::bool8</a>, type_id::BOOL8)</td></tr>
<tr class="memdesc:ad9f3553fd1261d377365d94c676fff9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all of the mappings between C++ types and their corresponding.  <a href="namespacecudf_1_1experimental.html#ad9f3553fd1261d377365d94c676fff9d">More...</a><br /></td></tr>
<tr class="separator:ad9f3553fd1261d377365d94c676fff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff6e0b5db7196157adfb5faa011f1b7"><td class="memItemLeft" align="right" valign="top"><a id="a3ff6e0b5db7196157adfb5faa011f1b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (int8_t, type_id::INT8)</td></tr>
<tr class="separator:a3ff6e0b5db7196157adfb5faa011f1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489fd1f060cf737cb26e4744026733c8"><td class="memItemLeft" align="right" valign="top"><a id="a489fd1f060cf737cb26e4744026733c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (int16_t, type_id::INT16)</td></tr>
<tr class="separator:a489fd1f060cf737cb26e4744026733c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5785ebd158419d354bf667df484f362"><td class="memItemLeft" align="right" valign="top"><a id="ad5785ebd158419d354bf667df484f362"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (int32_t, type_id::INT32)</td></tr>
<tr class="separator:ad5785ebd158419d354bf667df484f362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e0b25771c047dc39840f34595809ce"><td class="memItemLeft" align="right" valign="top"><a id="a46e0b25771c047dc39840f34595809ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (int64_t, type_id::INT64)</td></tr>
<tr class="separator:a46e0b25771c047dc39840f34595809ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949aeffd308db900470760e1fc033639"><td class="memItemLeft" align="right" valign="top"><a id="a949aeffd308db900470760e1fc033639"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (float, type_id::FLOAT32)</td></tr>
<tr class="separator:a949aeffd308db900470760e1fc033639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81660d9cad03d5b63b4e337e4de787f0"><td class="memItemLeft" align="right" valign="top"><a id="a81660d9cad03d5b63b4e337e4de787f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (double, type_id::FLOAT64)</td></tr>
<tr class="separator:a81660d9cad03d5b63b4e337e4de787f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad993a174da1d622843a28a8eb1b12c1a"><td class="memItemLeft" align="right" valign="top"><a id="ad993a174da1d622843a28a8eb1b12c1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="classcudf_1_1string__view.html">cudf::string_view</a>, type_id::STRING)</td></tr>
<tr class="separator:ad993a174da1d622843a28a8eb1b12c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa949a06fbc268a62eb62a1e0bc3555aa"><td class="memItemLeft" align="right" valign="top"><a id="aa949a06fbc268a62eb62a1e0bc3555aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a177c346e93407722169284f15d260687">cudf::timestamp_D</a>, type_id::TIMESTAMP_DAYS)</td></tr>
<tr class="separator:aa949a06fbc268a62eb62a1e0bc3555aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317c7b11f68118e1b8654eb5988066ba"><td class="memItemLeft" align="right" valign="top"><a id="a317c7b11f68118e1b8654eb5988066ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a3eb94ae284a4ec44c14765633fd6f0de">cudf::timestamp_s</a>, type_id::TIMESTAMP_SECONDS)</td></tr>
<tr class="separator:a317c7b11f68118e1b8654eb5988066ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4307e4ebf12b22b8032a1458f6528c"><td class="memItemLeft" align="right" valign="top"><a id="a3a4307e4ebf12b22b8032a1458f6528c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a1e65b98c47669295653e4fe59b66fe34">cudf::timestamp_ms</a>, type_id::TIMESTAMP_MILLISECONDS)</td></tr>
<tr class="separator:a3a4307e4ebf12b22b8032a1458f6528c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754a2c4642a97611591868e5349907c"><td class="memItemLeft" align="right" valign="top"><a id="ab754a2c4642a97611591868e5349907c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a0455750f053fbc9234bd7f1478a8b8a2">cudf::timestamp_us</a>, type_id::TIMESTAMP_MICROSECONDS)</td></tr>
<tr class="separator:ab754a2c4642a97611591868e5349907c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c2d574e277c0af5a61e2f2dbf9244b"><td class="memItemLeft" align="right" valign="top"><a id="a37c2d574e277c0af5a61e2f2dbf9244b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CUDF_TYPE_MAPPING</b> (<a class="el" href="namespacecudf.html#a8090bb1d4eb05e199337b8e98fcdddbf">cudf::timestamp_ns</a>, type_id::TIMESTAMP_NANOSECONDS)</td></tr>
<tr class="separator:a37c2d574e277c0af5a61e2f2dbf9244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b272ff7f81fde5d649dd75fd72144c"><td class="memTemplParams" colspan="2">template&lt;template&lt; cudf::type_id &gt; typename IdTypeMap = id_to_type_impl, typename Functor , typename... Ts&gt; </td></tr>
<tr class="memitem:a06b272ff7f81fde5d649dd75fd72144c"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto) CUDA_HOST_DEVICE_CALLABLE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html#a06b272ff7f81fde5d649dd75fd72144c">type_dispatcher</a> (<a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a> dtype, Functor f, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a06b272ff7f81fde5d649dd75fd72144c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes an <code>operator()</code> template with the type instantiation based on the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code>'s <code>id()</code>.  <a href="namespacecudf_1_1experimental.html#a06b272ff7f81fde5d649dd75fd72144c">More...</a><br /></td></tr>
<tr class="separator:a06b272ff7f81fde5d649dd75fd72144c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>In-development features. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a09ff9b3055486ff508a88bf2d891bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ff9b3055486ff508a88bf2d891bce8">&#9670;&nbsp;</a></span>id_to_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cudf::type_id Id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1experimental.html#a09ff9b3055486ff508a88bf2d891bce8">cudf::experimental::id_to_type</a> = typedef typename <a class="el" href="structcudf_1_1experimental_1_1id__to__type__impl.html">id_to_type_impl</a>&lt;Id&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code> to it's corresponding concrete C++ type. </p>
<p>------------------------------------------------------------------------&mdash;* Example: </p><div class="fragment"><div class="line">static_assert(std::is_same&lt;int32_t, id_to_type&lt;INT32&gt;);</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md561"></a>
@tparam t The &lt;tt&gt;cudf::type_id&lt;/tt&gt; to map</h2>

</div>
</div>
<a id="ab3198f71aa690ddfcd12b70245838c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3198f71aa690ddfcd12b70245838c78">&#9670;&nbsp;</a></span>scalar_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1experimental.html#ab3198f71aa690ddfcd12b70245838c78">cudf::experimental::scalar_type_t</a> = typedef typename <a class="el" href="structcudf_1_1experimental_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a>&lt;T&gt;::ScalarType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a C++ type to the scalar type required to hold its value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The concrete C++ type to map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af98fab32c66e913a0096c1a3789c5701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98fab32c66e913a0096c1a3789c5701">&#9670;&nbsp;</a></span>binary_operator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">cudf::experimental::binary_operator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of binary operations that can be performed on data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a9eeb52badb613229884838847294b90d"></a>ADD&#160;</td><td class="fielddoc"><p>operator + </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a241dd841abade20fcb27b8a9f494e1eb"></a>SUB&#160;</td><td class="fielddoc"><p>operator - </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a2cdf52a55876063ec93b7d18bc741f6c"></a>MUL&#160;</td><td class="fielddoc"><p>operator * </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a29bbf66f7f8529ec47e394fb5a36c646"></a>DIV&#160;</td><td class="fielddoc"><p>operator / using common type of lhs and rhs </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701aa14fdfc1aa76e925151b566a67c99406"></a>TRUE_DIV&#160;</td><td class="fielddoc"><p>operator / after promoting type to floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a77811fd0ec3d3ed2711a923332e8e69f"></a>FLOOR_DIV&#160;</td><td class="fielddoc"><p>operator / after promoting to 64 bit floating point and then flooring the result </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701ac5a28f4b35a2884fa3277150ac5d0967"></a>MOD&#160;</td><td class="fielddoc"><p>operator % </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a36aaf571a1008bd43f47509344cd13ad"></a>PYMOD&#160;</td><td class="fielddoc"><p>operator % but following python's sign rules for negatives </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a17faf4e999b8cee4c36915c1f54ccffe"></a>POW&#160;</td><td class="fielddoc"><p>lhs ^ rhs </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a969f331a87d8c958473c32b4d0e61a44"></a>EQUAL&#160;</td><td class="fielddoc"><p>operator == </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a4ea2d378cdec20f59330f113297bc1ce"></a>NOT_EQUAL&#160;</td><td class="fielddoc"><p>operator != </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a1798e8c3621ca53d9e3a80d257306000"></a>LESS&#160;</td><td class="fielddoc"><p>operator &lt; </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701ae7e72355289e404b762d4cf88824d23b"></a>GREATER&#160;</td><td class="fielddoc"><p>operator &gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a8b4a5cd69b217bf93b054ada7f49abd4"></a>LESS_EQUAL&#160;</td><td class="fielddoc"><p>operator &lt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a87e6b203bf40967d37a33f9a4438561a"></a>GREATER_EQUAL&#160;</td><td class="fielddoc"><p>operator &gt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701aaa5f2eafabf8fa18cbb708c657f37245"></a>BITWISE_AND&#160;</td><td class="fielddoc"><p>operator &amp; </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a0d89cfe1f2f7f0c2deb3d35455783ab9"></a>BITWISE_OR&#160;</td><td class="fielddoc"><p>operator | </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a6d7cca7c0f0f278c56131a25e77c4a5c"></a>BITWISE_XOR&#160;</td><td class="fielddoc"><p>operator ^ </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701aa770916377f618641eccd6783b13503a"></a>LOGICAL_AND&#160;</td><td class="fielddoc"><p>operator &amp;&amp; </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a0d0389dd347e259ac16a47fc9db81c18"></a>LOGICAL_OR&#160;</td><td class="fielddoc"><p>operator || </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701ab139deebcee4d159eb0f185ee4ae5f6c"></a>COALESCE&#160;</td><td class="fielddoc"><p>operator x,y x is null ? y : x </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a8949d722159e21bb5941af5b0e92aeb5"></a>GENERIC_BINARY&#160;</td><td class="fielddoc"><p>generic binary operator to be generated with input ptx code </p>
</td></tr>
<tr><td class="fieldname"><a id="af98fab32c66e913a0096c1a3789c5701a0b010d84b45dcb367a81c7c029d3f5bb"></a>INVALID_BINARY&#160;</td><td class="fielddoc"><p>invalid operation </p>
</td></tr>
</table>

</div>
</div>
<a id="a43b073c676d07d514a051888b2b753cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b073c676d07d514a051888b2b753cd">&#9670;&nbsp;</a></span>duplicate_keep_option</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">cudf::experimental::duplicate_keep_option</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choices for drop_duplicates API for retainment of duplicate rows. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43b073c676d07d514a051888b2b753cda5968b12bf2e72e702a998c7fa6c83b1e"></a>KEEP_FIRST&#160;</td><td class="fielddoc"><p>Keeps first duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b073c676d07d514a051888b2b753cda4583fc151efe5098dd96eeec8cf74699"></a>KEEP_LAST&#160;</td><td class="fielddoc"><p>Keeps last duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43b073c676d07d514a051888b2b753cda40c4abe57c2fda3e580eee916b9e0558"></a>KEEP_NONE&#160;</td><td class="fielddoc"><p>Keeps only unique rows are kept. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5f4f0e0f1bfa906673bf5c2a2b13b151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4f0e0f1bfa906673bf5c2a2b13b151">&#9670;&nbsp;</a></span>interpolation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">cudf::experimental::interpolation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolation method to use when the desired quantile lies between two data points i and j. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151aaac544aacc3615aada24897a215f5046"></a>LINEAR&#160;</td><td class="fielddoc"><p>Linear interpolation between i and j. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151aa7c48ba367e019d004bfb0239b85f2b3"></a>LOWER&#160;</td><td class="fielddoc"><p>Lower data point (i) </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151a5bc0a7ce2c77ccd49169277e9289e5d1"></a>HIGHER&#160;</td><td class="fielddoc"><p>Higher data point (j) </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151aafa8fd4b90a3f8123b4bd30446518a7e"></a>MIDPOINT&#160;</td><td class="fielddoc"><p>(i + j)/2 </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f4f0e0f1bfa906673bf5c2a2b13b151aad135772d7cf93dd0ccf9d2474b34e6a"></a>NEAREST&#160;</td><td class="fielddoc"><p>i or j, whichever is nearest </p>
</td></tr>
</table>

</div>
</div>
<a id="ad483c874f6010437111325063b87daef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad483c874f6010437111325063b87daef">&#9670;&nbsp;</a></span>mask_allocation_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">cudf::experimental::mask_allocation_policy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md287"></a>
@brief Indicates when to allocate a mask, based on an existing mask.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad483c874f6010437111325063b87daefa443475558f0168dff92ecde26b98ae5a"></a>NEVER&#160;</td><td class="fielddoc"><p>Do not allocate a null mask, regardless of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4"></a>RETAIN&#160;</td><td class="fielddoc"><p>Allocate a null mask if the input contains one. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad483c874f6010437111325063b87daefaf3fc827ade4b968e50406496907ef962"></a>ALWAYS&#160;</td><td class="fielddoc"><p>Allocate a null mask, regardless of input. </p>
</td></tr>
</table>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a3">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad7f314cd95af9fb330bfdfb735e42fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f314cd95af9fb330bfdfb735e42fb8">&#9670;&nbsp;</a></span>reduction_op</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8">cudf::experimental::reduction_op</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These enums indicate the supported reduction operations that can be performed on a column. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8a6970bdc2201030b9c03fbdcf3973858a"></a>SUM&#160;</td><td class="fielddoc"><p>Computes the sum of all values in the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8ace31e2a082d17e038fcc6e3006166653"></a>MIN&#160;</td><td class="fielddoc"><p>Computes the minimum of all values in the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8a26a4b44a837bf97b972628509912b4a5"></a>MAX&#160;</td><td class="fielddoc"><p>Computes the maximum of all values in the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8a2544e5b1e7659a7ba6f06444cc03d066"></a>PRODUCT&#160;</td><td class="fielddoc"><p>Computes the multiplicative product of all values in the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8a82481d5e97d96d9cc385f34a4eb1555b"></a>SUMOFSQUARES&#160;</td><td class="fielddoc"><p>Computes the sum of squares of the values in the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8a4ea6d1161ea24d7599365f574aff6610"></a>MEAN&#160;</td><td class="fielddoc"><p>Computes the arithmetic mean of the values in the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8ad6f4440b8633f973d33c78928bdac2e1"></a>VAR&#160;</td><td class="fielddoc"><p>Computes the variance of the values in the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8ac6ce23be5d350ce18a665427d2d950f7"></a>STD&#160;</td><td class="fielddoc"><p>Computes the standard deviation of the values in the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8a8e1bde3c3d303163521522cf1d62f21f"></a>ANY&#160;</td><td class="fielddoc"><p>Computes to true if any of the values are non-zero/true. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7f314cd95af9fb330bfdfb735e42fb8a5fb1f955b45e38e31789286a1790398d"></a>ALL&#160;</td><td class="fielddoc"><p>Computes to true if all of the values are non-zero/true. </p>
</td></tr>
</table>

</div>
</div>
<a id="af44baaeea3ec9df2ee3029e515c713cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44baaeea3ec9df2ee3029e515c713cf">&#9670;&nbsp;</a></span>scan_op</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cf">cudf::experimental::scan_op</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These enums indicate the supported operations of prefix scan that can be performed on a column. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af44baaeea3ec9df2ee3029e515c713cfa6970bdc2201030b9c03fbdcf3973858a"></a>SUM&#160;</td><td class="fielddoc"><p>Computes the prefix scan of sum operation of all values for the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="af44baaeea3ec9df2ee3029e515c713cface31e2a082d17e038fcc6e3006166653"></a>MIN&#160;</td><td class="fielddoc"><p>Computes the prefix scan of maximum operation of all values for the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="af44baaeea3ec9df2ee3029e515c713cfa26a4b44a837bf97b972628509912b4a5"></a>MAX&#160;</td><td class="fielddoc"><p>Computes the prefix scan of maximum operation of all values for the column. </p>
</td></tr>
<tr><td class="fieldname"><a id="af44baaeea3ec9df2ee3029e515c713cfa2544e5b1e7659a7ba6f06444cc03d066"></a>PRODUCT&#160;</td><td class="fielddoc"><p>Computes the prefix scan of multiplicative product operation of all values for the column. </p>
</td></tr>
</table>

</div>
</div>
<a id="a57a49aef820830d7830862408645b8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a49aef820830d7830862408645b8c7">&#9670;&nbsp;</a></span>weak_ordering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">cudf::experimental::weak_ordering</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Result type of the <code><a class="el" href="classcudf_1_1experimental_1_1element__relational__comparator.html" title="Performs a relational comparison between two elements in two columns.">element_relational_comparator</a></code> function object. </p>
<p>------------------------------------------------------------------------&mdash;* Indicates how two elements <code>a</code> and <code>b</code> compare with one and another.</p>
<p>Equivalence is defined as <code>not (a&lt;b) and not (b&lt;a)</code>. Elements that are EQUIVALENT may not necessarily be <em>equal</em>.</p>
<hr  />
 <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a57a49aef820830d7830862408645b8c7a1798e8c3621ca53d9e3a80d257306000"></a>LESS&#160;</td><td class="fielddoc"><p>Indicates <code>a</code> is less than (ordered before) <code>b</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a57a49aef820830d7830862408645b8c7acd1908d025919ff975513ff143c3e34c"></a>EQUIVALENT&#160;</td><td class="fielddoc"><p>Indicates <code>a</code> is ordered neither before nor after <code>b</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a57a49aef820830d7830862408645b8c7ae7e72355289e404b762d4cf88824d23b"></a>GREATER&#160;</td><td class="fielddoc"><p>Indicates <code>a</code> is greater than (ordered after) <code>b</code> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a20ce6302e4458066d832420207ea7a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ce6302e4458066d832420207ea7a02">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the same size and type as the <code>input</code>. Supports only fixed-width types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A column with sufficient uninitialized capacity to hold the same number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a7">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a721801079c0de1398a1e089a39995ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721801079c0de1398a1e089a39995ce8">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daef">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf_1_1experimental.html#ad483c874f6010437111325063b87daefa47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the specified size and same type as the <code>input</code>. Supports only fixed-width types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The desired number of elements that the new column should have capacity for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A column with sufficient uninitialized capacity to hold the specified number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>

</div>
</div>
<a id="aefad034a999eb89006a326e42d1d6060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefad034a999eb89006a326e42d1d6060">&#9670;&nbsp;</a></span>apply_boolean_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt; cudf::experimental::apply_boolean_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters <code>input</code> using <code>boolean_mask</code> of boolean values as a mask. </p>
<p>Given an input <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code> and a mask <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>, an element <code>i</code> from each <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> of the <code>input</code> is copied to the corresponding output column if the corresponding element <code>i</code> in the mask is non-null and <code>true</code>. This operation is stable: the input order is preserved.</p>
<dl class="section note"><dt>Note</dt><dd>if <code>input.num_rows()</code> is zero, there is no error, and an empty table is returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if The <code>input</code> size and <code>boolean_mask</code> size mismatches. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>boolean_mask</code> is not <code>BOOL8</code> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a> to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>A nullable <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> of type BOOL8 used as a mask to filter the <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr<table class="doxtable">
</table>
containing copy of all rows of <code>input</code> passing the filter defined by <code>boolean_mask</code>. </dd></dl>

</div>
</div>
<a id="aa7f801601e66a4f87d2e5bb36d14d6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f801601e66a4f87d2e5bb36d14d6ae">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">binary_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two columns. </p>
<p>The output contains the result of op(lhs[i], rhs[i]) for all 0 &lt;= i &lt; lhs.size()</p>
<p>Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand column </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand column </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired data type of the output column </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource for allocating output column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; Output column </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> are different sizes </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> dtypes aren't fixed-width </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't numeric </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92dcc219332f9b308133acedaf7ad301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92dcc219332f9b308133acedaf7ad301">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>ptx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two columns using a user-defined PTX function. </p>
<p>The output contains the result of op(lhs[i], rhs[i]) for all 0 &lt;= i &lt; lhs.size()</p>
<p>Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand column </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand column </td></tr>
    <tr><td class="paramname">ptx</td><td>String containing the PTX of a binary function </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired data type of the output column. It is assumed that output_type is compatible with the output data type of the function in the PTX code </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource for allocating output column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; Output column </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> are different sizes </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> dtypes aren't numeric </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't numeric </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a431c506497318aad70e2f4442bdb9e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431c506497318aad70e2f4442bdb9e4e">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">binary_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a column and a scalar. </p>
<p>The output contains the result of op(lhs[i], rhs) for all 0 &lt;= i &lt; lhs.size() The column elements are the left operand and the scalar is the right operand. This distinction is significant in case of non-commutative binary operations</p>
<p>Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand column </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand scalar </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired data type of the output column </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource for allocating output column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; Output column </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> dtypes aren't numeric </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't numeric </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ba197a98bdf5dec040d4bd275ad0450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba197a98bdf5dec040d4bd275ad0450">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#af98fab32c66e913a0096c1a3789c5701">binary_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a scalar and a column. </p>
<p>The output contains the result of op(lhs, rhs[i]) for all 0 &lt;= i &lt; rhs.size() The scalar is the left operand and the column elements are the right operand. This distinction is significant in case of non-commutative binary operations</p>
<p>Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand scalar </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand column </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired data type of the output column </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource for allocating output column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; Output column </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> dtypes aren't numeric </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't numeric </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf23e8ea75238ff81d762d0d1e336a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf23e8ea75238ff81d762d0d1e336a4c">&#9670;&nbsp;</a></span>bools_to_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, cudf::size_type &gt; cudf::experimental::bools_to_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a bitmask from a column of boolean elements. </p>
<p>If element <code>i</code> in <code>input</code> is <code>true</code>, bit <code>i</code> in the resulting mask is set (<code>1</code>). Else, if element <code>i</code> is <code>false</code> or null, bit <code>i</code> is unset (<code>0</code>).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>input.type()</code> is a non-boolean type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Boolean elements to convert to a bitmask. </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource used to allocate the returned bitmask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing a <code>device_buffer</code> with the new bitmask and it's null count obtained from input considering <code>true</code> represent <code>valid</code>/<code>1</code> and <code>false</code> represent <code>invalid</code>/<code>0</code>. </dd></dl>

</div>
</div>
<a id="ad3fc07ab285374a3c0227870f10a86ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fc07ab285374a3c0227870f10a86ce">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>out_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts data from dtype specified in input to dtype specified in output. Supports only fixed-width types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></td><td>Input column </td></tr>
    <tr><td class="paramname">out_type</td><td>Desired datatype of output column </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;column&gt; Result of the cast operation </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>out_type</code> is not a fixed-width type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8030184f1f28bc0bdced49f28f18cbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8030184f1f28bc0bdced49f28f18cbcf">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces values less than <code>lo</code> in <code>input</code> with <code>lo</code>, and values greater than <code>hi</code> with <code>hi</code>. </p>
<p>if <code>lo</code> is invalid, then lo will not be considered while evaluating the input (Essentially considered minimum value of that type). if <code>hi</code> is invalid, then hi will not be considered while evaluating the input (Essentially considered maximum value of that type).</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">   input: {1, 2, 3, NULL, 5, 6, 7}</div>
<div class="line"> </div>
<div class="line">   valid lo and hi</div>
<div class="line">   lo: 3, hi: 5</div>
<div class="line">   output:{3, 3, 3, NULL, 5, 5, 5}</div>
<div class="line"> </div>
<div class="line">   invalid lo</div>
<div class="line">   lo: NULL, hi:5</div>
<div class="line">   output:{1, 2, 3, NULL, 5, 5, 5}</div>
<div class="line"> </div>
<div class="line">   invalid hi</div>
<div class="line">   lo: 3, hi:NULL</div>
<div class="line">   output:{3, 3, 3, NULL, 5, 6, 7}</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lo.type() != hi.type()</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lo.type() != input.type()</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Column whose elements will be clamped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lo</td><td>Minimum clamp value. All elements less than <code>lo</code> will be replaced by <code>lo</code>. Ignored if null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>Maximum clamp value. All elements greater than <code>hi</code> will be replaced by <code>hi</code>. Ignored if null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the returned result column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a clamped column as per <code>lo</code> and <code>hi</code> boundaries </dd></dl>

</div>
</div>
<a id="ab59b75670715814a0280eafbf434129a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59b75670715814a0280eafbf434129a">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lo_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>hi_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces values less than <code>lo</code> in <code>input</code> with <code>lo_replace</code>, and values greater than <code>hi</code> with <code>hi_replace</code>. </p>
<p>if <code>lo</code> is invalid, then lo will not be considered while evaluating the input (Essentially considered minimum value of that type). if <code>hi</code> is invalid, then hi will not be considered while evaluating the input (Essentially considered maximum value of that type).</p>
<dl class="section note"><dt>Note</dt><dd>: If <code>lo</code> is valid then <code>lo_replace</code> should be valid If <code>hi</code> is valid then <code>hi_replace</code> should be valid</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">   input: {1, 2, 3, NULL, 5, 6, 7}</div>
<div class="line"> </div>
<div class="line">   valid lo and hi</div>
<div class="line">   lo: 3, hi: 5, lo_replace : 0, hi_replace : 16</div>
<div class="line">   output:{0, 0, 3, NULL, 5, 16, 16}</div>
<div class="line"> </div>
<div class="line">   invalid lo</div>
<div class="line">   lo: NULL, hi: 5, lo_replace : 0, hi_replace : 16</div>
<div class="line">   output:{1, 2, 3, NULL, 5, 16, 16}</div>
<div class="line"> </div>
<div class="line">   invalid hi</div>
<div class="line">   lo: 3, hi: NULL, lo_replace : 0, hi_replace : 16</div>
<div class="line">   output:{0, 0, 3, NULL, 5, 6, 7}</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lo.type() != hi.type()</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lo_replace.type() != hi_replace.type()</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lo.type() != lo_replace.type()</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lo.type() != input.type()</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Column whose elements will be clamped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lo</td><td>Minimum clamp value. All elements less than <code>lo</code> will be replaced by <code>lo_replace</code>. Ignored if null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lo_replace</td><td>All elements less than <code>lo</code> will be replaced by <code>lo_replace</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>Maximum clamp value. All elements greater than <code>hi</code> will be replaced by <code>hi_replace</code>. Ignored if null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi_replace</td><td>All elements greater than <code>hi</code> will be replaced by <code>hi_replace</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the returned result column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a clamped column as per <code>lo</code> and <code>hi</code> boundaries </dd></dl>

</div>
</div>
<a id="a1b56089ab0490194a96cdfd249a72181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b56089ab0490194a96cdfd249a72181">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::concatenate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tables_to_concat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Columns of <code>tables_to_concat</code> are concatenated vertically to return a single <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a>. </p>
<p>------------------------------------------------------------------------&mdash;* example: </p><div class="fragment"><div class="line">column_view c0; <span class="comment">//Contains {0,1,2,3}</span></div>
<div class="line">column_view c1; <span class="comment">//Contains {4,5,6,7}</span></div>
<div class="line">table_view t0{{c0, c0}};</div>
<div class="line">table_view t1{{c1, c1}};</div>
<div class="line">...</div>
<div class="line">auto t = <a class="code" href="namespacecudf_1_1experimental.html#a1b56089ab0490194a96cdfd249a72181">concatenate</a>({t0.view(), t1.view()});</div>
<div class="line">column_view tc0 = (t-&gt;view()).column(0); <span class="comment">//Contains {0,1,2,3,4,5,6,7}</span></div>
<div class="line">column_view tc1 = (t-&gt;view()).column(1); <span class="comment">//Contains {0,1,2,3,4,5,6,7}</span></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If number of columns mismatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables_to_concat</td><td>The table views to be concatenated into a single table </td></tr>
    <tr><td class="paramname">mr</td><td>Optional The resource to use for all allocations </td></tr>
    <tr><td class="paramname">stream</td><td>Optional The stream on which to execute all allocations and copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to a single table having all the rows from the </dd></dl>
<h2><a class="anchor" id="autotoc_md479"></a>
elements of &lt;tt&gt;tables_to_concat&lt;/tt&gt; respectively in the same order.</h2>

</div>
</div>
<a id="a5865ad6c683aa22832c7d74f36a52c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5865ad6c683aa22832c7d74f36a52c1b">&#9670;&nbsp;</a></span>contiguous_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structcudf_1_1experimental_1_1contiguous__split__result.html">contiguous_split_result</a> &gt; cudf::experimental::contiguous_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a deep-copy split of a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code>s into a single contiguous block of memory. </p>
<p>The memory for the output views is allocated in a single contiguous <code>rmm::device_buffer</code> returned in the <code><a class="el" href="structcudf_1_1experimental_1_1contiguous__split__result.html" title="The result(s) of a contiguous_split">contiguous_split_result</a></code>. There is no top-level owning table.</p>
<p>The returned views of <code>input</code> are constructed from a vector of indices, that indicate where each split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>splits[i] != input.size()</code>, or <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code></p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory contained in the <code>all_data</code> field of the returned <a class="el" href="structcudf_1_1experimental_1_1contiguous__split__result.html" title="The result(s) of a contiguous_split">contiguous_split_result</a>. <br  />
</dd></dl>
<p>Example: input: [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28}, {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}] splits: {2, 5, 9} output: [{{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}, {{50, 52}, {54, 56, 58}, {60, 62, 64, 66}, {68}}]</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>View of a table to split </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splits</td><td>A vector of indices where the view will be split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all returned allocations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Optional CUDA stream on which to execute kernels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code> and the viewed memory buffer. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a11">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad11643d0378285cf1d7b17826fbb35bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11643d0378285cf1d7b17826fbb35bb">&#9670;&nbsp;</a></span>copy_if_else() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: output[i] = (boolean_mask[i]) ? lhs[i] : rhs[i]</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same length </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean_mask contains nulls </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type <a class="el" href="structcudf_1_1experimental_1_1bool8.html">bool8</a> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs and rhs <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left-hand</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right-hand</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Non-nullable</td><td>column of <code>BOOL8</code> elements that control selection from <code>lhs</code> or <code>rhs</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>resource for allocating device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a12">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a317d50ca96c4e8842947e991c19eccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317d50ca96c4e8842947e991c19eccf9">&#9670;&nbsp;</a></span>copy_if_else() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: output[i] = (boolean_mask[i]) ? lhs[i] : rhs</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type <a class="el" href="structcudf_1_1experimental_1_1bool8.html">bool8</a> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left-hand</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right-hand</td><td>scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></td><td>representing "left (true) / right (false)" boolean for each element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>resource for allocating device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="a659eb118490384c27a3cf9802a56197e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659eb118490384c27a3cf9802a56197e">&#9670;&nbsp;</a></span>copy_if_else() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: output[i] = (boolean_mask[i]) ? lhs : rhs[i]</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type <a class="el" href="structcudf_1_1experimental_1_1bool8.html">bool8</a> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as rhs <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left-hand</td><td>scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right-hand</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></td><td>representing "left (true) / right (false)" boolean for each element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>resource for allocating device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="a603125f72d0498da871083aa1495db7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603125f72d0498da871083aa1495db7c">&#9670;&nbsp;</a></span>copy_if_else() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>. </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: output[i] = (boolean_mask[i]) ? lhs : rhs</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type <a class="el" href="structcudf_1_1experimental_1_1bool8.html">bool8</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left-hand</td><td>scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right-hand</td><td>scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></td><td>representing "left (true) / right (false)" boolean for each element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>resource for allocating device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="a77b5739505c21058c97d6f29c996c16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b5739505c21058c97d6f29c996c16f">&#9670;&nbsp;</a></span>copy_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>target_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements out-of-place from one column to another. </p>
<p>Creates a new column as if an in-place copy was performed into <code>target</code>. A copy of <code>target</code> is created first and then the elements indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) were copied from the elements indicated by the indices [<code>source_begin</code>, <code>source_end</code>) of <code>source</code> (where N = (<code>source_end</code> - <code>source_begin</code>)). Elements outside the range are copied from <code>target</code> into the returned new column target.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>target</code> and <code>source</code> have different types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The column to copy from inside the range. </td></tr>
    <tr><td class="paramname">target</td><td>The column to copy from outside the range. </td></tr>
    <tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
    <tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
    <tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate the result target column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; The result target column </dd></dl>

</div>
</div>
<a id="ac649c525d788647c5d6bf3b6b4cedb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac649c525d788647c5d6bf3b6b4cedb87">&#9670;&nbsp;</a></span>copy_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::experimental::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements in-place from one column to another. </p>
<p>Overwrites the range of elements in <code>target</code> indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) with the elements from <code>source</code> indicated by the indices [<code>source_begin</code>, <code>source_end</code>) (where N = (<code>source_end</code> - <code>source_begin</code>)). Use the out-of-place copy function returning std::unique_ptr&lt;column&gt; for uses cases requiring memory reallocation. For example for strings columns and other variable-width types.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if memory reallocation is required (e.g. for variable width types). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>target</code> and <code>source</code> have different types. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>source</code> has null values and <code>target</code> is not nullable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The column to copy from </td></tr>
    <tr><td class="paramname">target</td><td>The preallocated column to copy into </td></tr>
    <tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
    <tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
    <tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a8">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad9f3553fd1261d377365d94c676fff9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f3553fd1261d377365d94c676fff9d">&#9670;&nbsp;</a></span>CUDF_TYPE_MAPPING()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::experimental::CUDF_TYPE_MAPPING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1experimental_1_1bool8.html">cudf::experimental::bool8</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type_id::BOOL8&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines all of the mappings between C++ types and their corresponding. </p>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md563"></a>
&lt;tt&gt;cudf::type_id&lt;/tt&gt; values.</h2>

</div>
</div>
<a id="a051cdf96b8c340add8fe1416909d06e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051cdf96b8c340add8fe1416909d06e7">&#9670;&nbsp;</a></span>drop_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt; cudf::experimental::drop_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#a43b073c676d07d514a051888b2b753cd">duplicate_keep_option</a> const &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&#160;</td>
          <td class="paramname"><em>nulls_are_equal</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table without duplicate rows. </p>
<p>Given an <code>input</code> <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a>, each row is copied to output table if the corresponding row of <code>keys</code> columns is unique, where the definition of unique depends on the value of <code>keep:</code> </p><ul>
<li>KEEP_FIRST: only the first of a sequence of duplicate rows is copied</li>
<li>KEEP_LAST: only the last of a sequence of duplicate rows is copied</li>
<li>KEEP_NONE: no duplicate rows are copied</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if The <code>input</code> row size mismatches with <code>keys</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>input <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a> to copy only unique rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>vector of indices representing key columns from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>keep first entry, last entry, or no entries if duplicates found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_are_equal</td><td>flag to denote nulls are equal if true, nulls are not equal if false </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr<table class="doxtable">
</table>
with unique rows as per specified <code>keep</code>. </dd></dl>

</div>
</div>
<a id="a9fadf20c2bcd430f728769d1bcd050ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fadf20c2bcd430f728769d1bcd050ec">&#9670;&nbsp;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of empty columns with the same types as the <code>input_table</code> </p>
<p>Creates the <code><a class="el" href="classcudf_1_1column.html">cudf::column</a></code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_table</td><td>Immutable view of input table to emulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;table&gt; A table of empty columns with the same types as the columns in <code>input_table</code> </dd></dl>

</div>
</div>
<a id="a1b4b9e142e2a1fd804dc76d76b260473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4b9e142e2a1fd804dc76d76b260473">&#9670;&nbsp;</a></span>equality_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , std::enable_if_t&lt; std::is_floating_point&lt; Element &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ bool cudf::experimental::equality_compare </td>
          <td>(</td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization for floating-point <code>Element</code> type to check if <code>lhs</code> is equivalent to <code>rhs</code>. <code>nan == nan</code>. </p>
<p>A specialization for non-floating-point <code>Element</code> type to check if <code>lhs</code> is equivalent to <code>rhs</code>.</p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second element </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md464"></a>
@return bool &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;lhs&lt;/tt&gt; == &lt;tt&gt;rhs&lt;/tt&gt; else &lt;tt&gt;false&lt;/tt&gt;.</h2>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second element </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md465"></a>
@return bool &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;lhs&lt;/tt&gt; == &lt;tt&gt;rhs&lt;/tt&gt; else &lt;tt&gt;false&lt;/tt&gt;.</h2>

</div>
</div>
<a id="ae713ac30fdf8c5f5b37f9f4612180f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae713ac30fdf8c5f5b37f9f4612180f8b">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in a column out-of-place with a scalar value. </p>
<p>------------------------------------------------------------------------&mdash;* Creates a new column as-if an in-place fill was performed into <code>input</code>; i.e. it is as if a copy of <code>input</code> was created first and then the elements indicated by the indices [<code>begin</code>, <code>end</code>) were overwritten by <code>value</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>for invalid range (if <code>begin</code> &lt; 0, <code>begin</code> &gt; <code>end</code>, <code>begin</code> &gt;= <code>destination.size()</code>, or <code>end</code> &gt; <code>destination.size()</code>). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>destination</code> and <code>value</code> have different types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column used to create a new column. The new column is created by replacing the values of <code>input</code> in the specified range with <code>value</code>. </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the fill range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>The index of the last element in the fill range (exclusive) </td></tr>
    <tr><td class="paramname">value</td><td>The scalar value to fill </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate the result output column </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md340"></a>
@return std::unique_ptr&lt;column&gt; The result output column</h2>

</div>
</div>
<a id="abdcc600a269f9142df29f43dd61d6521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcc600a269f9142df29f43dd61d6521">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::experimental::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in-place in a column with a scalar value. </p>
<p>------------------------------------------------------------------------&mdash;* Fills N elements of <code>destination</code> starting at <code>begin</code> with <code>value</code>, where N = (<code>end</code> - <code>begin</code>).</p>
<p>Overwrites the range of elements in <code>destination</code> indicated by the indices [<code>begin</code>, <code>end</code>) with <code>value</code>. Use the out-of-place fill function returning std::unique_ptr&lt;column&gt; for use cases requiring memory reallocation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if memory reallocation is required (e.g. for variable width types). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>for invalid range (if <code>begin</code> &lt; 0, <code>begin</code> &gt; <code>end</code>, <code>begin</code> &gt;= <code>destination.size()</code>, or <code>end</code> &gt; <code>destination.size()</code>). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>destination</code> and <code>value</code> have different types. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>value</code> is invalid but <code>destination</code> is not nullable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The preallocated column to fill into </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the fill range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>The index of the last element in the fill range (exclusive) </td></tr>
    <tr><td class="paramname">value</td><td>The scalar value to fill </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md339"></a>
@return void</h2>

</div>
</div>
<a id="a785dc5fa5540c9b0e6329847216ac89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785dc5fa5540c9b0e6329847216ac89b">&#9670;&nbsp;</a></span>find_and_replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::find_and_replace_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values_to_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements from <code>input_col</code> according to the mapping <code>old_values</code> to. </p>
<p>Return a copy of <code>input_col</code> replacing all <code>old_values[i]</code> present with <code>new_values[i]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_col</td><td>The column to find and replace values in. </td></tr>
    <tr><td class="paramname">values_to_replace</td><td>The values to replace </td></tr>
    <tr><td class="paramname">replacement_values</td><td>The values to replace with </td></tr>
    <tr><td class="paramname">mr</td><td>Optional device_memory_resource to use for allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of <code>input</code> with specified values replaced. </dd></dl>

</div>
</div>
<a id="a1edcfa60adcae62ead9197feeaf87ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edcfa60adcae62ead9197feeaf87ba0">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the specified rows (including null values) of a set of columns. </p>
<p>Gathers the rows of the source columns according to <code>gather_map</code> such that row "i" in the resulting table's columns will contain row "gather_map[i]" from the source columns. The number of rows in the result table will be equal to the number of elements in <code>gather_map</code>.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>View into a non-nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>gather_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;table&gt; Result of the gather </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a0">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4408bbab28c58c51404f2495fbff725d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4408bbab28c58c51404f2495fbff725d">&#9670;&nbsp;</a></span>interleave_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::interleave_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleave columns of a table into a single column. </p>
<p>Converts the column major table <code>input</code> into a row major column. Example: </p><div class="fragment"><div class="line">in     = [[A1, A2, A3], [B1, B2, B3]]</div>
<div class="line"><span class="keywordflow">return</span> = [A1, B1, A2, B2, A3, B3]</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input contains no columns. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input columns dtypes are not identical.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Table containing columns to interleave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interleaved columns as a single column </dd></dl>

</div>
</div>
<a id="aeee88668e664b238e3f6375c610539f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee88668e664b238e3f6375c610539f8">&#9670;&nbsp;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::is_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code>BOOL8</code> elements indicating the presence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>true</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>false</code> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input</code> is a non-floating point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A column of floating-point elements </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, The resource to use for allocating the device memory in the returned column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;column&gt; A non-nulalble column of <code>BOOL8</code> elements with <code>true</code> representing <code>NAN</code> values </dd></dl>

</div>
</div>
<a id="a4004d81e75a4398cc0742efa36e3ff04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4004d81e75a4398cc0742efa36e3ff04">&#9670;&nbsp;</a></span>is_not_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::is_not_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code>BOOL8</code> elements indicating the absence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>false</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>true</code> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input</code> is a non-floating point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A column of floating-point elements </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, The resource to use for allocating the device memory in the returned column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;column&gt; A non-nulalble column of <code>BOOL8</code> elements with <code>false</code> representing <code>NAN</code> values </dd></dl>

</div>
</div>
<a id="a7e8216839cc624ea3a69aa60943ccbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8216839cc624ea3a69aa60943ccbde">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::experimental::is_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code>BOOL8</code> elements where for every element in <code>input</code> <code>true</code> indicates the value is null and <code>false</code> indicates the value is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> as input </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;cudf::column&gt; A non-nulalble column of <code>BOOL8</code> elements with <code>true</code> representing <code>null</code> values. </dd></dl>

</div>
</div>
<a id="aac969ee758bff8ff7c0df765f5bd10bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac969ee758bff8ff7c0df765f5bd10bd">&#9670;&nbsp;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::experimental::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the rows of a <code>table</code> are sorted in a lexicographical order. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>table whose rows need to be compared for ordering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column_order</td><td>The expected sort order for each column. Size must be equal to <code>in.num_columns()</code> or empty. If empty, it is expected all columns are in ascending order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_precedence</td><td>The desired order of null compared to other elements for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, <code><a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a></code> is assumed for all columns.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md458"></a>
@returns bool                true if sorted as expected, false if not.</h2>

</div>
</div>
<a id="aeb3f89042ed2eb6a4a38a86919f526bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3f89042ed2eb6a4a38a86919f526bc">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::experimental::is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code>BOOL8</code> elements where for every element in <code>input</code> <code>true</code> indicates the value is valid and <code>false</code> indicates the value is null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> as input </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;cudf::column&gt; A non-nulalble column of <code>BOOL8</code> elements with <code>false</code> representing <code>null</code> values. </dd></dl>

</div>
</div>
<a id="a9da07e36844255fd5bc535c5718a155a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da07e36844255fd5bc535c5718a155a">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find smallest indices in a sorted table where values should be inserted to maintain order. </p>
<p>For each row v in <code>values</code>, find the first index in <code>t</code> where inserting the row will maintain the sort order of <code>t</code> </p>
<p>Example:</p>
<p>Single column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 1 }</p>
<p>Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 3 }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Table to search </td></tr>
    <tr><td class="paramname">values</td><td>Find insert locations for these values </td></tr>
    <tr><td class="paramname">column_order</td><td>Vector of column sort order </td></tr>
    <tr><td class="paramname">null_precedence</td><td>Vector of null_precedence enums values </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to use for device memory allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A non-nullable column of cudf::size_type elements containing the insertion points. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2detail_2search_8hpp-example.html#a0">/rapids/cudf/cpp/include/cudf/detail/search.hpp</a>, and <a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2search_8hpp-example.html#a0">/rapids/cudf/cpp/include/cudf/search.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7994a4f7c22fb477a6f51ba5d2ffd0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7994a4f7c22fb477a6f51ba5d2ffd0c1">&#9670;&nbsp;</a></span>make_argmax_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; cudf::experimental::make_argmax_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory to create a ARGMAX aggregation. </p>
<p>Factory to create an <code>argmax</code> aggregation.</p>
<p><code>argmax</code> returns the index of the maximum element. </p>

</div>
</div>
<a id="af87231ab8430ae7b296c3a0110096b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87231ab8430ae7b296c3a0110096b26">&#9670;&nbsp;</a></span>make_argmin_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; cudf::experimental::make_argmin_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory to create a ARGMIN aggregation. </p>
<p>Factory to create an <code>argmin</code> aggregation.</p>
<p><code>argmin</code> returns the index of the minimum element. </p>

</div>
</div>
<a id="afdf5751f91dd4da5c76b0b54fc2dc9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf5751f91dd4da5c76b0b54fc2dc9ee">&#9670;&nbsp;</a></span>make_quantile_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; cudf::experimental::make_quantile_aggregation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151">interpolation</a>&#160;</td>
          <td class="paramname"><em>i</em> = <code><a class="el" href="namespacecudf_1_1experimental.html#a5f4f0e0f1bfa906673bf5c2a2b13b151aaac544aacc3615aada24897a215f5046">interpolation::LINEAR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory to create a QUANTILE aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantiles</td><td>The desired quantiles </td></tr>
    <tr><td class="paramname">interpolation</td><td>The desired interpolation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0f85485889732efb9510c2d2811bd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f85485889732efb9510c2d2811bd08">&#9670;&nbsp;</a></span>make_std_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; cudf::experimental::make_std_aggregation </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory to create a STD aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ddof</td><td>Delta degrees of freedom. The divisor used in calculation of <code>std</code> is <code>N - ddof</code>, where <code>N</code> is the population size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03b177a3721692f887f0ec3386bc6ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b177a3721692f887f0ec3386bc6ace">&#9670;&nbsp;</a></span>make_udf_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; cudf::experimental::make_udf_aggregation </td>
          <td>(</td>
          <td class="paramtype">udf_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>user_defined_aggregator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory to create a UDF aggregation. </p>
<p>Factory to create a aggregation base on UDF for PTX or CUDA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>either udf_type::PTX or udf_type::CUDA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_defined_aggregator</td><td>A string containing the aggregator code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_type</td><td>expected output type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>aggregation unique pointer housing user_defined_aggregator string. </dd></dl>

</div>
</div>
<a id="a6378a7fb9a679f0eff3ac828d23d7aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6378a7fb9a679f0eff3ac828d23d7aa4">&#9670;&nbsp;</a></span>make_variance_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; cudf::experimental::make_variance_aggregation </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory to create a VARIANCE aggregation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ddof</td><td>Delta degrees of freedom. The divisor used in calculation of <code>variance</code> is <code>N - ddof</code>, where <code>N</code> is the population size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99d54d902dca3ba2fda445aa97c3fd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d54d902dca3ba2fda445aa97c3fd76">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt; cudf::experimental::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>left_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>right_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cudf::size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>key_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">cudf::order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted tables. </p>
<p>Merges two sorted tables into one sorted table containing data from both tables.</p>
<p>Example 1: input: table 1 =&gt; col 1 {0, 1, 2, 3} col 2 {4, 5, 6, 7} table 2 =&gt; col 1 {1, 2} col 2 {8, 9} output: table =&gt; col 1 {0, 1, 1, 2, 2, 3} col 2 {4, 5, 8, 6, 9, 7}</p>
<p>Example 2: input: table 1 =&gt; col 0 {1, 0} col 1 {'c', 'b'} col 2 {RED, GREEN}</p>
<p>table 2 =&gt; col 0 {1} col 1 {'a'} col 2 {NULL}</p>
<p>with key_cols[] = {0,1} and asc_desc[] = {ASC, ASC};</p>
<p>Lex-sorting is on columns {0,1}; hence, lex-sorting of ((L0 x L1) V (R0 x R1)) is: (0,'b', GREEN), (1,'a', NULL), (1,'c', RED)</p>
<p>(third column, the "color", just "goes along for the ride"; meaning is permutted according to the data movements dictated by lexicographic ordering of columns 0 and 1);</p>
<p>with result columns:</p>
<p>Res0 = {0,1,1} Res1 = {'b', 'a', 'c'} Res2 = {GREEN, NULL, RED}</p>
<p>@Param[in] left_table A sorted table to be merged @Param[in] right_table A sorted table to be merged @Param[in] key_cols Indices of left_cols and right_cols to be used for comparison criteria @Param[in] column_order Sort order types of columns indexed by key_cols @Param[in] null_precedence Array indicating the order of nulls with respect to non-nulls for the indexing columns (key_cols)</p>
<p>@Returns A table containing sorted data from left_table and right_table </p>

</div>
</div>
<a id="a2509a63c1180c2438c1feda1788e9539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2509a63c1180c2438c1feda1788e9539">&#9670;&nbsp;</a></span>nans_to_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, size_type &gt; cudf::experimental::nans_to_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a null_mask from <code>input</code> by converting <code>NaN</code> to null and preserving existing null values and also returns new null_count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>input.type()</code> is a non-floating type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>An immutable view of the input column of floating-point type </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for for all device allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing a <code>device_buffer</code> with the new bitmask and it's null count obtained by replacing <code>NaN</code> in <code>input</code> with null. </dd></dl>

</div>
</div>
<a id="a3f25817755c09f6285bd9ea355cd9aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f25817755c09f6285bd9ea355cd9aa3">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; cudf::experimental::reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcudf_1_1column__view.html">column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#ad7f314cd95af9fb330bfdfb735e42fb8">reduction_op</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the reduction of the values in all rows of a column. This function does not detect overflows in reductions. Using a higher precision <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (timestamp, string...). The null values are skipped for the operation. If the column is empty, the member <code><a class="el" href="namespacecudf_1_1experimental.html#aeb3f89042ed2eb6a4a38a86919f526bc" title="Creates a column of BOOL8 elements where for every element in input true indicates the value is valid...">is_valid()</a></code> of the output scalar will contain <code>false</code>. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if reduction is called for non-arithmetic output type and operator other than <code>min</code> and <code>max</code>. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if input column data type is not convertible to output data type. If the input column has arithmetic type, output_dtype can be any arithmetic type. For <code>mean</code>, <code>var</code> and <code>std</code> ops, a floating point output type must be specified. If the input column has non-arithmetic type eg.(timestamp, string...), the same type must be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>Input column view </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operator applied by the reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_dtype</td><td>The computation and output precision. @params[in] mr The resource to use for all allocations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ddof</td><td>Delta Degrees of Freedom: the divisor used in calculation of <code>std</code> and <code>var</code> is <code>N - ddof</code>, where <code>N</code> is the population size.` </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcudf_1_1scalar.html" title="An owning class to represent a singular value.">cudf::scalar</a> the result value If the reduction fails, the member is_valid of the output scalar </dd></dl>
<h2><a class="anchor" id="autotoc_md452"></a>
will contain &lt;tt&gt;false&lt;/tt&gt;.</h2>

</div>
</div>
<a id="a9616e7fc22050601796328dfa9b4bb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9616e7fc22050601796328dfa9b4bb8c">&#9670;&nbsp;</a></span>relational_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , std::enable_if_t&lt; std::is_floating_point&lt; Element &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="namespacecudf_1_1experimental.html#a57a49aef820830d7830862408645b8c7">weak_ordering</a> cudf::experimental::relational_compare </td>
          <td>(</td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization for floating-point <code>Element</code> type rerlational comparison to derive the order of the elements with respect to <code>lhs</code>. Specialization is to handle <code>nan</code> in the order shown below. <code>[-Inf, -ve, 0, -0, +ve, +Inf, NaN, NaN, null] (for <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb" title="NULL values ordered after all other values.">null_order::AFTER</a>)</code> <code>[null, -Inf, -ve, 0, -0, +ve, +Inf, NaN, NaN] (for <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a>)</code> </p>
<p>A specialization for non-floating-point <code>Element</code> type relational comparison to derive the order of the elements with respect to <code>lhs</code>.</p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weak_ordering Indicates the relationship between the elements in </dd></dl>
<h2><a class="anchor" id="autotoc_md462"></a>
the &lt;tt&gt;lhs&lt;/tt&gt; and &lt;tt&gt;rhs&lt;/tt&gt; columns.</h2>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weak_ordering Indicates the relationship between the elements in </dd></dl>
<h2><a class="anchor" id="autotoc_md463"></a>
the &lt;tt&gt;lhs&lt;/tt&gt; and &lt;tt&gt;rhs&lt;/tt&gt; columns.</h2>

</div>
</div>
<a id="a821183b38dc84793cf9ccc43abd3c86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821183b38dc84793cf9ccc43abd3c86a">&#9670;&nbsp;</a></span>repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_count</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table. </p>
<p>------------------------------------------------------------------------&mdash;* Creates a new table by repeating the rows of <code>input_table</code>. The number of repetitions of each element is defined by the value at the corresponding index of <code>count</code> Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = [1,2,3]</div>
<div class="line"><span class="keywordflow">return</span> = [4,5,5,6,6,6]</div>
</div><!-- fragment --><p> <code>count</code> should not have null values; should not contain negative values; and the sum of count elements should not overflow the size_type's limit. It is undefined behavior if <code>count</code> has negative values or the sum overflows and <code>check_count</code> is set to false.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if the data type of <code>count</code> is not size_type. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>input_table</code> and <code>count</code> have different number of rows. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>count</code> has null values. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_count</code> is set to true and <code>count</code> has negative values or the sum of <code>count</code> elements overflows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_table</td><td>Input table </td></tr>
    <tr><td class="paramname">count</td><td>Non-nullable column of a integral type </td></tr>
    <tr><td class="paramname">check_count</td><td>Whether to check count (negative values and overflow) </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate the result output table </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md341"></a>
@return std::unique_ptr&lt;table&gt; The result table containing the repetitions</h2>

</div>
</div>
<a id="a536b3d7781bb64ae0d9b8a64a0328be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536b3d7781bb64ae0d9b8a64a0328be7">&#9670;&nbsp;</a></span>repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table. </p>
<p>------------------------------------------------------------------------&mdash;* Creates a new table by repeating <code>count</code> times the rows of <code>input_table</code>. Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = 2</div>
<div class="line"><span class="keywordflow">return</span> = [4,4,5,5,6,6]</div>
</div><!-- fragment --> <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if the data type of <code>count</code> is not size_type. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>count</code> is invalid or <code>count</code> is negative. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>input_table.num_rows()</code> * <code>count</code> overflows size_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_table</td><td>Input table </td></tr>
    <tr><td class="paramname">count</td><td>Non-null scalar of a integral type </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to allocate the result output table </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md342"></a>
@return std::unique_ptr&lt;table&gt; The result table containing the repetitions</h2>

</div>
</div>
<a id="ad2d7d63257ec8b61f4b5c5662dea8e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d7d63257ec8b61f4b5c5662dea8e5f">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::replace_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with corresponding values of another column. </p>
<p>If <code>input[i]</code> is NULL, then <code>output[i]</code> will contain <code>replacement[i]</code>. <code>input</code> and <code>replacement</code> must be of the same type and size. must be of the same type and same size as the first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A column whose null values will be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A <a class="el" href="classcudf_1_1column.html">cudf::column</a> whose values will replace null values in input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional device_memory_resource to use for allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of <code>input</code> with the null values replaced with corresponding values from <code>replacement</code>. </dd></dl>

</div>
</div>
<a id="ac4485649fdaa0a76de6b7fd2a90a5ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4485649fdaa0a76de6b7fd2a90a5ffd">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::replace_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with a scalar. </p>
<p>If <code>input[i]</code> is NULL, then <code>output[i]</code> will contain <code>replacement</code>. <code>input</code> and <code>replacement</code> must have the same type. a <a class="el" href="classcudf_1_1scalar.html" title="An owning class to represent a singular value.">cudf::scalar</a> of the same data type as the column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A column whose null values will be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>Scalar used to replace null values in <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional device_memory_resource to use for allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of <code>input</code> with null values replaced by <code>replacement</code>. </dd></dl>

</div>
</div>
<a id="ae049fae22f3b0dc38c49cff63b00206c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae049fae22f3b0dc38c49cff63b00206c">&#9670;&nbsp;</a></span>rolling_window() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a variable-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is dynamic (varying for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window + 1</code>. Element <code>i</code> uses elements <code>[i-preceding_window, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
<li>support for dynamic rolling windows, i.e. window size can be specified for each element using an additional array.</li>
</ul>
<p>The returned column for <code>op == COUNT</code> always has INT32 type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if window column type is not INT32</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_col</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>A non-nullable column of INT32 window sizes in the forward direction. <code>preceding_window[i]</code> specifies preceding window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>A non-nullable column of INT32 window sizes in the backward direction. <code>following_window[i]</code> specifies following window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The rolling window aggregation type (sum, max, min, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="ad634be1518c6ecc479ac1fe0dbda3a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad634be1518c6ecc479ac1fe0dbda3a2a">&#9670;&nbsp;</a></span>rolling_window() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1aggregation.html">aggregation</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a fixed-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is static (the same for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window + 1</code>. Element <code>i</code> uses elements <code>[i-preceding_window, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_col</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="a12bca240b20effd38193266111604657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bca240b20effd38193266111604657">&#9670;&nbsp;</a></span>round_robin_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">cudf::experimental::table</a> &gt;, std::vector&lt; cudf::size_type &gt; &gt; cudf::experimental::round_robin_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>num_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>start_partition</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round-robin partition. </p>
<p>Returns a new table with rows re-arranged into partition groups and a vector of row offsets to the start of each partition in the output table. Rows are assigned partitions based on their row index in the table, in a round robin fashion.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if num_partitions &lt;= 1 </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if start_partition &gt;= num_partitions.</td></tr>
  </table>
  </dd>
</dl>
<p>A good analogy for the algorithm is dealing out cards:</p>
<ol type="1">
<li>The deck of cards is represented as the rows in the table.</li>
<li>The number of partitions is the number of players being dealt cards.</li>
<li>the start_partition indicates which player starts getting cards first.</li>
</ol>
<p>The algorithm has two outcomes:</p>
<p>(a) Another deck of cards formed by stacking each player's cards back into a deck again, preserving the order of cards dealt to each player, starting with player 0. (b) A vector into the output deck indicating where a player's cards start.</p>
<p>A player's deck (partition) is the range of cards starting at the corresponding offset and ending at the next player's starting offset or the last card in the deck if it's the last player.</p>
<p>When num_partitions &gt; nrows, we have more players than cards. We start dealing to the first indicated player and continuing around the players until we run out of cards before we run out of players. Players that did not get any cards are represented by offset[i] == offset[i+1] or offset[i] == <a class="el" href="classcudf_1_1experimental_1_1table.html#afcd7efcfd04796d1274a53f380159fa1">table.num_rows()</a> if i == num_partitions-1 meaning there are no cards (rows) in their deck (partition).</p>
<p>Example 1: input: table =&gt; col 1 {0, ..., 12} num_partitions = 3 start_partition = 0</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {0,3,6,9,12,1,4,7,10,2,5,8,11} partition_offsets =&gt; {0,5,9}</p>
<p>Example 2: input: table =&gt; col 1 {0, ..., 12} num_partitions = 3 start_partition = 1</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {2,5,8,11,0,3,6,9,12,1,4,7,10} partition_offsets =&gt; {0,4,9}</p>
<p>Example 3: input: table =&gt; col 1 {0, ..., 10} num_partitions = 3 start_partition = 0</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {0,3,6,9,1,4,7,10,2,5,8} partition_offsets =&gt; {0,4,8}</p>
<p>Example 4: input: table =&gt; col 1 {0, ..., 10} num_partitions = 3 start_partition = 1</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {2,5,8,0,3,6,9,1,4,7,10} partition_offsets =&gt; {0,3,7}</p>
<p>Example 5: input: table =&gt; col 1 {0, ..., 10} num_partitions = 3 start_partition = 2</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {1,4,7,10,2,5,8,0,3,6,9} partition_offsets =&gt; {0,4,7}</p>
<p>Example 6: input: table =&gt; col 1 {0, ..., 10} num_partitions = 15 &gt; num_rows = 11 start_partition = 2</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {0,1,2,3,4,5,6,7,8,9,10} partition_offsets =&gt; {0,0,0,1,2,3,4,5,6,7,8,9,10,11,11}</p>
<p>Example 7: input: table =&gt; col 1 {0, ..., 10} num_partitions = 15 &gt; num_rows = 11 start_partition = 10</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {5,6,7,8,9,10,0,1,2,3,4} partition_offsets =&gt; {0,1,2,3,4,5,6,6,6,6,6,7,8,9,10}</p>
<p>Example 8: input: table =&gt; col 1 {0, ..., 10} num_partitions = 15 &gt; num_rows = 11 start_partition = 14</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {1,2,3,4,5,6,7,8,9,10,0} partition_offsets =&gt; {0,1,2,3,4,5,6,7,8,9,10,10,10,10,10}</p>
<p>Example 9: input: table =&gt; col 1 {0, ..., 10} num_partitions = 11 == num_rows = 11 start_partition = 2</p>
<p>output: pair&lt;table, partition_offsets&gt; table =&gt; col 1 {9,10,0,1,2,3,4,5,6,7,8} partition_offsets =&gt; {0,1,2,3,4,5,6,7,8,9,10}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input table to be round-robin partitioned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_partitions</td><td>Number of partitions for the table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_partition</td><td>Index of the 1st partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory allocator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair consisting of an unique_ptr to the partitioned table and the partition offsets for each partition within the table. </dd></dl>

</div>
</div>
<a id="ab402cbc5ae2de3e024abf2231d185e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab402cbc5ae2de3e024abf2231d185e3e">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcudf_1_1column__view.html">column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1experimental.html#af44baaeea3ec9df2ee3029e515c713cf">scan_op</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scan of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if column datatype is not numeric type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column view for the scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation of the scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inclusive</td><td>The flag for applying an inclusive scan if true, an exclusive scan if false. @params[in] mr The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md453"></a>
@returns unique pointer to new output column</h2>

</div>
</div>
<a id="a71c7d359043b804ba7b6b0c38606c8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c7d359043b804ba7b6b0c38606c8d9">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::scatter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters a row of scalar values into a copy of the target table according to a scatter map. </p>
<p>Scatters values from the source row into the target table out-of-place, returning a "destination table". The scatter is performed according to a scatter map such that row <code>scatter_map[i]</code> of the destination table is replaced by the source row. All other rows of the destination table equal corresponding rows of the target table.</p>
<p>The number of elements in source must match the number of columns in target and their corresponding datatypes must be the same.</p>
<p>If the same index appears more than once in the scatter map, the result is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>scatter_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the target table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input scalars containing values to be scattered into the target columns </td></tr>
    <tr><td class="paramname">indices</td><td>A non-nullable column of integral indices that indicate the rows in the target table to be replaced by source. </td></tr>
    <tr><td class="paramname">target</td><td>The set of columns into which values from the source_table are to be scattered </td></tr>
    <tr><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>scatter_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramname">mr</td><td>The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md286"></a>
@return Result of scattering values from source to target</h2>

</div>
</div>
<a id="a66e9825f07db3744b175c518c687b537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e9825f07db3744b175c518c687b537">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>scatter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows of the source table into a copy of the target table according to a scatter map. </p>
<p>Scatters values from the source table into the target table out-of-place, returning a "destination table". The scatter is performed according to a scatter map such that row <code>scatter_map[i]</code> of the destination table gets row <code>i</code> of the source table. All other rows of the destination table equal corresponding rows of the target table.</p>
<p>The number of columns in source must match the number of columns in target and their corresponding datatypes must be the same.</p>
<p>If the same index appears more than once in the scatter map, the result is undefined.</p>
<p>A negative value <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>target</code> table.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>scatter_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the target table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input columns containing values to be scattered into the target columns </td></tr>
    <tr><td class="paramname">scatter_map</td><td>A non-nullable column of integral indices that maps the rows in the source table to rows in the target table. The size must be equal to or less than the number of elements in the source columns. </td></tr>
    <tr><td class="paramname">target</td><td>The set of columns into which values from the source_table are to be scattered </td></tr>
    <tr><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>scatter_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramname">mr</td><td>The resource to use for all allocations </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md285"></a>
@return Result of scattering values from source to target</h2>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a1">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1ab89c9919455c060e0ab7b435d772a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab89c9919455c060e0ab7b435d772a1">&#9670;&nbsp;</a></span>scatter_to_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; &gt; cudf::experimental::scatter_to_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>partition_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows of a table to <code>n</code> tables according to a partition map. </p>
<p>Copies the rows from the input table to new tables according to the table indices given by partition_map. The number of output tables is one more than the maximum value in <code>partition_map</code>.</p>
<p>Output table <code>i</code> in [0, n] is empty if <code>i</code> does not appear in partition_map. output table will be empty.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when partition_map is a non-integer type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when partition_map is larger than input </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when partition_map has nulls</td></tr>
  </table>
  </dd>
</dl>
<p>Example: input: [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28}, { 1, 2, 3, 4, null, 0, 2, 4, 6, 2}] partition_map: {3, 4, 3, 1, 4, 4, 0, 1, 1, 1} output: {[{22}, {2}], [{16, 24, 26, 28}, {4, 4, 6, 2}], [{}, {}], [{10, 14}, {1, 3}], [{12, 18, 20}, {2, null, 0}]}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Table of rows to be partitioned into a set of tables tables according to <code>partition_map</code> </td></tr>
    <tr><td class="paramname">partition_map</td><td>Non-null column of integer values that map each row in <code>input</code> table into one of the output tables </td></tr>
    <tr><td class="paramname">mr</td><td>The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of tables containing the scattered rows of <code>input</code>. <code>table</code> <code>i</code> contains all rows <code>j</code> from <code>input</code> where <code>partition_map[j] == i</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a2">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa524c9b8616c57e3079161fa33f405c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa524c9b8616c57e3079161fa33f405c7">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lexicographic sort of the rows of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to sort </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>input</code>. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>The device memory resource used to allocate the returned table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New table containing the desired sorted order of <code>input</code> </dd></dl>

</div>
</div>
<a id="a6f329aec79c6699e308ff9916e5a2f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f329aec79c6699e308ff9916e5a2f50">&#9670;&nbsp;</a></span>sort_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">table</a> &gt; cudf::experimental::sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a key-value sort. </p>
<p>Creates a new table that reorders the rows of <code>values</code> according to the lexicographic ordering of the rows of <code>keys</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>values.num_rows() != keys.num_rows()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The table to reorder </td></tr>
    <tr><td class="paramname">keys</td><td>The table that determines the ordering </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column in <code>keys</code>. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>The device memory resource used to allocate the returned table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reordering of <code>values</code> determined by the lexicographic order of the rows of <code>keys</code>. </dd></dl>

</div>
</div>
<a id="a0b484f1dcc0f825e04929974481811ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b484f1dcc0f825e04929974481811ee">&#9670;&nbsp;</a></span>sorted_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::sorted_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the row indices that would produce <code>input</code> in a lexicographical sorted order. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to sort </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired sort order for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of null compared to other elements for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted in <code><a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values.">null_order::BEFORE</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A non-nullable column of INT32 elements </dd></dl>
<h2><a class="anchor" id="autotoc_md457"></a>
containing the permuted row indices of &lt;tt&gt;input&lt;/tt&gt; if it were sorted</h2>

</div>
</div>
<a id="aa08f61e372c72069f45fcd2bcf9936e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08f61e372c72069f45fcd2bcf9936e8">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::experimental::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits. </p>
<p>The returned view's of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>splits[i] != input.size()</code>, or <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code></p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} splits: {2, 5, 9} output: {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to split </td></tr>
    <tr><td class="paramname">splits</td><td>A vector of indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2copying_8hpp-example.html#a9">/rapids/cudf/cpp/include/cudf/copying.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8f4bd1cfd9b40f54975494511a78a15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4bd1cfd9b40f54975494511a78a15e">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::experimental::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code>s according to a set of indices derived from expected splits. </p>
<p>The returned views of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>splits[i] != input.size()</code>, or <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code></p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<p>Example: input: [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28}, {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}] splits: {2, 5, 9} output: [{{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}, {{50, 52}, {54, 56, 58}, {60, 62, 64, 66}, {68}}]</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of a table to split </td></tr>
    <tr><td class="paramname">splits</td><td>A vector of indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>. </dd></dl>

</div>
</div>
<a id="a9cf88ec3542f2af93dfd48fbd38976c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf88ec3542f2af93dfd48fbd38976c1">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>unary_udf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_ptx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column by applying a unary function against every element of an input column. </p>
<p>Computes: <code>out[i] = F(in[i])</code></p>
<p>The output null mask is the same is the input null mask so if input[i] is null then output[i] is also null</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>An immutable view of the input column to transform </td></tr>
    <tr><td class="paramname">unary_udf</td><td>The PTX/CUDA string of the unary function to apply </td></tr>
    <tr><td class="paramname">outout_type</td><td>The output type that is compatible with the output type in the UDF </td></tr>
    <tr><td class="paramname">is_ptx</td><td>true: the UDF is treated as PTX code; false: the UDF is treated as CUDA code </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for for all device allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcudf_1_1column.html">cudf::column</a> The column resulting from applying the unary function to every element of the input </dd></dl>

</div>
</div>
<a id="a06b272ff7f81fde5d649dd75fd72144c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b272ff7f81fde5d649dd75fd72144c">&#9670;&nbsp;</a></span>type_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; cudf::type_id &gt; typename IdTypeMap = id_to_type_impl, typename Functor , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) CUDA_HOST_DEVICE_CALLABLE cudf::experimental::type_dispatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes an <code>operator()</code> template with the type instantiation based on the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code>'s <code>id()</code>. </p>
<p>------------------------------------------------------------------------&mdash;* Example usage with a functor that returns the size of the dispatched type:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>size_of_functor{</div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"> <span class="keywordtype">int</span> operator()(){</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(T);</div>
<div class="line"> }</div>
<div class="line">};</div>
<div class="line"><a class="code" href="classcudf_1_1data__type.html">cudf::data_type</a> t{<a class="code" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae">INT32</a>};</div>
<div class="line">cudf::type_dispatcher(t, size_of_functor{});  <span class="comment">// returns 4</span></div>
</div><!-- fragment --><p>The <code>type_dispatcher</code> uses <code>cudf::type_to_id&lt;t&gt;</code> to provide a default mapping of <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code>s to dispatched C++ types. However, this mapping may be customized by explicitly specifying a user-defined trait struct for the <code>IdTypeMap</code>. For example, to always dispatch <code>int32_t</code></p>
<p>``` template&lt;cudf::type_id t&gt; struct always_int{ using type = int32_t; }</p>
<p>// This will always invoke <code>operator()&lt;int32_t&gt;</code> cudf::type_dispatcher&lt;always_int&gt;(data_type, f); </p><div class="fragment"><div class="line">It is sometimes necessary to customize the dispatched functor<span class="stringliteral">&#39;s</span></div>
<div class="line"><span class="stringliteral">`operator()` for different types.  This can be done in several ways.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">The first method is to use explicit template specialization. This is useful</span></div>
<div class="line"><span class="stringliteral">for specializing behavior for single types. For example, a functor that</span></div>
<div class="line"><span class="stringliteral">prints `int32_t` or `double` when invoked with either of those types, else it</span></div>
<div class="line"><span class="stringliteral">prints `unhandled type`:</span></div>
</div><!-- fragment --><p> struct type_printer { template &lt;typename columntype&gt;=""&gt; void operator()() { std::cout &lt;&lt; "unhandled type\n"; } };</p>
<p>// Due to a bug in g++, explicit member function specializations need to be // defined outside of the class definition template &lt;&gt; void type_printer::operator()&lt;int32_t&gt;() { std::cout &lt;&lt; "int32_t\n"; }</p>
<p>template &lt;&gt; void type_printer::operator()&lt;double&gt;() { std::cout &lt;&lt; "double\n"; } </p><div class="fragment"><div class="line">A second method is to use SFINAE with `std::enable_if_t`. This is useful <span class="keywordflow">for</span></div>
<div class="line">specializing <span class="keywordflow">for</span> a set of types that share some <span class="keyword">property</span>. For example, a</div>
<div class="line">functor that prints `integral` or `floating point` <span class="keywordflow">for</span> integral or floating</div>
<div class="line">point types:</div>
</div><!-- fragment --><p> struct integral_or_floating_point { template &lt;typename ColumnType, std::enable_if_t&lt;not std::is_integral&lt;ColumnType&gt;::value and not std::is_floating_point&lt;ColumnType&gt;::value&gt;* *= nullptr&gt; void operator()() { std::cout &lt;&lt; "neither integral nor floating
*point\n"; } </p><pre class="fragment">template &lt;typename ColumnType,
          std::enable_if_t&lt;std::is_integral&lt;ColumnType&gt;::value&gt;* = nullptr&gt;
void operator()() { std::cout &lt;&lt; "integral\n"; }

template &lt; typename ColumnType,
           std::enable_if_t&lt;std::is_floating_point&lt;ColumnType&gt;::value&gt;* =
</pre><p> *nullptr&gt; void operator()() { std::cout &lt;&lt; "floating point\n"; } }; ```</p>
<p>For more info on SFINAE and <code>std::enable_if</code>, see <a href="https://eli.thegreenplace.net/2014/sfinae-and-enable_if/">https://eli.thegreenplace.net/2014/sfinae-and-enable_if/</a></p>
<p>The return type for all template instantiations of the functor's "operator()" lambda must be the same, else there will be a compiler error as you would be trying to return different types from the same function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1experimental_1_1id__to__type__impl.html">id_to_type_impl</a></td><td>Maps a <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code> its dispatched C++ type </td></tr>
    <tr><td class="paramname">Functor</td><td>The callable object's type </td></tr>
    <tr><td class="paramname">Ts</td><td>Variadic parameter pack type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code> whose <code>id()</code> determines which template instantiation is invoked </td></tr>
    <tr><td class="paramname">f</td><td>The callable whose <code>operator()</code> template is invoked </td></tr>
    <tr><td class="paramname">args</td><td>Parameter pack of arguments forwarded to the <code>operator()</code> invocation </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md564"></a>
@return Whatever is returned by the callable's &lt;tt&gt;operator()&lt;/tt&gt;</h2>

</div>
</div>
<a id="a2b5b8575cc88f64e4462769d31a1f6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5b8575cc88f64e4462769d31a1f6b1">&#9670;&nbsp;</a></span>type_to_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">type_id</a> cudf::experimental::type_to_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a C++ type to it's corresponding <code><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></code> </p>
<p>------------------------------------------------------------------------&mdash;* When explicitly passed a template argument of a given type, returns the appropriate <code>type_id</code> enum for the specified C++ type.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> cudf::type_to_id&lt;int32_t&gt;();        <span class="comment">// Returns INT32</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md560"></a>
@tparam T The type to map to a &lt;tt&gt;cudf::type_id&lt;/tt&gt;</h2>

</div>
</div>
<a id="acc6145e96e588da5d0795b16b723d561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6145e96e588da5d0795b16b723d561">&#9670;&nbsp;</a></span>unary_operation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::experimental::unary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::experimental::unary_op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs unary op on all values in column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> as input </td></tr>
    <tr><td class="paramname">op</td><td>operation to perform </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;cudf::column&gt; Result of the operation </dd></dl>

</div>
</div>
<a id="a49dceec176e91e0f709beaf6d93dbf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dceec176e91e0f709beaf6d93dbf07">&#9670;&nbsp;</a></span>unique_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::size_type cudf::experimental::unique_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&#160;</td>
          <td class="paramname"><em>ignore_nulls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&#160;</td>
          <td class="paramname"><em>nan_as_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the unique elements in the <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>. </p>
<p>Given an input <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>, number of unique elements in this <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> is returned</p>
<p>If both <code>ignore_nulls</code> and <code>nan_as_null</code> are true, both <code>NaN</code> and <code>null</code> values are ignored. If <code>ignore_nulls</code> is true and <code>nan_as_null</code> is false, only <code>null</code> is ignored, <code>NaN</code> is considered in unique count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> whose unique elements will be counted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_nulls</td><td>flag to ignore <code>null</code> in unique count if true </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nan_as_null</td><td>flag to consider <code>NaN==null</code> if true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all allocations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unique elements </dd></dl>

</div>
</div>
<a id="a49f3dfeef33f906f5d41725ca9abbd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f3dfeef33f906f5d41725ca9abbd96">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::experimental::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find largest indices in a sorted table where values should be inserted to maintain order. </p>
<p>For each row v in <code>values</code>, find the last index in <code>t</code> where inserting the row will maintain the sort order of <code>t</code> </p>
<p>Example:</p>
<p>Single Column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 3 }</p>
<p>Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 5 * * </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>Table to search </td></tr>
    <tr><td class="paramname">values</td><td>Find insert locations for these values </td></tr>
    <tr><td class="paramname">column_order</td><td>Vector of column sort order </td></tr>
    <tr><td class="paramname">null_precedence</td><td>Vector of null_precedence enums values </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to use for device memory allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;column&gt; A non-nullable column of cudf::size_type elements containing the insertion points. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2detail_2search_8hpp-example.html#a1">/rapids/cudf/cpp/include/cudf/detail/search.hpp</a>, and <a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2search_8hpp-example.html#a1">/rapids/cudf/cpp/include/cudf/search.hpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacecudf_1_1experimental_html_a1b56089ab0490194a96cdfd249a72181"><div class="ttname"><a href="namespacecudf_1_1experimental.html#a1b56089ab0490194a96cdfd249a72181">cudf::experimental::concatenate</a></div><div class="ttdeci">std::unique_ptr&lt; table &gt; concatenate(std::vector&lt; table_view &gt; const &amp;tables_to_concat, rmm::mr::device_memory_resource *mr, cudaStream_t stream)</div><div class="ttdoc">Columns of tables_to_concat are concatenated vertically to return a single table_view.</div><div class="ttdef"><b>Definition:</b> table.cpp:92</div></div>
<div class="ttc" id="aclasscudf_1_1data__type_html"><div class="ttname"><a href="classcudf_1_1data__type.html">cudf::data_type</a></div><div class="ttdoc">Indicator for the logical data type of an element in a column.</div><div class="ttdef"><b>Definition:</b> types.hpp:171</div></div>
<div class="ttc" id="anamespacecudf_html_acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae"><div class="ttname"><a href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae">cudf::INT32</a></div><div class="ttdoc">4 byte signed integer</div><div class="ttdef"><b>Definition:</b> types.hpp:149</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
