<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: cudf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cudf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>cuDF interfaces  
<a href="namespacecudf.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecudf_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html">experimental</a></td></tr>
<tr class="memdesc:namespacecudf_1_1experimental"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-development features. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1avro__read__arg.html">avro_read_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1column.html">column</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1column__device__view.html">column_device_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable, non-owning view of device data as a column of elements.  <a href="classcudf_1_1column__device__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1column__view.html">column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data as a column of elements, some of which may be null as indicated by a bitmask.  <a href="classcudf_1_1column__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1create__column__from__view.html">create_column_from_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1create__column__from__view__vector.html">create_column_from_view_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1csv__read__arg.html">csv_read_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input arguments to the <code>read_csv</code> interface.  <a href="structcudf_1_1csv__read__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1cuda__error.html">cuda_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a CUDA error is encountered.  <a href="structcudf_1_1cuda__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1data__type.html">data_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator for the logical data type of an element in a column.  <a href="classcudf_1_1data__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceAnd.html">DeviceAnd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceCount.html">DeviceCount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceMax.html">DeviceMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceMin.html">DeviceMin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceOr.html">DeviceOr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceProduct.html">DeviceProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceSum.html">DeviceSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceXor.html">DeviceXor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__boolean__impl.html">is_boolean_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__compound__impl.html">is_compound_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__fixed__width__impl.html">is_fixed_width_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__numeric__impl.html">is_numeric_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__relationally__comparable__impl.html">is_relationally_comparable_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__relationally__comparable__impl_3_01L_00_01R_00_01void__t_3_01less__comparable_e55590d6a511f5004b91a7c1dc07c638.html">is_relationally_comparable_impl&lt; L, R, void_t&lt; less_comparable&lt; L, R &gt;, greater_comparable&lt; L, R &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__simple__impl.html">is_simple_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__timestamp__impl.html">is_timestamp_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1json__read__arg.html">json_read_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input arguments to the <code>read_json</code> interface.  <a href="structcudf_1_1json__read__arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when logical precondition is violated.  <a href="structcudf_1_1logic__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1meanvar.html">meanvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">intermediate struct to calculate mean and variance This is an example case to output a struct from column input.  <a href="structcudf_1_1meanvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__column__device__view.html">mutable_column_device_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable, non-owning view of device data as a column of elements.  <a href="classcudf_1_1mutable__column__device__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, mutable view of device data as a column of elements, some of which may be null as indicated by a bitmask.  <a href="classcudf_1_1mutable__column__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__table__device__view.html">mutable_table_device_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__table__view.html">mutable_table_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <code><a class="el" href="classcudf_1_1mutable__column__view.html" title="A non-owning, mutable view of device data as a column of elements, some of which may be null as indic...">mutable_column_view</a></code>s of the same size.  <a href="classcudf_1_1mutable__table__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1numeric__scalar.html">numeric_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a numerical value in device memory.  <a href="classcudf_1_1numeric__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1numeric__scalar__device__view.html">numeric_scalar_device_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of scalar_device_view that stores a pointer to a numerical value.  <a href="classcudf_1_1numeric__scalar__device__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1orc__read__arg.html">orc_read_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1orc__write__arg.html">orc_write_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1order__info.html">order_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor.html">pair_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pair accessor with/without null bitmask A unary function returns <code>thrust::pair&lt;ResultType, bool&gt;</code>. If the element at index <code>i</code> is valid, returns <code>ResultType{data[i]}</code> and <code>true</code> indicating the value was valid. If the element at <code>i</code> is null, returns <code>ResultType{identity}</code> and <code>false</code> indicating the element was null.  <a href="structcudf_1_1pair__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor_3_01ElementType_00_01ResultType_00_01false_01_4.html">pair_accessor&lt; ElementType, ResultType, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1pair__accessor_3_01ElementType_00_01ResultType_00_01true_01_4.html">pair_accessor&lt; ElementType, ResultType, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1parquet__read__arg.html">parquet_read_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1scalar.html">scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a singular value.  <a href="classcudf_1_1scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1sink__info.html">sink_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1source__info.html">source_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a string in device memory.  <a href="classcudf_1_1string__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1string__scalar__device__view.html">string_scalar_device_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of scalar_device_view that stores a pointer to a string value.  <a href="classcudf_1_1string__scalar__device__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1string__view.html">string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data that is a variable length char array representing a UTF-8 string. The caller must maintain the device memory for the lifetime of this instance.  <a href="classcudf_1_1string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column-view of strings type, an instance of this class provides a wrapper on this compound column for strings operations.  <a href="classcudf_1_1strings__column__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1table.html">table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for a set of gdf_columns of equal number of rows.  <a href="structcudf_1_1table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1table__device__view.html">table_device_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1table__view.html">table_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s of the same size.  <a href="classcudf_1_1table__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1timestamp__scalar.html">timestamp_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a timestamp value in device memory.  <a href="classcudf_1_1timestamp__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1timestamp__scalar__device__view.html">timestamp_scalar_device_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of scalar_device_view that stores a pointer to a timestamp value.  <a href="classcudf_1_1timestamp__scalar__device__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1transformer__meanvar.html">transformer_meanvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a scalar value to construct a <code>meanvar</code> object. This transforms <code>thrust::pair&lt;ElementType, bool&gt;</code> into <code>ResultType = meanvar&lt;ElementType&gt;</code> form.  <a href="structcudf_1_1transformer__meanvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1transformer__squared.html">transformer_squared</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a scalar by first casting to another type, and then squaring the result.  <a href="structcudf_1_1transformer__squared.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor.html">value_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">value accessor with/without null bitmask A unary function returns scalar value at <code>id</code>. <code>operator() (cudf::size_type id)</code> computes <code>data</code> value and valid flag at <code>id</code>  <a href="structcudf_1_1value__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor_3_01ElementType_00_01ResultType_00_01false_01_4.html">value_accessor&lt; ElementType, ResultType, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1value__accessor_3_01ElementType_00_01ResultType_00_01true_01_4.html">value_accessor&lt; ElementType, ResultType, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0b75348b715cc23b1a6f8b5cf03589cc"><td class="memItemLeft" align="right" valign="top"><a id="a0b75348b715cc23b1a6f8b5cf03589cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>char_utf8</b> = uint32_t</td></tr>
<tr class="separator:a0b75348b715cc23b1a6f8b5cf03589cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aff16b2db009d92300befaca11827e9"><td class="memItemLeft" align="right" valign="top"><a id="a0aff16b2db009d92300befaca11827e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = int32_t</td></tr>
<tr class="separator:a0aff16b2db009d92300befaca11827e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d17001baf070a639c3a5e8ed8c46d34"><td class="memItemLeft" align="right" valign="top"><a id="a1d17001baf070a639c3a5e8ed8c46d34"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bitmask_type</b> = uint32_t</td></tr>
<tr class="separator:a1d17001baf070a639c3a5e8ed8c46d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b06145972e36cd6b4d72ad20dd10ac1"><td class="memItemLeft" align="right" valign="top"><a id="a9b06145972e36cd6b4d72ad20dd10ac1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>valid_type</b> = uint8_t</td></tr>
<tr class="separator:a9b06145972e36cd6b4d72ad20dd10ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcf6e0215f538e1fc7f2a7eeca26a72"><td class="memItemLeft" align="right" valign="top"><a id="a7fcf6e0215f538e1fc7f2a7eeca26a72"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>category</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; int32_t, GDF_CATEGORY &gt;</td></tr>
<tr class="separator:a7fcf6e0215f538e1fc7f2a7eeca26a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3d8c2c1542347d5fe53eb5ea98d6c3"><td class="memItemLeft" align="right" valign="top"><a id="abf3d8c2c1542347d5fe53eb5ea98d6c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>nvstring_category</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; int32_t, GDF_STRING_CATEGORY &gt;</td></tr>
<tr class="separator:abf3d8c2c1542347d5fe53eb5ea98d6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81283c02853c54792443ac894fe9470"><td class="memItemLeft" align="right" valign="top"><a id="af81283c02853c54792443ac894fe9470"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; int64_t, GDF_TIMESTAMP &gt;</td></tr>
<tr class="separator:af81283c02853c54792443ac894fe9470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a02d06c7839eca9b32aa5eec7cb499"><td class="memItemLeft" align="right" valign="top"><a id="a53a02d06c7839eca9b32aa5eec7cb499"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>date32</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; int32_t, GDF_DATE32 &gt;</td></tr>
<tr class="separator:a53a02d06c7839eca9b32aa5eec7cb499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefd74f615ca0d9ff5d461ce0117980f"><td class="memItemLeft" align="right" valign="top"><a id="afefd74f615ca0d9ff5d461ce0117980f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>date64</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; int64_t, GDF_DATE64 &gt;</td></tr>
<tr class="separator:afefd74f615ca0d9ff5d461ce0117980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48f25f2c82bb07876001ae8f624e080"><td class="memItemLeft" align="right" valign="top"><a id="ad48f25f2c82bb07876001ae8f624e080"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bool8</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; int8_t, GDF_BOOL8 &gt;</td></tr>
<tr class="separator:ad48f25f2c82bb07876001ae8f624e080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9130d674f5ef432c1405fadd304a8c26"><td class="memTemplParams" colspan="2"><a id="a9130d674f5ef432c1405fadd304a8c26"></a>
template&lt;typename... &gt; </td></tr>
<tr class="memitem:a9130d674f5ef432c1405fadd304a8c26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>void_t</b> = void</td></tr>
<tr class="separator:a9130d674f5ef432c1405fadd304a8c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc1c1fe68e5031f9865b4d9114a2491"><td class="memTemplParams" colspan="2"><a id="a6cc1c1fe68e5031f9865b4d9114a2491"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a6cc1c1fe68e5031f9865b4d9114a2491"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>less_comparable</b> = decltype(std::declval&lt; L &gt;()&lt; std::declval&lt; R &gt;())</td></tr>
<tr class="separator:a6cc1c1fe68e5031f9865b4d9114a2491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a5866cc4b46bbff21bf863130d2f81"><td class="memTemplParams" colspan="2"><a id="a19a5866cc4b46bbff21bf863130d2f81"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a19a5866cc4b46bbff21bf863130d2f81"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>greater_comparable</b> = decltype(std::declval&lt; L &gt;() &gt; std::declval&lt; R &gt;())</td></tr>
<tr class="separator:a19a5866cc4b46bbff21bf863130d2f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f93751a82c0e8f38d39d52b5e19313"><td class="memTemplParams" colspan="2"><a id="a32f93751a82c0e8f38d39d52b5e19313"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32f93751a82c0e8f38d39d52b5e19313"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_timestamp_t</b> = simt::std::disjunction&lt; std::is_same&lt; <a class="el" href="namespacecudf.html#a177c346e93407722169284f15d260687">cudf::timestamp_D</a>, T &gt;, std::is_same&lt; <a class="el" href="namespacecudf.html#a3eb94ae284a4ec44c14765633fd6f0de">cudf::timestamp_s</a>, T &gt;, std::is_same&lt; <a class="el" href="namespacecudf.html#a1e65b98c47669295653e4fe59b66fe34">cudf::timestamp_ms</a>, T &gt;, std::is_same&lt; <a class="el" href="namespacecudf.html#a0455750f053fbc9234bd7f1478a8b8a2">cudf::timestamp_us</a>, T &gt;, std::is_same&lt; <a class="el" href="namespacecudf.html#a8090bb1d4eb05e199337b8e98fcdddbf">cudf::timestamp_ns</a>, T &gt; &gt;</td></tr>
<tr class="separator:a32f93751a82c0e8f38d39d52b5e19313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177c346e93407722169284f15d260687"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a177c346e93407722169284f15d260687">timestamp_D</a> = <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt; simt::std::chrono::duration&lt; int32_t, simt::std::ratio&lt; 86400 &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a177c346e93407722169284f15d260687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int32_t duration of days since the unix.  <a href="namespacecudf.html#a177c346e93407722169284f15d260687">More...</a><br /></td></tr>
<tr class="separator:a177c346e93407722169284f15d260687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb94ae284a4ec44c14765633fd6f0de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3eb94ae284a4ec44c14765633fd6f0de">timestamp_s</a> = <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt; simt::std::chrono::duration&lt; int64_t, simt::std::ratio&lt; 1 &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a3eb94ae284a4ec44c14765633fd6f0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int64_t duration of seconds since the.  <a href="namespacecudf.html#a3eb94ae284a4ec44c14765633fd6f0de">More...</a><br /></td></tr>
<tr class="separator:a3eb94ae284a4ec44c14765633fd6f0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e65b98c47669295653e4fe59b66fe34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a1e65b98c47669295653e4fe59b66fe34">timestamp_ms</a> = <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt; simt::std::chrono::duration&lt; int64_t, simt::std::milli &gt; &gt;</td></tr>
<tr class="memdesc:a1e65b98c47669295653e4fe59b66fe34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int64_t duration of milliseconds since.  <a href="namespacecudf.html#a1e65b98c47669295653e4fe59b66fe34">More...</a><br /></td></tr>
<tr class="separator:a1e65b98c47669295653e4fe59b66fe34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0455750f053fbc9234bd7f1478a8b8a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0455750f053fbc9234bd7f1478a8b8a2">timestamp_us</a> = <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt; simt::std::chrono::duration&lt; int64_t, simt::std::micro &gt; &gt;</td></tr>
<tr class="memdesc:a0455750f053fbc9234bd7f1478a8b8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int64_t duration of microseconds since.  <a href="namespacecudf.html#a0455750f053fbc9234bd7f1478a8b8a2">More...</a><br /></td></tr>
<tr class="separator:a0455750f053fbc9234bd7f1478a8b8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8090bb1d4eb05e199337b8e98fcdddbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a8090bb1d4eb05e199337b8e98fcdddbf">timestamp_ns</a> = <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt; simt::std::chrono::duration&lt; int64_t, simt::std::nano &gt; &gt;</td></tr>
<tr class="memdesc:a8090bb1d4eb05e199337b8e98fcdddbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int64_t duration of nanoseconds since.  <a href="namespacecudf.html#a8090bb1d4eb05e199337b8e98fcdddbf">More...</a><br /></td></tr>
<tr class="separator:a8090bb1d4eb05e199337b8e98fcdddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a267e03474dcfd85242d2fdc6e5846ec6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> { <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6a615857bddd061281abf998989fb2ba8f">NEVER</a>, 
<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, 
<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6a995bafc1b2e35df60002e61e2ec0c6df">ALWAYS</a>
 }</td></tr>
<tr class="separator:a267e03474dcfd85242d2fdc6e5846ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d60cf0790fb642cce1c91f1dba63c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8ab424744b6ce548ac355f5830c0a8c5e1">LINEAR</a> =0, 
<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8a00b75d21f696dc9d435e8b4b3c3bc58d">LOWER</a>, 
<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8ae5385a7a8eb742f08471ba73ea2d77ba">HIGHER</a>, 
<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8a7b5062e7868e9d05c598ef7ad6619014">MIDPOINT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8a04fd403d483f6415e0b006bc67bd8fac">NEAREST</a>
<br />
 }</td></tr>
<tr class="memdesc:a94d60cf0790fb642cce1c91f1dba63c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolation method to use, when the desired quantile lies between two data points i and j.  <a href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">More...</a><br /></td></tr>
<tr class="separator:a94d60cf0790fb642cce1c91f1dba63c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> { <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa86ea4bfd2b3121412b0a63a3697926ec">KEEP_FIRST</a> = 0, 
<a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa1d1398f646d74e801389737f07d89d1c">KEEP_LAST</a>, 
<a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3aa6fb3154b77231184b596b4add407aa2a">KEEP_NONE</a>
 }</td></tr>
<tr class="memdesc:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choices for drop_duplicates API for retainment of duplicate rows.  <a href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">More...</a><br /></td></tr>
<tr class="separator:a69091647ea1f9c9d4cdcf7c8876bea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15567f1034536ae6f7f14179334a19b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">unary_op</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6b585cf453d36fbb0381b38bc2c966e1">SIN</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19baf7c88ff3bee94b5c3c16c405706ef34a">COS</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19baa91cdd09214d36d756b5f13803ddd890">TAN</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba463397f416a024fb7df7d906a0436dbb">ARCSIN</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba1e17febbc6d14208d0a264562dcee2e9">ARCCOS</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19bad1c5c0c8ffe6bf038e617b0aad0f9aac">ARCTAN</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6e272b8c75625066b2c8994cec6c8f73">EXP</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba1509f8449abb15062ad85e15fb3861d7">LOG</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba6ac653ea3d15f23b0f6e61b447f783ea">SQRT</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba8b0d502b44d1472a2d5fa3638f0ce945">CEIL</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba07e330cc72f454a6369d267d1bfb2d7e">FLOOR</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19bab226be3789467f51f32cf06550a4c46e">ABS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba62a7f82a72f8422f631cb550b7201667">BIT_INVERT</a>, 
<a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19ba5e654d9830c09fc254d4f9f19fbdfe6e">NOT</a>
<br />
 }</td></tr>
<tr class="memdesc:ab15567f1034536ae6f7f14179334a19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of unary operations that can be performed on data.  <a href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">More...</a><br /></td></tr>
<tr class="separator:ab15567f1034536ae6f7f14179334a19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750f02016b046079f7062d334890b4fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">order</a> : bool { <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fca83ec681a20197326c163ea3b39ef7c32">order::ASCENDING</a>, 
<a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fcacff818f0ae4cef845577e39283886a53">order::DESCENDING</a>
 }</td></tr>
<tr class="separator:a750f02016b046079f7062d334890b4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e6d6e8a21583ce0e85ee73e5abb31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> : bool { <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb">null_order::AFTER</a>, 
<a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07">null_order::BEFORE</a>
 }</td></tr>
<tr class="separator:a058e6d6e8a21583ce0e85ee73e5abb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa481249b705132999f4d082aacd21dbf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> { <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a>, 
<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa37d7c1f4781c3276729ed1678c0c0844">UNINITIALIZED</a>, 
<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfadb86173d779f7b173db120643cc1c402">ALL_VALID</a>, 
<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa042cac70175410616150fafb92f76351">ALL_NULL</a>
 }</td></tr>
<tr class="separator:aa481249b705132999f4d082aacd21dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4cd7157c4379954b5772936f89c59b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">type_id</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59bab2c14e467fcbf9a215ccc679f35bb027">EMPTY</a> = 0, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba71f4b0467efae61c1e3ac5910178940f">INT8</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba7dafa1ea3755308998ff8c972342c099">INT16</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae">INT32</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59bab9c234f82eec5cb83e3ea67aac9c1166">INT64</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba37225001c5ad4b3d1aa808620debfe7a">FLOAT32</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59baf24707a0d5537fd50bca87cd18a9a0e5">FLOAT64</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba9100ee556e5cf9b6dada6c7c506fa138">BOOL8</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba8a653791c2c90530cd2452ef46a01ab2">TIMESTAMP_DAYS</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba75e3c065f03583dc3b94ec069c4fe34d">TIMESTAMP_SECONDS</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba5cb4e0f1d7d608d8801707a376e43b64">TIMESTAMP_MILLISECONDS</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59bab892ce722f86206a6496700f2c4a3abf">TIMESTAMP_MICROSECONDS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba9864c6a53387a840e7c6ed2672fed2c9">TIMESTAMP_NANOSECONDS</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59baabcc7f7b028da5bba90f587958cc1026">CATEGORY</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59bae008ab0db4e9b28f33e1e3c9c3daf444">STRING</a>, 
<a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59ba0f6b1e874ab643a0f237082cb35acad5">NUM_TYPE_IDS</a>
<br />
 }</td></tr>
<tr class="separator:acd4cd7157c4379954b5772936f89c59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae942e9a8d320f23d61bee22ddc06df55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae942e9a8d320f23d61bee22ddc06df55">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *lhs, <a class="el" href="structgdf__column__.html">gdf_column</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:ae942e9a8d320f23d61bee22ddc06df55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> and a gdf_column.  <a href="namespacecudf.html#ae942e9a8d320f23d61bee22ddc06df55">More...</a><br /></td></tr>
<tr class="separator:ae942e9a8d320f23d61bee22ddc06df55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02af1454978d7d7f7b9f651437b3ab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa02af1454978d7d7f7b9f651437b3ab5">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__column__.html">gdf_column</a> *lhs, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:aa02af1454978d7d7f7b9f651437b3ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a gdf_column and a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a>.  <a href="namespacecudf.html#aa02af1454978d7d7f7b9f651437b3ab5">More...</a><br /></td></tr>
<tr class="separator:aa02af1454978d7d7f7b9f651437b3ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad01e2e81bc2b671dfb8963a7be22e3b0">binary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out, <a class="el" href="structgdf__column__.html">gdf_column</a> *lhs, <a class="el" href="structgdf__column__.html">gdf_column</a> *rhs, gdf_binary_operator ope)</td></tr>
<tr class="memdesc:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two gdf_columns.  <a href="namespacecudf.html#ad01e2e81bc2b671dfb8963a7be22e3b0">More...</a><br /></td></tr>
<tr class="separator:ad01e2e81bc2b671dfb8963a7be22e3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f727c257f82efc1a7b144eb6dcbb2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a1f727c257f82efc1a7b144eb6dcbb2d8">binary_operation</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;lhs, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;rhs, const std::string &amp;ptx, gdf_dtype output_type)</td></tr>
<tr class="memdesc:a1f727c257f82efc1a7b144eb6dcbb2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two gdf_columns using a user-defined PTX function.  <a href="namespacecudf.html#a1f727c257f82efc1a7b144eb6dcbb2d8">More...</a><br /></td></tr>
<tr class="separator:a1f727c257f82efc1a7b144eb6dcbb2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="memItemLeft" align="right" valign="top">rmm::device_vector&lt; bit_mask::bit_mask_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aec006bc00092dd8ec47f2c7ca6fe01d4">row_bitmask</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a bitmask indicating the presence of NULL values in rows of a table.  <a href="namespacecudf.html#aec006bc00092dd8ec47f2c7ca6fe01d4">More...</a><br /></td></tr>
<tr class="separator:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084ff0262deda4407ff67857cf1660c0"><td class="memTemplParams" colspan="2">template&lt;typename bit_container , typename predicate , typename size_type &gt; </td></tr>
<tr class="memitem:a084ff0262deda4407ff67857cf1660c0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bit_container *, size_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a084ff0262deda4407ff67857cf1660c0">valid_if</a> (const bit_container *source_mask, const predicate &amp;p, size_type num_bits, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a084ff0262deda4407ff67857cf1660c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a bitmask where every bit is marked with valid if and only if predicate(bit) and source_mask(bit) are both true.  <a href="namespacecudf.html#a084ff0262deda4407ff67857cf1660c0">More...</a><br /></td></tr>
<tr class="separator:a084ff0262deda4407ff67857cf1660c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48561f1e899da3a79132c108463840de"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a48561f1e899da3a79132c108463840de">state_null_count</a> (<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> state, size_type size)</td></tr>
<tr class="memdesc:a48561f1e899da3a79132c108463840de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the null count for a null mask of the specified <code>state</code> representing <code>size</code> elements.  <a href="namespacecudf.html#a48561f1e899da3a79132c108463840de">More...</a><br /></td></tr>
<tr class="separator:a48561f1e899da3a79132c108463840de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26b8cbca80321602bc3f39ab6cce8d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3c26b8cbca80321602bc3f39ab6cce8d">bitmask_allocation_size_bytes</a> (size_type number_of_bits, std::size_t padding_boundary=64)</td></tr>
<tr class="memdesc:a3c26b8cbca80321602bc3f39ab6cce8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the required bytes necessary to represent the specified number of bits with a given padding boundary.  <a href="namespacecudf.html#a3c26b8cbca80321602bc3f39ab6cce8d">More...</a><br /></td></tr>
<tr class="separator:a3c26b8cbca80321602bc3f39ab6cce8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62014db2c1d82cbd2f3e067d27088ab"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad62014db2c1d82cbd2f3e067d27088ab">num_bitmask_words</a> (size_type number_of_bits)</td></tr>
<tr class="memdesc:ad62014db2c1d82cbd2f3e067d27088ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <code>bitmask_type</code> words required to represent the specified number of bits.  <a href="namespacecudf.html#ad62014db2c1d82cbd2f3e067d27088ab">More...</a><br /></td></tr>
<tr class="separator:ad62014db2c1d82cbd2f3e067d27088ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5834edc8cde53fb6b23f2e95847c8066"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5834edc8cde53fb6b23f2e95847c8066">create_null_mask</a> (size_type size, <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> state, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a5834edc8cde53fb6b23f2e95847c8066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>device_buffer</code> for use as a null value indicator bitmask of a <code>column</code>.  <a href="namespacecudf.html#a5834edc8cde53fb6b23f2e95847c8066">More...</a><br /></td></tr>
<tr class="separator:a5834edc8cde53fb6b23f2e95847c8066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a5ec95d99413d1f5f37124bc33fd83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a96a5ec95d99413d1f5f37124bc33fd83">set_null_mask</a> (bitmask_type *bitmask, size_type size, bool valid, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a96a5ec95d99413d1f5f37124bc33fd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pre-allocated bitmask buffer to a given state.  <a href="namespacecudf.html#a96a5ec95d99413d1f5f37124bc33fd83">More...</a><br /></td></tr>
<tr class="separator:a96a5ec95d99413d1f5f37124bc33fd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8405a236b985ea3d8a626f92e40658c"><td class="memItemLeft" align="right" valign="top">cudf::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae8405a236b985ea3d8a626f92e40658c">count_set_bits</a> (bitmask_type const  *bitmask, size_type start, size_type stop)</td></tr>
<tr class="memdesc:ae8405a236b985ea3d8a626f92e40658c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bitmask, counts the number of set (1) bits in the range <code>[start, stop)</code>  <a href="namespacecudf.html#ae8405a236b985ea3d8a626f92e40658c">More...</a><br /></td></tr>
<tr class="separator:ae8405a236b985ea3d8a626f92e40658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff1677d6e025ceb78e4fdc631125170"><td class="memItemLeft" align="right" valign="top">cudf::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aeff1677d6e025ceb78e4fdc631125170">count_unset_bits</a> (bitmask_type const  *bitmask, size_type start, size_type stop)</td></tr>
<tr class="memdesc:aeff1677d6e025ceb78e4fdc631125170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bitmask, counts the number of unset (0) bits in the range <code>[start, stop)</code>.  <a href="namespacecudf.html#aeff1677d6e025ceb78e4fdc631125170">More...</a><br /></td></tr>
<tr class="separator:aeff1677d6e025ceb78e4fdc631125170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17512d5f18a405bff0ec9b9987eaed6e"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a17512d5f18a405bff0ec9b9987eaed6e">copy_bitmask</a> (bitmask_type const  *mask, size_type begin_bit, size_type end_bit, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a17512d5f18a405bff0ec9b9987eaed6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>device_buffer</code> from a slice of bitmask defined by a range of indices <code>[begin_bit, end_bit)</code>.  <a href="namespacecudf.html#a17512d5f18a405bff0ec9b9987eaed6e">More...</a><br /></td></tr>
<tr class="separator:a17512d5f18a405bff0ec9b9987eaed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0483dfaa7c4ef5878988f5a1ee0345cd"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0483dfaa7c4ef5878988f5a1ee0345cd">copy_bitmask</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;view, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a0483dfaa7c4ef5878988f5a1ee0345cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>view</code>'s bitmask from the bits <code>[view.offset(), view.offset() + view.size())</code> into a <code>device_buffer</code>  <a href="namespacecudf.html#a0483dfaa7c4ef5878988f5a1ee0345cd">More...</a><br /></td></tr>
<tr class="separator:a0483dfaa7c4ef5878988f5a1ee0345cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfd5d8fe7e7ece5f642d95bc0640ffe"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#adcfd5d8fe7e7ece5f642d95bc0640ffe">concatenate_masks</a> (std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; const &amp;views, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:adcfd5d8fe7e7ece5f642d95bc0640ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <code>views[i]</code>'s bitmask from the bits <code>[views[i].offset(), views[i].offset() + views[i].size())</code> for all elements views[i] in views into a <code>device_buffer</code>  <a href="namespacecudf.html#adcfd5d8fe7e7ece5f642d95bc0640ffe">More...</a><br /></td></tr>
<tr class="separator:adcfd5d8fe7e7ece5f642d95bc0640ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79e6af7c78b2aac90456cfcd20cd7db"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad79e6af7c78b2aac90456cfcd20cd7db">bitmask_and</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;view, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:ad79e6af7c78b2aac90456cfcd20cd7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitwise AND of the bitmasks of columns of a table.  <a href="namespacecudf.html#ad79e6af7c78b2aac90456cfcd20cd7db">More...</a><br /></td></tr>
<tr class="separator:ad79e6af7c78b2aac90456cfcd20cd7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d275bb55b8c0ac520f23f371d92e2b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a24d275bb55b8c0ac520f23f371d92e2b">concatenate</a> (std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; const  &amp;columns_to_concat, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a24d275bb55b8c0ac520f23f371d92e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple columns into a single column.  <a href="namespacecudf.html#a24d275bb55b8c0ac520f23f371d92e2b">More...</a><br /></td></tr>
<tr class="separator:a24d275bb55b8c0ac520f23f371d92e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b0daf2c01663d51cb3b87ad8ce93c0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a51b0daf2c01663d51cb3b87ad8ce93c0">size_of</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> t)</td></tr>
<tr class="memdesc:a51b0daf2c01663d51cb3b87ad8ce93c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of elements of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>  <a href="namespacecudf.html#a51b0daf2c01663d51cb3b87ad8ce93c0">More...</a><br /></td></tr>
<tr class="separator:a51b0daf2c01663d51cb3b87ad8ce93c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80de7d88a408ab660541a4a3b214ead"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa80de7d88a408ab660541a4a3b214ead">make_empty_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:aa80de7d88a408ab660541a4a3b214ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty column of the specified <code>type</code>.  <a href="namespacecudf.html#aa80de7d88a408ab660541a4a3b214ead">More...</a><br /></td></tr>
<tr class="separator:aa80de7d88a408ab660541a4a3b214ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67659a0dfb8fb06d47d196b59544e9f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae67659a0dfb8fb06d47d196b59544e9f">make_numeric_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> state=<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ae67659a0dfb8fb06d47d196b59544e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <a href="namespacecudf.html#ae67659a0dfb8fb06d47d196b59544e9f">More...</a><br /></td></tr>
<tr class="separator:ae67659a0dfb8fb06d47d196b59544e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc58612aa9425021086af0e7be540be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aebc58612aa9425021086af0e7be540be">make_timestamp_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> state=<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:aebc58612aa9425021086af0e7be540be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <a href="namespacecudf.html#aebc58612aa9425021086af0e7be540be">More...</a><br /></td></tr>
<tr class="separator:aebc58612aa9425021086af0e7be540be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5606fb76c3a0dc7fddd3de54745f8f18"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5606fb76c3a0dc7fddd3de54745f8f18">make_fixed_width_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a> state=<a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a5606fb76c3a0dc7fddd3de54745f8f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <a href="namespacecudf.html#a5606fb76c3a0dc7fddd3de54745f8f18">More...</a><br /></td></tr>
<tr class="separator:a5606fb76c3a0dc7fddd3de54745f8f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef675a9c75a848ab796ae9b2b51c4238"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aef675a9c75a848ab796ae9b2b51c4238">count_descendants</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> parent)</td></tr>
<tr class="memdesc:aef675a9c75a848ab796ae9b2b51c4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of descendants of the specified parent.  <a href="namespacecudf.html#aef675a9c75a848ab796ae9b2b51c4238">More...</a><br /></td></tr>
<tr class="separator:aef675a9c75a848ab796ae9b2b51c4238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbb86eb24e5093dcddeb0a0640b768f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3fbb86eb24e5093dcddeb0a0640b768f">allocate_column</a> (gdf_dtype dtype, cudf::size_type size, bool allocate_mask=true, <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> info=<a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>{}, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a3fbb86eb24e5093dcddeb0a0640b768f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new column of the specified size and type.  <a href="namespacecudf.html#a3fbb86eb24e5093dcddeb0a0640b768f">More...</a><br /></td></tr>
<tr class="separator:a3fbb86eb24e5093dcddeb0a0640b768f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206ad1cc4b21f7f14c5d5f7d304efbda"><td class="memItemLeft" align="right" valign="top"><a id="a206ad1cc4b21f7f14c5d5f7d304efbda"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><b>empty_like</b> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input)</td></tr>
<tr class="separator:a206ad1cc4b21f7f14c5d5f7d304efbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67e312abf9656990598ba81dfcef15c"><td class="memItemLeft" align="right" valign="top"><a id="ae67e312abf9656990598ba81dfcef15c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>should_allocate_mask</b> (<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc, bool mask_exists)</td></tr>
<tr class="separator:ae67e312abf9656990598ba81dfcef15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72ee052f776990ab9240e757d8493ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ac72ee052f776990ab9240e757d8493ad">allocate_like</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:ac72ee052f776990ab9240e757d8493ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new column of the same size and type as the input.  <a href="namespacecudf.html#ac72ee052f776990ab9240e757d8493ad">More...</a><br /></td></tr>
<tr class="separator:ac72ee052f776990ab9240e757d8493ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cd23de19c39850cb4869f83c6b73da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#af4cd23de19c39850cb4869f83c6b73da">allocate_like</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, cudf::size_type size, <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:af4cd23de19c39850cb4869f83c6b73da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new column of the specified size and same type as the input.  <a href="namespacecudf.html#af4cd23de19c39850cb4869f83c6b73da">More...</a><br /></td></tr>
<tr class="separator:af4cd23de19c39850cb4869f83c6b73da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa7e6bf39cb5dd5cdb370d0a562675922">copy</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column that is a copy of input.  <a href="namespacecudf.html#aa7e6bf39cb5dd5cdb370d0a562675922">More...</a><br /></td></tr>
<tr class="separator:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3588fc0b833a8f2d7213651a05f48c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3588fc0b833a8f2d7213651a05f48c80">empty_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t)</td></tr>
<tr class="memdesc:a3588fc0b833a8f2d7213651a05f48c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of empty columns with the same types as the inputs.  <a href="namespacecudf.html#a3588fc0b833a8f2d7213651a05f48c80">More...</a><br /></td></tr>
<tr class="separator:a3588fc0b833a8f2d7213651a05f48c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada80dc11907eac4cd65640233b777452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ada80dc11907eac4cd65640233b777452">allocate_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:ada80dc11907eac4cd65640233b777452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns with the same type and allocation size as the input.  <a href="namespacecudf.html#ada80dc11907eac4cd65640233b777452">More...</a><br /></td></tr>
<tr class="separator:ada80dc11907eac4cd65640233b777452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4654d206fea417b13b245c085771ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#afd4654d206fea417b13b245c085771ee">allocate_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, cudf::size_type size, <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a>, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:afd4654d206fea417b13b245c085771ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns with the specified size and same type as the input.  <a href="namespacecudf.html#afd4654d206fea417b13b245c085771ee">More...</a><br /></td></tr>
<tr class="separator:afd4654d206fea417b13b245c085771ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a9fae65b5e23d13aec03edef7a8aeacb0">copy</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns and deep copies the data from an input table.  <a href="namespacecudf.html#a9fae65b5e23d13aec03edef7a8aeacb0">More...</a><br /></td></tr>
<tr class="separator:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dad593f28fe6f5f4d412794540e3ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a09dad593f28fe6f5f4d412794540e3ba">copy_range</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *out_column, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;in_column, cudf::size_type out_begin, cudf::size_type out_end, cudf::size_type in_begin)</td></tr>
<tr class="memdesc:a09dad593f28fe6f5f4d412794540e3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements from one column to another.  <a href="namespacecudf.html#a09dad593f28fe6f5f4d412794540e3ba">More...</a><br /></td></tr>
<tr class="separator:a09dad593f28fe6f5f4d412794540e3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3571c0c6314b622d87a18281ad08e212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3571c0c6314b622d87a18281ad08e212">gather</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, <a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;gather_map, bool check_bounds=false)</td></tr>
<tr class="memdesc:a3571c0c6314b622d87a18281ad08e212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the the specified rows (including null values) of a set of columns, returning the result as a <code>table</code>.  <a href="namespacecudf.html#a3571c0c6314b622d87a18281ad08e212">More...</a><br /></td></tr>
<tr class="separator:a3571c0c6314b622d87a18281ad08e212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89365977c2da3d50a3262a1e540d1352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a89365977c2da3d50a3262a1e540d1352">gather</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, <a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;gather_map, <a class="el" href="structcudf_1_1table.html">table</a> *destination_table, bool check_bounds=false)</td></tr>
<tr class="memdesc:a89365977c2da3d50a3262a1e540d1352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows (including null values) of a set of source columns into a set of destination columns.  <a href="namespacecudf.html#a89365977c2da3d50a3262a1e540d1352">More...</a><br /></td></tr>
<tr class="separator:a89365977c2da3d50a3262a1e540d1352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e37d2953ec00878b60fa9626da49f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a6e37d2953ec00878b60fa9626da49f29">gather</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, cudf::size_type const gather_map[], <a class="el" href="structcudf_1_1table.html">table</a> *destination_table, bool check_bounds=false)</td></tr>
<tr class="memdesc:a6e37d2953ec00878b60fa9626da49f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows (including null values) of a set of source columns into a set of destination columns.  <a href="namespacecudf.html#a6e37d2953ec00878b60fa9626da49f29">More...</a><br /></td></tr>
<tr class="separator:a6e37d2953ec00878b60fa9626da49f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ee593defbe8e2fcaa05b50fbd6612e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae9ee593defbe8e2fcaa05b50fbd6612e">scatter</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;source, <a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;scatter_map, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;target, bool check_bounds=false)</td></tr>
<tr class="memdesc:ae9ee593defbe8e2fcaa05b50fbd6612e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>table</code> as if an in-place scatter from a <code>source</code> table was performed on the <code>target</code> table.  <a href="namespacecudf.html#ae9ee593defbe8e2fcaa05b50fbd6612e">More...</a><br /></td></tr>
<tr class="separator:ae9ee593defbe8e2fcaa05b50fbd6612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f6b4e349cd583550839de7221464d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae8f6b4e349cd583550839de7221464d9">scatter</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;source, cudf::size_type const scatter_map[], <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;target, bool check_bounds=false)</td></tr>
<tr class="memdesc:ae8f6b4e349cd583550839de7221464d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>table</code> as if an in-place scatter from a <code>source</code> table was performed on the <code>target</code> table.  <a href="namespacecudf.html#ae8f6b4e349cd583550839de7221464d9">More...</a><br /></td></tr>
<tr class="separator:ae8f6b4e349cd583550839de7221464d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be522d016a38551534b8bd107d16cde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a2be522d016a38551534b8bd107d16cde">scatter</a> (std::vector&lt; <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &gt; const  &amp;source, cudf::size_type const scatter_map[], cudf::size_type num_scatter_rows, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;target)</td></tr>
<tr class="memdesc:a2be522d016a38551534b8bd107d16cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>table</code> as if scattering a set of <code><a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a></code> values into the rows of a <code>target</code> table in-place.  <a href="namespacecudf.html#a2be522d016a38551534b8bd107d16cde">More...</a><br /></td></tr>
<tr class="separator:a2be522d016a38551534b8bd107d16cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa398ba021c84cb39c9e1dcd65d81b64"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaa398ba021c84cb39c9e1dcd65d81b64">scatter_to_tables</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;input, <a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;scatter_map)</td></tr>
<tr class="memdesc:aaa398ba021c84cb39c9e1dcd65d81b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of a table to <code>n</code> tables according to a scatter map.  <a href="namespacecudf.html#aaa398ba021c84cb39c9e1dcd65d81b64">More...</a><br /></td></tr>
<tr class="separator:aaa398ba021c84cb39c9e1dcd65d81b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2052fccb1d1278d538c598cda51e0b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a4c2052fccb1d1278d538c598cda51e0b">slice</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input, cudf::size_type const  *indices, cudf::size_type num_indices)</td></tr>
<tr class="memdesc:a4c2052fccb1d1278d538c598cda51e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a column (including null values) into a set of columns according to a set of indices.  <a href="namespacecudf.html#a4c2052fccb1d1278d538c598cda51e0b">More...</a><br /></td></tr>
<tr class="separator:a4c2052fccb1d1278d538c598cda51e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eccb66e7e41c2dd5008136b1b4b320d"><td class="memItemLeft" align="right" valign="top"><a id="a2eccb66e7e41c2dd5008136b1b4b320d"></a>
rmm::device_vector&lt; cudf::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>splits_to_slice_indices</b> (cudf::size_type const *splits, cudf::size_type const num_splits, cudf::size_type const split_end)</td></tr>
<tr class="separator:a2eccb66e7e41c2dd5008136b1b4b320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6b5215c4e4be3ee20f107451d81411"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a7d6b5215c4e4be3ee20f107451d81411">split</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input, cudf::size_type const  *splits, cudf::size_type num_splits)</td></tr>
<tr class="memdesc:a7d6b5215c4e4be3ee20f107451d81411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a column (including null values) into a set of columns according to a set of indices.  <a href="namespacecudf.html#a7d6b5215c4e4be3ee20f107451d81411">More...</a><br /></td></tr>
<tr class="separator:a7d6b5215c4e4be3ee20f107451d81411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96182c5521d8723e0a2a0532d2c39bb1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a96182c5521d8723e0a2a0532d2c39bb1">from_dlpack</a> (DLManagedTensor const  *managed_tensor, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a96182c5521d8723e0a2a0532d2c39bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DLPack DLTensor into a cudf table.  <a href="namespacecudf.html#a96182c5521d8723e0a2a0532d2c39bb1">More...</a><br /></td></tr>
<tr class="separator:a96182c5521d8723e0a2a0532d2c39bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bafde3c29e61d8443804eac18a22c87"><td class="memItemLeft" align="right" valign="top">DLManagedTensor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0bafde3c29e61d8443804eac18a22c87">to_dlpack</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a0bafde3c29e61d8443804eac18a22c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a cudf table into a DLPack DLTensor.  <a href="namespacecudf.html#a0bafde3c29e61d8443804eac18a22c87">More...</a><br /></td></tr>
<tr class="separator:a0bafde3c29e61d8443804eac18a22c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4c06ce5a604ed1019a523036529b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a9e4c06ce5a604ed1019a523036529b83">fill</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *<a class="el" href="classcudf_1_1column.html">column</a>, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> const  &amp;value, cudf::size_type begin, cudf::size_type end)</td></tr>
<tr class="memdesc:a9e4c06ce5a604ed1019a523036529b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in a column with a scalar value.  <a href="namespacecudf.html#a9e4c06ce5a604ed1019a523036529b83">More...</a><br /></td></tr>
<tr class="separator:a9e4c06ce5a604ed1019a523036529b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c4ffa4dba2b1e23f4f4322f7b06408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae7c4ffa4dba2b1e23f4f4322f7b06408">repeat</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;in, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;count)</td></tr>
<tr class="memdesc:ae7c4ffa4dba2b1e23f4f4322f7b06408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <a href="namespacecudf.html#ae7c4ffa4dba2b1e23f4f4322f7b06408">More...</a><br /></td></tr>
<tr class="separator:ae7c4ffa4dba2b1e23f4f4322f7b06408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00deb58e53fc1648eb5dce3e79d0790c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a00deb58e53fc1648eb5dce3e79d0790c">repeat</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;in, const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;count)</td></tr>
<tr class="memdesc:a00deb58e53fc1648eb5dce3e79d0790c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <a href="namespacecudf.html#a00deb58e53fc1648eb5dce3e79d0790c">More...</a><br /></td></tr>
<tr class="separator:a00deb58e53fc1648eb5dce3e79d0790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8135c27fbc0411c711c13f7ac77733d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ac8135c27fbc0411c711c13f7ac77733d">tile</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;in, gdf_size_type count)</td></tr>
<tr class="memdesc:ac8135c27fbc0411c711c13f7ac77733d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new table by tiling the input table.  <a href="namespacecudf.html#ac8135c27fbc0411c711c13f7ac77733d">More...</a><br /></td></tr>
<tr class="separator:ac8135c27fbc0411c711c13f7ac77733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9637af7bcb33dfc0b080aa1c1a24e2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;, std::vector&lt; size_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a1a9637af7bcb33dfc0b080aa1c1a24e2">hash_partition</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, std::vector&lt; size_type &gt; const  &amp;columns_to_hash, int num_partitions, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a1a9637af7bcb33dfc0b080aa1c1a24e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions rows from the input table into multiple output tables.  <a href="namespacecudf.html#a1a9637af7bcb33dfc0b080aa1c1a24e2">More...</a><br /></td></tr>
<tr class="separator:a1a9637af7bcb33dfc0b080aa1c1a24e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e682abfb2a17865a3d4d94b24f9e5a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a4e682abfb2a17865a3d4d94b24f9e5a3">hash</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, std::vector&lt; uint32_t &gt; const  &amp;initial_hash={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a4e682abfb2a17865a3d4d94b24f9e5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of each row in the input set of columns.  <a href="namespacecudf.html#a4e682abfb2a17865a3d4d94b24f9e5a3">More...</a><br /></td></tr>
<tr class="separator:a4e682abfb2a17865a3d4d94b24f9e5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b0228c369a3729572f77dcbbe490be"><td class="memItemLeft" align="right" valign="top"><a id="a10b0228c369a3729572f77dcbbe490be"></a>
std::pair&lt; gdf_dtype, <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convertStringToDtype</b> (const std::string &amp;dtype)</td></tr>
<tr class="separator:a10b0228c369a3729572f77dcbbe490be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180c2173acf91cbac095cf4bd02c6089"><td class="memItemLeft" align="right" valign="top"><a id="a180c2173acf91cbac095cf4bd02c6089"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>infer_compression_type</b> (const std::string &amp;compression_arg, const std::string &amp;filename, const std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; &amp;ext_to_comp_map)</td></tr>
<tr class="separator:a180c2173acf91cbac095cf4bd02c6089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7969fa8f427959b25681e979ea2c01a"><td class="memItemLeft" align="right" valign="top"><a id="aa7969fa8f427959b25681e979ea2c01a"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_avro</b> (<a class="el" href="structcudf_1_1avro__read__arg.html">avro_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:aa7969fa8f427959b25681e979ea2c01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59a215482cdc7bc3ba850d2a0fa9f86"><td class="memItemLeft" align="right" valign="top"><a id="ab59a215482cdc7bc3ba850d2a0fa9f86"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_csv</b> (<a class="el" href="structcudf_1_1csv__read__arg.html">csv_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:ab59a215482cdc7bc3ba850d2a0fa9f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2430dcb97885610d55a2ddc34f7e8c1e"><td class="memItemLeft" align="right" valign="top"><a id="a2430dcb97885610d55a2ddc34f7e8c1e"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_json</b> (<a class="el" href="structcudf_1_1json__read__arg.html">json_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:a2430dcb97885610d55a2ddc34f7e8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ad77aef16f9ee3607c92778e14417"><td class="memItemLeft" align="right" valign="top"><a id="af36ad77aef16f9ee3607c92778e14417"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_orc</b> (<a class="el" href="structcudf_1_1orc__read__arg.html">orc_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:af36ad77aef16f9ee3607c92778e14417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67681fe72eda8509719c0ba70c1d12c"><td class="memItemLeft" align="right" valign="top"><a id="af67681fe72eda8509719c0ba70c1d12c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_orc</b> (<a class="el" href="structcudf_1_1orc__write__arg.html">orc_write_arg</a> const &amp;args)</td></tr>
<tr class="separator:af67681fe72eda8509719c0ba70c1d12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67516b133f0735f23f0024f86d8756d8"><td class="memItemLeft" align="right" valign="top"><a id="a67516b133f0735f23f0024f86d8756d8"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_parquet</b> (<a class="el" href="structcudf_1_1parquet__read__arg.html">parquet_read_arg</a> const &amp;args)</td></tr>
<tr class="separator:a67516b133f0735f23f0024f86d8756d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5315ca38e017e2ed42a400483bba3b56"><td class="memTemplParams" colspan="2">template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;cudf::size_type&gt;&gt; </td></tr>
<tr class="memitem:a5315ca38e017e2ed42a400483bba3b56"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5315ca38e017e2ed42a400483bba3b56">make_iterator</a> (const ElementType *data, const bit_mask::bit_mask_t *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="memdesc:a5315ca38e017e2ed42a400483bba3b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an iterator over the elements of a column.  <a href="namespacecudf.html#a5315ca38e017e2ed42a400483bba3b56">More...</a><br /></td></tr>
<tr class="separator:a5315ca38e017e2ed42a400483bba3b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe08330ff86be12d805f6a662e023a8"><td class="memTemplParams" colspan="2"><a id="a8fe08330ff86be12d805f6a662e023a8"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;cudf::size_type&gt;&gt; </td></tr>
<tr class="memitem:a8fe08330ff86be12d805f6a662e023a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_iterator</b> (const ElementType *data, const cudf::valid_type *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a8fe08330ff86be12d805f6a662e023a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memTemplParams" colspan="2"><a id="af06d674f7e1bd773e4166ef4d7fcf959"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;cudf::size_type&gt;&gt; </td></tr>
<tr class="memitem:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_iterator</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:af06d674f7e1bd773e4166ef4d7fcf959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memTemplParams" colspan="2">template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;cudf::size_type&gt;&gt; </td></tr>
<tr class="memitem:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a20b11ec1348ab46ae20792ea4e2c0ca4">make_pair_iterator</a> (const ElementType *data, const bit_mask::bit_mask_t *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="memdesc:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an iterator over the elements of a column Input iterator which can be used for cub and thrust.  <a href="namespacecudf.html#a20b11ec1348ab46ae20792ea4e2c0ca4">More...</a><br /></td></tr>
<tr class="separator:a20b11ec1348ab46ae20792ea4e2c0ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45743caade405cc99319bd95c2eaeb4e"><td class="memTemplParams" colspan="2"><a id="a45743caade405cc99319bd95c2eaeb4e"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;cudf::size_type&gt;&gt; </td></tr>
<tr class="memitem:a45743caade405cc99319bd95c2eaeb4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pair_iterator</b> (const ElementType *data, const cudf::valid_type *valid=nullptr, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a45743caade405cc99319bd95c2eaeb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f930d43783b2f9ff84a219b19d245"><td class="memTemplParams" colspan="2"><a id="a657f930d43783b2f9ff84a219b19d245"></a>
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;cudf::size_type&gt;&gt; </td></tr>
<tr class="memitem:a657f930d43783b2f9ff84a219b19d245"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pair_iterator</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>, ResultType identity=ResultType{0}, Iterator_Index const it=Iterator_Index(0))</td></tr>
<tr class="separator:a657f930d43783b2f9ff84a219b19d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325cbb27e6779a8d235f11f92979bb1f"><td class="memTemplParams" colspan="2">template&lt;typename data_type &gt; </td></tr>
<tr class="memitem:a325cbb27e6779a8d235f11f92979bb1f"><td class="memTemplItemLeft" align="right" valign="top">gdf_error&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a325cbb27e6779a8d235f11f92979bb1f">allocValueBuffer</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> **buffer, const cudf::size_type buffer_length, const <a class="el" href="classcudf_1_1data__type.html">data_type</a> value)</td></tr>
<tr class="memdesc:a325cbb27e6779a8d235f11f92979bb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer and fills it with a repeated value.  <a href="namespacecudf.html#a325cbb27e6779a8d235f11f92979bb1f">More...</a><br /></td></tr>
<tr class="separator:a325cbb27e6779a8d235f11f92979bb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ef104e8889becc66feebc7bf8aaf0e"><td class="memTemplParams" colspan="2">template&lt;typename data_type &gt; </td></tr>
<tr class="memitem:a99ef104e8889becc66feebc7bf8aaf0e"><td class="memTemplItemLeft" align="right" valign="top">gdf_error&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a99ef104e8889becc66feebc7bf8aaf0e">allocSequenceBuffer</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> **buffer, const cudf::size_type buffer_length)</td></tr>
<tr class="memdesc:a99ef104e8889becc66feebc7bf8aaf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer and fills it with a sequence.  <a href="namespacecudf.html#a99ef104e8889becc66feebc7bf8aaf0e">More...</a><br /></td></tr>
<tr class="separator:a99ef104e8889becc66feebc7bf8aaf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f36dd8856235cc97ba5c260b81d45bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0f36dd8856235cc97ba5c260b81d45bf">trivial_full_join</a> (const cudf::size_type left_size, const cudf::size_type right_size, <a class="el" href="structgdf__column__.html">gdf_column</a> *left_result, <a class="el" href="structgdf__column__.html">gdf_column</a> *right_result)</td></tr>
<tr class="memdesc:a0f36dd8856235cc97ba5c260b81d45bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivially computes full join of two tables if one of the tables are empty.  <a href="namespacecudf.html#a0f36dd8856235cc97ba5c260b81d45bf">More...</a><br /></td></tr>
<tr class="separator:a0f36dd8856235cc97ba5c260b81d45bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324e3af1901162a99c4e182255e63964"><td class="memTemplParams" colspan="2">template&lt;JoinType join_type&gt; </td></tr>
<tr class="memitem:a324e3af1901162a99c4e182255e63964"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a324e3af1901162a99c4e182255e63964">join_call</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, <a class="el" href="structgdf__column__.html">gdf_column</a> *left_result, <a class="el" href="structgdf__column__.html">gdf_column</a> *right_result, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="memdesc:a324e3af1901162a99c4e182255e63964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the join operation between two sets of columns.  <a href="namespacecudf.html#a324e3af1901162a99c4e182255e63964">More...</a><br /></td></tr>
<tr class="separator:a324e3af1901162a99c4e182255e63964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdf6b2cb89dd765ce5ca6a507a143c3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aecdf6b2cb89dd765ce5ca6a507a143c3">non_common_column_indices</a> (cudf::size_type num_columns, std::vector&lt; cudf::size_type &gt; const &amp;common_column_indices)</td></tr>
<tr class="memdesc:aecdf6b2cb89dd765ce5ca6a507a143c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with non-common indices which is set difference between <code>[0, num_columns)</code> and index values in common_column_indices.  <a href="namespacecudf.html#aecdf6b2cb89dd765ce5ca6a507a143c3">More...</a><br /></td></tr>
<tr class="separator:aecdf6b2cb89dd765ce5ca6a507a143c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d468c4194dbbf8a94ff15b6f260b1"><td class="memTemplParams" colspan="2">template&lt;JoinType join_type, typename index_type &gt; </td></tr>
<tr class="memitem:a191d468c4194dbbf8a94ff15b6f260b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a191d468c4194dbbf8a94ff15b6f260b1">construct_join_output_df</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structgdf__column__.html">gdf_column</a> *left_indices, <a class="el" href="structgdf__column__.html">gdf_column</a> *right_indices)</td></tr>
<tr class="memdesc:a191d468c4194dbbf8a94ff15b6f260b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers rows indicated by <code>left_indices</code> and <code>right_indices</code> from tables <code>left</code> and <code>right</code>, respectively, into a single <code>table</code>.  <a href="namespacecudf.html#a191d468c4194dbbf8a94ff15b6f260b1">More...</a><br /></td></tr>
<tr class="separator:a191d468c4194dbbf8a94ff15b6f260b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa52645708c7f40b19e86fde0caa170"><td class="memTemplParams" colspan="2">template&lt;JoinType join_type, typename index_type &gt; </td></tr>
<tr class="memitem:a7aa52645708c7f40b19e86fde0caa170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a7aa52645708c7f40b19e86fde0caa170">join_call_compute_df</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structcudf_1_1table.html">cudf::table</a> *joined_indices, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="memdesc:a7aa52645708c7f40b19e86fde0caa170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs join on the columns provided in <code>left</code> and <code>right</code> as per the joining indices given in <code>left_on</code> and <code>right_on</code> and creates a single table.  <a href="namespacecudf.html#a7aa52645708c7f40b19e86fde0caa170">More...</a><br /></td></tr>
<tr class="separator:a7aa52645708c7f40b19e86fde0caa170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb25244db54dfda018d96d5b7e1c8d42"><td class="memItemLeft" align="right" valign="top"><a id="acb25244db54dfda018d96d5b7e1c8d42"></a>
<a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>left_join</b> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structcudf_1_1table.html">cudf::table</a> *joined_indices, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="separator:acb25244db54dfda018d96d5b7e1c8d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15e1a6d3db28c73d8e5183547ac3726"><td class="memItemLeft" align="right" valign="top"><a id="aa15e1a6d3db28c73d8e5183547ac3726"></a>
<a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inner_join</b> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structcudf_1_1table.html">cudf::table</a> *joined_indices, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="separator:aa15e1a6d3db28c73d8e5183547ac3726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fde2ff19418ffd5333c0f526bf3e17"><td class="memItemLeft" align="right" valign="top"><a id="a94fde2ff19418ffd5333c0f526bf3e17"></a>
<a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>full_join</b> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;left, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;right, std::vector&lt; cudf::size_type &gt; const &amp;left_on, std::vector&lt; cudf::size_type &gt; const &amp;right_on, std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;columns_in_common, <a class="el" href="structcudf_1_1table.html">cudf::table</a> *joined_indices, <a class="el" href="structgdf__context__.html">gdf_context</a> *join_context)</td></tr>
<tr class="separator:a94fde2ff19418ffd5333c0f526bf3e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f137cce1b677a6d0f0de87d64627ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa5f137cce1b677a6d0f0de87d64627ec">merge</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;left_table, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;right_table, std::vector&lt; cudf::size_type &gt; const  &amp;key_cols, std::vector&lt; order_by_type &gt; const  &amp;asc_desc, bool nulls_are_smallest=false)</td></tr>
<tr class="memdesc:aa5f137cce1b677a6d0f0de87d64627ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted tables.  <a href="namespacecudf.html#aa5f137cce1b677a6d0f0de87d64627ec">More...</a><br /></td></tr>
<tr class="separator:aa5f137cce1b677a6d0f0de87d64627ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac52a52a504d46887f1368ae13a96ffb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aac52a52a504d46887f1368ae13a96ffb">is_sorted</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>, std::vector&lt; int8_t &gt; const  &amp;descending, bool nulls_are_smallest)</td></tr>
<tr class="memdesc:aac52a52a504d46887f1368ae13a96ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the rows of a <code>table</code> are sorted in a lexicographical order.  <a href="namespacecudf.html#aac52a52a504d46887f1368ae13a96ffb">More...</a><br /></td></tr>
<tr class="separator:aac52a52a504d46887f1368ae13a96ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c828f318cb2c14c8ac0567f5084d1e7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a>, <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a6c828f318cb2c14c8ac0567f5084d1e7">group_quantiles</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;keys, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;values, std::vector&lt; double &gt; const  &amp;quantiles, <a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a> <a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a>=<a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8ab424744b6ce548ac355f5830c0a8c5e1">LINEAR</a>, bool include_nulls=false)</td></tr>
<tr class="memdesc:a6c828f318cb2c14c8ac0567f5084d1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find values at given quantiles within groups.  <a href="namespacecudf.html#a6c828f318cb2c14c8ac0567f5084d1e7">More...</a><br /></td></tr>
<tr class="separator:a6c828f318cb2c14c8ac0567f5084d1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aad879c6bbd17521333c06dab5db483"><td class="memItemLeft" align="right" valign="top">gdf_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3aad879c6bbd17521333c06dab5db483">quantile_exact</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *col_in, <a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a> prec, double q, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *result, <a class="el" href="structgdf__context__.html">gdf_context</a> *ctxt)</td></tr>
<tr class="memdesc:a3aad879c6bbd17521333c06dab5db483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes exact quantile.  <a href="namespacecudf.html#a3aad879c6bbd17521333c06dab5db483">More...</a><br /></td></tr>
<tr class="separator:a3aad879c6bbd17521333c06dab5db483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecb9e39d5b5475f53260497f3a8db0a"><td class="memItemLeft" align="right" valign="top">gdf_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaecb9e39d5b5475f53260497f3a8db0a">quantile_approx</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> *col_in, double q, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> *result, <a class="el" href="structgdf__context__.html">gdf_context</a> *ctxt)</td></tr>
<tr class="memdesc:aaecb9e39d5b5475f53260497f3a8db0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes approximate quantile.  <a href="namespacecudf.html#aaecb9e39d5b5475f53260497f3a8db0a">More...</a><br /></td></tr>
<tr class="separator:aaecb9e39d5b5475f53260497f3a8db0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7d308aae78cd6323814732ec4a2278"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a>, <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aab7d308aae78cd6323814732ec4a2278">group_std</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;keys, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;values, cudf::size_type ddof=1)</td></tr>
<tr class="memdesc:aab7d308aae78cd6323814732ec4a2278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a group wise standard deviation.  <a href="namespacecudf.html#aab7d308aae78cd6323814732ec4a2278">More...</a><br /></td></tr>
<tr class="separator:aab7d308aae78cd6323814732ec4a2278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534d665f0890f93214d43f494fe907b1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a>, <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a534d665f0890f93214d43f494fe907b1">group_var</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;keys, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;values, cudf::size_type ddof=1)</td></tr>
<tr class="memdesc:a534d665f0890f93214d43f494fe907b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a group wise variance.  <a href="namespacecudf.html#a534d665f0890f93214d43f494fe907b1">More...</a><br /></td></tr>
<tr class="separator:a534d665f0890f93214d43f494fe907b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdab46512f8d4cf604ed983c02556bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__scalar.html">gdf_scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#afdab46512f8d4cf604ed983c02556bf4">reduce</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *col, cudf::reduction::operators op, gdf_dtype output_dtype, cudf::size_type ddof=1)</td></tr>
<tr class="memdesc:afdab46512f8d4cf604ed983c02556bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision <code>dtype</code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> will contain <code>false</code>.  <a href="namespacecudf.html#afdab46512f8d4cf604ed983c02556bf4">More...</a><br /></td></tr>
<tr class="separator:afdab46512f8d4cf604ed983c02556bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a65546aa9c42e87334fb5e1e3f274bc6b">scan</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *input, <a class="el" href="structgdf__column__.html">gdf_column</a> *output, gdf_scan_op op, bool inclusive)</td></tr>
<tr class="memdesc:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null.  <a href="namespacecudf.html#a65546aa9c42e87334fb5e1e3f274bc6b">More...</a><br /></td></tr>
<tr class="separator:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e93b1c814e07e108ad015d27ca2372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a68e93b1c814e07e108ad015d27ca2372">find_and_replace_all</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input_col, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;values_to_replace, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;replacement_values)</td></tr>
<tr class="memdesc:a68e93b1c814e07e108ad015d27ca2372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements from <code>input_col</code> according to the mapping <code>values_to_replace</code> to <code>replacement_values</code>, that is, replace all <code>values_to_replace[i]</code> present in <code>input_col</code> with <code>replacement_values[i]</code>.  <a href="namespacecudf.html#a68e93b1c814e07e108ad015d27ca2372">More...</a><br /></td></tr>
<tr class="separator:a68e93b1c814e07e108ad015d27ca2372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85645250c7ada0b73a61e9a691931b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a85645250c7ada0b73a61e9a691931b36">replace_nulls</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;replacement)</td></tr>
<tr class="memdesc:a85645250c7ada0b73a61e9a691931b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with corresponding values of another column.  <a href="namespacecudf.html#a85645250c7ada0b73a61e9a691931b36">More...</a><br /></td></tr>
<tr class="separator:a85645250c7ada0b73a61e9a691931b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad66cc66793473e7fc90ad3ed4cd1b450">replace_nulls</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input, const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;replacement)</td></tr>
<tr class="memdesc:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with a scalar.  <a href="namespacecudf.html#ad66cc66793473e7fc90ad3ed4cd1b450">More...</a><br /></td></tr>
<tr class="separator:ad66cc66793473e7fc90ad3ed4cd1b450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775c771fa16245d5fca471246892fe5a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a775c771fa16245d5fca471246892fe5a">normalize_nans_and_zeros</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a775c771fa16245d5fca471246892fe5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from a column of floating-point elements and replaces <code>-NaN</code> and <code>-0.0</code> with <code>+NaN</code> and <code>+0.0</code>, respectively.  <a href="namespacecudf.html#a775c771fa16245d5fca471246892fe5a">More...</a><br /></td></tr>
<tr class="separator:a775c771fa16245d5fca471246892fe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e8dd1b37b4175001b89219ab8ac96f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab2e8dd1b37b4175001b89219ab8ac96f">normalize_nans_and_zeros</a> (<a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;in_out)</td></tr>
<tr class="memdesc:ab2e8dd1b37b4175001b89219ab8ac96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a column of floating-point elements to replace all <code>-NaN</code> and <code>-0.0</code> with <code>+NaN</code> and <code>+0.0</code>, respectively.  <a href="namespacecudf.html#ab2e8dd1b37b4175001b89219ab8ac96f">More...</a><br /></td></tr>
<tr class="separator:ab2e8dd1b37b4175001b89219ab8ac96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992265bb26358a252b18da882b7f6df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a992265bb26358a252b18da882b7f6df5">stack</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;input)</td></tr>
<tr class="memdesc:a992265bb26358a252b18da882b7f6df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack rows of a Table into a single column.  <a href="namespacecudf.html#a992265bb26358a252b18da882b7f6df5">More...</a><br /></td></tr>
<tr class="separator:a992265bb26358a252b18da882b7f6df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822e21195f0d4ed160adf2dbe0eca038"><td class="memItemLeft" align="right" valign="top"><a id="a822e21195f0d4ed160adf2dbe0eca038"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rolling_window</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input_col, cudf::size_type window, cudf::size_type min_periods, cudf::size_type forward_window, gdf_agg_op agg_type, const cudf::size_type *window_col, const cudf::size_type *min_periods_col, const cudf::size_type *forward_window_col)</td></tr>
<tr class="separator:a822e21195f0d4ed160adf2dbe0eca038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85c229c4f7d98d22f25894931f898d"><td class="memItemLeft" align="right" valign="top"><a id="a1a85c229c4f7d98d22f25894931f898d"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rolling_window</b> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input, cudf::size_type window, cudf::size_type min_periods, cudf::size_type forward_window, const std::string &amp;user_defined_aggregator, gdf_agg_op agg_op, gdf_dtype output_type, cudf::size_type const *window_col, cudf::size_type const *min_periods_col, cudf::size_type const *forward_window_col)</td></tr>
<tr class="separator:a1a85c229c4f7d98d22f25894931f898d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114a73a1397a4c17375599f3113172ff"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a114a73a1397a4c17375599f3113172ff">make_numeric_scalar</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a114a73a1397a4c17375599f3113172ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar with uninitialized storage to hold a value of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> and a validity bool.  <a href="namespacecudf.html#a114a73a1397a4c17375599f3113172ff">More...</a><br /></td></tr>
<tr class="separator:a114a73a1397a4c17375599f3113172ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073f763f8f75e7aa3b551fe21e533bae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a073f763f8f75e7aa3b551fe21e533bae">make_timestamp_scalar</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a073f763f8f75e7aa3b551fe21e533bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar with uninitialized storage to hold a value of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> and a validity bool.  <a href="namespacecudf.html#a073f763f8f75e7aa3b551fe21e533bae">More...</a><br /></td></tr>
<tr class="separator:a073f763f8f75e7aa3b551fe21e533bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693de6f22cd656b6d859b83a106a762e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a693de6f22cd656b6d859b83a106a762e">make_default_constructed_scalar</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:a693de6f22cd656b6d859b83a106a762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs default constructed scalar of type <code>type</code>  <a href="namespacecudf.html#a693de6f22cd656b6d859b83a106a762e">More...</a><br /></td></tr>
<tr class="separator:a693de6f22cd656b6d859b83a106a762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90960c52c1f1fe3ab2257bad89b18fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae90960c52c1f1fe3ab2257bad89b18fc">lower_bound</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;values, std::vector&lt; bool &gt; const  &amp;desc_flags, bool nulls_as_largest=true)</td></tr>
<tr class="memdesc:ae90960c52c1f1fe3ab2257bad89b18fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find smallest indices in a sorted table where values should be inserted to maintain order.  <a href="namespacecudf.html#ae90960c52c1f1fe3ab2257bad89b18fc">More...</a><br /></td></tr>
<tr class="separator:ae90960c52c1f1fe3ab2257bad89b18fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4423a474f1918e65aed295f0600c488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad4423a474f1918e65aed295f0600c488">upper_bound</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, <a class="el" href="structcudf_1_1table.html">table</a> const  &amp;values, std::vector&lt; bool &gt; const  &amp;desc_flags, bool nulls_as_largest=true)</td></tr>
<tr class="memdesc:ad4423a474f1918e65aed295f0600c488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find largest indices in a sorted table where values should be inserted to maintain order.  <a href="namespacecudf.html#ad4423a474f1918e65aed295f0600c488">More...</a><br /></td></tr>
<tr class="separator:ad4423a474f1918e65aed295f0600c488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad614fa15b385e74efb6dcf3fa663fd7c"><td class="memItemLeft" align="right" valign="top"><a id="ad614fa15b385e74efb6dcf3fa663fd7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;<a class="el" href="classcudf_1_1column.html">column</a>, <a class="el" href="structgdf__scalar.html">gdf_scalar</a> const &amp;value)</td></tr>
<tr class="separator:ad614fa15b385e74efb6dcf3fa663fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad888a160fd5439ce10ed29232debc200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad888a160fd5439ce10ed29232debc200">apply_boolean_mask</a> (<a class="el" href="structcudf_1_1table.html">table</a> const &amp;input, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;boolean_mask)</td></tr>
<tr class="memdesc:ad888a160fd5439ce10ed29232debc200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table using a column of boolean values as a mask.  <a href="namespacecudf.html#ad888a160fd5439ce10ed29232debc200">More...</a><br /></td></tr>
<tr class="separator:ad888a160fd5439ce10ed29232debc200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e2081a7b72b9e1ee1013b7f16127fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">cudf::table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a98e2081a7b72b9e1ee1013b7f16127fa">drop_duplicates</a> (const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;input, const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;keys, const <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep, const bool nulls_are_equal=true)</td></tr>
<tr class="memdesc:a98e2081a7b72b9e1ee1013b7f16127fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table without duplicate rows.  <a href="namespacecudf.html#a98e2081a7b72b9e1ee1013b7f16127fa">More...</a><br /></td></tr>
<tr class="separator:a98e2081a7b72b9e1ee1013b7f16127fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb33beea254a4697b0a1678a34ea16"><td class="memItemLeft" align="right" valign="top">cudf::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad3fb33beea254a4697b0a1678a34ea16">unique_count</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, bool const ignore_nulls, bool const nan_as_null)</td></tr>
<tr class="memdesc:ad3fb33beea254a4697b0a1678a34ea16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the unique elements in the column.  <a href="namespacecudf.html#ad3fb33beea254a4697b0a1678a34ea16">More...</a><br /></td></tr>
<tr class="separator:ad3fb33beea254a4697b0a1678a34ea16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f0e5730d9073dda64effa64dce2cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa3f0e5730d9073dda64effa64dce2cfa">drop_nulls</a> (<a class="el" href="structcudf_1_1table.html">table</a> const &amp;input, <a class="el" href="structcudf_1_1table.html">table</a> const &amp;keys, cudf::size_type keep_threshold)</td></tr>
<tr class="memdesc:aa3f0e5730d9073dda64effa64dce2cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table to remove null elements.  <a href="namespacecudf.html#aa3f0e5730d9073dda64effa64dce2cfa">More...</a><br /></td></tr>
<tr class="separator:aa3f0e5730d9073dda64effa64dce2cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c1f9dc1aaa71e250df1eed4b02f3d8"><td class="memItemLeft" align="right" valign="top"><a id="ac4c1f9dc1aaa71e250df1eed4b02f3d8"></a>
<a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><b>drop_nulls</b> (<a class="el" href="structcudf_1_1table.html">table</a> const &amp;input, <a class="el" href="structcudf_1_1table.html">table</a> const &amp;keys)</td></tr>
<tr class="separator:ac4c1f9dc1aaa71e250df1eed4b02f3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806dfe2d3033333c99fd399afeddab3d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a806dfe2d3033333c99fd399afeddab3d">make_strings_column</a> (const rmm::device_vector&lt; thrust::pair&lt; const char *, size_type &gt;&gt; &amp;strings, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a806dfe2d3033333c99fd399afeddab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct STRING type column given a vector of pointer/size pairs. The total number of char bytes must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column.  <a href="namespacecudf.html#a806dfe2d3033333c99fd399afeddab3d">More...</a><br /></td></tr>
<tr class="separator:a806dfe2d3033333c99fd399afeddab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc1ed49a1ddbc5eefde47266e9055ce"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a2dc1ed49a1ddbc5eefde47266e9055ce">make_strings_column</a> (const rmm::device_vector&lt; char &gt; &amp;strings, const rmm::device_vector&lt; size_type &gt; &amp;offsets, const rmm::device_vector&lt; bitmask_type &gt; &amp;null_mask={}, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a2dc1ed49a1ddbc5eefde47266e9055ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct STRING type column given a device vector of chars encoded as UTF-8, a device vector of byte offsets identifying individual strings within the char vector, and an optional null bitmask.  <a href="namespacecudf.html#a2dc1ed49a1ddbc5eefde47266e9055ce">More...</a><br /></td></tr>
<tr class="separator:a2dc1ed49a1ddbc5eefde47266e9055ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab955065a94f1322650056cd5721807b0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab955065a94f1322650056cd5721807b0">make_strings_column</a> (const std::vector&lt; char &gt; &amp;strings, const std::vector&lt; size_type &gt; &amp;offsets, const std::vector&lt; bitmask_type &gt; &amp;null_mask={}, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ab955065a94f1322650056cd5721807b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct STRING type column given a host vector of chars encoded as UTF-8, a host vector of byte offsets identifying individual strings within the char vector, and an optional null bitmask.  <a href="namespacecudf.html#ab955065a94f1322650056cd5721807b0">More...</a><br /></td></tr>
<tr class="separator:ab955065a94f1322650056cd5721807b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabc5ec71f9be5db72e64ed461ac1fa6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#acabc5ec71f9be5db72e64ed461ac1fa6">make_strings_column</a> (size_type num_strings, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; offsets_column, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; chars_column, size_type null_count, rmm::device_buffer &amp;&amp;null_mask, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:acabc5ec71f9be5db72e64ed461ac1fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a STRING type column given offsets column, chars columns, and null mask and null count. The columns and mask are moved into the resulting strings column.  <a href="namespacecudf.html#acabc5ec71f9be5db72e64ed461ac1fa6">More...</a><br /></td></tr>
<tr class="separator:acabc5ec71f9be5db72e64ed461ac1fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baa6152d40906019ccc2e66eff4dab4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a9baa6152d40906019ccc2e66eff4dab4">make_string_scalar</a> (std::string const  &amp;string, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a9baa6152d40906019ccc2e66eff4dab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct STRING type scalar given a <code>std::string</code>. The size of the <code>std::string</code> must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes.  <a href="namespacecudf.html#a9baa6152d40906019ccc2e66eff4dab4">More...</a><br /></td></tr>
<tr class="separator:a9baa6152d40906019ccc2e66eff4dab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gdf_dtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad2f973d94c67ab3dc1a183c5adb3753d">column_dtypes</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of the dtypes of the columns in a table.  <a href="namespacecudf.html#ad2f973d94c67ab3dc1a183c5adb3753d">More...</a><br /></td></tr>
<tr class="separator:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c2c74e4d88e3c0b67e7dea9f7086cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad2c2c74e4d88e3c0b67e7dea9f7086cc">column_dtype_infos</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ad2c2c74e4d88e3c0b67e7dea9f7086cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of the dtype_infos of the columns in a table.  <a href="namespacecudf.html#ad2c2c74e4d88e3c0b67e7dea9f7086cc">More...</a><br /></td></tr>
<tr class="separator:ad2c2c74e4d88e3c0b67e7dea9f7086cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada393acb565321d740f2b9950ffe2941"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ada393acb565321d740f2b9950ffe2941">has_nulls</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ada393acb565321d740f2b9950ffe2941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a table contains any null values.  <a href="namespacecudf.html#ada393acb565321d740f2b9950ffe2941">More...</a><br /></td></tr>
<tr class="separator:ada393acb565321d740f2b9950ffe2941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbd2350ad171265f45f63404ab32ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a7dbd2350ad171265f45f63404ab32ffd">concat</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;table1, <a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;table2)</td></tr>
<tr class="memdesc:a7dbd2350ad171265f45f63404ab32ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>table1</code> and <code>table2</code> are concatenated to return single table  <a href="namespacecudf.html#a7dbd2350ad171265f45f63404ab32ffd">More...</a><br /></td></tr>
<tr class="separator:a7dbd2350ad171265f45f63404ab32ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dd52f40723ec83772eb53024ab5129"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bit_mask_t *, cudf::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad9dd52f40723ec83772eb53024ab5129">nans_to_nulls</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input)</td></tr>
<tr class="memdesc:ad9dd52f40723ec83772eb53024ab5129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column with floating point values, generate a bitmask where every NaN is indicated as the corresponding null bit.  <a href="namespacecudf.html#ad9dd52f40723ec83772eb53024ab5129">More...</a><br /></td></tr>
<tr class="separator:ad9dd52f40723ec83772eb53024ab5129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45876c5d57c0d0afb921add28b3516e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a45876c5d57c0d0afb921add28b3516e3">transform</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input, const std::string &amp;unary_udf, gdf_dtype output_type, bool is_ptx)</td></tr>
<tr class="memdesc:a45876c5d57c0d0afb921add28b3516e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by applying a unary function against every element of an input column.  <a href="namespacecudf.html#a45876c5d57c0d0afb921add28b3516e3">More...</a><br /></td></tr>
<tr class="separator:a45876c5d57c0d0afb921add28b3516e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9097a8bfea9db9999dd8e120b0e71bce"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a9097a8bfea9db9999dd8e120b0e71bce">transpose</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const  &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a9097a8bfea9db9999dd8e120b0e71bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new table transposed from the input table.  <a href="namespacecudf.html#a9097a8bfea9db9999dd8e120b0e71bce">More...</a><br /></td></tr>
<tr class="separator:a9097a8bfea9db9999dd8e120b0e71bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9904c47d7ae6d33143b6441cba45d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aca9904c47d7ae6d33143b6441cba45d2">cast</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, gdf_dtype out_type, <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> out_info=<a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>{})</td></tr>
<tr class="memdesc:aca9904c47d7ae6d33143b6441cba45d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts data from dtype specified in input to dtype specified in output.  <a href="namespacecudf.html#aca9904c47d7ae6d33143b6441cba45d2">More...</a><br /></td></tr>
<tr class="separator:aca9904c47d7ae6d33143b6441cba45d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4de4905066fbb3c645b05a1fc1d31d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae4de4905066fbb3c645b05a1fc1d31d2">unary_operation</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">unary_op</a> op)</td></tr>
<tr class="memdesc:ae4de4905066fbb3c645b05a1fc1d31d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unary op on all values in column.  <a href="namespacecudf.html#ae4de4905066fbb3c645b05a1fc1d31d2">More...</a><br /></td></tr>
<tr class="separator:ae4de4905066fbb3c645b05a1fc1d31d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c69a3f630734ceead55f5fc2dd6ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a90c69a3f630734ceead55f5fc2dd6ede">is_null</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input)</td></tr>
<tr class="memdesc:a90c69a3f630734ceead55f5fc2dd6ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the <code>input</code> column for <code>null</code> values, and creates a <code>bool</code> column of same size with <code>true</code> representing <code>null</code> values and <code>false</code> for other.  <a href="namespacecudf.html#a90c69a3f630734ceead55f5fc2dd6ede">More...</a><br /></td></tr>
<tr class="separator:a90c69a3f630734ceead55f5fc2dd6ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f30952e94aede1208c6f3195d1e9fc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a4f30952e94aede1208c6f3195d1e9fc3">is_not_null</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input)</td></tr>
<tr class="memdesc:a4f30952e94aede1208c6f3195d1e9fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the <code>input</code> column for <code>null</code> values, and creates a <code>bool</code> column of same size with <code>false</code> representing <code>null</code> values and <code>true</code> for other.  <a href="namespacecudf.html#a4f30952e94aede1208c6f3195d1e9fc3">More...</a><br /></td></tr>
<tr class="separator:a4f30952e94aede1208c6f3195d1e9fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>)</td></tr>
<tr class="memdesc:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures a gdf_column is valid, i.e. that its fields are consistent with each other, and logical in themselves, in representing a proper column.  <a href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">More...</a><br /></td></tr>
<tr class="separator:afa70e889e2b83eba15ed8e8e864dd3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9985a7fc88fb9b13d429e29405e12ae"><td class="memItemLeft" align="right" valign="top"><a id="ab9985a7fc88fb9b13d429e29405e12ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *column_ptr)</td></tr>
<tr class="separator:ab9985a7fc88fb9b13d429e29405e12ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d288a83fd8de580d2274f825997cbf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0d288a83fd8de580d2274f825997cbf3">have_same_type</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;validated_column_1, const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;validated_column_2, bool ignore_extra_type_info=false) noexcept</td></tr>
<tr class="memdesc:a0d288a83fd8de580d2274f825997cbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures two (valid!) columns have the same type.  <a href="namespacecudf.html#a0d288a83fd8de580d2274f825997cbf3">More...</a><br /></td></tr>
<tr class="separator:a0d288a83fd8de580d2274f825997cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11851549cdd993a7a09c280a6d015135"><td class="memItemLeft" align="right" valign="top"><a id="a11851549cdd993a7a09c280a6d015135"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>have_same_type</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *validated_column_ptr_1, const <a class="el" href="structgdf__column__.html">gdf_column</a> *validated_column_ptr_2, bool ignore_extra_type_info) noexcept</td></tr>
<tr class="separator:a11851549cdd993a7a09c280a6d015135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f193177256b121627a35887dc9f816"><td class="memTemplParams" colspan="2"><a id="a40f193177256b121627a35887dc9f816"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40f193177256b121627a35887dc9f816"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_data</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a40f193177256b121627a35887dc9f816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b3e096195676e94b7c8398747459ff"><td class="memTemplParams" colspan="2"><a id="a52b3e096195676e94b7c8398747459ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52b3e096195676e94b7c8398747459ff"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_data</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a52b3e096195676e94b7c8398747459ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571f2362be95df8c2348bcce96fc522b"><td class="memItemLeft" align="right" valign="top"><a id="a571f2362be95df8c2348bcce96fc522b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_an_integer</b> (gdf_dtype element_type) noexcept</td></tr>
<tr class="separator:a571f2362be95df8c2348bcce96fc522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1090d2083c2700bef73bb07b29f8eb"><td class="memItemLeft" align="right" valign="top"><a id="a8d1090d2083c2700bef73bb07b29f8eb"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_integral</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a8d1090d2083c2700bef73bb07b29f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a3589a60ac4e16c069ae1852d80264"><td class="memItemLeft" align="right" valign="top"><a id="a49a3589a60ac4e16c069ae1852d80264"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_integral</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a49a3589a60ac4e16c069ae1852d80264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"><td class="memItemLeft" align="right" valign="top"><a id="a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_nullable</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a2db5b2cb45e0e4d7f9f1d7cb25ca32ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a4a65a257d9746a9d65f8a8a6de1a5"><td class="memItemLeft" align="right" valign="top"><a id="a83a4a65a257d9746a9d65f8a8a6de1a5"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_nulls</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;<a class="el" href="classcudf_1_1column.html">column</a>) noexcept</td></tr>
<tr class="separator:a83a4a65a257d9746a9d65f8a8a6de1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="memItemLeft" align="right" valign="top"><a id="aea3dfde6d57f821aa1825a90a8cdddcb"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aea3dfde6d57f821aa1825a90a8cdddcb">size_of</a> (gdf_dtype element_type)</td></tr>
<tr class="memdesc:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of values of a column element type. <br /></td></tr>
<tr class="separator:aea3dfde6d57f821aa1825a90a8cdddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="memItemLeft" align="right" valign="top"><a id="aaf37d87f3ef5bb0736ad2dfeeac3e766"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaf37d87f3ef5bb0736ad2dfeeac3e766">byte_width</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;col) noexcept</td></tr>
<tr class="memdesc:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of each element of a column (a.k.a. the column's width) <br /></td></tr>
<tr class="separator:aaf37d87f3ef5bb0736ad2dfeeac3e766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63f5b61fc23af128d77caf9ed921309"><td class="memTemplParams" colspan="2">template&lt;typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:ac63f5b61fc23af128d77caf9ed921309"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value||std::is_same&lt; T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::date32</a> &gt;::value||std::is_same&lt; T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::date64</a> &gt;::value||std::is_same&lt; T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::timestamp</a> &gt;::value||std::is_same&lt; T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::category</a> &gt;::value||std::is_same&lt; T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::nvstring_category</a> &gt;::value, T &gt; __forceinline__ __device__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ac63f5b61fc23af128d77caf9ed921309">genericAtomicOperation</a> (T *address, T const &amp;update_value, BinaryOp op)</td></tr>
<tr class="memdesc:ac63f5b61fc23af128d77caf9ed921309"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction.  <a href="namespacecudf.html#ac63f5b61fc23af128d77caf9ed921309">More...</a><br /></td></tr>
<tr class="separator:ac63f5b61fc23af128d77caf9ed921309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memTemplParams" colspan="2"><a id="acafbd5dbae09b26c92b964e0122d5fc9"></a>
template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genericAtomicOperation</b> (<a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a> *address, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a> const &amp;update_value, BinaryOp op)</td></tr>
<tr class="separator:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffb30b38c5cbcf1c312603477608824"><td class="memTemplParams" colspan="2"><a id="a3ffb30b38c5cbcf1c312603477608824"></a>
template&lt;typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a3ffb30b38c5cbcf1c312603477608824"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacecudf.html#a90ebb90931abfed637396889b7829173">cudf::is_timestamp</a>&lt; T &gt;), T &gt; __forceinline__ __device__&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genericAtomicOperation</b> (T *address, T const &amp;update_value, BinaryOp op)</td></tr>
<tr class="separator:a3ffb30b38c5cbcf1c312603477608824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2557402b8fda0c96a9e997ba9ecb9a"><td class="memTemplParams" colspan="2"><a id="a0f2557402b8fda0c96a9e997ba9ecb9a"></a>
template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:a0f2557402b8fda0c96a9e997ba9ecb9a"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="structcudf_1_1experimental_1_1bool8.html">cudf::experimental::bool8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genericAtomicOperation</b> (<a class="el" href="structcudf_1_1experimental_1_1bool8.html">cudf::experimental::bool8</a> *address, <a class="el" href="structcudf_1_1experimental_1_1bool8.html">cudf::experimental::bool8</a> const &amp;update_value, BinaryOp op)</td></tr>
<tr class="separator:a0f2557402b8fda0c96a9e997ba9ecb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcaaa009a6de4a88ba26b8479fb3c57"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a7bcaaa009a6de4a88ba26b8479fb3c57"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a7bcaaa009a6de4a88ba26b8479fb3c57">make_numeric_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, B &amp;&amp;null_mask, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a7bcaaa009a6de4a88ba26b8479fb3c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <a href="namespacecudf.html#a7bcaaa009a6de4a88ba26b8479fb3c57">More...</a><br /></td></tr>
<tr class="separator:a7bcaaa009a6de4a88ba26b8479fb3c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2059fd303a1baca0a6c6f45192fa89e"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:aa2059fd303a1baca0a6c6f45192fa89e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa2059fd303a1baca0a6c6f45192fa89e">make_timestamp_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, B &amp;&amp;null_mask, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:aa2059fd303a1baca0a6c6f45192fa89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <a href="namespacecudf.html#aa2059fd303a1baca0a6c6f45192fa89e">More...</a><br /></td></tr>
<tr class="separator:aa2059fd303a1baca0a6c6f45192fa89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206743e8bf8c30699498608d0b5876a5"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a206743e8bf8c30699498608d0b5876a5"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a206743e8bf8c30699498608d0b5876a5">make_fixed_width_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, B &amp;&amp;null_mask, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a206743e8bf8c30699498608d0b5876a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <a href="namespacecudf.html#a206743e8bf8c30699498608d0b5876a5">More...</a><br /></td></tr>
<tr class="separator:a206743e8bf8c30699498608d0b5876a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23161719d6de26448dce74b8783f89c8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a23161719d6de26448dce74b8783f89c8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, T &gt; __forceinline__ __device__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a23161719d6de26448dce74b8783f89c8">genericAtomicOperation</a> (T *address, T const &amp;update_value, BinaryOp op)</td></tr>
<tr class="memdesc:a23161719d6de26448dce74b8783f89c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction.  <a href="namespacecudf.html#a23161719d6de26448dce74b8783f89c8">More...</a><br /></td></tr>
<tr class="separator:a23161719d6de26448dce74b8783f89c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786e49ed5e27ff8517c3b6402655d1af"><td class="memTemplParams" colspan="2"><a id="a786e49ed5e27ff8517c3b6402655d1af"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a786e49ed5e27ff8517c3b6402655d1af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a786e49ed5e27ff8517c3b6402655d1af">get_scalar_device_view</a> (<a class="el" href="classcudf_1_1numeric__scalar.html">numeric_scalar</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:a786e49ed5e27ff8517c3b6402655d1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device view of a <a class="el" href="classcudf_1_1numeric__scalar.html" title="An owning class to represent a numerical value in device memory.">numeric_scalar</a>. <br /></td></tr>
<tr class="separator:a786e49ed5e27ff8517c3b6402655d1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5287e6197c09c4828103bae453ab5c58"><td class="memItemLeft" align="right" valign="top"><a id="a5287e6197c09c4828103bae453ab5c58"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5287e6197c09c4828103bae453ab5c58">get_scalar_device_view</a> (<a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> &amp;s)</td></tr>
<tr class="memdesc:a5287e6197c09c4828103bae453ab5c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device view of a <a class="el" href="classcudf_1_1string__scalar.html" title="An owning class to represent a string in device memory.">string_scalar</a>. <br /></td></tr>
<tr class="separator:a5287e6197c09c4828103bae453ab5c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22ceb0ce0a74a2f9d8876b5c8a33d2b"><td class="memTemplParams" colspan="2"><a id="ae22ceb0ce0a74a2f9d8876b5c8a33d2b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae22ceb0ce0a74a2f9d8876b5c8a33d2b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae22ceb0ce0a74a2f9d8876b5c8a33d2b">get_scalar_device_view</a> (<a class="el" href="classcudf_1_1timestamp__scalar.html">timestamp_scalar</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:ae22ceb0ce0a74a2f9d8876b5c8a33d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device view of a <a class="el" href="classcudf_1_1timestamp__scalar.html" title="An owning class to represent a timestamp value in device memory.">timestamp_scalar</a>. <br /></td></tr>
<tr class="separator:ae22ceb0ce0a74a2f9d8876b5c8a33d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84612c5efd7a5d2c6701581308a5d3b"><td class="memItemLeft" align="right" valign="top"><a id="ae84612c5efd7a5d2c6701581308a5d3b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_nulls</b> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> view)</td></tr>
<tr class="separator:ae84612c5efd7a5d2c6701581308a5d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f79c6fbeb12b15851bee1aa09f76c92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a2f79c6fbeb12b15851bee1aa09f76c92">have_same_types</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;rhs)</td></tr>
<tr class="memdesc:a2f79c6fbeb12b15851bee1aa09f76c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code>s have columns of same types.  <a href="namespacecudf.html#a2f79c6fbeb12b15851bee1aa09f76c92">More...</a><br /></td></tr>
<tr class="separator:a2f79c6fbeb12b15851bee1aa09f76c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd500e54a0760773f941986e8e056b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa5bd500e54a0760773f941986e8e056b">operator==</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;lhs, <a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;rhs)</td></tr>
<tr class="memdesc:aa5bd500e54a0760773f941986e8e056b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> objects for equality.  <a href="namespacecudf.html#aa5bd500e54a0760773f941986e8e056b">More...</a><br /></td></tr>
<tr class="separator:aa5bd500e54a0760773f941986e8e056b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd7d3be7317e7621d5b073c7176a582"><td class="memItemLeft" align="right" valign="top">constexpr CUDA_HOST_DEVICE_CALLABLE size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a9fd7d3be7317e7621d5b073c7176a582">word_index</a> (size_type bit_index)</td></tr>
<tr class="separator:a9fd7d3be7317e7621d5b073c7176a582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce276d67cc17e299f29de43a391af75"><td class="memItemLeft" align="right" valign="top">constexpr CUDA_HOST_DEVICE_CALLABLE size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a7ce276d67cc17e299f29de43a391af75">intra_word_index</a> (size_type bit_index)</td></tr>
<tr class="separator:a7ce276d67cc17e299f29de43a391af75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4063fafa03398865ddae121b3ca939"><td class="memItemLeft" align="right" valign="top">CUDA_HOST_DEVICE_CALLABLE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3c4063fafa03398865ddae121b3ca939">set_bit_unsafe</a> (bitmask_type *bitmask, size_type bit_index)</td></tr>
<tr class="memdesc:a3c4063fafa03398865ddae121b3ca939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified bit to <code>1</code>  <a href="namespacecudf.html#a3c4063fafa03398865ddae121b3ca939">More...</a><br /></td></tr>
<tr class="separator:a3c4063fafa03398865ddae121b3ca939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabda3ecfba220ffdfd76a7076259483"><td class="memItemLeft" align="right" valign="top">CUDA_HOST_DEVICE_CALLABLE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaabda3ecfba220ffdfd76a7076259483">clear_bit_unsafe</a> (bitmask_type *bitmask, size_type bit_index)</td></tr>
<tr class="memdesc:aaabda3ecfba220ffdfd76a7076259483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified bit to <code>0</code>  <a href="namespacecudf.html#aaabda3ecfba220ffdfd76a7076259483">More...</a><br /></td></tr>
<tr class="separator:aaabda3ecfba220ffdfd76a7076259483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd9af00974def8f416225ad650d33c9"><td class="memItemLeft" align="right" valign="top">CUDA_HOST_DEVICE_CALLABLE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#accd9af00974def8f416225ad650d33c9">bit_is_set</a> (bitmask_type const *bitmask, size_type bit_index)</td></tr>
<tr class="memdesc:accd9af00974def8f416225ad650d33c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specified bit is set to <code>1</code>  <a href="namespacecudf.html#accd9af00974def8f416225ad650d33c9">More...</a><br /></td></tr>
<tr class="separator:accd9af00974def8f416225ad650d33c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265021448d5a11e023232cb649865092"><td class="memItemLeft" align="right" valign="top">constexpr CUDA_HOST_DEVICE_CALLABLE bitmask_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a265021448d5a11e023232cb649865092">set_least_significant_bits</a> (size_type n)</td></tr>
<tr class="memdesc:a265021448d5a11e023232cb649865092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask word with the <code>n</code> least significant bits set.  <a href="namespacecudf.html#a265021448d5a11e023232cb649865092">More...</a><br /></td></tr>
<tr class="separator:a265021448d5a11e023232cb649865092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d621017e15820e37826a73484fe5376"><td class="memItemLeft" align="right" valign="top">constexpr CUDA_HOST_DEVICE_CALLABLE bitmask_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a1d621017e15820e37826a73484fe5376">set_most_significant_bits</a> (size_type n)</td></tr>
<tr class="memdesc:a1d621017e15820e37826a73484fe5376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask word with the <code>n</code> most significant bits set.  <a href="namespacecudf.html#a1d621017e15820e37826a73484fe5376">More...</a><br /></td></tr>
<tr class="separator:a1d621017e15820e37826a73484fe5376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ced5d0e49afdda2879ae5535a03167"><td class="memTemplParams" colspan="2"><a id="a16ced5d0e49afdda2879ae5535a03167"></a>
template&lt;class functor_t , typename... Ts&gt; </td></tr>
<tr class="memitem:a16ced5d0e49afdda2879ae5535a03167"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto) CUDA_HOST_DEVICE_CALLABLE&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_dispatcher</b> (gdf_dtype dtype, functor_t f, Ts &amp;&amp;... args)</td></tr>
<tr class="separator:a16ced5d0e49afdda2879ae5535a03167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad7b0f1bc518e47eaa2cfdd0ec88e3989">gdf_dtype_of</a> ()</td></tr>
<tr class="memdesc:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to it's corresponding gdf_dtype.  <a href="namespacecudf.html#ad7b0f1bc518e47eaa2cfdd0ec88e3989">More...</a><br /></td></tr>
<tr class="separator:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memTemplParams" colspan="2"><a id="ad0a0a98fdfe7a302afb2dfcaeb536412"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int8_t &gt;</b> ()</td></tr>
<tr class="separator:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d"><td class="memTemplParams" colspan="2"><a id="ae3d9564b2dc03eee3515499cae68827d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int16_t &gt;</b> ()</td></tr>
<tr class="separator:ae3d9564b2dc03eee3515499cae68827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memTemplParams" colspan="2"><a id="ae5ac9bfed0ac9684cc5c201271d4bca5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int32_t &gt;</b> ()</td></tr>
<tr class="separator:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memTemplParams" colspan="2"><a id="a17d6aab829fdfa0a8e805693fe6d0682"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int64_t &gt;</b> ()</td></tr>
<tr class="separator:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124"><td class="memTemplParams" colspan="2"><a id="aef0bacd5dab94476140d35bd1a44c124"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; float &gt;</b> ()</td></tr>
<tr class="separator:aef0bacd5dab94476140d35bd1a44c124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac"><td class="memTemplParams" colspan="2"><a id="aa02973e71d09dc7a3636d2a836968dac"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; double &gt;</b> ()</td></tr>
<tr class="separator:aa02973e71d09dc7a3636d2a836968dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5"><td class="memTemplParams" colspan="2"><a id="ab49efe66b146dc87425669653bde18f5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::bool8 &gt;</b> ()</td></tr>
<tr class="separator:ab49efe66b146dc87425669653bde18f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memTemplParams" colspan="2"><a id="a1e1b828c8f1b2b46e015afb85902ba52"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::date32 &gt;</b> ()</td></tr>
<tr class="separator:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c"><td class="memTemplParams" colspan="2"><a id="adb20c98631c4c203372547135f13732c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::date64 &gt;</b> ()</td></tr>
<tr class="separator:adb20c98631c4c203372547135f13732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memTemplParams" colspan="2"><a id="ad2576f3b441a5f87a0d5b67b7d21b854"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::timestamp &gt;</b> ()</td></tr>
<tr class="separator:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memTemplParams" colspan="2"><a id="a4e807d272b4582ff4d2a0dd9c6b8b309"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::category &gt;</b> ()</td></tr>
<tr class="separator:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919"><td class="memTemplParams" colspan="2"><a id="a0f831e82c6b13cd54c940e74fc46b919"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::nvstring_category &gt;</b> ()</td></tr>
<tr class="separator:a0f831e82c6b13cd54c940e74fc46b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606"><td class="memTemplParams" colspan="2"><a id="a5d1e00fa2d40d07ed6114dc064582606"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; NVStrings &gt;</b> ()</td></tr>
<tr class="separator:a5d1e00fa2d40d07ed6114dc064582606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9b08b206b1340c5ac3893d17943309"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:aef9b08b206b1340c5ac3893d17943309"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aef9b08b206b1340c5ac3893d17943309">is_relationally_comparable</a> ()</td></tr>
<tr class="memdesc:aef9b08b206b1340c5ac3893d17943309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether objects of types <code>L</code> and <code>R</code> can be relationally compared.  <a href="namespacecudf.html#aef9b08b206b1340c5ac3893d17943309">More...</a><br /></td></tr>
<tr class="separator:aef9b08b206b1340c5ac3893d17943309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736c39af324b57534639bd3d8af357e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a736c39af324b57534639bd3d8af357e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a736c39af324b57534639bd3d8af357e4">is_numeric</a> ()</td></tr>
<tr class="memdesc:a736c39af324b57534639bd3d8af357e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a numeric type.  <a href="namespacecudf.html#a736c39af324b57534639bd3d8af357e4">More...</a><br /></td></tr>
<tr class="separator:a736c39af324b57534639bd3d8af357e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac193df7b5be153a88978c2e6564bf4f2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ac193df7b5be153a88978c2e6564bf4f2">is_numeric</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ac193df7b5be153a88978c2e6564bf4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <a href="namespacecudf.html#ac193df7b5be153a88978c2e6564bf4f2">More...</a><br /></td></tr>
<tr class="separator:ac193df7b5be153a88978c2e6564bf4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b9dd3a6ee95fa52224a53869cd164e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1b9dd3a6ee95fa52224a53869cd164e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa1b9dd3a6ee95fa52224a53869cd164e">is_boolean</a> ()</td></tr>
<tr class="memdesc:aa1b9dd3a6ee95fa52224a53869cd164e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>T</code> is a Boolean type.  <a href="namespacecudf.html#aa1b9dd3a6ee95fa52224a53869cd164e">More...</a><br /></td></tr>
<tr class="separator:aa1b9dd3a6ee95fa52224a53869cd164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96675e30be80f4236360466adcf9a70c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a96675e30be80f4236360466adcf9a70c">is_boolean</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:a96675e30be80f4236360466adcf9a70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a Boolean <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <a href="namespacecudf.html#a96675e30be80f4236360466adcf9a70c">More...</a><br /></td></tr>
<tr class="separator:a96675e30be80f4236360466adcf9a70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebb90931abfed637396889b7829173"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90ebb90931abfed637396889b7829173"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a90ebb90931abfed637396889b7829173">is_timestamp</a> ()</td></tr>
<tr class="memdesc:a90ebb90931abfed637396889b7829173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a timestamp type.  <a href="namespacecudf.html#a90ebb90931abfed637396889b7829173">More...</a><br /></td></tr>
<tr class="separator:a90ebb90931abfed637396889b7829173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f7b448c30ecbce54e8c1243ccc8c4d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a96f7b448c30ecbce54e8c1243ccc8c4d">is_timestamp</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:a96f7b448c30ecbce54e8c1243ccc8c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <a href="namespacecudf.html#a96f7b448c30ecbce54e8c1243ccc8c4d">More...</a><br /></td></tr>
<tr class="separator:a96f7b448c30ecbce54e8c1243ccc8c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa937abead085ea9420b15c6473f08a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa937abead085ea9420b15c6473f08a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aaa937abead085ea9420b15c6473f08a7">is_fixed_width</a> ()</td></tr>
<tr class="memdesc:aaa937abead085ea9420b15c6473f08a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of type <code>T</code> are fixed-width.  <a href="namespacecudf.html#aaa937abead085ea9420b15c6473f08a7">More...</a><br /></td></tr>
<tr class="separator:aaa937abead085ea9420b15c6473f08a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347d883100d3f7c725ad64c649f59c11"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a347d883100d3f7c725ad64c649f59c11">is_fixed_width</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:a347d883100d3f7c725ad64c649f59c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of <code>type</code> are fixed-width.  <a href="namespacecudf.html#a347d883100d3f7c725ad64c649f59c11">More...</a><br /></td></tr>
<tr class="separator:a347d883100d3f7c725ad64c649f59c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e1cea4200d1d92d7f38d596333d28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14e1cea4200d1d92d7f38d596333d28a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a14e1cea4200d1d92d7f38d596333d28a">is_compound</a> ()</td></tr>
<tr class="memdesc:a14e1cea4200d1d92d7f38d596333d28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a compound type.  <a href="namespacecudf.html#a14e1cea4200d1d92d7f38d596333d28a">More...</a><br /></td></tr>
<tr class="separator:a14e1cea4200d1d92d7f38d596333d28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f296c6fe2b6ae35ac59e41cbf1487d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad7f296c6fe2b6ae35ac59e41cbf1487d">is_compound</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ad7f296c6fe2b6ae35ac59e41cbf1487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of <code>type</code> are compound.  <a href="namespacecudf.html#ad7f296c6fe2b6ae35ac59e41cbf1487d">More...</a><br /></td></tr>
<tr class="separator:ad7f296c6fe2b6ae35ac59e41cbf1487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f075ce6421723e214c0d153fe695f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad15f075ce6421723e214c0d153fe695f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad15f075ce6421723e214c0d153fe695f">is_simple</a> ()</td></tr>
<tr class="memdesc:ad15f075ce6421723e214c0d153fe695f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a simple type.  <a href="namespacecudf.html#ad15f075ce6421723e214c0d153fe695f">More...</a><br /></td></tr>
<tr class="separator:ad15f075ce6421723e214c0d153fe695f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e62b8bc2981be767ae3f6843877956"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae6e62b8bc2981be767ae3f6843877956">is_simple</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ae6e62b8bc2981be767ae3f6843877956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of <code>type</code> are simple.  <a href="namespacecudf.html#ae6e62b8bc2981be767ae3f6843877956">More...</a><br /></td></tr>
<tr class="separator:ae6e62b8bc2981be767ae3f6843877956"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aab6fe3e771357669cccd3a8fe0ee3729"><td class="memItemLeft" align="right" valign="top">__constant__ char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aab6fe3e771357669cccd3a8fe0ee3729">max_string_sentinel</a> [5] {&quot;\xF7\xBF\xBF\xBF&quot;}</td></tr>
<tr class="memdesc:aab6fe3e771357669cccd3a8fe0ee3729"><td class="mdescLeft">&#160;</td><td class="mdescRight">string value for sentinel which is used in min, max reduction operators This sentinel string value is the highest possible valid UTF-8 encoded character. This serves as identity value for maximum operator on string values. Also, this char pointer serves as valid device pointer of identity value for minimum operator on string values.  <a href="namespacecudf.html#aab6fe3e771357669cccd3a8fe0ee3729">More...</a><br /></td></tr>
<tr class="separator:aab6fe3e771357669cccd3a8fe0ee3729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>cuDF interfaces </p>
<p>Invokes an instance of a functor template with the appropriate type determined by a gdf_dtype enum value.</p>
<p>This helper function accepts any object with an "operator()" template, e.g., a functor. It will invoke an instance of the template by passing in as the template argument an appropriate type determined by the value of the gdf_dtype argument.</p>
<p>The template may have 1 or more template parameters, but the first parameter must be the type dispatched from the gdf_dtype enum. The remaining template parameters must be able to be automatically deduced.</p>
<p>There is a 1-to-1 mapping of gdf_dtype enum values and dispatched types. However, different gdf_dtype values may have the same underlying type. Therefore, in order to provide the 1-to-1 mapping, a wrapper struct may be dispatched for certain gdf_dtype enum values in order to emulate a "strong
typedef".</p>
<p>A strong typedef provides a new, concrete type unlike a normal C++ typedef which is simply a type alias. These "strong typedef" structs simply wrap a single member variable of a fundamental type called 'value'.</p>
<p>The standard arithmetic operators are defined for the wrapper structs and therefore the wrapper struct types can be used as if they were fundamental types.</p>
<p>See <a class="el" href="wrapper__types_8hpp.html" title="Wrapper structs for for the non-fundamental gdf_dtype types.">wrapper_types.hpp</a> for more detail.</p>
<p>Example usage with a functor that returns the size of the dispatched type:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>example_functor{</div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"> <span class="keywordtype">int</span> operator()(){</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(T);</div>
<div class="line"> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">cudf::type_dispatcher(GDF_INT8, example_functor{});  <span class="comment">// returns 1</span></div>
<div class="line">cudf::type_dispatcher(GDF_INT64, example_functor{}); <span class="comment">// returns 8</span></div>
</div><!-- fragment --><p>Example usage of a functor for checking if element "i" in column "lhs" is equal to element "j" in column "rhs":</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>elements_are_equal{</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType&gt;</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">void</span> <span class="keyword">const</span> * lhs, <span class="keywordtype">int</span> i,</div>
<div class="line">                  <span class="keywordtype">void</span> <span class="keyword">const</span> * rhs, <span class="keywordtype">int</span> j)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Cast the void* data buffer to the dispatched type and retrieve</span></div>
<div class="line">elements</div>
<div class="line">    <span class="comment">// &quot;i&quot; and &quot;j&quot; from the respective columns</span></div>
<div class="line">    ColumnType <span class="keyword">const</span> i_elem = static_cast&lt;ColumnType const*&gt;(lhs)[i];</div>
<div class="line">    ColumnType <span class="keyword">const</span> j_elem = static_cast&lt;ColumnType const*&gt;(rhs)[j];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// operator== is defined for wrapper structs such that it performs the</span></div>
<div class="line">    <span class="comment">// operator== on the underlying values. Therefore, the wrapper structs</span></div>
<div class="line">    <span class="comment">// can be used as if they were fundamental arithmetic types</span></div>
<div class="line">    <span class="keywordflow">return</span> i_elem == j_elem;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>It is sometimes neccessary to customize the dispatched functor's <code>operator()</code> for different types. This can be done in several ways.</p>
<p>The first method is to use explicit template specialization. This is useful for specializing behavior for single types. For example, a functor that prints <code>int32_t</code> or <code>double</code> when invoked with either of those types, else it prints <code>unhandled type</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>type_printer {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">&quot;unhandled type\n&quot;</span>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Due to a bug in g++, explicit member function specializations need to be</span></div>
<div class="line"><span class="comment">// defined outside of the class definition</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> type_printer::operator()&lt;int32_t&gt;() { std::cout &lt;&lt; <span class="stringliteral">&quot;int32_t\n&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> type_printer::operator()&lt;<span class="keywordtype">double</span>&gt;() { std::cout &lt;&lt; <span class="stringliteral">&quot;double\n&quot;</span>; }</div>
</div><!-- fragment --><p>A second method is to use SFINAE with <code>std::enable_if_t</code>. This is useful for specializing for a set of types that share some property. For example, a functor that prints <code>integral</code> or <code>floating point</code> for integral or floating point types:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>integral_or_floating_point {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType,</div>
<div class="line">            std::enable_if_t&lt;not std::is_integral&lt;ColumnType&gt;::value and</div>
<div class="line">                             not std::is_floating_point&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">&quot;neither integral nor floating point\n&quot;</span>; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColumnType,</div>
<div class="line">            std::enable_if_t&lt;std::is_integral&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">&quot;integral\n&quot;</span>; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt; <span class="keyword">typename</span> ColumnType,</div>
<div class="line">             std::enable_if_t&lt;std::is_floating_point&lt;ColumnType&gt;::value&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()() { std::cout &lt;&lt; <span class="stringliteral">&quot;floating point\n&quot;</span>; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>For more info on SFINAE and <code>std::enable_if</code>, see <a href="https://eli.thegreenplace.net/2014/sfinae-and-enable_if/">https://eli.thegreenplace.net/2014/sfinae-and-enable_if/</a></p>
<p>The return type for all template instantiations of the functor's "operator()" lambda must be the same, else there will be a compiler error as you would be trying to return different types from the same function.</p>
<p>NOTE: It is undefined behavior if an unsupported or invalid <code>gdf_dtype</code> is supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The gdf_dtype enum that determines which type will be dispatched </td></tr>
    <tr><td class="paramname">f</td><td>The functor with a templated "operator()" that will be invoked with the dispatched type </td></tr>
    <tr><td class="paramname">args</td><td>A parameter-pack (i.e., arbitrary number of arguments) that will be perfectly-forwarded as the arguments of the functor's "operator()".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whatever is returned by the functor's "operator()". </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a177c346e93407722169284f15d260687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177c346e93407722169284f15d260687">&#9670;&nbsp;</a></span>timestamp_D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf.html#a177c346e93407722169284f15d260687">cudf::timestamp_D</a> = typedef <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt; simt::std::chrono::duration&lt;int32_t, simt::std::ratio&lt;86400&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias representing an int32_t duration of days since the unix. </p>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md568"></a>
epoch.</h2>

</div>
</div>
<a id="a1e65b98c47669295653e4fe59b66fe34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e65b98c47669295653e4fe59b66fe34">&#9670;&nbsp;</a></span>timestamp_ms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf.html#a1e65b98c47669295653e4fe59b66fe34">cudf::timestamp_ms</a> = typedef <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt;simt::std::chrono::duration&lt;int64_t, simt::std::milli&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias representing an int64_t duration of milliseconds since. </p>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md570"></a>
the unix epoch.</h2>

</div>
</div>
<a id="a8090bb1d4eb05e199337b8e98fcdddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8090bb1d4eb05e199337b8e98fcdddbf">&#9670;&nbsp;</a></span>timestamp_ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf.html#a8090bb1d4eb05e199337b8e98fcdddbf">cudf::timestamp_ns</a> = typedef <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt;simt::std::chrono::duration&lt;int64_t, simt::std::nano&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias representing an int64_t duration of nanoseconds since. </p>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md572"></a>
the unix epoch.</h2>

</div>
</div>
<a id="a3eb94ae284a4ec44c14765633fd6f0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb94ae284a4ec44c14765633fd6f0de">&#9670;&nbsp;</a></span>timestamp_s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf.html#a3eb94ae284a4ec44c14765633fd6f0de">cudf::timestamp_s</a> = typedef <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt; simt::std::chrono::duration&lt;int64_t, simt::std::ratio&lt;1&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias representing an int64_t duration of seconds since the. </p>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md569"></a>
unix epoch.</h2>

</div>
</div>
<a id="a0455750f053fbc9234bd7f1478a8b8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0455750f053fbc9234bd7f1478a8b8a2">&#9670;&nbsp;</a></span>timestamp_us</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf.html#a0455750f053fbc9234bd7f1478a8b8a2">cudf::timestamp_us</a> = typedef <a class="el" href="structcudf_1_1detail_1_1timestamp.html">detail::timestamp</a>&lt;simt::std::chrono::duration&lt;int64_t, simt::std::micro&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias representing an int64_t duration of microseconds since. </p>
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md571"></a>
the unix epoch.</h2>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a69091647ea1f9c9d4cdcf7c8876bea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69091647ea1f9c9d4cdcf7c8876bea3a">&#9670;&nbsp;</a></span>duplicate_keep_option</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">cudf::duplicate_keep_option</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choices for drop_duplicates API for retainment of duplicate rows. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa86ea4bfd2b3121412b0a63a3697926ec"></a>KEEP_FIRST&#160;</td><td class="fielddoc"><p>Keeps first duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa1d1398f646d74e801389737f07d89d1c"></a>KEEP_LAST&#160;</td><td class="fielddoc"><p>Keeps last duplicate row and unique rows. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69091647ea1f9c9d4cdcf7c8876bea3aa6fb3154b77231184b596b4add407aa2a"></a>KEEP_NONE&#160;</td><td class="fielddoc"><p>Don't keep any duplicate rows, Keeps only unique rows. </p>
</td></tr>
</table>

</div>
</div>
<a id="a94d60cf0790fb642cce1c91f1dba63c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d60cf0790fb642cce1c91f1dba63c8">&#9670;&nbsp;</a></span>interpolation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">cudf::interpolation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolation method to use, when the desired quantile lies between two data points i and j. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8ab424744b6ce548ac355f5830c0a8c5e1"></a>LINEAR&#160;</td><td class="fielddoc"><p>Linear interpolation between i and j. </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8a00b75d21f696dc9d435e8b4b3c3bc58d"></a>LOWER&#160;</td><td class="fielddoc"><p>Lower data point (i) </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8ae5385a7a8eb742f08471ba73ea2d77ba"></a>HIGHER&#160;</td><td class="fielddoc"><p>Higher data point (j) </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8a7b5062e7868e9d05c598ef7ad6619014"></a>MIDPOINT&#160;</td><td class="fielddoc"><p>(i + j)/2 </p>
</td></tr>
<tr><td class="fieldname"><a id="a94d60cf0790fb642cce1c91f1dba63c8a04fd403d483f6415e0b006bc67bd8fac"></a>NEAREST&#160;</td><td class="fielddoc"><p>i or j, whichever is nearest </p>
</td></tr>
</table>

</div>
</div>
<a id="a267e03474dcfd85242d2fdc6e5846ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267e03474dcfd85242d2fdc6e5846ec6">&#9670;&nbsp;</a></span>mask_allocation_policy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">cudf::mask_allocation_policy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md346"></a>
@brief Indicates when to allocate a mask, based on an existing mask.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a267e03474dcfd85242d2fdc6e5846ec6a615857bddd061281abf998989fb2ba8f"></a>NEVER&#160;</td><td class="fielddoc"><p>Do not allocate a null mask, regardless of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56"></a>RETAIN&#160;</td><td class="fielddoc"><p>Allocate a null mask if the input contains one. </p>
</td></tr>
<tr><td class="fieldname"><a id="a267e03474dcfd85242d2fdc6e5846ec6a995bafc1b2e35df60002e61e2ec0c6df"></a>ALWAYS&#160;</td><td class="fielddoc"><p>Allocate a null mask, regardless of input. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa481249b705132999f4d082aacd21dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa481249b705132999f4d082aacd21dbf">&#9670;&nbsp;</a></span>mask_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">cudf::mask_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md516"></a>
@brief Controls the allocation/initialization of a null mask.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344"></a>UNALLOCATED&#160;</td><td class="fielddoc"><p>Null mask not allocated, (all elements are valid) </p>
</td></tr>
<tr><td class="fieldname"><a id="aa481249b705132999f4d082aacd21dbfa37d7c1f4781c3276729ed1678c0c0844"></a>UNINITIALIZED&#160;</td><td class="fielddoc"><p>Null mask allocated, but not initialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa481249b705132999f4d082aacd21dbfadb86173d779f7b173db120643cc1c402"></a>ALL_VALID&#160;</td><td class="fielddoc"><p>Null mask allocated, initialized to all elements valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa481249b705132999f4d082aacd21dbfa042cac70175410616150fafb92f76351"></a>ALL_NULL&#160;</td><td class="fielddoc"><p>Null mask allocated, initialized to all elements NULL. </p>
</td></tr>
</table>

</div>
</div>
<a id="a058e6d6e8a21583ce0e85ee73e5abb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058e6d6e8a21583ce0e85ee73e5abb31">&#9670;&nbsp;</a></span>null_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md514"></a>
@brief Indicates how null values compare against all other values.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb"></a>AFTER&#160;</td><td class="fielddoc"><p>NULL values ordered <em>after</em> all other values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07"></a>BEFORE&#160;</td><td class="fielddoc"><p>NULL values ordered <em>before</em> all other values. </p>
</td></tr>
</table>

</div>
</div>
<a id="a750f02016b046079f7062d334890b4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750f02016b046079f7062d334890b4fc">&#9670;&nbsp;</a></span>order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#a750f02016b046079f7062d334890b4fc">cudf::order</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md513"></a>
@brief Indicates the order in which elements should be sorted.</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a750f02016b046079f7062d334890b4fca83ec681a20197326c163ea3b39ef7c32"></a>ASCENDING&#160;</td><td class="fielddoc"><p>Elements ordered from small to large. </p>
</td></tr>
<tr><td class="fieldname"><a id="a750f02016b046079f7062d334890b4fcacff818f0ae4cef845577e39283886a53"></a>DESCENDING&#160;</td><td class="fielddoc"><p>Elements ordered from large to small. </p>
</td></tr>
</table>

</div>
</div>
<a id="acd4cd7157c4379954b5772936f89c59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4cd7157c4379954b5772936f89c59b">&#9670;&nbsp;</a></span>type_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#acd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md517"></a>
@brief Identifies a column's logical element type</h2>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59bab2c14e467fcbf9a215ccc679f35bb027"></a>EMPTY&#160;</td><td class="fielddoc"><p>Always null with no underlying data. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba71f4b0467efae61c1e3ac5910178940f"></a>INT8&#160;</td><td class="fielddoc"><p>1 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba7dafa1ea3755308998ff8c972342c099"></a>INT16&#160;</td><td class="fielddoc"><p>2 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae"></a>INT32&#160;</td><td class="fielddoc"><p>4 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59bab9c234f82eec5cb83e3ea67aac9c1166"></a>INT64&#160;</td><td class="fielddoc"><p>8 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba37225001c5ad4b3d1aa808620debfe7a"></a>FLOAT32&#160;</td><td class="fielddoc"><p>4 byte floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59baf24707a0d5537fd50bca87cd18a9a0e5"></a>FLOAT64&#160;</td><td class="fielddoc"><p>8 byte floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba9100ee556e5cf9b6dada6c7c506fa138"></a>BOOL8&#160;</td><td class="fielddoc"><p>Boolean using one byte per value, 0 == false, else true. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba8a653791c2c90530cd2452ef46a01ab2"></a>TIMESTAMP_DAYS&#160;</td><td class="fielddoc"><p>days since Unix Epoch in int32 </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba75e3c065f03583dc3b94ec069c4fe34d"></a>TIMESTAMP_SECONDS&#160;</td><td class="fielddoc"><p>duration of seconds since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba5cb4e0f1d7d608d8801707a376e43b64"></a>TIMESTAMP_MILLISECONDS&#160;</td><td class="fielddoc"><p>duration of milliseconds since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59bab892ce722f86206a6496700f2c4a3abf"></a>TIMESTAMP_MICROSECONDS&#160;</td><td class="fielddoc"><p>duration of microseconds since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba9864c6a53387a840e7c6ed2672fed2c9"></a>TIMESTAMP_NANOSECONDS&#160;</td><td class="fielddoc"><p>duration of nanoseconds since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59baabcc7f7b028da5bba90f587958cc1026"></a>CATEGORY&#160;</td><td class="fielddoc"><p>Categorial/Dictionary type. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59bae008ab0db4e9b28f33e1e3c9c3daf444"></a>STRING&#160;</td><td class="fielddoc"><p>String elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4cd7157c4379954b5772936f89c59ba0f6b1e874ab643a0f237082cb35acad5"></a>NUM_TYPE_IDS&#160;</td><td class="fielddoc"><p>Total number of type ids. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab15567f1034536ae6f7f14179334a19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15567f1034536ae6f7f14179334a19b">&#9670;&nbsp;</a></span>unary_op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">cudf::unary_op</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of unary operations that can be performed on data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba6b585cf453d36fbb0381b38bc2c966e1"></a>SIN&#160;</td><td class="fielddoc"><p>Trigonometric sine. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19baf7c88ff3bee94b5c3c16c405706ef34a"></a>COS&#160;</td><td class="fielddoc"><p>Trigonometric cosine. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19baa91cdd09214d36d756b5f13803ddd890"></a>TAN&#160;</td><td class="fielddoc"><p>Trigonometric tangent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba463397f416a024fb7df7d906a0436dbb"></a>ARCSIN&#160;</td><td class="fielddoc"><p>Trigonometric sine inverse. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba1e17febbc6d14208d0a264562dcee2e9"></a>ARCCOS&#160;</td><td class="fielddoc"><p>Trigonometric cosine inverse. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19bad1c5c0c8ffe6bf038e617b0aad0f9aac"></a>ARCTAN&#160;</td><td class="fielddoc"><p>Trigonometric tangent inverse. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba6e272b8c75625066b2c8994cec6c8f73"></a>EXP&#160;</td><td class="fielddoc"><p>Exponential (base e, Euler number) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba1509f8449abb15062ad85e15fb3861d7"></a>LOG&#160;</td><td class="fielddoc"><p>Natural Logarithm (base e) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba6ac653ea3d15f23b0f6e61b447f783ea"></a>SQRT&#160;</td><td class="fielddoc"><p>Square-root (x^0.5) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba8b0d502b44d1472a2d5fa3638f0ce945"></a>CEIL&#160;</td><td class="fielddoc"><p>Smallest integer value not less than arg. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba07e330cc72f454a6369d267d1bfb2d7e"></a>FLOOR&#160;</td><td class="fielddoc"><p>largest integer value not greater than arg </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19bab226be3789467f51f32cf06550a4c46e"></a>ABS&#160;</td><td class="fielddoc"><p>Absolute value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba62a7f82a72f8422f631cb550b7201667"></a>BIT_INVERT&#160;</td><td class="fielddoc"><p>Bitwise Not (~) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15567f1034536ae6f7f14179334a19ba5e654d9830c09fc254d4f9f19fbdfe6e"></a>NOT&#160;</td><td class="fielddoc"><p>Logical Not (!) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3fbb86eb24e5093dcddeb0a0640b768f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbb86eb24e5093dcddeb0a0640b768f">&#9670;&nbsp;</a></span>allocate_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::allocate_column </td>
          <td>(</td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocate_mask</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>&#160;</td>
          <td class="paramname"><em>info</em> = <code><a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new column of the specified size and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>Datatype of the column </td></tr>
    <tr><td class="paramname">size</td><td>Size of the column </td></tr>
    <tr><td class="paramname">allocate_mask</td><td>Optional Whether or not to allocate bitmask </td></tr>
    <tr><td class="paramname">info</td><td>Optional Extra info for the column </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column An allocated column of given size and type </dd></dl>

</div>
</div>
<a id="af4cd23de19c39850cb4869f83c6b73da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cd23de19c39850cb4869f83c6b73da">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new column of the specified size and same type as the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to emulate </td></tr>
    <tr><td class="paramname">size</td><td>The size of the column to allocate in rows </td></tr>
    <tr><td class="paramname">mask_alloc</td><td>Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column An allocated column of same size and type of input </dd></dl>

</div>
</div>
<a id="ac72ee052f776990ab9240e757d8493ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72ee052f776990ab9240e757d8493ad">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new column of the same size and type as the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to emulate </td></tr>
    <tr><td class="paramname">mask_alloc</td><td>Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column An allocated column of same size and type of input </dd></dl>

</div>
</div>
<a id="afd4654d206fea417b13b245c085771ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4654d206fea417b13b245c085771ee">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns with the specified size and same type as the input. </p>
<p>Creates the <code>gdf_column</code> objects, and allocates underlying device memory for each column matching the input columns</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to emulate </td></tr>
    <tr><td class="paramname">size</td><td>The size of the columns to allocate </td></tr>
    <tr><td class="paramname">mask_alloc</td><td>Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table of columns with same type as <code>t</code> and specified <code>size</code> </dd></dl>

</div>
</div>
<a id="ada80dc11907eac4cd65640233b777452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada80dc11907eac4cd65640233b777452">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="namespacecudf.html#a267e03474dcfd85242d2fdc6e5846ec6aae077198d21c34fd782bf2616a040c56">RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns with the same type and allocation size as the input. </p>
<p>Creates the <code>gdf_column</code> objects, and allocates underlying device memory for each column matching the input columns</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to emulate </td></tr>
    <tr><td class="paramname">mask_alloc</td><td>Policy for allocating null mask. Defaults to RETAIN. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table of columns with same type and allocation size as input </dd></dl>

</div>
</div>
<a id="a99ef104e8889becc66feebc7bf8aaf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ef104e8889becc66feebc7bf8aaf0e">&#9670;&nbsp;</a></span>allocSequenceBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gdf_error cudf::allocSequenceBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudf::size_type&#160;</td>
          <td class="paramname"><em>buffer_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer and fills it with a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of the buffer to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_length</td><td>Amount of memory to be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></td><td>The data type to be used for the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon succesful completion </dd></dl>

</div>
</div>
<a id="a325cbb27e6779a8d235f11f92979bb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325cbb27e6779a8d235f11f92979bb1f">&#9670;&nbsp;</a></span>allocValueBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gdf_error cudf::allocValueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudf::size_type&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer and fills it with a repeated value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Address of the buffer to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_length</td><td>Amount of memory to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be filled into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></td><td>The data type to be used for the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon succesful completion </dd></dl>

</div>
</div>
<a id="ad888a160fd5439ce10ed29232debc200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad888a160fd5439ce10ed29232debc200">&#9670;&nbsp;</a></span>apply_boolean_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::apply_boolean_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a table using a column of boolean values as a mask. </p>
<p>Given an input table and a mask column, an element <code>i</code> from each column of the input table is copied to the corresponding output column if the corresponding element <code>i</code> in the mask is non-null and <code>true</code>. This operation is stable: the input order is preserved.</p>
<p>The input and mask columns must be of equal size (number of rows).</p>
<p>The output table has number of rows equal to the number of elements in boolean_mask that are both non-null and <code>true</code>. Note that the output table memory is allocated by this function but must be freed by the caller when finished.</p>
<dl class="section note"><dt>Note</dt><dd>that the <code>boolean_mask</code> may have just boolean data (no valid bitmask), or just a valid bitmask (no boolean data), or it may have both. The filter adapts to these three situations.</dd>
<dd>
if <code>input.num_rows()</code> is zero, there is no error, and an empty table is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input table to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>A column of type GDF_BOOL8 used as a mask to filter the input column corresponding index passes the filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> Table containing copy of all rows of <code>input</code> passing the filter defined by <code>boolean_mask</code>. </dd></dl>

</div>
</div>
<a id="a1f727c257f82efc1a7b144eb6dcbb2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f727c257f82efc1a7b144eb6dcbb2d8">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ptx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two gdf_columns using a user-defined PTX function. </p>
<p>Accepts a user-defined PTX function to apply between the <code>lhs</code> and <code>rhs</code>.</p>
<p>The desired output type must be specified in output_type. It is assumed that this output type is compatable with the output type in the PTX code.</p>
<p>The output column will be allocated and it is the user's reponsibility to free the device memory</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid masks of lhs and rhs gdf_columns</p>
<dl class="section return"><dt>Returns</dt><dd>A gdf_column as the output of the operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ptx</td><td>String containing the PTX of a binary function to apply between <code>lhs</code> and <code>rhs</code> </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired output type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad01e2e81bc2b671dfb8963a7be22e3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01e2e81bc2b671dfb8963a7be22e3b0">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two gdf_columns. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid masks of lhs and rhs gdf_columns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa02af1454978d7d7f7b9f651437b3ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02af1454978d7d7f7b9f651437b3ab5">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a gdf_column and a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a>. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid mask of lhs gdf_column and is_valid bool of rhs <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(gdf_column) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a>) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae942e9a8d320f23d61bee22ddc06df55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae942e9a8d320f23d61bee22ddc06df55">&#9670;&nbsp;</a></span>binary_operation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_binary_operator&#160;</td>
          <td class="paramname"><em>ope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> and a gdf_column. </p>
<p>The desired output type must be specified in out-&gt;dtype.</p>
<p>If the valid field in the gdf_column output is not nullptr, then it will be filled with the bitwise AND of the valid mask of rhs gdf_column and is_valid bool of lhs <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(gdf_column) Output of the operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>(<a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a>) First operand of the operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>(gdf_column) Second operand of the operation. </td></tr>
    <tr><td class="paramname">ope</td><td>(enum) The binary operator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accd9af00974def8f416225ad650d33c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd9af00974def8f416225ad650d33c9">&#9670;&nbsp;</a></span>bit_is_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDA_HOST_DEVICE_CALLABLE bool cudf::bit_is_set </td>
          <td>(</td>
          <td class="paramtype">bitmask_type const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the specified bit is set to <code>1</code> </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_index</td><td>Index of the bit to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The specified bit is <code>1</code> </dd></dl>
<h2><a class="anchor" id="autotoc_md526"></a>
@return false  The specified bit is &lt;tt&gt;0&lt;/tt&gt;</h2>

</div>
</div>
<a id="a3c26b8cbca80321602bc3f39ab6cce8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c26b8cbca80321602bc3f39ab6cce8d">&#9670;&nbsp;</a></span>bitmask_allocation_size_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cudf::bitmask_allocation_size_bytes </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>number_of_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>padding_boundary</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the required bytes necessary to represent the specified number of bits with a given padding boundary. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="section note"><dt>Note</dt><dd>The Arrow specification for the null bitmask requires a 64B padding boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_bits</td><td>The number of bits that need to be represented </td></tr>
    <tr><td class="paramname">padding_boundary</td><td>The value returned will be rounded up to a multiple of this value </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md444"></a>
@return std::size_t The necessary number of bytes</h2>

</div>
</div>
<a id="ad79e6af7c78b2aac90456cfcd20cd7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79e6af7c78b2aac90456cfcd20cd7db">&#9670;&nbsp;</a></span>bitmask_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::bitmask_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a bitwise AND of the bitmasks of columns of a table. </p>
<p>If any of the columns isn't nullable, it is considered all valid. If no column in the table is nullable, an empty bitmask is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The table of columns </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream on which to execute kernels </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource for allocating output bitmask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmm::device_buffer Output bitmask </dd></dl>

</div>
</div>
<a id="aca9904c47d7ae6d33143b6441cba45d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9904c47d7ae6d33143b6441cba45d2">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>out_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>&#160;</td>
          <td class="paramname"><em>out_info</em> = <code><a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts data from dtype specified in input to dtype specified in output. </p>
<dl class="section note"><dt>Note</dt><dd>In case of conversion from GDF_DATE32/GDF_DATE64/GDF_TIMESTAMP to GDF_TIMESTAMP, the time unit for output should be set in out_info.time_unit</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gdf_column</td><td>Input column </td></tr>
    <tr><td class="paramname">out_type</td><td>Desired datatype of output column </td></tr>
    <tr><td class="paramname">out_info</td><td>Extra info for output column in case of conversion to types that require extra info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Result of the cast operation </dd></dl>

</div>
</div>
<a id="aaabda3ecfba220ffdfd76a7076259483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabda3ecfba220ffdfd76a7076259483">&#9670;&nbsp;</a></span>clear_bit_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDA_HOST_DEVICE_CALLABLE void cudf::clear_bit_unsafe </td>
          <td>(</td>
          <td class="paramtype">bitmask_type *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified bit to <code>0</code> </p>
<p>------------------------------------------------------------------------&mdash;* This function is not thread-safe, i.e., attempting to update bits within the same word concurrently from multiple threads results in undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>The bitmask containing the bit to clear </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md525"></a>
@param bit_index The index of the bit to clear</h2>

</div>
</div>
<a id="ad2c2c74e4d88e3c0b67e7dea9f7086cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c2c74e4d88e3c0b67e7dea9f7086cc">&#9670;&nbsp;</a></span>column_dtype_infos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__dtype__extra__info.html">gdf_dtype_extra_info</a> &gt; cudf::column_dtype_infos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of the dtype_infos of the columns in a table. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to get the column dtypes_infos from </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md426"></a>
@return std::vector&lt;gdf_dtype_extra_info&gt;</h2>

</div>
</div>
<a id="ad2f973d94c67ab3dc1a183c5adb3753d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f973d94c67ab3dc1a183c5adb3753d">&#9670;&nbsp;</a></span>column_dtypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gdf_dtype &gt; cudf::column_dtypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of the dtypes of the columns in a table. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to get the column dtypes from </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md425"></a>
@return std::vector&lt;gdf_dtype&gt;</h2>

</div>
</div>
<a id="a7dbd2350ad171265f45f63404ab32ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbd2350ad171265f45f63404ab32ffd">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>table1</code> and <code>table2</code> are concatenated to return single table </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If number of rows mismatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table1</td><td>The table to be concatenated with <code>table2</code> </td></tr>
    <tr><td class="paramname">table2</td><td>The table to be concatenated with <code>table1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single table having all the columns from <code>table1</code> and <code>table2</code> </dd></dl>
<h2><a class="anchor" id="autotoc_md428"></a>
respectively in the same order.</h2>

</div>
</div>
<a id="a24d275bb55b8c0ac520f23f371d92e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d275bb55b8c0ac520f23f371d92e2b">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::concatenate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>columns_to_concat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates multiple columns into a single column. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If types of the input columns mismatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns_to_concat</td><td>The column views to be concatenated into a single column </td></tr>
    <tr><td class="paramname">mr</td><td>Optional The resource to use for all allocations </td></tr>
    <tr><td class="paramname">stream</td><td>Optional The stream on which to execute all allocations and copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to a single table having all the rows from the </dd></dl>
<h2><a class="anchor" id="autotoc_md178"></a>
elements of &lt;tt&gt;columns_to_concat&lt;/tt&gt; respectively in the same order.</h2>

</div>
</div>
<a id="adcfd5d8fe7e7ece5f642d95bc0640ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfd5d8fe7e7ece5f642d95bc0640ffe">&#9670;&nbsp;</a></span>concatenate_masks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::concatenate_masks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>views</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates <code>views[i]</code>'s bitmask from the bits <code>[views[i].offset(), views[i].offset() + views[i].size())</code> for all elements views[i] in views into a <code>device_buffer</code> </p>
<p>------------------------------------------------------------------------&mdash;* Returns empty <code>device_buffer</code> if the column is not nullable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">views</td><td>Vector of column views whose bitmask will to be concatenated </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, the memory resource that will be used for allocating the device memory for the new device_buffer </td></tr>
    <tr><td class="paramname">stream</td><td>Optional, stream on which all memory allocations and copies will be performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmm::device_buffer A <code>device_buffer</code> containing the bitmasks of all </dd></dl>
<h2><a class="anchor" id="autotoc_md451"></a>
the column views in the views vector</h2>

</div>
</div>
<a id="a191d468c4194dbbf8a94ff15b6f260b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191d468c4194dbbf8a94ff15b6f260b1">&#9670;&nbsp;</a></span>construct_join_output_df()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;JoinType join_type, typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::construct_join_output_df </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>columns_in_common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>left_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>right_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers rows indicated by <code>left_indices</code> and <code>right_indices</code> from tables <code>left</code> and <code>right</code>, respectively, into a single <code>table</code>. </p>
<p>The row from <code>left</code> at <code>left_indices[i]</code> will be concatenated with the row i from <code>right</code> at <code>right_indices[i]</code> to form a new row in the output <code>table</code>. If either <code>left_indices[i]</code> or <code>right_indices[i]</code> is negative, then the i contributions from <code>left</code> or <code>right</code> will be NULL.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If call to nvcategory_gather_table fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The left table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>the right table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns_in_common</td><td>is a vector of pairs of column indices from tables <code>left</code> and <code>right</code> respectively, that are "in common". For "common" columns, only a single output column will be produced. For an inner or left join, the result will be gathered from the column in <code>left</code>. For a full join, the result will be gathered from both common columns in <code>left</code> and <code>right</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_indices</td><td>Row indices from <code>left</code> to gather. If any row index is out of bounds, the contribution in the output <code>table</code> will be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_indicess</td><td>Row indices from <code>right</code> to gather. If any row index is out of bounds, the contribution in the output <code>table</code> will be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>table</code> containing the concatenation of rows from <code>left</code> and <code>right</code> specified by <code>left_indices</code> and <code>right_indices</code>, respectively. For any columns indicated by <code>columns_in_common</code>, only the corresponding column in <code>left</code> will be included in the result. Final form would look like <code>left(including common columns)+right(excluding common columns)</code>. </dd></dl>

</div>
</div>
<a id="aa7e6bf39cb5dd5cdb370d0a562675922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e6bf39cb5dd5cdb370d0a562675922">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column that is a copy of input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to copy </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column A copy of input </dd></dl>

</div>
</div>
<a id="a9fae65b5e23d13aec03edef7a8aeacb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae65b5e23d13aec03edef7a8aeacb0">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns and deep copies the data from an input table. </p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to copy </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations and copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table that is an exact copy of <code>t</code> </dd></dl>

</div>
</div>
<a id="a17512d5f18a405bff0ec9b9987eaed6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17512d5f18a405bff0ec9b9987eaed6e">&#9670;&nbsp;</a></span>copy_bitmask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::copy_bitmask </td>
          <td>(</td>
          <td class="paramtype">bitmask_type const *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>begin_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>end_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code>device_buffer</code> from a slice of bitmask defined by a range of indices <code>[begin_bit, end_bit)</code>. </p>
<p>------------------------------------------------------------------------&mdash;* Returns empty <code>device_buffer</code> if <code>bitmask == nullptr</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>begin_bit &gt; end_bit</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>begin_bit &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask residing in device memory whose bits will be copied </td></tr>
    <tr><td class="paramname">begin_bit</td><td>Index of the first bit to be copied (inclusive) </td></tr>
    <tr><td class="paramname">end_bit</td><td>Index of the last bit to be copied (exclusive) </td></tr>
    <tr><td class="paramname">stream</td><td>Optional, stream on which all memory allocations and copies will be performed </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, the memory resource that will be used for allocating the device memory for the new device_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmm::device_buffer A <code>device_buffer</code> containing the bits </dd></dl>
<h2><a class="anchor" id="autotoc_md449"></a>
&lt;tt&gt;[begin_bit, end_bit)&lt;/tt&gt; from &lt;tt&gt;mask&lt;/tt&gt;.</h2>

</div>
</div>
<a id="a0483dfaa7c4ef5878988f5a1ee0345cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0483dfaa7c4ef5878988f5a1ee0345cd">&#9670;&nbsp;</a></span>copy_bitmask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::copy_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies <code>view</code>'s bitmask from the bits <code>[view.offset(), view.offset() + view.size())</code> into a <code>device_buffer</code> </p>
<p>------------------------------------------------------------------------&mdash;* Returns empty <code>device_buffer</code> if the column is not nullable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Column view whose bitmask needs to be copied </td></tr>
    <tr><td class="paramname">stream</td><td>Optional, stream on which all memory allocations and copies will be performed </td></tr>
    <tr><td class="paramname">mr</td><td>Optional, the memory resource that will be used for allocating the device memory for the new device_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmm::device_buffer A <code>device_buffer</code> containing the bits </dd></dl>
<h2><a class="anchor" id="autotoc_md450"></a>
&lt;tt&gt;[view.offset(), view.offset() + view.size())&lt;/tt&gt; from &lt;tt&gt;view&lt;/tt&gt;'s bitmask.</h2>

</div>
</div>
<a id="a09dad593f28fe6f5f4d412794540e3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dad593f28fe6f5f4d412794540e3ba">&#9670;&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>out_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>in_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>out_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>out_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>in_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements from one column to another. </p>
<p>Copies N elements of <code>in_column</code> starting at <code>in_begin</code> to the N elements of <code>out_column</code> starting at <code>out_begin</code>, where N = (<code>out_end</code> - <code>out_begin</code>)</p>
<p>The datatypes of in_column and out_column must be the same.</p>
<p>If the input and output columns are the same and ranges overlap, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out_column</td><td>The preallocated column to copy into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_column</td><td>The column to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_begin</td><td>The starting index of the output range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_end</td><td>The index one past the end of the output range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_begin</td><td>The starting index of the input range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="aef675a9c75a848ab796ae9b2b51c4238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef675a9c75a848ab796ae9b2b51c4238">&#9670;&nbsp;</a></span>count_descendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type cudf::count_descendants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a>&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of descendants of the specified parent. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent whose descendants will be counted </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md255"></a>
@return size_type The number of descendants of the parent</h2>

</div>
</div>
<a id="ae8405a236b985ea3d8a626f92e40658c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8405a236b985ea3d8a626f92e40658c">&#9670;&nbsp;</a></span>count_set_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::size_type cudf::count_set_bits </td>
          <td>(</td>
          <td class="paramtype">bitmask_type const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bitmask, counts the number of set (1) bits in the range <code>[start, stop)</code> </p>
<p>------------------------------------------------------------------------&mdash;* Returns <code>0</code> if <code>bitmask == nullptr</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>start &gt; stop</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>start &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>Bitmask residing in device memory whose bits will be counted </td></tr>
    <tr><td class="paramname">start_bit</td><td>Index of the first bit to count (inclusive) </td></tr>
    <tr><td class="paramname">stop_bit</td><td>Index of the last bit to count (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md447"></a>
@return The number of non-zero bits in the specified range</h2>

</div>
</div>
<a id="aeff1677d6e025ceb78e4fdc631125170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff1677d6e025ceb78e4fdc631125170">&#9670;&nbsp;</a></span>count_unset_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::size_type cudf::count_unset_bits </td>
          <td>(</td>
          <td class="paramtype">bitmask_type const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bitmask, counts the number of unset (0) bits in the range <code>[start, stop)</code>. </p>
<p>------------------------------------------------------------------------&mdash;* Returns <code>0</code> if <code>bitmask == nullptr</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>start &gt; stop</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>start &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>Bitmask residing in device memory whose bits will be counted </td></tr>
    <tr><td class="paramname">start_bit</td><td>Index of the first bit to count (inclusive) </td></tr>
    <tr><td class="paramname">stop_bit</td><td>Index of the last bit to count (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md448"></a>
@return The number of zero bits in the specified range</h2>

</div>
</div>
<a id="a5834edc8cde53fb6b23f2e95847c8066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5834edc8cde53fb6b23f2e95847c8066">&#9670;&nbsp;</a></span>create_null_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::create_null_mask </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code>device_buffer</code> for use as a null value indicator bitmask of a <code>column</code>. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements to be represented by the mask </td></tr>
    <tr><td class="paramname">state</td><td>The desired state of the mask </td></tr>
    <tr><td class="paramname">stream</td><td>Optional, stream on which all memory allocations/operations will be submitted </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to use for device memory allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rmm::device_buffer A <code>device_buffer</code> for use as a null bitmask </dd></dl>
<h2><a class="anchor" id="autotoc_md445"></a>
satisfying the desired size and state</h2>

</div>
</div>
<a id="a98e2081a7b72b9e1ee1013b7f16127fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e2081a7b72b9e1ee1013b7f16127fa">&#9670;&nbsp;</a></span>drop_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::drop_duplicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecudf.html#a69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a>&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>nulls_are_equal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table without duplicate rows. </p>
<p>Given an input table, each row is copied to output table if the corresponding row of key column table is unique, where the definition of unique depends on the value of <code>keep:</code> </p><ul>
<li>KEEP_FIRST: only the first of a sequence of duplicate rows is copied</li>
<li>KEEP_LAST: only the last of a sequence of duplicate rows is copied</li>
<li>KEEP_NONE: no duplicate rows are copied</li>
</ul>
<p>The input table and key columns table should have same number of rows. Note that the memory for the output table columns is allocated by this function, so it must be freed by the caller when finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>input table to copy only unique rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>columns to consider to identify duplicate rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>keep first entry, last entry, or no entries if duplicates found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_are_equal</td><td>flag to denote nulls are equal if true, nulls are not equal if false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new table with only unique rows </dd></dl>

</div>
</div>
<a id="aa3f0e5730d9073dda64effa64dce2cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f0e5730d9073dda64effa64dce2cfa">&#9670;&nbsp;</a></span>drop_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::drop_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>keep_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a table to remove null elements. </p>
<p>Filters the rows of the input table considering only specified columns for validity / null values.</p>
<p>Given an input table, row <code>i</code> from the input columns is copied to the output if the same row <code>i</code> of <code>keys</code> has at leaast <code>keep_threshold</code> non-null fields.</p>
<p>This operation is stable: the input order is preserved in the output.</p>
<p>Note that the memory for the columns of the output table is allocated by this function but must be freed by the caller when finished.</p>
<p>Any non-nullable column in the input is treated as all non-null.</p>
<dl class="section note"><dt>Note</dt><dd>if <code>input.num_rows()</code> is zero, or <code>keys</code> is empty or has no nulls, there is no error, and an empty table is returned</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>keys</code> is non-empty and keys.num_rows() is less than input.num_rows()</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input table to filter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>The table of columns to check for nulls. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_threshold</td><td>The minimum number of non-null fields in a row required to keep the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> Table containing all rows of the input table with at least <code>keep_threshold</code> non-null fields in <code>keys</code>. </dd></dl>

</div>
</div>
<a id="a3588fc0b833a8f2d7213651a05f48c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3588fc0b833a8f2d7213651a05f48c80">&#9670;&nbsp;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of empty columns with the same types as the inputs. </p>
<p>Creates the <code>gdf_column</code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to delete the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input table to emulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table A table of empty columns of same type as input </dd></dl>

</div>
</div>
<a id="a9e4c06ce5a604ed1019a523036529b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4c06ce5a604ed1019a523036529b83">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in a column with a scalar value. </p>
<p>Fills N elements of <code>column</code> starting at <code>begin</code> with <code>value</code>, where N = (<code>end</code> - <code>begin</code>)</p>
<p>The datatypes of <code>column</code> and <code>value</code> must be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">column</td><td>The preallocated column to fill into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The scalar value to fill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The starting index of the fill range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The index one past the end of the fill range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a68e93b1c814e07e108ad015d27ca2372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e93b1c814e07e108ad015d27ca2372">&#9670;&nbsp;</a></span>find_and_replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::find_and_replace_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>values_to_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements from <code>input_col</code> according to the mapping <code>values_to_replace</code> to <code>replacement_values</code>, that is, replace all <code>values_to_replace[i]</code> present in <code>input_col</code> with <code>replacement_values[i]</code>. </p>
<p>Replace elements from <code>input_col</code> according to the mapping <code>old_values</code> to <code>new_values</code>, that is, replace all <code>old_values[i]</code> present in <code>col</code> with <code>new_values[i]</code> and return a new gdf_column <code>output</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>gdf_column with the data to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_to_replace</td><td>gdf_column with the old values to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement_values</td><td>gdf_column with the new values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output gdf_column with the modified data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>gdf_column with the data to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_to_replace</td><td>gdf_column with the old values to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement_values</td><td>gdf_column with the new replacement values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output gdf_column with the modified data </dd></dl>

</div>
</div>
<a id="a96182c5521d8723e0a2a0532d2c39bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96182c5521d8723e0a2a0532d2c39bb1">&#9670;&nbsp;</a></span>from_dlpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt; cudf::from_dlpack </td>
          <td>(</td>
          <td class="paramtype">DLManagedTensor const *&#160;</td>
          <td class="paramname"><em>managed_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DLPack DLTensor into a cudf table. </p>
<p>The <code>device_type</code> of the DLTensor must be <code>kDLGPU</code>, <code>kDLCPU</code>, or <code>kDLCPUPinned</code>, and <code>device_id</code> must match the current device. The <code>ndim</code> must be set to 1 or 2. The <code>dtype</code> must have 1 lane and the bitsize must match a supported <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The managed tensor is not deleted by this function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the any of the DLTensor fields are unsupported</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">managed_tensor</td><td>a 1D or 2D column-major (Fortran order) tensor </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Table with a copy of the tensor data </dd></dl>

</div>
</div>
<a id="a6e37d2953ec00878b60fa9626da49f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e37d2953ec00878b60fa9626da49f29">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type const&#160;</td>
          <td class="paramname"><em>gather_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> *&#160;</td>
          <td class="paramname"><em>destination_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the specified rows (including null values) of a set of source columns into a set of destination columns. </p>
<p>The two sets of columns must have equal numbers of columns.</p>
<p>Gathers the rows of the source columns into the destination columns according to <code>gather_map</code> such that row "i" in the destination columns will contain row "gather_map[i]" from the source columns.</p>
<p>The datatypes between coresponding columns in the source and destination columns must be the same.</p>
<p>The number of elements in the <code>gather_map</code> must equal the number of rows in the destination columns.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>An array of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>gather_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination_table</td><td>A preallocated set of columns with a number of rows equal in size to the number of elements in the gather_map that will contain the rearrangement of the source columns based on the mapping. Can be the same as <code>source_table</code> (in-place gather). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3571c0c6314b622d87a18281ad08e212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3571c0c6314b622d87a18281ad08e212">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the the specified rows (including null values) of a set of columns, returning the result as a <code>table</code>. </p>
<p>Gathers the rows of the source columns according to <code>gather_map</code> such that row "i" in the resulting table will contain row "gather_map[i]" from the source columns.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>A non-nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>gather_map</code> and throw an error if any of its values are out of bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> Result of the gather </dd></dl>

</div>
</div>
<a id="a89365977c2da3d50a3262a1e540d1352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89365977c2da3d50a3262a1e540d1352">&#9670;&nbsp;</a></span>gather() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> *&#160;</td>
          <td class="paramname"><em>destination_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the specified rows (including null values) of a set of source columns into a set of destination columns. </p>
<p>The two sets of columns must have equal numbers of columns.</p>
<p>Gathers the rows of the source columns into the destination columns according to <code>gather_map</code> such that row "i" in the destination columns will contain row "gather_map[i]" from the source columns.</p>
<p>The datatypes between coresponding columns in the source and destination columns must be the same.</p>
<p>The number of elements in the <code>gather_map</code> must equal the number of rows in the destination columns.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>A non-nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_bounds</td><td>Optionally perform bounds checking on the values of <code>gather_map</code> and throw an error if any of its values are out of bounds. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination_table</td><td>A preallocated set of columns with a number of rows equal in size to the number of elements in the gather_map that will contain the rearrangement of the source columns based on the mapping. Can be the same as <code>source_table</code> (in-place gather). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7b0f1bc518e47eaa2cfdd0ec88e3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b0f1bc518e47eaa2cfdd0ec88e3989">&#9670;&nbsp;</a></span>gdf_dtype_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr gdf_dtype cudf::gdf_dtype_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a C++ type to it's corresponding gdf_dtype. </p>
<p>------------------------------------------------------------------------&mdash;* When explicitly passed a template argument of a given type, returns the appropriate <code>gdf_dtype</code> for the specified C++ type.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> gdf_dtype_of&lt;int32_t&gt;();        <span class="comment">// Returns GDF_INT32</span></div>
<div class="line"><span class="keywordflow">return</span> gdf_dtype_of&lt;cudf::category&gt;(); <span class="comment">// Returns GDF_CATEGORY</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md535"></a>
@tparam T The type to map to a &lt;tt&gt;gdf_dtype&lt;/tt&gt;</h2>

</div>
</div>
<a id="a23161719d6de26448dce74b8783f89c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23161719d6de26448dce74b8783f89c8">&#9670;&nbsp;</a></span>genericAtomicOperation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value, T&gt; __forceinline__ __device__ cudf::genericAtomicOperation </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>update_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. </p>
<p>----------------------------------------------------------------------&mdash;* The supported cudf types for <code>genericAtomicOperation</code> are: int8_t, int16_t, int32_t, int64_t, float, double</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address of old value in global or shared memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The binary operator used for compute</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md329"></a>
@returns The old value at &lt;tt&gt;address&lt;/tt&gt;</h2>

</div>
</div>
<a id="ac63f5b61fc23af128d77caf9ed921309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63f5b61fc23af128d77caf9ed921309">&#9670;&nbsp;</a></span>genericAtomicOperation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_arithmetic&lt;T&gt;::value || std::is_same&lt;T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::date32</a>&gt;::value || std::is_same&lt;T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::date64</a>&gt;::value || std::is_same&lt;T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::timestamp</a>&gt;::value || std::is_same&lt;T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::category</a>&gt;::value || std::is_same&lt;T, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::nvstring_category</a>&gt;::value, T&gt; __forceinline__ __device__ cudf::genericAtomicOperation </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>update_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes 'BinaryOp'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. </p>
<p>----------------------------------------------------------------------&mdash;* The supported cudf types for <code>genericAtomicOperation</code> are: int8_t, int16_t, int32_t, int64_t, float, double, cudf::date32, cudf::date64, cudf::timestamp, cudf::category, cudf::nvstring_category, cudf::bool8</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address of old value in global or shared memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The binary operator used for compute</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md173"></a>
@returns The old value at &lt;tt&gt;address&lt;/tt&gt;</h2>

</div>
</div>
<a id="a6c828f318cb2c14c8ac0567f5084d1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c828f318cb2c14c8ac0567f5084d1e7">&#9670;&nbsp;</a></span>group_quantiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a>, <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt; cudf::group_quantiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>quantiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a>&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code><a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8ab424744b6ce548ac355f5830c0a8c5e1">LINEAR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_nulls</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find values at given quantiles within groups. </p>
<p>Computes groupby <code>keys</code> and finds values at each quantile specified in <code>quantiles</code> in each group of each column in <code>values</code>. When the quantile does not correspond to an exact index, but lies between index i and j, the result is an interpolation of values at index i and j, using the method specified in <code>interpolation</code>. Nulls are always ignored in <code>values</code>.</p>
<p>Returns the resulting quantile(s) for all groups in a single column. When more than one quantile is requested, each group's results are stored contiguously in the same order specified in <code>quantiles</code>.</p>
<p>Illustration: </p><div class="fragment"><div class="line">Let</div>
<div class="line">keys   = {[ a, c, b, c, a],}</div>
<div class="line">values = {[v1,v2,v3,v4,v5],}</div>
<div class="line">quantiles = {q1, q2}</div>
<div class="line">out_keys, out_values = <a class="code" href="namespacecudf.html#a6c828f318cb2c14c8ac0567f5084d1e7">group_quantiles</a>(keys, values, quantiles)</div>
<div class="line"> </div>
<div class="line">out_keys = {[ a,      b,     c     ],}</div>
<div class="line">out_vals = {[x1, x2, y1, y2, z1, z2],}</div>
<div class="line">where</div>
<div class="line">x1 = value at quantile q1 in group [v1,v5]</div>
<div class="line">x2 = value at quantile q2 in group [v1,v5]</div>
<div class="line">y1 = value at quantile q1 in group [v3]</div>
<div class="line">y2 = value at quantile q2 in group [v3]</div>
<div class="line">z1 = value at quantile q1 in group [v2,v4]</div>
<div class="line">z2 = value at quantile q2 in group [v2,v4]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to group by </td></tr>
    <tr><td class="paramname">values</td><td>Values to find the quantiles in </td></tr>
    <tr><td class="paramname">quantiles</td><td>List of quantiles q where q is in [0,1] </td></tr>
    <tr><td class="paramname">interpolation</td><td>Method to use for interpolating quantiles that lie between points </td></tr>
    <tr><td class="paramname">include_nulls</td><td>Whether to consider rows in <code>keys</code> that contain <code>NULL</code> values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;cudf::table, cudf::table&gt; First table contains the unique keys in <code>keys</code>. Second table contains per-group values at quantiles </dd></dl>

</div>
</div>
<a id="aab7d308aae78cd6323814732ec4a2278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7d308aae78cd6323814732ec4a2278">&#9670;&nbsp;</a></span>group_std()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a>, <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt; cudf::group_std </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a group wise standard deviation. </p>
<p>Computes groupby <code>keys</code> and computes the standard deviation of each group of each column in <code>values</code>. Nulls are always ignored in <code>values</code>.</p>
<div class="fragment"><div class="line">Let</div>
<div class="line">keys   = {[ a, c, b, c, a],}</div>
<div class="line">values = {[v1,v2,v3,v4,v5],}</div>
<div class="line">out_keys, out_vals = <a class="code" href="namespacecudf.html#aab7d308aae78cd6323814732ec4a2278">group_std</a>(keys, values)</div>
<div class="line"> </div>
<div class="line">out_keys = {[ a,           b,       c          ],}</div>
<div class="line">out_vals = {[ std(v1, v5), std(v3), std(v2, v4)],}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to group by </td></tr>
    <tr><td class="paramname">values</td><td>Values to find standard deviation for </td></tr>
    <tr><td class="paramname">ddof</td><td>Delta Degrees of Freedom: the divisor used in calculation is <code>N - ddof</code>, where <code>N</code> is the population size.` </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;cudf::table, cudf::table&gt; First table contains the unique keys in <code>keys</code>. Second table contains per-group standard deviation </dd></dl>

</div>
</div>
<a id="a534d665f0890f93214d43f494fe907b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534d665f0890f93214d43f494fe907b1">&#9670;&nbsp;</a></span>group_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a>, <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt; cudf::group_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a group wise variance. </p>
<p>Computes groupby <code>keys</code> and computes the variance of each group of each column in <code>values</code>. Nulls are always ignored in <code>values</code>.</p>
<div class="fragment"><div class="line">Let</div>
<div class="line">keys   = {[ a, c, b, c, a],}</div>
<div class="line">values = {[v1,v2,v3,v4,v5],}</div>
<div class="line">out_keys, out_vals = <a class="code" href="namespacecudf.html#aab7d308aae78cd6323814732ec4a2278">group_std</a>(keys, values)</div>
<div class="line"> </div>
<div class="line">out_keys = {[ a,           b,       c          ],}</div>
<div class="line">out_vals = {[ var(v1, v5), var(v3), var(v2, v4)],}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to group by </td></tr>
    <tr><td class="paramname">values</td><td>Values to find variance for </td></tr>
    <tr><td class="paramname">ddof</td><td>Delta Degrees of Freedom: the divisor used in calculation is <code>N - ddof</code>, where <code>N</code> is the population size.` </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;cudf::table, cudf::table&gt; First table contains the unique keys in <code>keys</code>. Second table contains per-group variance </dd></dl>

</div>
</div>
<a id="ada393acb565321d740f2b9950ffe2941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada393acb565321d740f2b9950ffe2941">&#9670;&nbsp;</a></span>has_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::has_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a table contains any null values. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to check for null values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the table contains one or more null values </dd></dl>
<h2><a class="anchor" id="autotoc_md427"></a>
@return false If the table contains zero null values</h2>

</div>
</div>
<a id="a4e682abfb2a17865a3d4d94b24f9e5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e682abfb2a17865a3d4d94b24f9e5a3">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>initial_hash</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the hash value of each row in the input set of columns. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table of columns to hash </td></tr>
    <tr><td class="paramname">initial_hash</td><td>Optional vector of initial hash values for each column. If this vector is empty then each element will be hashed as-is. </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md344"></a>
@returns A column where each row is the hash of a column from the input</h2>

</div>
</div>
<a id="a1a9637af7bcb33dfc0b080aa1c1a24e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9637af7bcb33dfc0b080aa1c1a24e2">&#9670;&nbsp;</a></span>hash_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt;, std::vector&lt; size_type &gt; &gt; cudf::hash_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>columns_to_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions rows from the input table into multiple output tables. </p>
<p>-----------------------------------------------------------------------&mdash;* Partitions rows of <code>input</code> into <code>num_partitions</code> bins based on the hash value of the columns specified by <code>columns_to_hash</code>. Rows partitioned into the same bin are grouped consecutively in the output table. Returns a vector of row offsets to the start of each partition in the output table.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is <code>columns_to_hash</code> is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to partition </td></tr>
    <tr><td class="paramname">columns_to_hash</td><td>Indices of input columns to hash </td></tr>
    <tr><td class="paramname">num_partitions</td><td>The number of partitions to use </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md343"></a>
@returns An output table and a vector of row offsets to each partition</h2>

</div>
</div>
<a id="a0d288a83fd8de580d2274f825997cbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d288a83fd8de580d2274f825997cbf3">&#9670;&nbsp;</a></span>have_same_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::have_same_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>validated_column_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>validated_column_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_extra_type_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures two (valid!) columns have the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validated_column_1</td><td>A column which would pass <a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate()</a> . </td></tr>
    <tr><td class="paramname">validated_column_2</td><td>A column which would pass <a class="el" href="namespacecudf.html#afa70e889e2b83eba15ed8e8e864dd3ff">validate()</a> . </td></tr>
    <tr><td class="paramname">ignore_extra_type_info</td><td>For some column element types, a column carries some qualifying information which applies to all elements (and thus not repeated for each one). Generally, this information should not be ignored, so that for two columns to have the same type, they must also share it. However, for potential practical reasons (with this being a utility rather than an API function), we allow the extra information to be ignored by setting this parameter to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f79c6fbeb12b15851bee1aa09f76c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f79c6fbeb12b15851bee1aa09f76c92">&#9670;&nbsp;</a></span>have_same_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::have_same_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <code><a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a></code>s have columns of same types. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left-side <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a> operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right-side <a class="el" href="classcudf_1_1table__view.html" title="A set of column_views of the same size.">table_view</a> operand </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md496"></a>
@return boolean comparison result</h2>

</div>
</div>
<a id="a7ce276d67cc17e299f29de43a391af75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce276d67cc17e299f29de43a391af75">&#9670;&nbsp;</a></span>intra_word_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA_HOST_DEVICE_CALLABLE size_type cudf::intra_word_index </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md523"></a>
@brief Returns the position within a word of the specified bit.</h2>

</div>
</div>
<a id="aa1b9dd3a6ee95fa52224a53869cd164e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b9dd3a6ee95fa52224a53869cd164e">&#9670;&nbsp;</a></span>is_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_boolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether <code>T</code> is a Boolean type. </p>
<p>------------------------------------------------------------------------&mdash;* <code>cudf::bool8</code> is cudf's Boolean type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is Boolean </dd></dl>
<h2><a class="anchor" id="autotoc_md549"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is not Boolean</h2>

</div>
</div>
<a id="a96675e30be80f4236360466adcf9a70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96675e30be80f4236360466adcf9a70c">&#9670;&nbsp;</a></span>is_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_boolean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether <code>type</code> is a Boolean <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>. </p>
<p>------------------------------------------------------------------------&mdash;* <code>cudf::bool8</code> is cudf's Boolean type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a Boolean </dd></dl>
<h2><a class="anchor" id="autotoc_md550"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is not a Boolean</h2>

</div>
</div>
<a id="a14e1cea4200d1d92d7f38d596333d28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e1cea4200d1d92d7f38d596333d28a">&#9670;&nbsp;</a></span>is_compound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_compound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the type <code>T</code> is a compound type. </p>
<p>------------------------------------------------------------------------&mdash;* <code>column</code>s with "compound" elements are logically a single column of elements, but may be concretely implemented with two or more <code>column</code>s. For example, a <code>STRING</code> column could contain a <code>column</code> of offsets and a child <code>column</code> of characters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a "compound" type </dd></dl>
<h2><a class="anchor" id="autotoc_md555"></a>
@return false &lt;tt&gt;T&lt;/tt&gt; corresponds to a "simple" type</h2>

</div>
</div>
<a id="ad7f296c6fe2b6ae35ac59e41cbf1487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f296c6fe2b6ae35ac59e41cbf1487d">&#9670;&nbsp;</a></span>is_compound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_compound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether elements of <code>type</code> are compound. </p>
<p>------------------------------------------------------------------------&mdash;* <code>column</code>s with "compound" elements are logically a single column of elements, but may be concretely implemented with two or more <code>column</code>s. For example, a <code>STRING</code> column could contain a <code>column</code> of offsets and a child <code>column</code> of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a compound type </dd></dl>
<h2><a class="anchor" id="autotoc_md556"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is a simple type</h2>

</div>
</div>
<a id="aaa937abead085ea9420b15c6473f08a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa937abead085ea9420b15c6473f08a7">&#9670;&nbsp;</a></span>is_fixed_width() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_fixed_width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether elements of type <code>T</code> are fixed-width. </p>
<p>------------------------------------------------------------------------&mdash;* Elements of a fixed-width type all have the same size in bytes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The C++ type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a fixed-width element type </dd></dl>
<h2><a class="anchor" id="autotoc_md553"></a>
@return false &lt;tt&gt;T&lt;/tt&gt; corresponds to a variable-width element type</h2>

</div>
</div>
<a id="a347d883100d3f7c725ad64c649f59c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347d883100d3f7c725ad64c649f59c11">&#9670;&nbsp;</a></span>is_fixed_width() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_fixed_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether elements of <code>type</code> are fixed-width. </p>
<p>------------------------------------------------------------------------&mdash;* Elements of a fixed-width type all have the same size in bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is fixed-width </dd></dl>
<h2><a class="anchor" id="autotoc_md554"></a>
@return false  &lt;tt&gt;type&lt;/tt&gt; is variable-width</h2>

</div>
</div>
<a id="a4f30952e94aede1208c6f3195d1e9fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f30952e94aede1208c6f3195d1e9fc3">&#9670;&nbsp;</a></span>is_not_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::is_not_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the <code>input</code> column for <code>null</code> values, and creates a <code>bool</code> column of same size with <code>false</code> representing <code>null</code> values and <code>true</code> for other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A gdf_column as input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column A column of type GDF_BOOL8 with <code>false</code> representing <code>null</code> values. </dd></dl>

</div>
</div>
<a id="a90c69a3f630734ceead55f5fc2dd6ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c69a3f630734ceead55f5fc2dd6ede">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::is_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the <code>input</code> column for <code>null</code> values, and creates a <code>bool</code> column of same size with <code>true</code> representing <code>null</code> values and <code>false</code> for other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A gdf_column as input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column A column of type GDF_BOOL8 with <code>true</code> representing <code>null</code> values. </dd></dl>

</div>
</div>
<a id="a736c39af324b57534639bd3d8af357e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736c39af324b57534639bd3d8af357e4">&#9670;&nbsp;</a></span>is_numeric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_numeric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the type <code>T</code> is a numeric type. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> is numeric </dd></dl>
<h2><a class="anchor" id="autotoc_md547"></a>
@return false  &lt;tt&gt;T&lt;/tt&gt; is not numeric</h2>

</div>
</div>
<a id="ac193df7b5be153a88978c2e6564bf4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac193df7b5be153a88978c2e6564bf4f2">&#9670;&nbsp;</a></span>is_numeric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_numeric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether <code>type</code> is a numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>. </p>
<p>------------------------------------------------------------------------&mdash;* "Numeric" types are fundamental integral/floating point types such as <code>INT*</code> or <code>FLOAT*</code>. Types that wrap a numeric type are not considered numeric, e.g., <code>TIMESTAMP</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is numeric </dd></dl>
<h2><a class="anchor" id="autotoc_md548"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is not numeric</h2>

</div>
</div>
<a id="aef9b08b206b1340c5ac3893d17943309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9b08b206b1340c5ac3893d17943309">&#9670;&nbsp;</a></span>is_relationally_comparable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_relationally_comparable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether objects of types <code>L</code> and <code>R</code> can be relationally compared. </p>
<p>------------------------------------------------------------------------&mdash;* Given two objects <code>L l</code>, and <code>R r</code>, returns true if <code>l &lt; r</code> and <code>l &gt; r</code> are well-formed expressions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>Type of the first object </td></tr>
    <tr><td class="paramname">R</td><td>Type of the second object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Objects of types <code>L</code> and <code>R</code> can be relationally be compared </dd></dl>
<h2><a class="anchor" id="autotoc_md546"></a>
@return false Objects of types &lt;tt&gt;L&lt;/tt&gt; and &lt;tt&gt;R&lt;/tt&gt; cannot be compared</h2>

</div>
</div>
<a id="ad15f075ce6421723e214c0d153fe695f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f075ce6421723e214c0d153fe695f">&#9670;&nbsp;</a></span>is_simple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_simple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the type <code>T</code> is a simple type. </p>
<p>------------------------------------------------------------------------&mdash;* "Simple" element types are implemented with only a single column, i.e., <code>num_children() == 0</code> for columns of "simple" elements</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a simple type </dd></dl>
<h2><a class="anchor" id="autotoc_md557"></a>
@return false &lt;tt&gt;T&lt;/tt&gt; corresponds to a compound type</h2>

</div>
</div>
<a id="ae6e62b8bc2981be767ae3f6843877956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e62b8bc2981be767ae3f6843877956">&#9670;&nbsp;</a></span>is_simple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_simple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether elements of <code>type</code> are simple. </p>
<p>------------------------------------------------------------------------&mdash;* "Simple" element types are implemented with only a single column, i.e., <code>num_children() == 0</code> for columns of "simple" elements</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a simple type </dd></dl>
<h2><a class="anchor" id="autotoc_md558"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is a compound type</h2>

</div>
</div>
<a id="aac52a52a504d46887f1368ae13a96ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac52a52a504d46887f1368ae13a96ffb">&#9670;&nbsp;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int8_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>descending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nulls_are_smallest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the rows of a <code>table</code> are sorted in a lexicographical order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>table whose rows need to be compared for ordering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descending</td><td>vector that specifies the expected ordering of each input column (0 is ascending order and 1 is descending) If this an empty vector, then it will be assumed that each column is in ascending order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_are_smallest</td><td>true indicates nulls are to be considered smaller than non-nulls ; false indicates opposite</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - if sorted , false - if not. </dd></dl>

</div>
</div>
<a id="a90ebb90931abfed637396889b7829173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ebb90931abfed637396889b7829173">&#9670;&nbsp;</a></span>is_timestamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_timestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the type <code>T</code> is a timestamp type. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> is a timestamp </dd></dl>
<h2><a class="anchor" id="autotoc_md551"></a>
@return false  &lt;tt&gt;T&lt;/tt&gt; is not a timestamp</h2>

</div>
</div>
<a id="a96f7b448c30ecbce54e8c1243ccc8c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f7b448c30ecbce54e8c1243ccc8c4d">&#9670;&nbsp;</a></span>is_timestamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::is_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether <code>type</code> is a timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>. </p>
<p>------------------------------------------------------------------------&mdash;* "Timestamp" types are int32_t or int64_t durations since the unix epoch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a timestamp </dd></dl>
<h2><a class="anchor" id="autotoc_md552"></a>
@return false &lt;tt&gt;type&lt;/tt&gt; is not a timestamp</h2>

</div>
</div>
<a id="a324e3af1901162a99c4e182255e63964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324e3af1901162a99c4e182255e63964">&#9670;&nbsp;</a></span>join_call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;JoinType join_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cudf::join_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>left_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>right_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__context__.html">gdf_context</a> *&#160;</td>
          <td class="paramname"><em>join_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the join operation between two sets of columns. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If <code>left</code>/<code>right</code> table is empty If number of rows in table is too big If it has in-valid join context If method is sort based and number of columns to join are more than <code>1</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Table of left columns to join </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Table of right columns to join </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_result</td><td>The join computed indices of the <code>left</code> table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">right_result</td><td>The join computed indices of the <code>right</code> table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">join_context</td><td>A structure that determines various run parameters, such as whether to perform a hash or sort based join </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">join_type</td><td>The type of join to be performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aa52645708c7f40b19e86fde0caa170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa52645708c7f40b19e86fde0caa170">&#9670;&nbsp;</a></span>join_call_compute_df()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;JoinType join_type, typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::join_call_compute_df </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cudf::size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>left_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cudf::size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; cudf::size_type, cudf::size_type &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>columns_in_common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> *&#160;</td>
          <td class="paramname"><em>joined_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__context__.html">gdf_context</a> *&#160;</td>
          <td class="paramname"><em>join_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs join on the columns provided in <code>left</code> and <code>right</code> as per the joining indices given in <code>left_on</code> and <code>right_on</code> and creates a single table. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if a sort-based join is requested and either <code>right_on</code> or <code>left_on</code> contains null values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The left table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The right table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_on</td><td>The column's indices from <code>left</code> to join on. Column <code>i</code> from <code>left_on</code> will be compared against column <code>i</code> of <code>right_on</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_on</td><td>The column's indices from <code>right</code> to join on. Column <code>i</code> from <code>right_on</code> will be compared with column <code>i</code> of <code>left_on</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns_in_common</td><td>is a vector of pairs of column indices into <code>left_on</code> and <code>right_on</code>, respectively, that are "in common". For "common" columns, only a single output column will be produced, which is gathered from <code>left_on</code> if it is left join or from intersection of <code>left_on</code> and <code>right_on</code> if it is inner join or gathered from both <code>left_on</code> and <code>right_on</code> if it is full join. Else, for every column in <code>left_on</code> and <code>right_on</code>, an output column will be produced.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>joined_indices Optional, if not <code>nullptr</code>, on return, will contain two non-nullable, <code>GDF_INT32</code> columns containing the indices of matching rows between <code>left_on</code> and <code>right_on</code>. The first column corresponds to rows in <code>left_on</code>, and the second to <code>right_on</code>. A value of <code>-1</code> in the second column indicates that the corresponding row in <code>left_on</code> has no match. And similarly <code>-1</code> in first column indicates that the corresponding row in <code>right_on</code> has no match. It is the caller's responsibility to free these columns. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">join_context</td><td>The context to use to control how the join is performed,e.g., sort vs hash based implementation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of joining <code>left</code> and <code>right</code> tables on the columns specified by <code>left_on</code> and <code>right_on</code>. The resulting table will be joined columns of <code>left(including common columns)+right(excluding common columns)</code>. </dd></dl>

</div>
</div>
<a id="ae90960c52c1f1fe3ab2257bad89b18fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90960c52c1f1fe3ab2257bad89b18fc">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&#160;</td>
          <td class="paramname"><em>desc_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nulls_as_largest</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find smallest indices in a sorted table where values should be inserted to maintain order. </p>
<p>------------------------------------------------------------------------&mdash;* For each row v in <code>values</code>, find the first index in <code>t</code> where inserting the row will maintain the sort order of <code>t</code> </p>
<p>Example:</p>
<p>Single column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 1 }</p>
<p>Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 3 }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Table to search </td></tr>
    <tr><td class="paramname">values</td><td>Find insert locations for these values </td></tr>
    <tr><td class="paramname">desc_flags</td><td>Vector of column sort order. False indicates the corresponding column is sorted ascending </td></tr>
    <tr><td class="paramname">nulls_as_largest</td><td>If true, nulls are considered larger than valid values, otherwise, nulls are considered smaller than valid values</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md422"></a>
@return gdf_column   Insertion points. Non-nullable column of type GDF_INT32 with same size as values.</h2>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2legacy_2search_8hpp-example.html#a1">/rapids/cudf/cpp/include/cudf/legacy/search.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a693de6f22cd656b6d859b83a106a762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693de6f22cd656b6d859b83a106a762e">&#9670;&nbsp;</a></span>make_default_constructed_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; cudf::make_default_constructed_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs default constructed scalar of type <code>type</code> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The desired element type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa80de7d88a408ab660541a4a3b214ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80de7d88a408ab660541a4a3b214ead">&#9670;&nbsp;</a></span>make_empty_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_empty_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an empty column of the specified <code>type</code>. </p>
<p>An empty column does not contain any elements or a validity mask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The desired type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Empty column with desired type </dd></dl>

</div>
</div>
<a id="a206743e8bf8c30699498608d0b5876a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206743e8bf8c30699498608d0b5876a5">&#9670;&nbsp;</a></span>make_fixed_width_column() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_fixed_width_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>null_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask. </p>
<dl class="section note"><dt>Note</dt><dd>null_count is optional and will be computed if not provided.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a fixed width type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired fixed width element type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_mask</td><td>Null mask to use for this column. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_count</td><td>Optional number of nulls in the null_mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocation and device kernels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>data</code> and <code>null_mask</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5606fb76c3a0dc7fddd3de54745f8f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5606fb76c3a0dc7fddd3de54745f8f18">&#9670;&nbsp;</a></span>make_fixed_width_column() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_fixed_width_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> is determined by the requested null mask <code>state</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a fixed width type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired fixed width type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Optional, controls allocation/initialization of the column's null mask. By default, no null mask is allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocation and device kernels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>data</code> and <code>null_mask</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5315ca38e017e2ed42a400483bba3b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5315ca38e017e2ed42a400483bba3b56">&#9670;&nbsp;</a></span>make_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;cudf::size_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cudf::make_iterator </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_mask::bit_mask_t *&#160;</td>
          <td class="paramname"><em>valid</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>identity</em> = <code>ResultType{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator_Index const&#160;</td>
          <td class="paramname"><em>it</em> = <code>Iterator_Index(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an iterator over the elements of a column. </p>
<p>----------------------------------------------------------------------&mdash;* If the column contains no null values (indicated by <code>has_nulls == false</code>) then dereferencing an iterator <code>it</code> returned by this function as <code>*(it + n)</code> will return <code>ResultType{ static_cast&lt;ElementType*&gt;(data)[n] }</code>.</p>
<p>If the column contains null values (indicated by <code>has_nulls == true</code>) then the result of de-referencing an iterator <code>it</code> returned by this function as <code>*(it+n)</code> will depend if element is valid or null. If the element is valid, it will return <code>ResultType{ static_cast&lt;ElementType*&gt;(data)[n] }</code>. If the element is null, it will return <code>ResultType{identity}</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">has_nulls</td><td>Indicates if the column contains null values (<code>null_count &gt; 0</code>) </td></tr>
    <tr><td class="paramname">ElementType</td><td>The cudf data type of input array </td></tr>
    <tr><td class="paramname">ResultType</td><td>cudf data type of output and <code>identity</code> value which is used when null bitmaps flag is false. </td></tr>
    <tr><td class="paramname">Iterator_Index</td><td>The base iterator which gives the index of array. The default is <code>thrust::counting_iterator</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The pointer of column data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid</td><td>The pointer of null bitmask of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>The identity value used when the mask value is false </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md127"></a>
@param[in] it       The index iterator, &lt;tt&gt;thrust::counting_iterator&lt;/tt&gt; by default</h2>

</div>
</div>
<a id="a7bcaaa009a6de4a88ba26b8479fb3c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcaaa009a6de4a88ba26b8479fb3c57">&#9670;&nbsp;</a></span>make_numeric_column() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_numeric_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>null_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask. </p>
<dl class="section note"><dt>Note</dt><dd>null_count is optional and will be computed if not provided.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired numeric element type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_mask</td><td>Null mask to use for this column. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_count</td><td>Optional number of nulls in the null_mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocation and device kernels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>data</code> and <code>null_mask</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae67659a0dfb8fb06d47d196b59544e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67659a0dfb8fb06d47d196b59544e9f">&#9670;&nbsp;</a></span>make_numeric_column() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_numeric_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> is determined by the requested null mask <code>state</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired numeric element type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Optional, controls allocation/initialization of the column's null mask. By default, no null mask is allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocation and device kernels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>data</code> and <code>null_mask</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a114a73a1397a4c17375599f3113172ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114a73a1397a4c17375599f3113172ff">&#9670;&nbsp;</a></span>make_numeric_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; cudf::make_numeric_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct scalar with uninitialized storage to hold a value of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> and a validity bool. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The desired numeric element type </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocations </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the scalar's <code>data</code> and <code>is_valid</code> bool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b11ec1348ab46ae20792ea4e2c0ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b11ec1348ab46ae20792ea4e2c0ca4">&#9670;&nbsp;</a></span>make_pair_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool has_nulls, typename ElementType , typename ResultType  = ElementType, typename Iterator_Index  = thrust::counting_iterator&lt;cudf::size_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cudf::make_pair_iterator </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bit_mask::bit_mask_t *&#160;</td>
          <td class="paramname"><em>valid</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>identity</em> = <code>ResultType{0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator_Index const&#160;</td>
          <td class="paramname"><em>it</em> = <code>Iterator_Index(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an iterator over the elements of a column Input iterator which can be used for cub and thrust. </p>
<p>----------------------------------------------------------------------&mdash;* The iterator returns thrust::pair&lt;ResultType, bool&gt; This is useful for more complex logic that depends on the validity. e.g. group_by.count, mean_var, sort algorism.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">has_nulls</td><td>True if the data has valid bit mask, False else </td></tr>
    <tr><td class="paramname">ElementType</td><td>The cudf data type of input array </td></tr>
    <tr><td class="paramname">ResultType</td><td>cudf data type of output and <code>identity</code> value which is used when null bitmaps flag is false. </td></tr>
    <tr><td class="paramname">Iterator_Index</td><td>The base iterator which gives the index of array. The default is <code>thrust::counting_iterator</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The pointer of column data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid</td><td>The pointer of null bitmask of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>The identity value used when the mask value is false </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md130"></a>
@param[in] it       The index iterator, &lt;tt&gt;thrust::counting_iterator&lt;/tt&gt; by default</h2>

</div>
</div>
<a id="a9baa6152d40906019ccc2e66eff4dab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baa6152d40906019ccc2e66eff4dab4">&#9670;&nbsp;</a></span>make_string_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; cudf::make_string_scalar </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct STRING type scalar given a <code>std::string</code>. The size of the <code>std::string</code> must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The <code>std::string</code> to copy to device </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocations </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the scalar's <code>data</code> and <code>is_valid</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dc1ed49a1ddbc5eefde47266e9055ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc1ed49a1ddbc5eefde47266e9055ce">&#9670;&nbsp;</a></span>make_strings_column() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_strings_column </td>
          <td>(</td>
          <td class="paramtype">const rmm::device_vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmm::device_vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rmm::device_vector&lt; bitmask_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_mask</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct STRING type column given a device vector of chars encoded as UTF-8, a device vector of byte offsets identifying individual strings within the char vector, and an optional null bitmask. </p>
<p><code>offsets.front()</code> must always be zero.</p>
<p>The total number of char bytes must not exceed the maximum size of size_type. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column. This function makes a deep copy of the strings, offsets, null_mask to create a new column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>The vector of chars in device memory. This char vector is expected to be UTF-8 encoded characters. </td></tr>
    <tr><td class="paramname">offsets</td><td>The vector of byte offsets in device memory. The number of elements is one more than the total number of strings so the <code>offsets.back()</code> is the total number of bytes in the strings array. <code>offsets.front()</code> must always be 0 to point to the beginning of <code>strings</code>. </td></tr>
    <tr><td class="paramname">null_mask</td><td>Device vector containing the null element indicator bitmask. Arrow format for nulls is used for interpeting this bitmask. </td></tr>
    <tr><td class="paramname">null_count</td><td>The number of null string entries. If equal to <code>UNKNOWN_NULL_COUNT</code>, the null count will be computed dynamically on the first invocation of <code><a class="el" href="classcudf_1_1column.html#a2d92092a5214eb9ea8205eea0adbd9bc" title="Returns the count of null elements.">column::null_count()</a></code> </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocation and device kernels </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>null_mask</code> and children. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a806dfe2d3033333c99fd399afeddab3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806dfe2d3033333c99fd399afeddab3d">&#9670;&nbsp;</a></span>make_strings_column() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_strings_column </td>
          <td>(</td>
          <td class="paramtype">const rmm::device_vector&lt; thrust::pair&lt; const char *, size_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct STRING type column given a vector of pointer/size pairs. The total number of char bytes must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> and <code>null_bitmask</code> are determined if a pair contains a null string. That is, for each pair, if <code>.first</code> is null, that string is considered null. Likewise, a string is considered empty (not null) if <code>.first</code> is not null and <code>.second</code> is 0. Otherwise the <code>.first</code> member must be a valid device address pointing to <code>.second</code> consecutive bytes.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>The vector of pointer/size pairs. Each pointer must be a device memory address or <code>nullptr</code> (indicating a null string). The size must be the number of bytes. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocation and device kernels </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>null_mask</code> and children. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab955065a94f1322650056cd5721807b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab955065a94f1322650056cd5721807b0">&#9670;&nbsp;</a></span>make_strings_column() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_strings_column </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bitmask_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_mask</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct STRING type column given a host vector of chars encoded as UTF-8, a host vector of byte offsets identifying individual strings within the char vector, and an optional null bitmask. </p>
<p><code>offsets.front()</code> must always be zero.</p>
<p>The total number of char bytes must not exceed the maximum size of size_type. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column. This function makes a deep copy of the strings, offsets, null_mask to create a new column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>The contiguous array of chars in host memory. This char array is expected to be UTF-8 encoded characters. </td></tr>
    <tr><td class="paramname">offsets</td><td>The array of byte offsets in host memory. The number of elements is one more than the total number of strings so the <code>offsets.back()</code> is the total number of bytes in the strings array. <code>offsets.front()</code> must always be 0 to point to the beginning of <code>strings</code>. </td></tr>
    <tr><td class="paramname">null_mask</td><td>Host vector containing the null element indicator bitmask. Arrow format for nulls is used for interpeting this bitmask. </td></tr>
    <tr><td class="paramname">null_count</td><td>The number of null string entries. If equal to <code>UNKNOWN_NULL_COUNT</code>, the null count will be computed dynamically on the first invocation of <code><a class="el" href="classcudf_1_1column.html#a2d92092a5214eb9ea8205eea0adbd9bc" title="Returns the count of null elements.">column::null_count()</a></code> </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocation and device kernels </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>null_mask</code> and children. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acabc5ec71f9be5db72e64ed461ac1fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabc5ec71f9be5db72e64ed461ac1fa6">&#9670;&nbsp;</a></span>make_strings_column() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_strings_column </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>num_strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td>
          <td class="paramname"><em>chars_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>null_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::device_buffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>null_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a STRING type column given offsets column, chars columns, and null mask and null count. The columns and mask are moved into the resulting strings column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_strings</td><td>The number of strings the column represents. </td></tr>
    <tr><td class="paramname">offsets</td><td>The column of offset values for this column. The number of elements is one more than the total number of strings so the offset[last] - offset[0] is the total number of bytes in the strings vector. </td></tr>
    <tr><td class="paramname">chars</td><td>The column of char bytes for all the strings for this column. Individual strings are identified by the offsets and the nullmask. </td></tr>
    <tr><td class="paramname">null_count</td><td>The number of null string entries. </td></tr>
    <tr><td class="paramname">null_mask</td><td>The bits specifying the null strings in device memory. Arrow format for nulls is used for interpeting this bitmask. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocation and device kernels </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>null_mask</code> and children. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2059fd303a1baca0a6c6f45192fa89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2059fd303a1baca0a6c6f45192fa89e">&#9670;&nbsp;</a></span>make_timestamp_column() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_timestamp_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>null_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask. </p>
<dl class="section note"><dt>Note</dt><dd>null_count is optional and will be computed if not provided.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a timestamp type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired timestamp element type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_mask</td><td>Null mask to use for this column. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_count</td><td>Optional number of nulls in the null_mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocation and device kernels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>data</code> and <code>null_mask</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebc58612aa9425021086af0e7be540be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc58612aa9425021086af0e7be540be">&#9670;&nbsp;</a></span>make_timestamp_column() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::make_timestamp_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbfa74ad69efae4a12aec59682147aac9344">UNALLOCATED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> is determined by the requested null mask <code>state</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a timestamp type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired timestamp element type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Optional, controls allocation/initialization of the column's null mask. By default, no null mask is allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocation and device kernels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>data</code> and <code>null_mask</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a073f763f8f75e7aa3b551fe21e533bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073f763f8f75e7aa3b551fe21e533bae">&#9670;&nbsp;</a></span>make_timestamp_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; cudf::make_timestamp_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct scalar with uninitialized storage to hold a value of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> and a validity bool. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a timestamp type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The desired timestamp element type </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream on which to issue all memory allocations </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the scalar's <code>data</code> and <code>is_valid</code> bool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5f137cce1b677a6d0f0de87d64627ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f137cce1b677a6d0f0de87d64627ec">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>left_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>right_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cudf::size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>key_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; order_by_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>asc_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nulls_are_smallest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted tables. </p>
<p>Merges two sorted tables (including null values) into one sorted table containing data from both tables.</p>
<p>Example: input: table 1 =&gt; col 1 {0, 1, 2, 3} col 2 {4, 5, 6, 7} table 2 =&gt; col 1 {1, 2} col 2 {8, 9} output: table =&gt; col 1 {0, 1, 1, 2, 2, 3} col 2 {4, 5, 8, 6, 9, 7}</p>
<p>@Param[in] left_table A sorted table to be merged @Param[in] right_table A sorted table to be merged @Param[in] key_cols Indices of left_cols and right_cols to be used for comparison criteria @Param[in] asc_desc Sort order types of columns indexed by key_cols @Param[in] nulls_are_smallest Flag indicating is nulls are to be treated as the smallest value</p>
<p>@Returns A table containing sorted data from left_table and right_table </p>

</div>
</div>
<a id="ad9dd52f40723ec83772eb53024ab5129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dd52f40723ec83772eb53024ab5129">&#9670;&nbsp;</a></span>nans_to_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bit_mask::bit_mask_t *, cudf::size_type &gt; cudf::nans_to_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a column with floating point values, generate a bitmask where every NaN is indicated as the corresponding null bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to generate bitmask from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>std::pair</code> of <code>bit_mask_t*</code>, the output bitmask, and its null count </dd></dl>

</div>
</div>
<a id="aecdf6b2cb89dd765ce5ca6a507a143c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdf6b2cb89dd765ce5ca6a507a143c3">&#9670;&nbsp;</a></span>non_common_column_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto cudf::non_common_column_indices </td>
          <td>(</td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>num_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cudf::size_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>common_column_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with non-common indices which is set difference between <code>[0, num_columns)</code> and index values in common_column_indices. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_columns</td><td>The number of columns , which represents column indices from <code>[0, num_columns)</code> in a table </td></tr>
    <tr><td class="paramname">common_column_indices</td><td>A vector of common indices which needs to be excluded from <code>[0, num_columns)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector A vector containing only the indices which are not present in </dd></dl>
<h2><a class="anchor" id="autotoc_md149"></a>
&lt;tt&gt;common_column_indices&lt;/tt&gt;</h2>

</div>
</div>
<a id="a775c771fa16245d5fca471246892fe5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775c771fa16245d5fca471246892fe5a">&#9670;&nbsp;</a></span>normalize_nans_and_zeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::normalize_nans_and_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from a column of floating-point elements and replaces <code>-NaN</code> and <code>-0.0</code> with <code>+NaN</code> and <code>+0.0</code>, respectively. </p>
<p>Converts floating point values from <code>input</code> using the following rules: Convert -NaN -&gt; NaN Convert -0.0 -&gt; 0.0</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column does not have floating point data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Column</td><td>of floating-point elements to copy and normalize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device_memory_resource</td><td>allocator for allocating output data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new column with the modified data </dd></dl>

</div>
</div>
<a id="ab2e8dd1b37b4175001b89219ab8ac96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e8dd1b37b4175001b89219ab8ac96f">&#9670;&nbsp;</a></span>normalize_nans_and_zeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::normalize_nans_and_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>in_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies a column of floating-point elements to replace all <code>-NaN</code> and <code>-0.0</code> with <code>+NaN</code> and <code>+0.0</code>, respectively. </p>
<p>Converts floating point values from <code>in_out</code> using the following rules: Convert -NaN -&gt; NaN Convert -0.0 -&gt; 0.0</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column does not have floating point data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Column</td><td>of floating-point elements to normalize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad62014db2c1d82cbd2f3e067d27088ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62014db2c1d82cbd2f3e067d27088ab">&#9670;&nbsp;</a></span>num_bitmask_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type cudf::num_bitmask_words </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>number_of_bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <code>bitmask_type</code> words required to represent the specified number of bits. </p>
<p>Unlike <code>bitmask_allocation_size_bytes</code>, which returns the number of <em>bytes</em> needed for a bitmask allocation (including padding), this function returns the <em>actual</em> number <code>bitmask_type</code> elements necessary to represent <code>number_of_bits</code>. This is useful when one wishes to process all of the bits in a bitmask and ignore the padding/slack bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_bits</td><td>The number of bits that need to be represented </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_type The necessary number of <code>bitmask_type</code> elements </dd></dl>

</div>
</div>
<a id="aa5bd500e54a0760773f941986e8e056b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bd500e54a0760773f941986e8e056b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> objects for equality. </p>
<p>------------------------------------------------------------------------&mdash;* // TODO Define exactly what it means for two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>s to be equal. e.g., are two timestamps with different resolutions equal? How about decimals with different scale/precision?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>The second <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>lhs</code> is equal to <code>rhs</code> </dd></dl>
<h2><a class="anchor" id="autotoc_md519"></a>
@return false &lt;tt&gt;lhs&lt;/tt&gt; is not equal to &lt;tt&gt;rhs&lt;/tt&gt;</h2>

</div>
</div>
<a id="aaecb9e39d5b5475f53260497f3a8db0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecb9e39d5b5475f53260497f3a8db0a">&#9670;&nbsp;</a></span>quantile_approx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gdf_error cudf::quantile_approx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>col_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__context__.html">gdf_context</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes approximate quantile. </p>
<p>Computes quantile with the same type as <code>col_in</code>. This function works only with arithmetic columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col_in</td><td>input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>requested quantile in [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The value at the requested quantile, with the same type as <code>col_in</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon successful compute, otherwise returns appropriate error code </dd></dl>

</div>
</div>
<a id="a3aad879c6bbd17521333c06dab5db483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aad879c6bbd17521333c06dab5db483">&#9670;&nbsp;</a></span>quantile_exact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gdf_error cudf::quantile_exact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>col_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#a94d60cf0790fb642cce1c91f1dba63c8">interpolation</a>&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__context__.html">gdf_context</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes exact quantile. </p>
<p>Computes quantile using double precision. This function works only with arithmetic columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col_in</td><td>input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interpolation</td><td>Method to use for interpolating quantiles that lie between points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>requested quantile in [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The value at the requested quantile </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDF_SUCCESS upon successful compute, otherwise returns appropriate error code </dd></dl>

</div>
</div>
<a id="afdab46512f8d4cf604ed983c02556bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdab46512f8d4cf604ed983c02556bf4">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> cudf::reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::reduction::operators&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>output_dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision <code>dtype</code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> will contain <code>false</code>. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>Input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operator applied by the reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_dtype</td><td>The computation and output precision. <code>dtype</code> must be a data type that is convertible from the input dtype. If the input column has arithmetic type or cudf::bool8 type, output_dtype can be any arithmetic type or cudf::bool8 type. For <code>mean</code>, <code>var</code> and <code>std</code> ops, a floating point type must be specified. If the input column has non-arithmetic type (date32, timestamp, category...), the same type must be specified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ddof</td><td>Delta Degrees of Freedom: the divisor used in calculation of <code>std</code> and <code>var</code> is <code>N - ddof</code>, where <code>N</code> is the population size.`</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> the result value If the reduction fails, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> </dd></dl>
<h2><a class="anchor" id="autotoc_md420"></a>
will contain &lt;tt&gt;false&lt;/tt&gt;.</h2>

</div>
</div>
<a id="ae7c4ffa4dba2b1e23f4f4322f7b06408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c4ffa4dba2b1e23f4f4322f7b06408">&#9670;&nbsp;</a></span>repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::repeat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table. </p>
<p>Creates a new table by repeating the rows of <code>in</code>. The number of repetitions of each element is defined by the value at the corresponding index of <code>count</code> Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = [1,2,3]</div>
<div class="line"><span class="keywordflow">return</span> = [4,5,5,6,6,6]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input column </td></tr>
    <tr><td class="paramname">count</td><td>Non-nullable column of type <code>GDF_INT32</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> The result table containing the repetitions </dd></dl>

</div>
</div>
<a id="a00deb58e53fc1648eb5dce3e79d0790c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00deb58e53fc1648eb5dce3e79d0790c">&#9670;&nbsp;</a></span>repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::repeat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table. </p>
<p>Creates a new table by repeating <code>count</code> times the rows of <code>in</code>. Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = 2</div>
<div class="line"><span class="keywordflow">return</span> = [4,4,5,5,6,6]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input column </td></tr>
    <tr><td class="paramname">count</td><td>Non-null scalar of type <code>GDF_INT32</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> The result table containing the repetitions </dd></dl>

</div>
</div>
<a id="a85645250c7ada0b73a61e9a691931b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85645250c7ada0b73a61e9a691931b36">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::replace_nulls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with corresponding values of another column. </p>
<p>Returns a column <code>output</code> such that if <code>input[i]</code> is valid, its value will be copied to <code>output[i]</code>. Otherwise, <code>replacements[i]</code> will be copied to <code>output[i]</code>.</p>
<p>The <code>input</code> and <code>replacement</code> columns must be of same size and have the same data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A gdf_column containing null values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A gdf_column whose values will replace null values in input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column with nulls replaced </dd></dl>

</div>
</div>
<a id="ad66cc66793473e7fc90ad3ed4cd1b450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66cc66793473e7fc90ad3ed4cd1b450">&#9670;&nbsp;</a></span>replace_nulls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::replace_nulls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with a scalar. </p>
<p>Returns a column <code>output</code> such that if <code>input[i]</code> is valid, its value will be copied to <code>output[i]</code>. Otherise, <code>replacement</code> will be coped to <code>output[i]</code>.</p>
<p><code>replacement</code> must have the same data type as <code>input</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A gdf_column containing null values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a> whose value will replace null values in input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column with nulls replaced </dd></dl>

</div>
</div>
<a id="aec006bc00092dd8ec47f2c7ca6fe01d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec006bc00092dd8ec47f2c7ca6fe01d4">&#9670;&nbsp;</a></span>row_bitmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_vector&lt; bit_mask::bit_mask_t &gt; cudf::row_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a bitmask indicating the presence of NULL values in rows of a table. </p>
<p>------------------------------------------------------------------------&mdash;* If a row <code>i</code> in <code>table</code> contains one or more NULL values, then bit <code>i</code> in the returned bitmask will be 0.</p>
<p>Otherwise, bit <code>i</code> will be 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to compute the row bitmask of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bit_mask::bit_mask_t* The bitmask indicating the presence of NULLs in </dd></dl>
<h2><a class="anchor" id="autotoc_md6"></a>
a row</h2>

</div>
</div>
<a id="a65546aa9c42e87334fb5e1e3f274bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65546aa9c42e87334fb5e1e3f274bc6b">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_scan_op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column for the san </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The pre-allocated output column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation of the scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inclusive</td><td>The flag for applying an inclusive scan if true, </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md421"></a>
an exclusive scan if false.</h2>

</div>
</div>
<a id="a2be522d016a38551534b8bd107d16cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be522d016a38551534b8bd107d16cde">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::scatter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgdf__scalar.html">gdf_scalar</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type const&#160;</td>
          <td class="paramname"><em>scatter_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>num_scatter_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>table</code> as if scattering a set of <code><a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information.">gdf_scalar</a></code> values into the rows of a <code>target</code> table in-place. </p>
<p><code>data</code> and <code>valid</code> of a specific row of the target_column is kept unchanged if the <code>scatter_map</code> does not map to that row.</p>
<p>The datatypes between coresponding columns in the source and target columns must be the same.</p>
<p>A negative index <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>destination_table</code>.</p>
<p>If the same index appears more than once in <code>scatter_map</code>, the result is undefined.</p>
<p>If the scalar is null (is_valid == false) and the target column does not have a valid bitmask, the destination column will have a bitmask allocated.</p>
<p>@Param[in] source The row to be scattered @Param[in] scatter_map An array that maps to rows in the output columns. @Param[in] target The table to copy and then perform an in-place scatter into the copy. </p><dl class="section return"><dt>Returns</dt><dd>[out] The result of the scatter </dd></dl>

</div>
</div>
<a id="ae8f6b4e349cd583550839de7221464d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f6b4e349cd583550839de7221464d9">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type const&#160;</td>
          <td class="paramname"><em>scatter_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>table</code> as if an in-place scatter from a <code>source</code> table was performed on the <code>target</code> table. </p>
<p>It is the user's reponsibility to free the device memory allocated in the returned table <code>destination_table</code>.</p>
<p>The <code>source_table</code> and the <code>target_table</code> must have equal numbers of columns.</p>
<p>The datatypes between coresponding columns in the source and target columns must be the same.</p>
<p>The number of elements in the <code>scatter_map</code> must equal the number of rows in the source columns.</p>
<p>A negative index <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>destination_table</code>.</p>
<p>If the same index appears more than once in <code>scatter_map</code>, the result is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>scatter_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the destination table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<p>A column in the output will only be nullable if:</p><ul>
<li>Its corresponding column in <code>target</code> is nullable</li>
<li>Its corresponding column in <code>source</code> has <code>null_count &gt; 0</code></li>
</ul>
<p>@Param[in] source The columns whose rows will be scattered @Param[in] scatter_map An array of integral indices that map rows in the input columns to rows in the output columns. @Param[in] target The table to copy and then perform an in-place scatter into the copy. @Param[in] check_bounds Optionally perform bounds checking on the values of <code>scatter_map</code> and throw an error if any of its values are out of bounds. </p><dl class="section return"><dt>Returns</dt><dd>[out] The result of the scatter </dd></dl>

</div>
</div>
<a id="ae9ee593defbe8e2fcaa05b50fbd6612e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ee593defbe8e2fcaa05b50fbd6612e">&#9670;&nbsp;</a></span>scatter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>scatter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_bounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>table</code> as if an in-place scatter from a <code>source</code> table was performed on the <code>target</code> table. </p>
<p>It is the user's reponsibility to free the device memory allocated in the returned table <code>destination_table</code>.</p>
<p>The <code>source_table</code> and the <code>target_table</code> must have equal numbers of columns.</p>
<p>The datatypes between coresponding columns in the source and target columns must be the same.</p>
<p>The number of elements in the <code>scatter_map</code> must equal the number of rows in the source columns.</p>
<p>A negative index <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>destination_table</code>.</p>
<p>If the same index appears more than once in <code>scatter_map</code>, the result is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;cudf::logic_error&lt;/tt&gt;</td><td>if <code>check_bounds == true</code> and an index exists in <code>scatter_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the destination table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<p>A column in the output will only be nullable if:</p><ul>
<li>Its corresponding column in <code>target</code> is nullable</li>
<li>Its corresponding column in <code>source</code> has <code>null_count &gt; 0</code></li>
</ul>
<p>@Param[in] source The columns whose rows will be scattered @Param[in] scatter_map A non-nullable column of integral indices that map rows in the input columns to rows in the output columns. @Param[in] target The table to copy and then perform an in-place scatter into the copy. @Param[in] check_bounds Optionally perform bounds checking on the values of <code>scatter_map</code> and throw an error if any of its values are out of bounds. </p><dl class="section return"><dt>Returns</dt><dd>[out] The result of the scatter </dd></dl>

</div>
</div>
<a id="aaa398ba021c84cb39c9e1dcd65d81b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa398ba021c84cb39c9e1dcd65d81b64">&#9670;&nbsp;</a></span>scatter_to_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structcudf_1_1table.html">cudf::table</a> &gt; cudf::scatter_to_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>scatter_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows of a table to <code>n</code> tables according to a scatter map. </p>
<p>Copies the rows from the input table to new tables according to the table indices given by scatter map. The number of output tables is one more than the maximum value in <code>scatter_map</code>. If a value in [0,n] does not appear in scatter_map, then the corresponding output table will be empty.</p>
<p><code>scatter_map</code> is a non-nullable column of <code>GDF_INT32</code> elements whose <code>size</code> equals <code>input.num_rows()</code> and contains numbers in range of [0, n].</p>
<p>Exceptional cases for the scatter_map column are: </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>scatter_map.dtype != GDF_INT32</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>scatter_map.size != input.num_rows()</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>has_nulls(scatter_map) == true</code></td></tr>
  </table>
  </dd>
</dl>
<p>Example: input: [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28}, { 1, 2, 3, 4, null, 0, 2, 4, 6, 2}] scatter_map: { 3, 4, 3, 1, 4, 4, 0, 1, 1, 1} output: {[{22}, {2}], [{16, 24, 26, 28}, {4, 4, 6, 2}], [{}, {}], [{10, 14}, {1, 3}], [{12, 18, 20}, {2, null, 0}]}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Table whose rows will be partitioned into a set of tables according to <code>scatter_map</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scatter_map</td><td>Non-nullable column of <code>GDF_INT32</code> values that map each row in <code>input</code> table into one of the output tables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of <code>table</code>s containing the scattered rows of <code>input</code>. <code>table</code> <code>i</code> contains all rows <code>j</code> from <code>input</code> where <code>scatter_map[j] == i</code>. </dd></dl>

</div>
</div>
<a id="a3c4063fafa03398865ddae121b3ca939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4063fafa03398865ddae121b3ca939">&#9670;&nbsp;</a></span>set_bit_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDA_HOST_DEVICE_CALLABLE void cudf::set_bit_unsafe </td>
          <td>(</td>
          <td class="paramtype">bitmask_type *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified bit to <code>1</code> </p>
<p>------------------------------------------------------------------------&mdash;* This function is not thread-safe, i.e., attempting to update bits within the same word concurrently from multiple threads results in undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>The bitmask containing the bit to set </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md524"></a>
@param bit_index Index of the bit to set</h2>

</div>
</div>
<a id="a265021448d5a11e023232cb649865092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265021448d5a11e023232cb649865092">&#9670;&nbsp;</a></span>set_least_significant_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA_HOST_DEVICE_CALLABLE bitmask_type cudf::set_least_significant_bits </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bitmask word with the <code>n</code> least significant bits set. </p>
<p>------------------------------------------------------------------------&mdash;* Behavior is undefined if <code>n &lt; 0</code> or if <code>n &gt;= size_in_bits&lt;bitmask_type&gt;()</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of least significant bits to set </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md527"></a>
@return A bitmask word with &lt;tt&gt;n&lt;/tt&gt; least significant bits set</h2>

</div>
</div>
<a id="a1d621017e15820e37826a73484fe5376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d621017e15820e37826a73484fe5376">&#9670;&nbsp;</a></span>set_most_significant_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA_HOST_DEVICE_CALLABLE bitmask_type cudf::set_most_significant_bits </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bitmask word with the <code>n</code> most significant bits set. </p>
<p>------------------------------------------------------------------------&mdash;* Behavior is undefined if <code>n &lt; 0</code> or if <code>n &gt;= size_in_bits&lt;bitmask_type&gt;()</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of most significant bits to set </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md528"></a>
@return A bitmask word with &lt;tt&gt;n&lt;/tt&gt; most significant bits set</h2>

</div>
</div>
<a id="a96a5ec95d99413d1f5f37124bc33fd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a5ec95d99413d1f5f37124bc33fd83">&#9670;&nbsp;</a></span>set_null_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::set_null_mask </td>
          <td>(</td>
          <td class="paramtype">bitmask_type *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a pre-allocated bitmask buffer to a given state. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>Pointer to bitmask (e.g. returned by <code><a class="el" href="classcudf_1_1detail_1_1column__view__base.html#adb21801d9f87e78e4efa464bf9b4512b" title="Returns raw pointer to the underlying bitmask allocation.">column_view.null_mask()</a></code>) </td></tr>
    <tr><td class="paramname">size</td><td>The number of elements represented by the mask (e.g., number of rows in a column) </td></tr>
    <tr><td class="paramname">valid</td><td>If true set all entries to valid; otherwise, set all to null. </td></tr>
    <tr><td class="paramname">stream</td><td>Optional, stream on which all memory allocations/operations </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md446"></a>
will be submitted</h2>

</div>
</div>
<a id="a51b0daf2c01663d51cb3b87ad8ce93c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b0daf2c01663d51cb3b87ad8ce93c0">&#9670;&nbsp;</a></span>size_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cudf::size_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size in bytes of elements of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> </p>
<dl class="section note"><dt>Note</dt><dd>Only fixed-width types are supported</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>is_fixed_width(element_type) == false</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of an element of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> </dd></dl>

</div>
</div>
<a id="a4c2052fccb1d1278d538c598cda51e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2052fccb1d1278d538c598cda51e0b">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt; cudf::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type const *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>num_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a column (including null values) into a set of columns according to a set of indices. </p>
<p>The "slice" function divides part of the input column into multiple intervals of rows using the indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.</p>
<p>The pairs of indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.</p>
<p>Exceptional cases for the indices array are: When the values in the pair are equal, the function returns an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.</p>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} indices: {1, 3, 5, 9, 2, 4, 8, 8} output: {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column whose rows will be sliced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>An device array of indices that are used to take 'slices' of the input column. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_indices</td><td>Number of indices in the indices array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of gdf_column*, each of which may have a different number of rows. The number of rows in each column is equal to the difference of two consecutive indices in the indices array. </dd></dl>

</div>
</div>
<a id="a7d6b5215c4e4be3ee20f107451d81411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6b5215c4e4be3ee20f107451d81411">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt; cudf::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type const *&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudf::size_type&#160;</td>
          <td class="paramname"><em>num_splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a column (including null values) into a set of columns according to a set of indices. </p>
<p>The "split" function divides the input column into multiple intervals of rows using the splits indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.</p>
<p>The indices array ('splits') is require to be a monotonic non-decreasing set. The indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.</p>
<p>The split function will take a pair of indices from the indices array ('splits') in a consecutive manner. For the first pair, the function will take the value 0 and the first element of the indices array. For the last pair, the function will take the last element of the indices array and the size of the input column.</p>
<p>Exceptional cases for the indices array are: When the values in the pair are equal, the function return an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.</p>
<p>The input columns may have different sizes. The number of columns must be equal to the number of indices in the array plus one.</p>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} splits: {2, 5, 9} output: {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column whose rows will be split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splits</td><td>An device array of indices that are used to divide the input column into multiple columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_splits</td><td>Number of splits in the splits indices array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of gdf_column*, each of which may have a different size a different number of rows. </dd></dl>

</div>
</div>
<a id="a992265bb26358a252b18da882b7f6df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992265bb26358a252b18da882b7f6df5">&#9670;&nbsp;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::stack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack rows of a Table into a single column. </p>
<p>Converts the column major table <code>in</code> into a row major contiguous buffer, which is returned as a <code>gdf_column</code>. Example: </p><div class="fragment"><div class="line">in = [[4,5,6], [1,2,3]]</div>
<div class="line"><span class="keywordflow">return</span> = [4,1,5,2,6,3]</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>: The dtype of all columns in <code>input</code> should be the same</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column The result stacked buffer as column </dd></dl>

</div>
</div>
<a id="a48561f1e899da3a79132c108463840de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48561f1e899da3a79132c108463840de">&#9670;&nbsp;</a></span>state_null_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type cudf::state_null_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#aa481249b705132999f4d082aacd21dbf">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the null count for a null mask of the specified <code>state</code> representing <code>size</code> elements. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state of the null mask </td></tr>
    <tr><td class="paramname">size</td><td>The number of elements represented by the mask </td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md443"></a>
@return size_type The count of null elements</h2>

</div>
</div>
<a id="ac8135c27fbc0411c711c13f7ac77733d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8135c27fbc0411c711c13f7ac77733d">&#9670;&nbsp;</a></span>tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">cudf::table</a> cudf::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcudf_1_1table.html">cudf::table</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new table by tiling the input table. </p>
<p>Creates a new table that contains the rows of <code>in</code> repeated <code>count</code> times. The difference from <code><a class="el" href="namespacecudf.html#ae7c4ffa4dba2b1e23f4f4322f7b06408" title="Repeat rows of a Table.">repeat()</a></code> is illustrated in the example below. Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = 2</div>
<div class="line"><span class="keywordflow">return</span> = [4,5,6,4,5,6]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input table </td></tr>
    <tr><td class="paramname">count</td><td>Number of times to tile the rows </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcudf_1_1table.html" title="A wrapper for a set of gdf_columns of equal number of rows.">cudf::table</a> The result table containing the tiled columns </dd></dl>

</div>
</div>
<a id="a0bafde3c29e61d8443804eac18a22c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bafde3c29e61d8443804eac18a22c87">&#9670;&nbsp;</a></span>to_dlpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DLManagedTensor * cudf::to_dlpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a cudf table into a DLPack DLTensor. </p>
<p>All columns must have the same data type and this type must be numeric. The columns may be nullable, but the null count must be zero. If the input table is empty or has zero rows, the result will be nullptr.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>deleter</code> method of the returned <code>DLManagedTensor</code> must be used to free the memory allocated for the tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the data types are not equal or not numeric, or if any of columns have non-zero null count</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Table to convert to DLPack </td></tr>
    <tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1D or 2D DLPack tensor with a copy of the table data, or nullptr </dd></dl>

</div>
</div>
<a id="a45876c5d57c0d0afb921add28b3516e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45876c5d57c0d0afb921add28b3516e3">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unary_udf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_ptx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column by applying a unary function against every element of an input column. </p>
<p>Computes: <code>out[i] = F(in[i])</code></p>
<p>Support all GDF data types except for GDF_CATEGORY or GDF_STRING. For GDF_STRING_CATEGORY the UDF is only applied to the indices, after which the underlying category is cleared and remapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to transform </td></tr>
    <tr><td class="paramname">unary_udf</td><td>The PTX/CUDA string of the unary function to apply </td></tr>
    <tr><td class="paramname">outout_type</td><td>The output type that is compatible with the output type in the PTX code </td></tr>
    <tr><td class="paramname">is_ptx</td><td>If true the UDF is treated as a piece of PTX code; if fasle the UDF is treated as a piece of CUDA code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column The column resulting from applying the unary function to every element of the input </dd></dl>

</div>
</div>
<a id="a9097a8bfea9db9999dd8e120b0e71bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9097a8bfea9db9999dd8e120b0e71bce">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1experimental_1_1table.html">experimental::table</a> &gt; cudf::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new table transposed from the input table. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column types are non-homogenous </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column types are non-fixed-width</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Input table of (ncols) number of columns each of size (nrows) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated output table with (nrows) columns each of size (ncols) </dd></dl>

</div>
</div>
<a id="a0f36dd8856235cc97ba5c260b81d45bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f36dd8856235cc97ba5c260b81d45bf">&#9670;&nbsp;</a></span>trivial_full_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::trivial_full_join </td>
          <td>(</td>
          <td class="paramtype">const cudf::size_type&#160;</td>
          <td class="paramname"><em>left_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudf::size_type&#160;</td>
          <td class="paramname"><em>right_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>left_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>right_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trivially computes full join of two tables if one of the tables are empty. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>"Dataset is empty" if both left_table and right_table are empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left_size</td><td>The size of the left table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_size</td><td>The size of the right table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rightcol</td><td>The right set of columns to join </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_result</td><td>The join computed indices of the left table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">right_result</td><td>The join computed indices of the right table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4de4905066fbb3c645b05a1fc1d31d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4de4905066fbb3c645b05a1fc1d31d2">&#9670;&nbsp;</a></span>unary_operation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::unary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf.html#ab15567f1034536ae6f7f14179334a19b">unary_op</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs unary op on all values in column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gdf_column</td><td>Input column </td></tr>
    <tr><td class="paramname">unary_op</td><td>operation to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Result of the operation </dd></dl>

</div>
</div>
<a id="ad3fb33beea254a4697b0a1678a34ea16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fb33beea254a4697b0a1678a34ea16">&#9670;&nbsp;</a></span>unique_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::size_type cudf::unique_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>ignore_nulls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>nan_as_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the unique elements in the column. </p>
<p>Given an input column, number of unique elements in this column is returned</p>
<p>If both <code>ignore_nulls</code> and <code>nan_as_null</code> are true, both <code>NaN</code> and <code>null</code> values are ignored. If <code>ignored_nulls</code> is true and <code>nan_as_null</code> is false, only <code>null</code> is ignored, <code>NaN</code> is considered in unique count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The column whose unique elements will be counted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_nulls</td><td>flag to ignore <code>null</code> in unique count if true, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nan_as_null</td><td>flag to consider <code>NaN==null</code> if true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unique elements </dd></dl>

</div>
</div>
<a id="ad4423a474f1918e65aed295f0600c488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4423a474f1918e65aed295f0600c488">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&#160;</td>
          <td class="paramname"><em>desc_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nulls_as_largest</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find largest indices in a sorted table where values should be inserted to maintain order. </p>
<p>------------------------------------------------------------------------&mdash;* For each row v in <code>values</code>, find the last index in <code>t</code> where inserting the row will maintain the sort order of <code>t</code> </p>
<p>Example:</p>
<p>Single Column: idx 0 1 2 3 4 column = { 10, 20, 20, 30, 50 } values = { 20 } result = { 3 }</p>
<p>Multi Column: idx 0 1 2 3 4 t = {{ 10, 20, 20, 20, 20 }, { 5.0, .5, .5, .7, .7 }, { 90, 77, 78, 61, 61 }} values = {{ 20 }, { .7 }, { 61 }} result = { 5 * * </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>Table to search </td></tr>
    <tr><td class="paramname">values</td><td>Find insert locations for these values </td></tr>
    <tr><td class="paramname">desc_flags</td><td>Vector of column sort order. False indicates the corresponding column is sorted ascending </td></tr>
    <tr><td class="paramname">nulls_as_largest</td><td>If true, nulls are considered larger than valid values, otherwise, nulls are considered smaller than valid values</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md423"></a>
@return gdf_column   Insertion points. Non-nullable column of type GDF_INT32 with same size as values.</h2>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2rapids_2cudf_2cpp_2include_2cudf_2legacy_2search_8hpp-example.html#a2">/rapids/cudf/cpp/include/cudf/legacy/search.hpp</a>.</dd>
</dl>

</div>
</div>
<a id="a084ff0262deda4407ff67857cf1660c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084ff0262deda4407ff67857cf1660c0">&#9670;&nbsp;</a></span>valid_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename bit_container , typename predicate , typename size_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bit_container*, size_type&gt; cudf::valid_if </td>
          <td>(</td>
          <td class="paramtype">const bit_container *&#160;</td>
          <td class="paramname"><em>source_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const predicate &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a>&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a bitmask where every bit is marked with valid if and only if predicate(bit) and source_mask(bit) are both true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_mask</td><td>The source mask </td></tr>
    <tr><td class="paramname">p</td><td>The predicate that has an operator() member function </td></tr>
    <tr><td class="paramname">num_bits</td><td>Number of bits </td></tr>
    <tr><td class="paramname">stream</td><td>An optional cudaStream_t object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated bitmask as well as its null_count </dd></dl>

</div>
</div>
<a id="afa70e889e2b83eba15ed8e8e864dd3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa70e889e2b83eba15ed8e8e864dd3ff">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures a gdf_column is valid, i.e. that its fields are consistent with each other, and logical in themselves, in representing a proper column. </p>
<p>Ensure the input is in a valid state representing a proper column. Specifically, ensures all fields have valid (rather than junk, uninitialized or declared-invalid values), and that they are consistent with each other. </p>

</div>
</div>
<a id="a9fd7d3be7317e7621d5b073c7176a582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd7d3be7317e7621d5b073c7176a582">&#9670;&nbsp;</a></span>word_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA_HOST_DEVICE_CALLABLE size_type cudf::word_index </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>bit_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>------------------------------------------------------------------------&mdash;* </p>
<h2><a class="anchor" id="autotoc_md522"></a>
@brief Returns the index of the word containing the specified bit.</h2>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aab6fe3e771357669cccd3a8fe0ee3729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6fe3e771357669cccd3a8fe0ee3729">&#9670;&nbsp;</a></span>max_string_sentinel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__constant__ char cudf::max_string_sentinel[5] {&quot;\xF7\xBF\xBF\xBF&quot;}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>string value for sentinel which is used in min, max reduction operators This sentinel string value is the highest possible valid UTF-8 encoded character. This serves as identity value for maximum operator on string values. Also, this char pointer serves as valid device pointer of identity value for minimum operator on string values. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacecudf_html_aab7d308aae78cd6323814732ec4a2278"><div class="ttname"><a href="namespacecudf.html#aab7d308aae78cd6323814732ec4a2278">cudf::group_std</a></div><div class="ttdeci">std::pair&lt; cudf::table, cudf::table &gt; group_std(cudf::table const &amp;keys, cudf::table const &amp;values, cudf::size_type ddof)</div><div class="ttdoc">Computes a group wise standard deviation.</div><div class="ttdef"><b>Definition:</b> reductions/legacy/group_std.cu:188</div></div>
<div class="ttc" id="anamespacecudf_html_a6c828f318cb2c14c8ac0567f5084d1e7"><div class="ttname"><a href="namespacecudf.html#a6c828f318cb2c14c8ac0567f5084d1e7">cudf::group_quantiles</a></div><div class="ttdeci">std::pair&lt; cudf::table, cudf::table &gt; group_quantiles(cudf::table const &amp;keys, cudf::table const &amp;values, std::vector&lt; double &gt; const &amp;quantiles, cudf::interpolation interpolation, bool include_nulls)</div><div class="ttdoc">Find values at given quantiles within groups.</div><div class="ttdef"><b>Definition:</b> quantiles/legacy/group_quantiles.cu:120</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
