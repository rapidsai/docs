<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.20" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>cuML C++ API: ML Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcuml</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/nightly/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">stable (0.19)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcuml/nightly">nightly (21.06)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuml/stable">stable (0.19)</a><a class="rapids-selector__menu-item" href="/api/libcuml/legacy">legacy (0.18)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> |
<a href="#var-members">Variables</a> </div>
<div class="headertitle">
<div class="title">ML Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceML_1_1CD"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1CD.html">CD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Datasets"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Datasets.html">Datasets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Dbscan"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Dbscan.html">Dbscan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1DecisionTree"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1DecisionTree.html">DecisionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1detail"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Explainer"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Explainer.html">Explainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1fil"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1fil.html">fil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1GLM"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1GLM.html">GLM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1HoltWinters"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1HoltWinters.html">HoltWinters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Internals"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Internals.html">Internals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1kmeans"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1kmeans.html">kmeans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1KNN"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1KNN.html">KNN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Metrics"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Metrics.html">Metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1OLS"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1OLS.html">OLS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1PCA"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1PCA.html">PCA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Ridge"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Ridge.html">Ridge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Solver"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Solver.html">Solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Sparse"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Sparse.html">Sparse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Spectral"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Spectral.html">Spectral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Stationarity"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Stationarity.html">Stationarity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1SVM"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1SVM.html">SVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1TSVD"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1TSVD.html">TSVD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1UMAP"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1UMAP.html">UMAP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1cachingDeviceAllocator.html">cachingDeviceAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Implemententation of ML::deviceAllocator using the cub's caching allocator API.  <a href="classML_1_1cachingDeviceAllocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1IVFFlatParam.html">IVFFlatParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1IVFParam.html">IVFParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1IVFPQParam.html">IVFPQParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1IVFSQParam.html">IVFSQParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1knn__graph.html">knn_graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1knnIndex.html">knnIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1knnIndexParam.html">knnIndexParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The main Logging class for cuML library.  <a href="classML_1_1Logger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__dense__inputs__t.html">manifold_dense_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__inputs__t.html">manifold_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__precomputed__knn__inputs__t.html">manifold_precomputed_knn_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__sparse__inputs__t.html">manifold_sparse_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1OptimParams.html">OptimParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1params.html">params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">structure for pca parameters. Ref: <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html</a> <a href="classML_1_1paramsPCATemplate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsSolver.html">paramsSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1PatternSetter.html">PatternSetter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">RAII based pattern setter for <a class="el" href="classML_1_1Logger.html" title="The main Logging class for cuML library.">Logger</a> class.  <a href="classML_1_1PatternSetter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1rand__mat.html">rand_mat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rf.html">rf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RF__params.html">RF_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rfClassifier.html">rfClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rfRegressor.html">rfRegressor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1stdAllocatorAdapter.html">stdAllocatorAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1Tensor.html">Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1thrustAllocatorAdapter.html">thrustAllocatorAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab2bffedf6f8d520e216a6542ebf6a0f1"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a></td></tr>
<tr class="separator:ab2bffedf6f8d520e216a6542ebf6a0f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a239d146c5a5545dd84e3d0b6e305f631"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a></td></tr>
<tr class="separator:a239d146c5a5545dd84e3d0b6e305f631"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae3b799705dfc8991beaf24c9a906bc76"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a>&lt; <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae3b799705dfc8991beaf24c9a906bc76">paramsTSVDMG</a></td></tr>
<tr class="separator:ae3b799705dfc8991beaf24c9a906bc76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9ff6828291243eca3956818d2f309339"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a>&lt; <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9ff6828291243eca3956818d2f309339">paramsPCAMG</a></td></tr>
<tr class="separator:a9ff6828291243eca3956818d2f309339"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36df48edc11fcd68dd8b6f4a76526e7b"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; float, int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a></td></tr>
<tr class="separator:a36df48edc11fcd68dd8b6f4a76526e7b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acbf0352d6a255f990fcdf949b898d6af"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; double, int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a></td></tr>
<tr class="separator:acbf0352d6a255f990fcdf949b898d6af"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a79048a796facf156e926834d97bec78f"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; float, float &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a></td></tr>
<tr class="separator:a79048a796facf156e926834d97bec78f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64f2117024176a6fab67a1a6b8925243"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; double, double &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a></td></tr>
<tr class="separator:a64f2117024176a6fab67a1a6b8925243"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ac020f9f913af2af87de5e462b72aba"><td align="right" class="memItemLeft" valign="top">typedef int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4ac020f9f913af2af87de5e462b72aba">knn_indices_dense_t</a></td></tr>
<tr class="separator:a4ac020f9f913af2af87de5e462b72aba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a59bd3f642cc2f46bedc2c7059cac837a"><td align="right" class="memItemLeft" valign="top">typedef int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a59bd3f642cc2f46bedc2c7059cac837a">knn_indices_sparse_t</a></td></tr>
<tr class="separator:a59bd3f642cc2f46bedc2c7059cac837a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7324898185a2fc9a9145f9bad555049b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049b">solver</a> : int { <a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049ba38769546eb5536bd58d5eb9922c3e0bf">solver::COV_EIG_DQ</a>, 
<a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049ba3a077c1d31d8e7f29a92eb7ea002daad">solver::COV_EIG_JACOBI</a>
 }</td></tr>
<tr class="separator:a7324898185a2fc9a9145f9bad555049b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a3879adb63715cec17550171436f6ab"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> { <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba38769546eb5536bd58d5eb9922c3e0bf">mg_solver::COV_EIG_DQ</a>, 
<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba3a077c1d31d8e7f29a92eb7ea002daad">mg_solver::COV_EIG_JACOBI</a>, 
<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba66c35cd8077f7e1db5faefbc048a646a">mg_solver::QR</a>
 }</td></tr>
<tr class="separator:a9a3879adb63715cec17550171436f6ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d83b99fe769e2e9bf3596bb1604ab4f"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> { <a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4fa9d8edfe721557c504d925e3bcace2edf">CLASSIFICATION</a>, 
<a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4fa2864cd9bbe2aa57118c71b9c717c3586">REGRESSION</a>
 }</td></tr>
<tr class="separator:a4d83b99fe769e2e9bf3596bb1604ab4f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af60801cb5c9adac3f6f5bd4bd43aa2f7"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">task_category</a> { <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7a88b80439ca4076839158d63d31271315">REGRESSION_MODEL</a> = 1, 
<a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7a9c8a19e179622826abd959f7639c7006">CLASSIFICATION_MODEL</a> = 2
 }</td></tr>
<tr class="separator:af60801cb5c9adac3f6f5bd4bd43aa2f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe38bfbbab4fa672be59b329e7decc17"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17">QuantizerType</a> { <br/>
  <a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17a97bcbdde6eb10ef71ee9235841914f4e">QT_8bit</a>, 
<a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17a4b5c06c77f4a98dd4703f6ecf6b83986">QT_4bit</a>, 
<a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17a0f25f9e60fc642dbdf33656e874a54e6">QT_8bit_uniform</a>, 
<a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17a5b917b193d8e9451805569f03de079ff">QT_4bit_uniform</a>, 
<br/>
  <a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17a7edf2a9b1cfdfcf34648f65554cebac0">QT_fp16</a>, 
<a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17a48ba4496ed0c91e343f456df462bb15a">QT_8bit_direct</a>, 
<a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17a875dc6aaf10e3070fb3cdaf243f557e0">QT_6bit</a>
<br/>
 }</td></tr>
<tr class="separator:afe38bfbbab4fa672be59b329e7decc17"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga134c8dc1d94a4ee420679aec61849e2b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga134c8dc1d94a4ee420679aec61849e2b">random_matrix_type</a> { <a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2baa7bee409e76fac7544d660db7e2eb7c0">unset</a>, 
<a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2bad1e6d312a4b10fe213eac82ffb1cdd72">dense</a>, 
<a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2baca3f848ed01f4ea23129374f48c98293">sparse</a>
 }</td></tr>
<tr class="separator:ga134c8dc1d94a4ee420679aec61849e2b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1adf3fea9cf9cde96ecf353b43818079"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079">lr_type</a> { <a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a5ccc94f0f9ce653134966e2377c71ca1">OPTIMAL</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079aabfea584e2f24b9920a5fb3058dd06bb">CONSTANT</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a98a91ed2cd2ff227d0393c406e09a106">INVSCALING</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a8108470840df674d6403e12c0d2ac63a">ADAPTIVE</a>
 }</td></tr>
<tr class="separator:a1adf3fea9cf9cde96ecf353b43818079"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67da49ce109878bcdbb29a8777d28de1"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1">loss_funct</a> { <a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1ad3c28e4d0ab8ed2b4c69c0483c6ffea4">SQRD_LOSS</a>, 
<a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1a007e4d0f43a45d8d9be3dde194ea410a">HINGE</a>, 
<a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1ad24128f8a7b16f59075a28323f13803d">LOG</a>
 }</td></tr>
<tr class="separator:a67da49ce109878bcdbb29a8777d28de1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a899c5f26e201a81a2c12bb7eed9b015d"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015d">penalty</a> { <a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015daf8cf4476d6fa69254aa96e2a9b385b07">NONE</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072">L1</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e">L2</a>, 
<a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015da80cad9123fc734ada9ef3a33ac30e627">ELASTICNET</a>
 }</td></tr>
<tr class="separator:a899c5f26e201a81a2c12bb7eed9b015d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe9899e0c7ff1cf722a35bcf35283953"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953">SPLIT_ALGO</a> { <a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a5ce779f6c1df4e4ec40cd9cee88837e2">HIST</a>, 
<a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a61e77c561b3834cdc46508db24d72f90">GLOBAL_QUANTILE</a>, 
<a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a5773eabe7d91f72e535b233ca73ba5c9">SPLIT_ALGO_END</a>
 }</td></tr>
<tr class="separator:afe9899e0c7ff1cf722a35bcf35283953"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a823912afaa51f58a997564eadb6d9405"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> { <br/>
  <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405af633f697107611ea3f0f2d18986be3e6">GINI</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ab55a4e6aef097bd8f786f4ddfd1de161">ENTROPY</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a746a9f45470e731c984d37744c48432e">MSE</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a71d3454116e1aace7f91b15f56567b1e">MAE</a>, 
<br/>
  <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ae346b778011ef4f488c1c87d64c1b174">CRITERION_END</a>
<br/>
 }</td></tr>
<tr class="separator:a823912afaa51f58a997564eadb6d9405"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0dcbb2c0993e8446dffd09b5de731a26"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> { <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a7c2ef7613d7b9a655691f9f24b893c11">CSS</a>, 
<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>
 }</td></tr>
<tr class="separator:a0dcbb2c0993e8446dffd09b5de731a26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8d55de18185e36dd8f8a6d735e6a91e6"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6">SeasonalType</a> { <a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6af28ffe4c75342f4012bcf16f798e0ec3">ADDITIVE</a>, 
<a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6abc34c50dc7f29a357f52f9e5c0308226">MULTIPLICATIVE</a>
 }</td></tr>
<tr class="separator:a8d55de18185e36dd8f8a6d735e6a91e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85e691126b37f5e1dc834841cad1479c"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479c">OptimCriterion</a> { <a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca7a9fdcb8befd1162d7ba06c5bc34bd21">OPTIM_BFGS_ITER_LIMIT</a> = 0, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca80e3d3c81590a148d565b7ddb78ef590">OPTIM_MIN_PARAM_DIFF</a> = 1, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca01a4b4daad43785b0587346034b10ef5">OPTIM_MIN_ERROR_DIFF</a> = 2, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca6c4ee736abd198cfc853b82b1e3a1fcc">OPTIM_MIN_GRAD_NORM</a> = 3
 }</td></tr>
<tr class="separator:a85e691126b37f5e1dc834841cad1479c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1529da2b94c67018bb14f404f6e9aeac"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeac">Norm</a> { <a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca6527e252610c64b85fdc9fc357c979cc">L0</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072">L1</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e">L2</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca83820f75ef6d53c49873c4269fdcdc26">LINF</a>
 }</td></tr>
<tr class="separator:a1529da2b94c67018bb14f404f6e9aeac"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2e906b2839782feeb92f9f8d6b72bcad"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2e906b2839782feeb92f9f8d6b72bcad">single_linkage_pairwise</a> (const raft::handle_t &amp;handle, const float *X, size_t m, size_t n, raft::hierarchy::linkage_output&lt; int, float &gt; *out, raft::distance::DistanceType metric, int n_clusters=5)</td></tr>
<tr class="memdesc:a2e906b2839782feeb92f9f8d6b72bcad"><td class="mdescLeft"> </td><td class="mdescRight">Computes single-linkage hierarchical clustering on a dense input feature matrix and outputs the labels, dendrogram, and minimum spanning tree. Connectivities are constructed using the full n^2 pairwise distance matrix. This can be very fast for smaller datasets when there is enough memory available.  <a href="namespaceML.html#a2e906b2839782feeb92f9f8d6b72bcad">More...</a><br/></td></tr>
<tr class="separator:a2e906b2839782feeb92f9f8d6b72bcad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0262446094debc247669f955e6f13e5f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0262446094debc247669f955e6f13e5f">single_linkage_neighbors</a> (const raft::handle_t &amp;handle, const float *X, size_t m, size_t n, raft::hierarchy::linkage_output&lt; int, float &gt; *out, raft::distance::DistanceType metric=raft::distance::DistanceType::L2Unexpanded, int c=15, int n_clusters=5)</td></tr>
<tr class="memdesc:a0262446094debc247669f955e6f13e5f"><td class="mdescLeft"> </td><td class="mdescRight">Computes single-linkage hierarchical clustering on a dense input feature matrix and outputs the labels, dendrogram, and minimum spanning tree. Connectivities are constructed using a k-nearest neighbors graph. While this strategy enables the algorithm to scale to much higher numbers of rows, it comes with the downside that additional knn steps may need to be executed to connect an otherwise unconnected k-nn graph.  <a href="namespaceML.html#a0262446094debc247669f955e6f13e5f">More...</a><br/></td></tr>
<tr class="separator:a0262446094debc247669f955e6f13e5f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab6638b428d61f67a7054b60c37ca3172"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab6638b428d61f67a7054b60c37ca3172">single_linkage_pairwise</a> (const raft::handle_t &amp;handle, const float *X, size_t m, size_t n, raft::hierarchy::linkage_output&lt; int64_t, float &gt; *out, raft::distance::DistanceType metric, int n_clusters=5)</td></tr>
<tr class="separator:ab6638b428d61f67a7054b60c37ca3172"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabb9694969393f0288a606c9184435ef9"><td align="right" class="memItemLeft" valign="top">std::string </td><td class="memItemRight" valign="bottom"><a class="el" href="group__CStringFormat.html#gabb9694969393f0288a606c9184435ef9">format</a> (const char *fmt, va_list &amp;vl)</td></tr>
<tr class="separator:gabb9694969393f0288a606c9184435ef9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad55df9da3c66646eee88f92620cef30a"><td align="right" class="memItemLeft" valign="top">std::string </td><td class="memItemRight" valign="bottom"><a class="el" href="group__CStringFormat.html#gad55df9da3c66646eee88f92620cef30a">format</a> (const char *fmt,...)</td></tr>
<tr class="separator:gad55df9da3c66646eee88f92620cef30a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5382ae5b01e8079b6e550b13d087d4fb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5382ae5b01e8079b6e550b13d087d4fb">pcaFit</a> (raft::handle_t &amp;handle, float *input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, float *mu, float *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a5382ae5b01e8079b6e550b13d087d4fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a82ec70080c3ee46d4ff21b8222868c93"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a82ec70080c3ee46d4ff21b8222868c93">pcaFit</a> (raft::handle_t &amp;handle, double *input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, double *mu, double *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a82ec70080c3ee46d4ff21b8222868c93"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8ca2904e5fd35b1a9b883c87e1c1274"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad8ca2904e5fd35b1a9b883c87e1c1274">pcaFitTransform</a> (raft::handle_t &amp;handle, float *input, float *trans_input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, float *mu, float *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ad8ca2904e5fd35b1a9b883c87e1c1274"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb11c10b247ee28f7897bb28156320e1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeb11c10b247ee28f7897bb28156320e1">pcaFitTransform</a> (raft::handle_t &amp;handle, double *input, double *trans_input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, double *mu, double *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:aeb11c10b247ee28f7897bb28156320e1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab49f1e8617076366a9be1fac04b8c92d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab49f1e8617076366a9be1fac04b8c92d">pcaInverseTransform</a> (raft::handle_t &amp;handle, float *trans_input, float *components, float *singular_vals, float *mu, float *input, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ab49f1e8617076366a9be1fac04b8c92d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6dc66b3d7ba1d41b448d4317272fbbc"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af6dc66b3d7ba1d41b448d4317272fbbc">pcaInverseTransform</a> (raft::handle_t &amp;handle, double *trans_input, double *components, double *singular_vals, double *mu, double *input, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:af6dc66b3d7ba1d41b448d4317272fbbc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9930aa036bcf52cf182f000ce355cdcd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9930aa036bcf52cf182f000ce355cdcd">pcaTransform</a> (raft::handle_t &amp;handle, float *input, float *components, float *trans_input, float *singular_vals, float *mu, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a9930aa036bcf52cf182f000ce355cdcd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac37aa9b10bb7445d9b3523dae260e681"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac37aa9b10bb7445d9b3523dae260e681">pcaTransform</a> (raft::handle_t &amp;handle, double *input, double *components, double *trans_input, double *singular_vals, double *mu, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ac37aa9b10bb7445d9b3523dae260e681"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2a071bdcbc710b1a4ca88efc02fd2489"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2a071bdcbc710b1a4ca88efc02fd2489">tsvdFit</a> (raft::handle_t &amp;handle, float *input, float *components, float *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a2a071bdcbc710b1a4ca88efc02fd2489"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:add33f23b1a15823449837dc884b13ddd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#add33f23b1a15823449837dc884b13ddd">tsvdFit</a> (raft::handle_t &amp;handle, double *input, double *components, double *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:add33f23b1a15823449837dc884b13ddd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac335d131520793dcf0831d753e1c7ab2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac335d131520793dcf0831d753e1c7ab2">tsvdInverseTransform</a> (raft::handle_t &amp;handle, float *trans_input, float *components, float *input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ac335d131520793dcf0831d753e1c7ab2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae2faa9e0c83e9270369e866281802624"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae2faa9e0c83e9270369e866281802624">tsvdInverseTransform</a> (raft::handle_t &amp;handle, double *trans_input, double *components, double *input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ae2faa9e0c83e9270369e866281802624"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1a8f7fa23231a10eb02ea2a3d4923335"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1a8f7fa23231a10eb02ea2a3d4923335">tsvdTransform</a> (raft::handle_t &amp;handle, float *input, float *components, float *trans_input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a1a8f7fa23231a10eb02ea2a3d4923335"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83f6113e72b200d0a4bef2759285a6ca"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a83f6113e72b200d0a4bef2759285a6ca">tsvdTransform</a> (raft::handle_t &amp;handle, double *input, double *components, double *trans_input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a83f6113e72b200d0a4bef2759285a6ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afba20c39f0790075843e9236fd043ca1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afba20c39f0790075843e9236fd043ca1">tsvdFitTransform</a> (raft::handle_t &amp;handle, float *input, float *trans_input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:afba20c39f0790075843e9236fd043ca1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae1a46cc3b471efc453be9e8fbecba363"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae1a46cc3b471efc453be9e8fbecba363">tsvdFitTransform</a> (raft::handle_t &amp;handle, double *input, double *trans_input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ae1a46cc3b471efc453be9e8fbecba363"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c7fcf2379a3d18e1c08840ff530eda9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5c7fcf2379a3d18e1c08840ff530eda9">set_all_rf_metrics</a> (<a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> rf_type, float accuracy, double mean_abs_error, double mean_squared_error, double median_abs_error)</td></tr>
<tr class="separator:a5c7fcf2379a3d18e1c08840ff530eda9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85f241652a9dfc89e280200e7618ed32"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85f241652a9dfc89e280200e7618ed32">set_rf_metrics_classification</a> (float accuracy)</td></tr>
<tr class="separator:a85f241652a9dfc89e280200e7618ed32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaa0b5eb27fbd28c93285b9ada72930d8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aaa0b5eb27fbd28c93285b9ada72930d8">set_rf_metrics_regression</a> (double mean_abs_error, double mean_squared_error, double median_abs_error)</td></tr>
<tr class="separator:aaa0b5eb27fbd28c93285b9ada72930d8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a390319c6e316ef242d477e8fa326f2d0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a390319c6e316ef242d477e8fa326f2d0">print</a> (const <a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> rf_metrics)</td></tr>
<tr class="separator:a390319c6e316ef242d477e8fa326f2d0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69f0169515a838c25ba3080b48ae2ceb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a69f0169515a838c25ba3080b48ae2ceb">validity_check</a> (const <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params)</td></tr>
<tr class="separator:a69f0169515a838c25ba3080b48ae2ceb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa3ded9ffe5af3b52a2b8a301a362af10"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa3ded9ffe5af3b52a2b8a301a362af10">print</a> (const <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params)</td></tr>
<tr class="separator:aa3ded9ffe5af3b52a2b8a301a362af10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa25bebb87dff8c328b2d4809f640f789"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa25bebb87dff8c328b2d4809f640f789">preprocess_labels</a> (int n_rows, std::vector&lt; int &gt; &amp;labels, std::map&lt; int, int &gt; &amp;labels_map, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aa25bebb87dff8c328b2d4809f640f789"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a05ee22c0f2c66e9bb7d60c72e5d61b32"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a05ee22c0f2c66e9bb7d60c72e5d61b32">postprocess_labels</a> (int n_rows, std::vector&lt; int &gt; &amp;labels, std::map&lt; int, int &gt; &amp;labels_map, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a05ee22c0f2c66e9bb7d60c72e5d61b32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1275db1b0385b97fbb481b719322a25"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:ab1275db1b0385b97fbb481b719322a25"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab1275db1b0385b97fbb481b719322a25">null_trees_ptr</a> (<a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&amp;forest)</td></tr>
<tr class="separator:ab1275db1b0385b97fbb481b719322a25"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47bd45d133f5b3bb3748a6e5d1c61c91"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a47bd45d133f5b3bb3748a6e5d1c61c91"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a47bd45d133f5b3bb3748a6e5d1c61c91">delete_rf_metadata</a> (<a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a47bd45d133f5b3bb3748a6e5d1c61c91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a365ba29d7ab5eef114015814d9d610ea"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a365ba29d7ab5eef114015814d9d610ea"><td align="right" class="memTemplItemLeft" valign="top">std::string </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a365ba29d7ab5eef114015814d9d610ea">get_rf_summary_text</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a365ba29d7ab5eef114015814d9d610ea"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8af17368b9e59dd87348191cb9129388"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a8af17368b9e59dd87348191cb9129388"><td align="right" class="memTemplItemLeft" valign="top">std::string </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8af17368b9e59dd87348191cb9129388">get_rf_detailed_text</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a8af17368b9e59dd87348191cb9129388"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a20b4def2d270c337188e8d3a27bd04df"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a20b4def2d270c337188e8d3a27bd04df"><td align="right" class="memTemplItemLeft" valign="top">std::string </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a20b4def2d270c337188e8d3a27bd04df">get_rf_json</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a20b4def2d270c337188e8d3a27bd04df"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a684813418506a4839a61692008e4cfb9"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a684813418506a4839a61692008e4cfb9"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a684813418506a4839a61692008e4cfb9">build_treelite_forest</a> (<a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> *model, const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest, int num_features, int <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">task_category</a>)</td></tr>
<tr class="separator:a684813418506a4839a61692008e4cfb9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"><td align="right" class="memItemLeft" valign="top"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee">concatenate_trees</a> (std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; treelite_handles)</td></tr>
<tr class="separator:ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af142813513ee46988a79fd3dc4ab52a6"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af142813513ee46988a79fd3dc4ab52a6">compare_concat_forest_to_subforests</a> (<a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> concat_tree_handle, std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; treelite_handles)</td></tr>
<tr class="separator:af142813513ee46988a79fd3dc4ab52a6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e62adbaee80935246fc0ff937575b59"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2e62adbaee80935246fc0ff937575b59">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&amp;forest, float *input, int n_rows, int n_cols, int *labels, int n_unique_labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a2e62adbaee80935246fc0ff937575b59"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38cfdf38af3291baa8b4a5f3a33b74a9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a38cfdf38af3291baa8b4a5f3a33b74a9">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&amp;forest, double *input, int n_rows, int n_cols, int *labels, int n_unique_labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a38cfdf38af3291baa8b4a5f3a33b74a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0a63f42d57ee6287cedb49f48a6fa220"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0a63f42d57ee6287cedb49f48a6fa220">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const float *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a0a63f42d57ee6287cedb49f48a6fa220"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a014e0b6e471acfa9829c62a05de49275"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a014e0b6e471acfa9829c62a05de49275">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const double *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a014e0b6e471acfa9829c62a05de49275"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36a34da015328e0518fc6ceec5f22710"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a36a34da015328e0518fc6ceec5f22710">predictGetAll</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const float *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a36a34da015328e0518fc6ceec5f22710"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40a10f5bf0cce48a4ea54d7f33281081"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a40a10f5bf0cce48a4ea54d7f33281081">predictGetAll</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const double *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a40a10f5bf0cce48a4ea54d7f33281081"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae91cc5ebb6e5b37e754ada49a37c3f2f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae91cc5ebb6e5b37e754ada49a37c3f2f">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const int *ref_labels, int n_rows, const int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ae91cc5ebb6e5b37e754ada49a37c3f2f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeff6bb49e843ea8d5135439648e633a8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeff6bb49e843ea8d5135439648e633a8">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const int *ref_labels, int n_rows, const int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aeff6bb49e843ea8d5135439648e633a8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5ac87bd832444ec058bfd447ae9f39a3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5ac87bd832444ec058bfd447ae9f39a3">set_rf_params</a> (int max_depth, int max_leaves, float max_features, int n_bins, int split_algo, int min_samples_leaf, int min_samples_split, float min_impurity_decrease, bool bootstrap_features, bool bootstrap, int n_trees, float max_samples, uint64_t seed, <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> split_criterion, bool quantile_per_tree, int cfg_n_streams, bool use_experimental_backend, int max_batch_size)</td></tr>
<tr class="separator:a5ac87bd832444ec058bfd447ae9f39a3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a970c9a51cb7fb36680c2f2e3ad88dca4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a970c9a51cb7fb36680c2f2e3ad88dca4">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&amp;forest, float *input, int n_rows, int n_cols, float *labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a970c9a51cb7fb36680c2f2e3ad88dca4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4dfca11198fa7304d1568c6c7ff09469"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4dfca11198fa7304d1568c6c7ff09469">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&amp;forest, double *input, int n_rows, int n_cols, double *labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a4dfca11198fa7304d1568c6c7ff09469"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae9ebff9eb10e9bcf8c9e2d9b6533259b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae9ebff9eb10e9bcf8c9e2d9b6533259b">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *forest, const float *input, int n_rows, int n_cols, float *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ae9ebff9eb10e9bcf8c9e2d9b6533259b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd7a72d075a98a0f8eeb197c81554348"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afd7a72d075a98a0f8eeb197c81554348">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *forest, const double *input, int n_rows, int n_cols, double *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:afd7a72d075a98a0f8eeb197c81554348"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a04e5fbd639ed8b2820ad3a1500d26732"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a04e5fbd639ed8b2820ad3a1500d26732">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *forest, const float *ref_labels, int n_rows, const float *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a04e5fbd639ed8b2820ad3a1500d26732"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa819cc3c995f572099b9b84e0897cd76"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa819cc3c995f572099b9b84e0897cd76">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *forest, const double *ref_labels, int n_rows, const double *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aa819cc3c995f572099b9b84e0897cd76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a44417adde26e5936aa7e05c2b8fb12"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9a44417adde26e5936aa7e05c2b8fb12">TSNE_fit</a> (const raft::handle_t &amp;handle, float *X, float *Y, int n, int p, int64_t *knn_indices, float *knn_dists, const int dim=2, int n_neighbors=1023, const float theta=0.5f, const float epssq=0.0025, float perplexity=50.0f, const int perplexity_max_iter=100, const float perplexity_tol=1e-5, const float early_exaggeration=12.0f, const int exaggeration_iter=250, const float min_gain=0.01f, const float pre_learning_rate=200.0f, const float post_learning_rate=500.0f, const int max_iter=1000, const float min_grad_norm=1e-7, const float pre_momentum=0.5, const float post_momentum=0.8, const long long random_state=-1, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>, const bool initialize_embeddings=true, bool barnes_hut=true)</td></tr>
<tr class="memdesc:a9a44417adde26e5936aa7e05c2b8fb12"><td class="mdescLeft"> </td><td class="mdescRight">Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2).  <a href="namespaceML.html#a9a44417adde26e5936aa7e05c2b8fb12">More...</a><br/></td></tr>
<tr class="separator:a9a44417adde26e5936aa7e05c2b8fb12"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a11b7b6bfe4fcd83c5cb1d0ebd995227d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a11b7b6bfe4fcd83c5cb1d0ebd995227d">TSNE_fit_sparse</a> (const raft::handle_t &amp;handle, int *indptr, int *indices, float *data, float *Y, int nnz, int n, int p, int *knn_indices, float *knn_dists, const int dim=2, int n_neighbors=1023, const float theta=0.5f, const float epssq=0.0025, float perplexity=50.0f, const int perplexity_max_iter=100, const float perplexity_tol=1e-5, const float early_exaggeration=12.0f, const int exaggeration_iter=250, const float min_gain=0.01f, const float pre_learning_rate=200.0f, const float post_learning_rate=500.0f, const int max_iter=1000, const float min_grad_norm=1e-7, const float pre_momentum=0.5, const float post_momentum=0.8, const long long random_state=-1, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>, const bool initialize_embeddings=true, bool barnes_hut=true)</td></tr>
<tr class="memdesc:a11b7b6bfe4fcd83c5cb1d0ebd995227d"><td class="mdescLeft"> </td><td class="mdescRight">Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2).  <a href="namespaceML.html#a11b7b6bfe4fcd83c5cb1d0ebd995227d">More...</a><br/></td></tr>
<tr class="separator:a11b7b6bfe4fcd83c5cb1d0ebd995227d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5bcb25fe2fd014d74ea5afb5eae005d3"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5bcb25fe2fd014d74ea5afb5eae005d3">brute_force_knn</a> (const raft::handle_t &amp;handle, std::vector&lt; float * &gt; &amp;input, std::vector&lt; int &gt; &amp;sizes, int D, float *search_items, int n, int64_t *res_I, float *res_D, int k, bool rowMajorIndex=false, bool rowMajorQuery=false, raft::distance::DistanceType metric=raft::distance::DistanceType::L2Expanded, float metric_arg=2.0f)</td></tr>
<tr class="memdesc:a5bcb25fe2fd014d74ea5afb5eae005d3"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances.  <a href="namespaceML.html#a5bcb25fe2fd014d74ea5afb5eae005d3">More...</a><br/></td></tr>
<tr class="separator:a5bcb25fe2fd014d74ea5afb5eae005d3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe64edbcd9d438d62eef462cddad346a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afe64edbcd9d438d62eef462cddad346a">approx_knn_build_index</a> (raft::handle_t &amp;handle, <a class="el" href="structML_1_1knnIndex.html">ML::knnIndex</a> *index, <a class="el" href="structML_1_1knnIndexParam.html">ML::knnIndexParam</a> *<a class="el" href="classML_1_1params.html">params</a>, raft::distance::DistanceType metric, float metricArg, float *index_array, int n, int D)</td></tr>
<tr class="memdesc:afe64edbcd9d438d62eef462cddad346a"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to build an approximate nearest neighbors index from an index array and a set of parameters.  <a href="namespaceML.html#afe64edbcd9d438d62eef462cddad346a">More...</a><br/></td></tr>
<tr class="separator:afe64edbcd9d438d62eef462cddad346a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85840e42938d39c7ba89168601e2854a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85840e42938d39c7ba89168601e2854a">approx_knn_search</a> (raft::handle_t &amp;handle, float *distances, int64_t *indices, <a class="el" href="structML_1_1knnIndex.html">ML::knnIndex</a> *index, int k, float *query_array, int n)</td></tr>
<tr class="memdesc:a85840e42938d39c7ba89168601e2854a"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform an approximate nearest neighbors search from previously built index and a query array.  <a href="namespaceML.html#a85840e42938d39c7ba89168601e2854a">More...</a><br/></td></tr>
<tr class="separator:a85840e42938d39c7ba89168601e2854a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a181e3084eb03bbcfdcde71c281141555"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a181e3084eb03bbcfdcde71c281141555">knn_classify</a> (raft::handle_t &amp;handle, int *out, int64_t *knn_indices, std::vector&lt; int * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a181e3084eb03bbcfdcde71c281141555"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a knn classification using a given a vector of label arrays. This supports multilabel classification by classifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn.  <a href="namespaceML.html#a181e3084eb03bbcfdcde71c281141555">More...</a><br/></td></tr>
<tr class="separator:a181e3084eb03bbcfdcde71c281141555"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a876ab255e2fc9f989d251f3ff57af5d5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a876ab255e2fc9f989d251f3ff57af5d5">knn_regress</a> (raft::handle_t &amp;handle, float *out, int64_t *knn_indices, std::vector&lt; float * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a876ab255e2fc9f989d251f3ff57af5d5"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a knn regression using a given a vector of label arrays. This supports multilabel regression by clasifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn.  <a href="namespaceML.html#a876ab255e2fc9f989d251f3ff57af5d5">More...</a><br/></td></tr>
<tr class="separator:a876ab255e2fc9f989d251f3ff57af5d5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8260b0b9f0efd7893d8b1c925c6839f0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8260b0b9f0efd7893d8b1c925c6839f0">knn_class_proba</a> (raft::handle_t &amp;handle, std::vector&lt; float * &gt; &amp;out, int64_t *knn_indices, std::vector&lt; int * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a8260b0b9f0efd7893d8b1c925c6839f0"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to compute knn class probabilities using a vector of device arrays containing discrete class labels. Note that the output is a vector, which is.  <a href="namespaceML.html#a8260b0b9f0efd7893d8b1c925c6839f0">More...</a><br/></td></tr>
<tr class="separator:a8260b0b9f0efd7893d8b1c925c6839f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga751d8a984b4aacd46234f7a8017f30aa"><td class="memTemplParams" colspan="2">template&lt;typename math_t &gt; </td></tr>
<tr class="memitem:ga751d8a984b4aacd46234f7a8017f30aa"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga751d8a984b4aacd46234f7a8017f30aa">RPROJfit</a> (const raft::handle_t &amp;handle, <a class="el" href="structML_1_1rand__mat.html">rand_mat</a>&lt; math_t &gt; *random_matrix, <a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:ga751d8a984b4aacd46234f7a8017f30aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5ba9ec2edbeb657dd2247d0207647fb2"><td class="memTemplParams" colspan="2">template&lt;typename math_t &gt; </td></tr>
<tr class="memitem:ga5ba9ec2edbeb657dd2247d0207647fb2"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga5ba9ec2edbeb657dd2247d0207647fb2">RPROJtransform</a> (const raft::handle_t &amp;handle, math_t *input, <a class="el" href="structML_1_1rand__mat.html">rand_mat</a>&lt; math_t &gt; *random_matrix, math_t *output, <a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:ga5ba9ec2edbeb657dd2247d0207647fb2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacb2b3ebad5d3f97745d7d8d8e57d8345"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#gacb2b3ebad5d3f97745d7d8d8e57d8345">johnson_lindenstrauss_min_dim</a> (size_t n_samples, double eps)</td></tr>
<tr class="separator:gacb2b3ebad5d3f97745d7d8d8e57d8345"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a236db2676ab7c1363895c81faa085a"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7a236db2676ab7c1363895c81faa085a">divide_by_mask_build_index</a> (const raft::handle_t &amp;handle, const bool *d_mask, int *d_index, int batch_size)</td></tr>
<tr class="separator:a7a236db2676ab7c1363895c81faa085a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac30d243b4af52a353b388781f6c80bbd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac30d243b4af52a353b388781f6c80bbd">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const float *d_in, const bool *d_mask, const int *d_index, float *d_out0, float *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:ac30d243b4af52a353b388781f6c80bbd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8664a4caa2bb7efe45a4772fef29dc6a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8664a4caa2bb7efe45a4772fef29dc6a">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const double *d_in, const bool *d_mask, const int *d_index, double *d_out0, double *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:a8664a4caa2bb7efe45a4772fef29dc6a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a77087155e5d034998297612c318b44c4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a77087155e5d034998297612c318b44c4">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const int *d_in, const bool *d_mask, const int *d_index, int *d_out0, int *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:a77087155e5d034998297612c318b44c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a96e538801438dbf2cb14b387bbfb5a66"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a96e538801438dbf2cb14b387bbfb5a66">divide_by_min_build_index</a> (const raft::handle_t &amp;handle, const float *d_matrix, int *d_batch, int *d_index, int *h_size, int batch_size, int n_sub)</td></tr>
<tr class="separator:a96e538801438dbf2cb14b387bbfb5a66"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ec36247a6875e497c2258a27da253e8"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1ec36247a6875e497c2258a27da253e8">divide_by_min_build_index</a> (const raft::handle_t &amp;handle, const double *d_matrix, int *d_batch, int *d_index, int *h_size, int batch_size, int n_sub)</td></tr>
<tr class="separator:a1ec36247a6875e497c2258a27da253e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2c70b44dbd2190b2b78f5b79b2374428"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2c70b44dbd2190b2b78f5b79b2374428">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const float *d_in, const int *d_batch, const int *d_index, float **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a2c70b44dbd2190b2b78f5b79b2374428"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a806f5807932256b6be674a37bd993dd9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a806f5807932256b6be674a37bd993dd9">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const double *d_in, const int *d_batch, const int *d_index, double **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a806f5807932256b6be674a37bd993dd9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a266431bebb4a84c70458265ea26b393b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a266431bebb4a84c70458265ea26b393b">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const int *d_in, const int *d_batch, const int *d_index, int **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a266431bebb4a84c70458265ea26b393b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a27ed4fdb2f62155d0a1fd81f1405a779"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a27ed4fdb2f62155d0a1fd81f1405a779">build_division_map</a> (const raft::handle_t &amp;handle, const int *const *hd_id, const int *h_size, int *d_id_to_pos, int *d_id_to_model, int batch_size, int n_sub)</td></tr>
<tr class="separator:a27ed4fdb2f62155d0a1fd81f1405a779"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb8f25b52e0576997c85d1488367ab76"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeb8f25b52e0576997c85d1488367ab76">merge_series</a> (const raft::handle_t &amp;handle, const float *const *hd_in, const int *d_id_to_pos, const int *d_id_to_sub, float *d_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:aeb8f25b52e0576997c85d1488367ab76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a03e79871ae0209450671f11bcd8965fe"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a03e79871ae0209450671f11bcd8965fe">merge_series</a> (const raft::handle_t &amp;handle, const double *const *hd_in, const int *d_id_to_pos, const int *d_id_to_sub, double *d_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a03e79871ae0209450671f11bcd8965fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad048e7644ca470414dc9c7fca5f2e189"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad048e7644ca470414dc9c7fca5f2e189">pack</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, double *param_vec)</td></tr>
<tr class="separator:ad048e7644ca470414dc9c7fca5f2e189"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a62e41ec81cdf10cea7be42c97eca6b32"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a62e41ec81cdf10cea7be42c97eca6b32">unpack</a> (raft::handle_t &amp;handle, <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, const double *param_vec)</td></tr>
<tr class="separator:a62e41ec81cdf10cea7be42c97eca6b32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa0653c7b782547550d2d8df07038e28a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa0653c7b782547550d2d8df07038e28a">batched_diff</a> (raft::handle_t &amp;handle, double *d_y_diff, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order)</td></tr>
<tr class="separator:aa0653c7b782547550d2d8df07038e28a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8d434323e4d805be8320a5d517bbd8b9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8d434323e4d805be8320a5d517bbd8b9">batched_loglike</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const double *d_params, double *loglike, double *d_vs, bool trans=true, bool host_loglike=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0, int fc_steps=0, double *d_fc=nullptr, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:a8d434323e4d805be8320a5d517bbd8b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab751422ded5ed3ec53f5f138d8bdcca4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab751422ded5ed3ec53f5f138d8bdcca4">batched_loglike</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *loglike, double *d_vs, bool trans=true, bool host_loglike=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0, int fc_steps=0, double *d_fc=nullptr, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:ab751422ded5ed3ec53f5f138d8bdcca4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38169d12d519a05e0e6c255efc45d004"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a38169d12d519a05e0e6c255efc45d004">batched_loglike_grad</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const double *d_x, double *d_grad, double h, bool trans=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0)</td></tr>
<tr class="separator:a38169d12d519a05e0e6c255efc45d004"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af1794d3b91c3c67dc5072a12910c48d2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af1794d3b91c3c67dc5072a12910c48d2">predict</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, int start, int end, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *d_y_p, bool pre_diff=true, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:af1794d3b91c3c67dc5072a12910c48d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a904aa5ac2206f2403f430ca7fd135f4f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a904aa5ac2206f2403f430ca7fd135f4f">information_criterion</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *ic, int ic_type)</td></tr>
<tr class="separator:a904aa5ac2206f2403f430ca7fd135f4f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a492e6cc8eeb77f760b7abf1c5d37801b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a492e6cc8eeb77f760b7abf1c5d37801b">estimate_x0</a> (raft::handle_t &amp;handle, <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order)</td></tr>
<tr class="separator:a492e6cc8eeb77f760b7abf1c5d37801b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b41fea6f2923aac90b27f01c5f9149e"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7b41fea6f2923aac90b27f01c5f9149e">batched_kalman_filter</a> (raft::handle_t &amp;handle, const double *d_ys_b, int nobs, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, double *d_loglike, double *d_vs, int fc_steps=0, double *d_fc=nullptr, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:a7b41fea6f2923aac90b27f01c5f9149e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1b3ecb77a2af6ef294f2b05eca4037ee"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1b3ecb77a2af6ef294f2b05eca4037ee">batched_jones_transform</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, bool isInv, const double *h_params, double *h_Tparams)</td></tr>
<tr class="separator:a1b3ecb77a2af6ef294f2b05eca4037ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af0f446810d4972e9bee95fca756cb958"><td align="right" class="memItemLeft" valign="top">auto </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af0f446810d4972e9bee95fca756cb958">thrust_exec_policy</a> (std::shared_ptr&lt; <a class="el" href="quantile_8h.html#a835ee0b83c8b4efdaef43c9d85819800">deviceAllocator</a> &gt; allocator, cudaStream_t stream) -&gt; std::unique_ptr&lt; decltype(thrust::cuda::par(_decltypeHelper)), std::function&lt; void(decltype(thrust::cuda::par(_decltypeHelper)) *)&gt;&gt;</td></tr>
<tr class="memdesc:af0f446810d4972e9bee95fca756cb958"><td class="mdescLeft"> </td><td class="mdescRight">Returns a unique_ptr to a Thrust CUDA execution policy that uses the passed in allocator for temporary memory allocation.  <a href="namespaceML.html#af0f446810d4972e9bee95fca756cb958">More...</a><br/></td></tr>
<tr class="separator:af0f446810d4972e9bee95fca756cb958"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d769926cc27c80a2daa3779c606c133"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9d769926cc27c80a2daa3779c606c133">convert_level_to_spdlog</a> (int level)</td></tr>
<tr class="separator:a9d769926cc27c80a2daa3779c606c133"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aacfa74158f3a2d08f6ddae02dbfb2992"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aacfa74158f3a2d08f6ddae02dbfb2992">PUSH_RANGE</a> (const char *name)</td></tr>
<tr class="memdesc:aacfa74158f3a2d08f6ddae02dbfb2992"><td class="mdescLeft"> </td><td class="mdescRight">Push a named nvtx range.  <a href="namespaceML.html#aacfa74158f3a2d08f6ddae02dbfb2992">More...</a><br/></td></tr>
<tr class="separator:aacfa74158f3a2d08f6ddae02dbfb2992"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a516be7eeb210dc391738e9761a886533"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a516be7eeb210dc391738e9761a886533">POP_RANGE</a> ()</td></tr>
<tr class="separator:a516be7eeb210dc391738e9761a886533"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9597fa4e87eb201ef8bbe7e8b1c5dcab"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9597fa4e87eb201ef8bbe7e8b1c5dcab">is_dev_ptr</a> (const void *p)</td></tr>
<tr class="separator:a9597fa4e87eb201ef8bbe7e8b1c5dcab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a57fd5e0a140f0ee4ccef55173c038c97"><td align="right" class="memItemLeft" valign="top"><a class="el" href="cuml__api_8h.html#a8df780989bb7721c053f639cd9845911">cumlError_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a57fd5e0a140f0ee4ccef55173c038c97">knn_search</a> (const <a class="el" href="cuml__api_8h.html#a30e042c19d08153b33363b358c223156">cumlHandle_t</a> handle, float **input, int *sizes, int n_params, int D, float *search_items, int n, int64_t *res_I, float *res_D, int k, bool rowMajorIndex, bool rowMajorQuery, int metric_type, float metric_arg, bool expanded)</td></tr>
<tr class="memdesc:a57fd5e0a140f0ee4ccef55173c038c97"><td class="mdescLeft"> </td><td class="mdescRight">Flat C API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances.  <a href="namespaceML.html#a57fd5e0a140f0ee4ccef55173c038c97">More...</a><br/></td></tr>
<tr class="separator:a57fd5e0a140f0ee4ccef55173c038c97"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae9e9f22920ecd0dd7ab05981dd3a0cac"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae9e9f22920ecd0dd7ab05981dd3a0cac">get_device</a> (const void *ptr)</td></tr>
<tr class="separator:ae9e9f22920ecd0dd7ab05981dd3a0cac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ea5c03024c5683984f17d889421f40c"><td align="right" class="memItemLeft" valign="top">cudaMemoryType </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2ea5c03024c5683984f17d889421f40c">memory_type</a> (const void *p)</td></tr>
<tr class="separator:a2ea5c03024c5683984f17d889421f40c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a13b2600cf250418d851752f64d633860"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a13b2600cf250418d851752f64d633860">is_device_or_managed_type</a> (const void *p)</td></tr>
<tr class="separator:a13b2600cf250418d851752f64d633860"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7181e4d6d170b0aa91dc7a368abf3d1c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7181e4d6d170b0aa91dc7a368abf3d1c">handleMap</a></td></tr>
<tr class="memdesc:a7181e4d6d170b0aa91dc7a368abf3d1c"><td class="mdescLeft"> </td><td class="mdescRight">Static handle map instance (see <a class="el" href="cumlHandle_8cpp.html">cumlHandle.cpp</a>)  <a href="namespaceML.html#a7181e4d6d170b0aa91dc7a368abf3d1c">More...</a><br/></td></tr>
<tr class="separator:a7181e4d6d170b0aa91dc7a368abf3d1c"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4ac020f9f913af2af87de5e462b72aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac020f9f913af2af87de5e462b72aba">◆ </a></span>knn_indices_dense_t</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef int64_t <a class="el" href="namespaceML.html#a4ac020f9f913af2af87de5e462b72aba">ML::knn_indices_dense_t</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a59bd3f642cc2f46bedc2c7059cac837a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bd3f642cc2f46bedc2c7059cac837a">◆ </a></span>knn_indices_sparse_t</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef int <a class="el" href="namespaceML.html#a59bd3f642cc2f46bedc2c7059cac837a">ML::knn_indices_sparse_t</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a239d146c5a5545dd84e3d0b6e305f631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239d146c5a5545dd84e3d0b6e305f631">◆ </a></span>paramsPCA</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a> <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">ML::paramsPCA</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9ff6828291243eca3956818d2f309339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff6828291243eca3956818d2f309339">◆ </a></span>paramsPCAMG</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a>&lt;<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a>&gt; <a class="el" href="namespaceML.html#a9ff6828291243eca3956818d2f309339">ML::paramsPCAMG</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ab2bffedf6f8d520e216a6542ebf6a0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bffedf6f8d520e216a6542ebf6a0f1">◆ </a></span>paramsTSVD</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a> <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">ML::paramsTSVD</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae3b799705dfc8991beaf24c9a906bc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b799705dfc8991beaf24c9a906bc76">◆ </a></span>paramsTSVDMG</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a>&lt;<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a>&gt; <a class="el" href="namespaceML.html#ae3b799705dfc8991beaf24c9a906bc76">ML::paramsTSVDMG</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="acbf0352d6a255f990fcdf949b898d6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf0352d6a255f990fcdf949b898d6af">◆ </a></span>RandomForestClassifierD</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;double, int&gt; <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">ML::RandomForestClassifierD</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a36df48edc11fcd68dd8b6f4a76526e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36df48edc11fcd68dd8b6f4a76526e7b">◆ </a></span>RandomForestClassifierF</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;float, int&gt; <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">ML::RandomForestClassifierF</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a64f2117024176a6fab67a1a6b8925243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f2117024176a6fab67a1a6b8925243">◆ </a></span>RandomForestRegressorD</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;double, double&gt; <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">ML::RandomForestRegressorD</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a79048a796facf156e926834d97bec78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79048a796facf156e926834d97bec78f">◆ </a></span>RandomForestRegressorF</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;float, float&gt; <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">ML::RandomForestRegressorF</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a823912afaa51f58a997564eadb6d9405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823912afaa51f58a997564eadb6d9405">◆ </a></span>CRITERION</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">ML::CRITERION</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405af633f697107611ea3f0f2d18986be3e6"></a>GINI </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ab55a4e6aef097bd8f786f4ddfd1de161"></a>ENTROPY </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a746a9f45470e731c984d37744c48432e"></a>MSE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a71d3454116e1aace7f91b15f56567b1e"></a>MAE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ae346b778011ef4f488c1c87d64c1b174"></a>CRITERION_END </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a0dcbb2c0993e8446dffd09b5de731a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcbb2c0993e8446dffd09b5de731a26">◆ </a></span>LoglikeMethod</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">ML::LoglikeMethod</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0dcbb2c0993e8446dffd09b5de731a26a7c2ef7613d7b9a655691f9f24b893c11"></a>CSS </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab"></a>MLE </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a67da49ce109878bcdbb29a8777d28de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67da49ce109878bcdbb29a8777d28de1">◆ </a></span>loss_funct</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1">ML::loss_funct</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1ad3c28e4d0ab8ed2b4c69c0483c6ffea4"></a>SQRD_LOSS </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1a007e4d0f43a45d8d9be3dde194ea410a"></a>HINGE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1ad24128f8a7b16f59075a28323f13803d"></a>LOG </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a1adf3fea9cf9cde96ecf353b43818079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf3fea9cf9cde96ecf353b43818079">◆ </a></span>lr_type</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079">ML::lr_type</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a5ccc94f0f9ce653134966e2377c71ca1"></a>OPTIMAL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079aabfea584e2f24b9920a5fb3058dd06bb"></a>CONSTANT </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a98a91ed2cd2ff227d0393c406e09a106"></a>INVSCALING </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a8108470840df674d6403e12c0d2ac63a"></a>ADAPTIVE </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a9a3879adb63715cec17550171436f6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3879adb63715cec17550171436f6ab">◆ </a></span>mg_solver</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">ML::mg_solver</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba38769546eb5536bd58d5eb9922c3e0bf"></a>COV_EIG_DQ </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba3a077c1d31d8e7f29a92eb7ea002daad"></a>COV_EIG_JACOBI </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba66c35cd8077f7e1db5faefbc048a646a"></a>QR </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a1529da2b94c67018bb14f404f6e9aeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1529da2b94c67018bb14f404f6e9aeac">◆ </a></span>Norm</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeac">ML::Norm</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca6527e252610c64b85fdc9fc357c979cc"></a>L0 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072"></a>L1 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e"></a>L2 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca83820f75ef6d53c49873c4269fdcdc26"></a>LINF </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a85e691126b37f5e1dc834841cad1479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e691126b37f5e1dc834841cad1479c">◆ </a></span>OptimCriterion</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479c">ML::OptimCriterion</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca7a9fdcb8befd1162d7ba06c5bc34bd21"></a>OPTIM_BFGS_ITER_LIMIT </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca80e3d3c81590a148d565b7ddb78ef590"></a>OPTIM_MIN_PARAM_DIFF </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca01a4b4daad43785b0587346034b10ef5"></a>OPTIM_MIN_ERROR_DIFF </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca6c4ee736abd198cfc853b82b1e3a1fcc"></a>OPTIM_MIN_GRAD_NORM </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a899c5f26e201a81a2c12bb7eed9b015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899c5f26e201a81a2c12bb7eed9b015d">◆ </a></span>penalty</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015d">ML::penalty</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a899c5f26e201a81a2c12bb7eed9b015daf8cf4476d6fa69254aa96e2a9b385b07"></a>NONE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072"></a>L1 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e"></a>L2 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a899c5f26e201a81a2c12bb7eed9b015da80cad9123fc734ada9ef3a33ac30e627"></a>ELASTICNET </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="afe38bfbbab4fa672be59b329e7decc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe38bfbbab4fa672be59b329e7decc17">◆ </a></span>QuantizerType</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#afe38bfbbab4fa672be59b329e7decc17">ML::QuantizerType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe38bfbbab4fa672be59b329e7decc17a97bcbdde6eb10ef71ee9235841914f4e"></a>QT_8bit </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe38bfbbab4fa672be59b329e7decc17a4b5c06c77f4a98dd4703f6ecf6b83986"></a>QT_4bit </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe38bfbbab4fa672be59b329e7decc17a0f25f9e60fc642dbdf33656e874a54e6"></a>QT_8bit_uniform </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe38bfbbab4fa672be59b329e7decc17a5b917b193d8e9451805569f03de079ff"></a>QT_4bit_uniform </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe38bfbbab4fa672be59b329e7decc17a7edf2a9b1cfdfcf34648f65554cebac0"></a>QT_fp16 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe38bfbbab4fa672be59b329e7decc17a48ba4496ed0c91e343f456df462bb15a"></a>QT_8bit_direct </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe38bfbbab4fa672be59b329e7decc17a875dc6aaf10e3070fb3cdaf243f557e0"></a>QT_6bit </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a4d83b99fe769e2e9bf3596bb1604ab4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d83b99fe769e2e9bf3596bb1604ab4f">◆ </a></span>RF_type</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">ML::RF_type</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d83b99fe769e2e9bf3596bb1604ab4fa9d8edfe721557c504d925e3bcace2edf"></a>CLASSIFICATION </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d83b99fe769e2e9bf3596bb1604ab4fa2864cd9bbe2aa57118c71b9c717c3586"></a>REGRESSION </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a8d55de18185e36dd8f8a6d735e6a91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d55de18185e36dd8f8a6d735e6a91e6">◆ </a></span>SeasonalType</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6">ML::SeasonalType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d55de18185e36dd8f8a6d735e6a91e6af28ffe4c75342f4012bcf16f798e0ec3"></a>ADDITIVE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d55de18185e36dd8f8a6d735e6a91e6abc34c50dc7f29a357f52f9e5c0308226"></a>MULTIPLICATIVE </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a7324898185a2fc9a9145f9bad555049b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7324898185a2fc9a9145f9bad555049b">◆ </a></span>solver</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049b">ML::solver</a> : int</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">COV_EIG_DQ</td><td>covariance of input will be used along with eigen decomposition using divide and conquer method for symmetric matrices </td></tr>
<tr><td class="paramname">COV_EIG_JACOBI</td><td>covariance of input will be used along with eigen decomposition using jacobi method for symmetric matrices </td></tr>
</table>
</dd>
</dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7324898185a2fc9a9145f9bad555049ba38769546eb5536bd58d5eb9922c3e0bf"></a>COV_EIG_DQ </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7324898185a2fc9a9145f9bad555049ba3a077c1d31d8e7f29a92eb7ea002daad"></a>COV_EIG_JACOBI </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="afe9899e0c7ff1cf722a35bcf35283953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9899e0c7ff1cf722a35bcf35283953">◆ </a></span>SPLIT_ALGO</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953">ML::SPLIT_ALGO</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a5ce779f6c1df4e4ec40cd9cee88837e2"></a>HIST </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a61e77c561b3834cdc46508db24d72f90"></a>GLOBAL_QUANTILE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a5773eabe7d91f72e535b233ca73ba5c9"></a>SPLIT_ALGO_END </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="af60801cb5c9adac3f6f5bd4bd43aa2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60801cb5c9adac3f6f5bd4bd43aa2f7">◆ </a></span>task_category</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">ML::task_category</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af60801cb5c9adac3f6f5bd4bd43aa2f7a88b80439ca4076839158d63d31271315"></a>REGRESSION_MODEL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af60801cb5c9adac3f6f5bd4bd43aa2f7a9c8a19e179622826abd959f7639c7006"></a>CLASSIFICATION_MODEL </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afe64edbcd9d438d62eef462cddad346a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe64edbcd9d438d62eef462cddad346a">◆ </a></span>approx_knn_build_index()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::approx_knn_build_index </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1knnIndex.html">ML::knnIndex</a> * </td>
<td class="paramname"><em>index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1knnIndexParam.html">ML::knnIndexParam</a> * </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">raft::distance::DistanceType </td>
<td class="paramname"><em>metric</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>metricArg</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>index_array</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>D</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to build an approximate nearest neighbors index from an index array and a set of parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>index to be built </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>parametrization of the index to be built </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Euclidean (L2) is used by default </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metricArg</td><td>metric argument </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">index_array</td><td>the index array to build the index with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in the index array </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>the dimensionality of the index array </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a85840e42938d39c7ba89168601e2854a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85840e42938d39c7ba89168601e2854a">◆ </a></span>approx_knn_search()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::approx_knn_search </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>distances</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1knnIndex.html">ML::knnIndex</a> * </td>
<td class="paramname"><em>index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>query_array</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform an approximate nearest neighbors search from previously built index and a query array. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>distances of the nearest neighbors toward their query point </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>indices of the nearest neighbors </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index to perform a search with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the number of nearest neighbors to search for </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">query_array</td><td>the query to perform a search with </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in the query array </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aa0653c7b782547550d2d8df07038e28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0653c7b782547550d2d8df07038e28a">◆ </a></span>batched_diff()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_diff </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_y_diff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the differenced series (seasonal and/or non-seasonal differences)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_y_diff</td><td>Differenced series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Original series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a1b3ecb77a2af6ef294f2b05eca4037ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3ecb77a2af6ef294f2b05eca4037ee">◆ </a></span>batched_jones_transform()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_jones_transform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>isInv</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>h_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_Tparams</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Convenience function for batched "jones transform" used in ARIMA to ensure certain properties of the AR and MA parameters (takes host array and returns host array)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series analyzed. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">isInv</td><td>Do the inverse transform? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h_params</td><td>ARIMA parameters by batch (mu, ar, ma) (host) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">h_Tparams</td><td>Transformed ARIMA parameters (expects pre-allocated array of size (p+q)*batch_size) (host) </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a7b41fea6f2923aac90b27f01c5f9149e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b41fea6f2923aac90b27f01c5f9149e">◆ </a></span>batched_kalman_filter()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_kalman_filter </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_ys_b</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nobs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>level</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_upper</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>An ARIMA specialized batched kalman filter to evaluate ARMA parameters and provide the resulting prediction as well as loglikelihood fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_ys_b</td><td>Batched time series Shape (nobs, batch_size) (col-major, device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of samples per time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of series making up the batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_loglike</td><td>Resulting log-likelihood (per series) (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>Residual between the prediction and the original series. shape=(nobs-d-s*D, batch_size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ab751422ded5ed3ec53f5f138d8bdcca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab751422ded5ed3ec53f5f138d8bdcca4">◆ </a></span>batched_loglike() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_loglike </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> </td>
<td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>truncate</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>level</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_upper</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the loglikelihood of the given parameter on the given time series in a batched context.</p>
<dl class="section note"><dt>Note</dt><dd>: this overload should be used when the parameters are already unpacked to avoid useless packing / unpacking</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Log-Likelihood of the model per series </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>The residual between model and original signal. shape = (n_obs-d-s*D, batch_size) (device) Note: no output when using CSS estimation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a8d434323e4d805be8320a5d517bbd8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d434323e4d805be8320a5d517bbd8b9">◆ </a></span>batched_loglike() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_loglike </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> </td>
<td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>truncate</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>level</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_upper</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the loglikelihood of the given parameter on the given time series in a batched context.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_params</td><td>Parameters to evaluate grouped by series: [mu0, ar.., ma.., mu1, ..] (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Log-Likelihood of the model per series </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>The residual between model and original signal. shape = (n_obs-d-s*D, batch_size) (device) Note: no output when using CSS estimation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a38169d12d519a05e0e6c255efc45d004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38169d12d519a05e0e6c255efc45d004">◆ </a></span>batched_loglike_grad()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_loglike_grad </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_x</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>h</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> </td>
<td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>truncate</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the gradient of the log-likelihood</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_x</td><td>Parameters grouped by series </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_grad</td><td>Gradient to compute </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Finite-differencing step size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a5bcb25fe2fd014d74ea5afb5eae005d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcb25fe2fd014d74ea5afb5eae005d3">◆ </a></span>brute_force_knn()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::brute_force_knn </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>sizes</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>D</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>search_items</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>res_I</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>res_D</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>rowMajorIndex</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>rowMajorQuery</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">raft::distance::DistanceType </td>
<td class="paramname"><em>metric</em> = <code>raft::distance::DistanceType::L2Expanded</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>metric_arg</em> = <code>2.0f</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>vector of pointers to the input arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>vector of sizes of input arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>the dimensionality of the arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">search_items</td><td>array of items to search of dimensionality D </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in search_items </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">res_I</td><td>the resulting index array of size n * k </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">res_D</td><td>the resulting distance array of size n * k </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the number of nearest neighbors to return </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rowMajorIndex</td><td>are the index arrays in row-major order? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rowMajorQuery</td><td>are the query arrays in row-major order? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Euclidean (L2) is used by default </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric_arg</td><td>the value of <code>p</code> for Minkowski (l-p) distances. This is ignored if the metric_type is not Minkowski. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a27ed4fdb2f62155d0a1fd81f1405a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ed4fdb2f62155d0a1fd81f1405a779">◆ </a></span>build_division_map()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::build_division_map </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int *const * </td>
<td class="paramname"><em>hd_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>h_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_id_to_pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_id_to_model</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Build a map to associate each batch member with a model and index in the associated sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">hd_id</td><td>Host array of pointers to device arrays containing the indices of the members of each sub-batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h_size</td><td>Host array containing the size of each sub-batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_id_to_pos</td><td>Device array containing the position of each member in its new sub-batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_id_to_model</td><td>Device array associating each member with its sub-batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a684813418506a4839a61692008e4cfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684813418506a4839a61692008e4cfb9">◆ </a></span>build_treelite_forest()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::build_treelite_forest </td>
<td>(</td>
<td class="paramtype"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> * </td>
<td class="paramname"><em>model</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>task_category</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af142813513ee46988a79fd3dc4ab52a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142813513ee46988a79fd3dc4ab52a6">◆ </a></span>compare_concat_forest_to_subforests()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::compare_concat_forest_to_subforests </td>
<td>(</td>
<td class="paramtype"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> </td>
<td class="paramname"><em>concat_tree_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; </td>
<td class="paramname"><em>treelite_handles</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee">◆ </a></span>concatenate_trees()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> ML::concatenate_trees </td>
<td>(</td>
<td class="paramtype">std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; </td>
<td class="paramname"><em>treelite_handles</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9d769926cc27c80a2daa3779c606c133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d769926cc27c80a2daa3779c606c133">◆ </a></span>convert_level_to_spdlog()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int ML::convert_level_to_spdlog </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>level</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a47bd45d133f5b3bb3748a6e5d1c61c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bd45d133f5b3bb3748a6e5d1c61c91">◆ </a></span>delete_rf_metadata()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::delete_rf_metadata </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a7a236db2676ab7c1363895c81faa085a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a236db2676ab7c1363895c81faa085a">◆ </a></span>divide_by_mask_build_index()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int ML::divide_by_mask_build_index </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool * </td>
<td class="paramname"><em>d_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch division by mask step 1: build an index of the position of each series in its new batch and measure the size of each sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_mask</td><td>Boolean mask </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of 'true' series in the mask </dd></dl>
</div>
</div>
<a id="a8664a4caa2bb7efe45a4772fef29dc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8664a4caa2bb7efe45a4772fef29dc6a">◆ </a></span>divide_by_mask_execute() <span class="overload">[1/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_mask_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool * </td>
<td class="paramname"><em>d_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_out0</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_out1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac30d243b4af52a353b388781f6c80bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d243b4af52a353b388781f6c80bbd">◆ </a></span>divide_by_mask_execute() <span class="overload">[2/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_mask_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool * </td>
<td class="paramname"><em>d_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>d_out0</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>d_out1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch division by mask step 2: create both sub-batches from the mask and index</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input batch. Each series is a contiguous chunk </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_mask</td><td>Boolean mask </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_out0</td><td>The sub-batch for the 'false' members </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_out1</td><td>The sub-batch for the 'true' members </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of data points per series </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a77087155e5d034998297612c318b44c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77087155e5d034998297612c318b44c4">◆ </a></span>divide_by_mask_execute() <span class="overload">[3/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_mask_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool * </td>
<td class="paramname"><em>d_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_out0</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_out1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a1ec36247a6875e497c2258a27da253e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec36247a6875e497c2258a27da253e8">◆ </a></span>divide_by_min_build_index() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_build_index </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_matrix</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>h_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a96e538801438dbf2cb14b387bbfb5a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e538801438dbf2cb14b387bbfb5a66">◆ </a></span>divide_by_min_build_index() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_build_index </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>d_matrix</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>h_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch division by minimum value step 1: build an index of which sub-batch each series belongs to, an index of the position of each series in its new batch, and measure the size of each sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_matrix</td><td>Matrix of the values to minimize Shape: (batch_size, n_sub) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_batch</td><td>Which sub-batch each series belongs to </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">h_size</td><td>Size of each sub-batch (host) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a806f5807932256b6be674a37bd993dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806f5807932256b6be674a37bd993dd9">◆ </a></span>divide_by_min_execute() <span class="overload">[1/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double ** </td>
<td class="paramname"><em>hd_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2c70b44dbd2190b2b78f5b79b2374428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c70b44dbd2190b2b78f5b79b2374428">◆ </a></span>divide_by_min_execute() <span class="overload">[2/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float ** </td>
<td class="paramname"><em>hd_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch division by minimum value step 2: create all the sub-batches</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input batch. Each series is a contiguous chunk </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_batch</td><td>Which sub-batch each series belongs to </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_index</td><td>Index of each series in its new sub-batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hd_out</td><td>Host array of pointers to device arrays of each sub-batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of data points per series </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a266431bebb4a84c70458265ea26b393b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266431bebb4a84c70458265ea26b393b">◆ </a></span>divide_by_min_execute() <span class="overload">[3/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int ** </td>
<td class="paramname"><em>hd_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a492e6cc8eeb77f760b7abf1c5d37801b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492e6cc8eeb77f760b7abf1c5d37801b">◆ </a></span>estimate_x0()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::estimate_x0 </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Provide initial estimates to ARIMA parameters mu, AR, and MA</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a38cfdf38af3291baa8b4a5f3a33b74a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cfdf38af3291baa8b4a5f3a33b74a9">◆ </a></span>fit() <span class="overload">[1/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_unique_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2e62adbaee80935246fc0ff937575b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e62adbaee80935246fc0ff937575b59">◆ </a></span>fit() <span class="overload">[2/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_unique_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a4dfca11198fa7304d1568c6c7ff09469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfca11198fa7304d1568c6c7ff09469">◆ </a></span>fit() <span class="overload">[3/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a970c9a51cb7fb36680c2f2e3ad88dca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970c9a51cb7fb36680c2f2e3ad88dca4">◆ </a></span>fit() <span class="overload">[4/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae9e9f22920ecd0dd7ab05981dd3a0cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e9f22920ecd0dd7ab05981dd3a0cac">◆ </a></span>get_device()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int ML::get_device </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>ptr</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a8af17368b9e59dd87348191cb9129388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af17368b9e59dd87348191cb9129388">◆ </a></span>get_rf_detailed_text()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::string ML::get_rf_detailed_text </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a20b4def2d270c337188e8d3a27bd04df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b4def2d270c337188e8d3a27bd04df">◆ </a></span>get_rf_json()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::string ML::get_rf_json </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a365ba29d7ab5eef114015814d9d610ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365ba29d7ab5eef114015814d9d610ea">◆ </a></span>get_rf_summary_text()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::string ML::get_rf_summary_text </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a904aa5ac2206f2403f430ca7fd135f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904aa5ac2206f2403f430ca7fd135f4f">◆ </a></span>information_criterion()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::information_criterion </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>ic</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ic_type</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute an information criterion (AIC, AICc, BIC)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ic</td><td>Array where to write the information criteria Shape: (batch_size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ic_type</td><td>Type of information criterion wanted. 0: AIC, 1: AICc, 2: BIC </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a9597fa4e87eb201ef8bbe7e8b1c5dcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597fa4e87eb201ef8bbe7e8b1c5dcab">◆ </a></span>is_dev_ptr()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool ML::is_dev_ptr </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>p</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a13b2600cf250418d851752f64d633860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b2600cf250418d851752f64d633860">◆ </a></span>is_device_or_managed_type()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool ML::is_device_or_managed_type </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>p</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a8260b0b9f0efd7893d8b1c925c6839f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8260b0b9f0efd7893d8b1c925c6839f0">◆ </a></span>knn_class_proba()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_class_proba </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_index_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_query_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to compute knn class probabilities using a vector of device arrays containing discrete class labels. Note that the output is a vector, which is. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>vector of output arrays on device. vector size = n_outputs. Each array should have size(n_samples, n_classes) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>array on device of knn indices (size n_samples * k) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of labels on device (size n_samples) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of labels in y </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of rows in knn_indices and out </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a181e3084eb03bbcfdcde71c281141555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181e3084eb03bbcfdcde71c281141555">◆ </a></span>knn_classify()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_classify </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_index_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_query_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a knn classification using a given a vector of label arrays. This supports multilabel classification by classifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output array on device (size n_samples * size of y vector) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>index array on device resulting from knn query (size n_samples * k) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>vector of label arrays on device vector size is number of (size n_samples) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of vertices in index (eg. size of each y array) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of samples in knn_indices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a876ab255e2fc9f989d251f3ff57af5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876ab255e2fc9f989d251f3ff57af5d5">◆ </a></span>knn_regress()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_regress </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_index_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_query_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a knn regression using a given a vector of label arrays. This supports multilabel regression by clasifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output array on device (size n_samples) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>array on device of knn indices (size n_samples * k) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of labels on device (size n_samples) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of vertices in index (eg. size of each y array) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of samples in knn_indices and out </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a57fd5e0a140f0ee4ccef55173c038c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fd5e0a140f0ee4ccef55173c038c97">◆ </a></span>knn_search()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="cuml__api_8h.html#a8df780989bb7721c053f639cd9845911">cumlError_t</a> ML::knn_search </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="cuml__api_8h.html#a30e042c19d08153b33363b358c223156">cumlHandle_t</a> </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float ** </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>sizes</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>D</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>search_items</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>res_I</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>res_D</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>rowMajorIndex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>rowMajorQuery</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>metric_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>metric_arg</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>expanded</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>an array of pointers to the input arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>an array of sizes of input arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_params</td><td>array size of input and sizes </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>the dimensionality of the arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">search_items</td><td>array of items to search of dimensionality D </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in search_items </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">res_I</td><td>the resulting index array of size n * k </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">res_D</td><td>the resulting distance array of size n * k </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the number of nearest neighbors to return </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rowMajorIndex</td><td>is the index array in row major layout? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rowMajorQuery</td><td>is the query array in row major layout? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric_type</td><td>distance metric to use. Specify the metric using the integer value of the enum <code>ML::MetricType</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric_arg</td><td>the value of <code>p</code> for Minkowski (l-p) distances. This is ignored if the metric_type is not Minkowski. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">expanded</td><td>should lp-based distances be returned in their expanded form (e.g., without raising to the 1/p power). </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a2ea5c03024c5683984f17d889421f40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea5c03024c5683984f17d889421f40c">◆ </a></span>memory_type()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">cudaMemoryType ML::memory_type </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>p</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a03e79871ae0209450671f11bcd8965fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e79871ae0209450671f11bcd8965fe">◆ </a></span>merge_series() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::merge_series </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double *const * </td>
<td class="paramname"><em>hd_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_id_to_pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_id_to_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aeb8f25b52e0576997c85d1488367ab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8f25b52e0576997c85d1488367ab76">◆ </a></span>merge_series() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::merge_series </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float *const * </td>
<td class="paramname"><em>hd_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_id_to_pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_id_to_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>d_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Merge multiple sub-batches into one batch according to the maps that associate each id in the unique batch to a sub-batch and a position in this sub-batch.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">hd_in</td><td>Host array of pointers to device arrays containing the sub-batches </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_id_to_pos</td><td>Device array containing the position of each member in its new sub-batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_id_to_sub</td><td>Device array associating each member with its sub-batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output merged batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations (or forecasts) per series </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ab1275db1b0385b97fbb481b719322a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1275db1b0385b97fbb481b719322a25">◆ </a></span>null_trees_ptr()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::null_trees_ptr </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&amp; </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ad048e7644ca470414dc9c7fca5f2e189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad048e7644ca470414dc9c7fca5f2e189">◆ </a></span>pack()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pack </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>param_vec</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Pack separate parameter arrays into a compact array</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Parameter structure </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">param_vec</td><td>Compact parameter array </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a82ec70080c3ee46d4ff21b8222868c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ec70080c3ee46d4ff21b8222868c93">◆ </a></span>pcaFit() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFit </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a5382ae5b01e8079b6e550b13d087d4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5382ae5b01e8079b6e550b13d087d4fb">◆ </a></span>pcaFit() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFit </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aeb11c10b247ee28f7897bb28156320e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb11c10b247ee28f7897bb28156320e1">◆ </a></span>pcaFitTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFitTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ad8ca2904e5fd35b1a9b883c87e1c1274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ca2904e5fd35b1a9b883c87e1c1274">◆ </a></span>pcaFitTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFitTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af6dc66b3d7ba1d41b448d4317272fbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dc66b3d7ba1d41b448d4317272fbbc">◆ </a></span>pcaInverseTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaInverseTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ab49f1e8617076366a9be1fac04b8c92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49f1e8617076366a9be1fac04b8c92d">◆ </a></span>pcaInverseTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaInverseTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac37aa9b10bb7445d9b3523dae260e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37aa9b10bb7445d9b3523dae260e681">◆ </a></span>pcaTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9930aa036bcf52cf182f000ce355cdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9930aa036bcf52cf182f000ce355cdcd">◆ </a></span>pcaTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a516be7eeb210dc391738e9761a886533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516be7eeb210dc391738e9761a886533">◆ </a></span>POP_RANGE()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::POP_RANGE </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Pop the latest range </p>
</div>
</div>
<a id="a05ee22c0f2c66e9bb7d60c72e5d61b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ee22c0f2c66e9bb7d60c72e5d61b32">◆ </a></span>postprocess_labels()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::postprocess_labels </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::map&lt; int, int &gt; &amp; </td>
<td class="paramname"><em>labels_map</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a014e0b6e471acfa9829c62a05de49275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014e0b6e471acfa9829c62a05de49275">◆ </a></span>predict() <span class="overload">[1/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a0a63f42d57ee6287cedb49f48a6fa220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a63f42d57ee6287cedb49f48a6fa220">◆ </a></span>predict() <span class="overload">[2/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="afd7a72d075a98a0f8eeb197c81554348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7a72d075a98a0f8eeb197c81554348">◆ </a></span>predict() <span class="overload">[3/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae9ebff9eb10e9bcf8c9e2d9b6533259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ebff9eb10e9bcf8c9e2d9b6533259b">◆ </a></span>predict() <span class="overload">[4/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af1794d3b91c3c67dc5072a12910c48d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1794d3b91c3c67dc5072a12910c48d2">◆ </a></span>predict() <span class="overload">[5/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>start</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>end</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_y_p</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>pre_diff</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>level</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_upper</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batched in-sample and out-of-sample prediction of a time-series given all the model parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Batched Time series to predict. Shape: (num_samples, batch size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Index to start the prediction </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Index to end the prediction (excluded) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_y_p</td><td>Prediction output (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_diff</td><td>Whether to use pre-differencing </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a40a10f5bf0cce48a4ea54d7f33281081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a10f5bf0cce48a4ea54d7f33281081">◆ </a></span>predictGetAll() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predictGetAll </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a36a34da015328e0518fc6ceec5f22710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a34da015328e0518fc6ceec5f22710">◆ </a></span>predictGetAll() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predictGetAll </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa25bebb87dff8c328b2d4809f640f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25bebb87dff8c328b2d4809f640f789">◆ </a></span>preprocess_labels()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::preprocess_labels </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::map&lt; int, int &gt; &amp; </td>
<td class="paramname"><em>labels_map</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a390319c6e316ef242d477e8fa326f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390319c6e316ef242d477e8fa326f2d0">◆ </a></span>print() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::print </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td>
<td class="paramname"><em>rf_metrics</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa3ded9ffe5af3b52a2b8a301a362af10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ded9ffe5af3b52a2b8a301a362af10">◆ </a></span>print() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::print </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aacfa74158f3a2d08f6ddae02dbfb2992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfa74158f3a2d08f6ddae02dbfb2992">◆ </a></span>PUSH_RANGE()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::PUSH_RANGE </td>
<td>(</td>
<td class="paramtype">const char * </td>
<td class="paramname"><em>name</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Push a named nvtx range. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">name</td><td>range name </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aeff6bb49e843ea8d5135439648e633a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff6bb49e843ea8d5135439648e633a8">◆ </a></span>score() <span class="overload">[1/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae91cc5ebb6e5b37e754ada49a37c3f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91cc5ebb6e5b37e754ada49a37c3f2f">◆ </a></span>score() <span class="overload">[2/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa819cc3c995f572099b9b84e0897cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819cc3c995f572099b9b84e0897cd76">◆ </a></span>score() <span class="overload">[3/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a04e5fbd639ed8b2820ad3a1500d26732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e5fbd639ed8b2820ad3a1500d26732">◆ </a></span>score() <span class="overload">[4/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a5c7fcf2379a3d18e1c08840ff530eda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7fcf2379a3d18e1c08840ff530eda9">◆ </a></span>set_all_rf_metrics()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_all_rf_metrics </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> </td>
<td class="paramname"><em>rf_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>accuracy</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_abs_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_squared_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>median_abs_error</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a85f241652a9dfc89e280200e7618ed32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f241652a9dfc89e280200e7618ed32">◆ </a></span>set_rf_metrics_classification()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_rf_metrics_classification </td>
<td>(</td>
<td class="paramtype">float </td>
<td class="paramname"><em>accuracy</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aaa0b5eb27fbd28c93285b9ada72930d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0b5eb27fbd28c93285b9ada72930d8">◆ </a></span>set_rf_metrics_regression()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_rf_metrics_regression </td>
<td>(</td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_abs_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_squared_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>median_abs_error</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a5ac87bd832444ec058bfd447ae9f39a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac87bd832444ec058bfd447ae9f39a3">◆ </a></span>set_rf_params()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__params.html">RF_params</a> ML::set_rf_params </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_depth</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_leaves</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>max_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_bins</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>split_algo</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>min_samples_leaf</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>min_samples_split</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>min_impurity_decrease</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>bootstrap_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>bootstrap</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_trees</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>max_samples</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint64_t </td>
<td class="paramname"><em>seed</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> </td>
<td class="paramname"><em>split_criterion</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>quantile_per_tree</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_streams</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_experimental_backend</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_batch_size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a0262446094debc247669f955e6f13e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0262446094debc247669f955e6f13e5f">◆ </a></span>single_linkage_neighbors()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::single_linkage_neighbors </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>m</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">raft::hierarchy::linkage_output&lt; int, float &gt; * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">raft::distance::DistanceType </td>
<td class="paramname"><em>metric</em> = <code>raft::distance::DistanceType::L2Unexpanded</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>c</em> = <code>15</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_clusters</em> = <code>5</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes single-linkage hierarchical clustering on a dense input feature matrix and outputs the labels, dendrogram, and minimum spanning tree. Connectivities are constructed using a k-nearest neighbors graph. While this strategy enables the algorithm to scale to much higher numbers of rows, it comes with the downside that additional knn steps may need to be executed to connect an otherwise unconnected k-nn graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>raft handle to encapsulate expensive resources </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>dense feature matrix on device </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows in X </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns in X </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Must be supported by the dense pairwise distances API. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>container object for output arrays </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>the optimal value of k is guaranteed to be at least log(n) + c where c is some constant. This constant can usually be set to a fairly low value, like 15, and still maintain good performance. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">n_clusters</td><td>number of clusters to cut from resulting dendrogram </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a2e906b2839782feeb92f9f8d6b72bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e906b2839782feeb92f9f8d6b72bcad">◆ </a></span>single_linkage_pairwise() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::single_linkage_pairwise </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>m</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">raft::hierarchy::linkage_output&lt; int, float &gt; * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">raft::distance::DistanceType </td>
<td class="paramname"><em>metric</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_clusters</em> = <code>5</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes single-linkage hierarchical clustering on a dense input feature matrix and outputs the labels, dendrogram, and minimum spanning tree. Connectivities are constructed using the full n^2 pairwise distance matrix. This can be very fast for smaller datasets when there is enough memory available. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>raft handle to encapsulate expensive resources </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>dense feature matrix on device </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows in X </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns in X </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Must be supported by the dense pairwise distances API. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>container object for output arrays </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">n_clusters</td><td>number of clusters to cut from resulting dendrogram </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ab6638b428d61f67a7054b60c37ca3172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6638b428d61f67a7054b60c37ca3172">◆ </a></span>single_linkage_pairwise() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::single_linkage_pairwise </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>m</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">raft::hierarchy::linkage_output&lt; int64_t, float &gt; * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">raft::distance::DistanceType </td>
<td class="paramname"><em>metric</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_clusters</em> = <code>5</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af0f446810d4972e9bee95fca756cb958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f446810d4972e9bee95fca756cb958">◆ </a></span>thrust_exec_policy()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">auto ML::thrust_exec_policy </td>
<td>(</td>
<td class="paramtype">std::shared_ptr&lt; <a class="el" href="quantile_8h.html#a835ee0b83c8b4efdaef43c9d85819800">deviceAllocator</a> &gt; </td>
<td class="paramname"><em>allocator</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">cudaStream_t </td>
<td class="paramname"><em>stream</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> -&gt; std::unique_ptr&lt;
    decltype(thrust::cuda::par(_decltypeHelper)),
    std::function&lt;void(decltype(thrust::cuda::par(_decltypeHelper))*)&gt;&gt; </td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a unique_ptr to a Thrust CUDA execution policy that uses the passed in allocator for temporary memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>The allocator to use </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream that the allocator will use</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Thrust execution policy that will use allocator for temporary memory allocation. </dd></dl>
</div>
</div>
<a id="a9a44417adde26e5936aa7e05c2b8fb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a44417adde26e5936aa7e05c2b8fb12">◆ </a></span>TSNE_fit()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::TSNE_fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>Y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>p</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>knn_dists</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>dim</em> = <code>2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_neighbors</em> = <code>1023</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>theta</em> = <code>0.5f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>epssq</em> = <code>0.0025</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>perplexity</em> = <code>50.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>perplexity_max_iter</em> = <code>100</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>perplexity_tol</em> = <code>1e-5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>early_exaggeration</em> = <code>12.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>exaggeration_iter</em> = <code>250</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>min_gain</em> = <code>0.01f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>pre_learning_rate</em> = <code>200.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>post_learning_rate</em> = <code>500.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>max_iter</em> = <code>1000</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>min_grad_norm</em> = <code>1e-7</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>pre_momentum</em> = <code>0.5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>post_momentum</em> = <code>0.8</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const long long </td>
<td class="paramname"><em>random_state</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool </td>
<td class="paramname"><em>initialize_embeddings</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>barnes_hut</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2). </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The GPU handle. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>The dataset you want to apply TSNE on. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The final embedding. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows in data X. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Number of columns in data X. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>Array containing nearest neighors indices. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_dists</td><td>Array containing nearest neighors distances. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of output dimensions for embeddings Y. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_neighbors</td><td>Number of nearest neighbors used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>Float between 0 and 1. Tradeoff for speed (0) vs accuracy (1) for Barnes Hut only. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">epssq</td><td>A tiny jitter to promote numerical stability. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity</td><td>How many nearest neighbors are used during construction of Pij. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity_max_iter</td><td>Number of iterations used to construct Pij. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity_tol</td><td>The small tolerance used for Pij to ensure numerical stability. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">early_exaggeration</td><td>How much early pressure you want the clusters in TSNE to spread out more. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">exaggeration_iter</td><td>How many iterations you want the early pressure to run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_gain</td><td>Rounds up small gradient updates. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_learning_rate</td><td>The learning rate during exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">post_learning_rate</td><td>The learning rate after exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations TSNE should run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_grad_norm</td><td>The smallest gradient norm TSNE should terminate on. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_momentum</td><td>The momentum used during the exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">post_momentum</td><td>The momentum used after the exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">random_state</td><td>Set this to -1 for pure random intializations or &gt;= 0 for reproducible outputs. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>verbosity level for logging messages during execution </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">initialize_embeddings</td><td>Whether to overwrite the current Y vector with random noise. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut</td><td>Whether to use the fast Barnes Hut or use the slower exact version.</td></tr>
</table>
</dd>
</dl>
<p>The CUDA implementation is derived from the excellent CannyLabs open source implementation here: <a href="https://github.com/CannyLab/tsne-cuda/">https://github.com/CannyLab/tsne-cuda/</a>. The CannyLabs code is licensed according to the conditions in cuml/cpp/src/tsne/cannylabs_tsne_license.txt. A full description of their approach is available in their article t-SNE-CUDA: GPU-Accelerated t-SNE and its Applications to Modern Data (<a href="https://arxiv.org/abs/1807.11824">https://arxiv.org/abs/1807.11824</a>). </p>
</div>
</div>
<a id="a11b7b6bfe4fcd83c5cb1d0ebd995227d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b7b6bfe4fcd83c5cb1d0ebd995227d">◆ </a></span>TSNE_fit_sparse()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::TSNE_fit_sparse </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>indptr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>Y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nnz</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>p</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>knn_dists</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>dim</em> = <code>2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_neighbors</em> = <code>1023</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>theta</em> = <code>0.5f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>epssq</em> = <code>0.0025</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>perplexity</em> = <code>50.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>perplexity_max_iter</em> = <code>100</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>perplexity_tol</em> = <code>1e-5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>early_exaggeration</em> = <code>12.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>exaggeration_iter</em> = <code>250</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>min_gain</em> = <code>0.01f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>pre_learning_rate</em> = <code>200.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>post_learning_rate</em> = <code>500.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>max_iter</em> = <code>1000</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>min_grad_norm</em> = <code>1e-7</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>pre_momentum</em> = <code>0.5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>post_momentum</em> = <code>0.8</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const long long </td>
<td class="paramname"><em>random_state</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool </td>
<td class="paramname"><em>initialize_embeddings</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>barnes_hut</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2). </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The GPU handle. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indptr</td><td>indptr of CSR dataset. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>indices of CSR dataset. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data of CSR dataset. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The final embedding. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nnz</td><td>The number of non-zero entries in the CSR. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows in data X. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Number of columns in data X. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>Array containing nearest neighors indices. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_dists</td><td>Array containing nearest neighors distances. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of output dimensions for embeddings Y. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_neighbors</td><td>Number of nearest neighbors used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>Float between 0 and 1. Tradeoff for speed (0) vs accuracy (1) for Barnes Hut only. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">epssq</td><td>A tiny jitter to promote numerical stability. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity</td><td>How many nearest neighbors are used during construction of Pij. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity_max_iter</td><td>Number of iterations used to construct Pij. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity_tol</td><td>The small tolerance used for Pij to ensure numerical stability. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">early_exaggeration</td><td>How much early pressure you want the clusters in TSNE to spread out more. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">exaggeration_iter</td><td>How many iterations you want the early pressure to run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_gain</td><td>Rounds up small gradient updates. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_learning_rate</td><td>The learning rate during exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">post_learning_rate</td><td>The learning rate after exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations TSNE should run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_grad_norm</td><td>The smallest gradient norm TSNE should terminate on. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_momentum</td><td>The momentum used during the exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">post_momentum</td><td>The momentum used after the exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">random_state</td><td>Set this to -1 for pure random intializations or &gt;= 0 for reproducible outputs. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>verbosity level for logging messages during execution </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">initialize_embeddings</td><td>Whether to overwrite the current Y vector with random noise. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut</td><td>Whether to use the fast Barnes Hut or use the slower exact version.</td></tr>
</table>
</dd>
</dl>
<p>The CUDA implementation is derived from the excellent CannyLabs open source implementation here: <a href="https://github.com/CannyLab/tsne-cuda/">https://github.com/CannyLab/tsne-cuda/</a>. The CannyLabs code is licensed according to the conditions in cuml/cpp/src/tsne/cannylabs_tsne_license.txt. A full description of their approach is available in their article t-SNE-CUDA: GPU-Accelerated t-SNE and its Applications to Modern Data (<a href="https://arxiv.org/abs/1807.11824">https://arxiv.org/abs/1807.11824</a>). </p>
</div>
</div>
<a id="add33f23b1a15823449837dc884b13ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add33f23b1a15823449837dc884b13ddd">◆ </a></span>tsvdFit() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFit </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2a071bdcbc710b1a4ca88efc02fd2489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a071bdcbc710b1a4ca88efc02fd2489">◆ </a></span>tsvdFit() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFit </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae1a46cc3b471efc453be9e8fbecba363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a46cc3b471efc453be9e8fbecba363">◆ </a></span>tsvdFitTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="afba20c39f0790075843e9236fd043ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba20c39f0790075843e9236fd043ca1">◆ </a></span>tsvdFitTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae2faa9e0c83e9270369e866281802624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2faa9e0c83e9270369e866281802624">◆ </a></span>tsvdInverseTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdInverseTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac335d131520793dcf0831d753e1c7ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac335d131520793dcf0831d753e1c7ab2">◆ </a></span>tsvdInverseTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdInverseTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a83f6113e72b200d0a4bef2759285a6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f6113e72b200d0a4bef2759285a6ca">◆ </a></span>tsvdTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a1a8f7fa23231a10eb02ea2a3d4923335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8f7fa23231a10eb02ea2a3d4923335">◆ </a></span>tsvdTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a62e41ec81cdf10cea7be42c97eca6b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e41ec81cdf10cea7be42c97eca6b32">◆ </a></span>unpack()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::unpack </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>param_vec</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Unpack a compact array into separate parameter arrays</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">params</td><td>Parameter structure </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">param_vec</td><td>Compact parameter array </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a69f0169515a838c25ba3080b48ae2ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0169515a838c25ba3080b48ae2ceb">◆ </a></span>validity_check()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::validity_check </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7181e4d6d170b0aa91dc7a368abf3d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7181e4d6d170b0aa91dc7a368abf3d1c">◆ </a></span>handleMap</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a> ML::handleMap</td>
</tr>
</table>
</div><div class="memdoc">
<p>Static handle map instance (see <a class="el" href="cumlHandle_8cpp.html">cumlHandle.cpp</a>) </p>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"/></a> 1.8.20
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
