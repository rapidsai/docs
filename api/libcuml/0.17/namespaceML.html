<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.20" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>cuML C++ API: ML Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcuml</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (0.17)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcuml/nightly">nightly (0.19)</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">stable (0.18)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuml/legacy">legacy (0.17)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> |
<a href="#var-members">Variables</a> </div>
<div class="headertitle">
<div class="title">ML Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceML_1_1CD"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1CD.html">CD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Datasets"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Datasets.html">Datasets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1DecisionTree"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1DecisionTree.html">DecisionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1detail"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Distance"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Distance.html">Distance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Explainer"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Explainer.html">Explainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1fil"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1fil.html">fil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1GLM"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1GLM.html">GLM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1HoltWinters"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1HoltWinters.html">HoltWinters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Internals"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Internals.html">Internals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1kmeans"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1kmeans.html">kmeans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1KNN"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1KNN.html">KNN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Metrics"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Metrics.html">Metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1OLS"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1OLS.html">OLS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1PCA"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1PCA.html">PCA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Ridge"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Ridge.html">Ridge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Solver"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Solver.html">Solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Sparse"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Sparse.html">Sparse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Spectral"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Spectral.html">Spectral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Stationarity"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Stationarity.html">Stationarity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1SVM"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1SVM.html">SVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1TSVD"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1TSVD.html">TSVD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1UMAP"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1UMAP.html">UMAP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1cachingDeviceAllocator.html">cachingDeviceAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Implemententation of ML::deviceAllocator using the cub's caching allocator API.  <a href="classML_1_1cachingDeviceAllocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1knn__graph.html">knn_graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The main Logging class for cuML library.  <a href="classML_1_1Logger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__dense__inputs__t.html">manifold_dense_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__inputs__t.html">manifold_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__precomputed__knn__inputs__t.html">manifold_precomputed_knn_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__sparse__inputs__t.html">manifold_sparse_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1OptimParams.html">OptimParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1params.html">params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">structure for pca parameters. Ref: <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html</a> <a href="classML_1_1paramsPCATemplate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsSolver.html">paramsSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1PatternSetter.html">PatternSetter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">RAII based pattern setter for <a class="el" href="classML_1_1Logger.html" title="The main Logging class for cuML library.">Logger</a> class.  <a href="classML_1_1PatternSetter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1rand__mat.html">rand_mat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rf.html">rf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RF__params.html">RF_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rfClassifier.html">rfClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rfRegressor.html">rfRegressor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1stdAllocatorAdapter.html">stdAllocatorAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1Tensor.html">Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1thrustAllocatorAdapter.html">thrustAllocatorAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab2bffedf6f8d520e216a6542ebf6a0f1"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a></td></tr>
<tr class="separator:ab2bffedf6f8d520e216a6542ebf6a0f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a239d146c5a5545dd84e3d0b6e305f631"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a></td></tr>
<tr class="separator:a239d146c5a5545dd84e3d0b6e305f631"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae3b799705dfc8991beaf24c9a906bc76"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a>&lt; <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae3b799705dfc8991beaf24c9a906bc76">paramsTSVDMG</a></td></tr>
<tr class="separator:ae3b799705dfc8991beaf24c9a906bc76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9ff6828291243eca3956818d2f309339"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a>&lt; <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9ff6828291243eca3956818d2f309339">paramsPCAMG</a></td></tr>
<tr class="separator:a9ff6828291243eca3956818d2f309339"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36df48edc11fcd68dd8b6f4a76526e7b"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; float, int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a></td></tr>
<tr class="separator:a36df48edc11fcd68dd8b6f4a76526e7b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acbf0352d6a255f990fcdf949b898d6af"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; double, int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a></td></tr>
<tr class="separator:acbf0352d6a255f990fcdf949b898d6af"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a79048a796facf156e926834d97bec78f"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; float, float &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a></td></tr>
<tr class="separator:a79048a796facf156e926834d97bec78f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64f2117024176a6fab67a1a6b8925243"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; double, double &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a></td></tr>
<tr class="separator:a64f2117024176a6fab67a1a6b8925243"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ac020f9f913af2af87de5e462b72aba"><td align="right" class="memItemLeft" valign="top">typedef int64_t </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4ac020f9f913af2af87de5e462b72aba">knn_indices_dense_t</a></td></tr>
<tr class="separator:a4ac020f9f913af2af87de5e462b72aba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a59bd3f642cc2f46bedc2c7059cac837a"><td align="right" class="memItemLeft" valign="top">typedef int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a59bd3f642cc2f46bedc2c7059cac837a">knn_indices_sparse_t</a></td></tr>
<tr class="separator:a59bd3f642cc2f46bedc2c7059cac837a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7324898185a2fc9a9145f9bad555049b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049b">solver</a> : int { <a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049ba38769546eb5536bd58d5eb9922c3e0bf">solver::COV_EIG_DQ</a>, 
<a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049ba3a077c1d31d8e7f29a92eb7ea002daad">solver::COV_EIG_JACOBI</a>
 }</td></tr>
<tr class="separator:a7324898185a2fc9a9145f9bad555049b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a3879adb63715cec17550171436f6ab"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> { <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba38769546eb5536bd58d5eb9922c3e0bf">mg_solver::COV_EIG_DQ</a>, 
<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba3a077c1d31d8e7f29a92eb7ea002daad">mg_solver::COV_EIG_JACOBI</a>, 
<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba66c35cd8077f7e1db5faefbc048a646a">mg_solver::QR</a>
 }</td></tr>
<tr class="separator:a9a3879adb63715cec17550171436f6ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d83b99fe769e2e9bf3596bb1604ab4f"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> { <a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4fa9d8edfe721557c504d925e3bcace2edf">CLASSIFICATION</a>, 
<a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4fa2864cd9bbe2aa57118c71b9c717c3586">REGRESSION</a>
 }</td></tr>
<tr class="separator:a4d83b99fe769e2e9bf3596bb1604ab4f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af60801cb5c9adac3f6f5bd4bd43aa2f7"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">task_category</a> { <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7a88b80439ca4076839158d63d31271315">REGRESSION_MODEL</a> = 1, 
<a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7a9c8a19e179622826abd959f7639c7006">CLASSIFICATION_MODEL</a> = 2
 }</td></tr>
<tr class="separator:af60801cb5c9adac3f6f5bd4bd43aa2f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d9fd2e8fe0cfbbd81877eee212b88d9"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9">MetricType</a> { <br/>
  <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9a138628cbf0d89bc28f2dd159f426c13d">METRIC_INNER_PRODUCT</a> = 0, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9a5e87bd6f2a6c86ad23937eedf66de99b">METRIC_L2</a>, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9a6d9ec7c577a546e75c72ee872241ef4e">METRIC_L1</a>, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9aa01f9bc4910d9f004046489a11dc815e">METRIC_Linf</a>, 
<br/>
  <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ab136e195c4dd9de8a55edaa0830ddf2f">METRIC_Lp</a>, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ae507c1b9eb779a39b742fa8e3e22cd0e">METRIC_Canberra</a> = 20, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9a2124363d5cceb96ec8c9d87e0e9ece05">METRIC_BrayCurtis</a>, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ad4265672a802bf53d58db72de56ddd22">METRIC_JensenShannon</a>, 
<br/>
  <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ae401fdab977404f1b08e85985f7b4bf8">METRIC_Cosine</a> = 100, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ad4bc32758f26d167d264e7574429b024">METRIC_Correlation</a>
<br/>
 }</td></tr>
<tr class="separator:a4d9fd2e8fe0cfbbd81877eee212b88d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga134c8dc1d94a4ee420679aec61849e2b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga134c8dc1d94a4ee420679aec61849e2b">random_matrix_type</a> { <a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2baa7bee409e76fac7544d660db7e2eb7c0">unset</a>, 
<a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2bad1e6d312a4b10fe213eac82ffb1cdd72">dense</a>, 
<a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2baca3f848ed01f4ea23129374f48c98293">sparse</a>
 }</td></tr>
<tr class="separator:ga134c8dc1d94a4ee420679aec61849e2b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1adf3fea9cf9cde96ecf353b43818079"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079">lr_type</a> { <a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a5ccc94f0f9ce653134966e2377c71ca1">OPTIMAL</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079aabfea584e2f24b9920a5fb3058dd06bb">CONSTANT</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a98a91ed2cd2ff227d0393c406e09a106">INVSCALING</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a8108470840df674d6403e12c0d2ac63a">ADAPTIVE</a>
 }</td></tr>
<tr class="separator:a1adf3fea9cf9cde96ecf353b43818079"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67da49ce109878bcdbb29a8777d28de1"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1">loss_funct</a> { <a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1ad3c28e4d0ab8ed2b4c69c0483c6ffea4">SQRD_LOSS</a>, 
<a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1a007e4d0f43a45d8d9be3dde194ea410a">HINGE</a>, 
<a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1ad24128f8a7b16f59075a28323f13803d">LOG</a>
 }</td></tr>
<tr class="separator:a67da49ce109878bcdbb29a8777d28de1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a899c5f26e201a81a2c12bb7eed9b015d"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015d">penalty</a> { <a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015daf8cf4476d6fa69254aa96e2a9b385b07">NONE</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072">L1</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e">L2</a>, 
<a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015da80cad9123fc734ada9ef3a33ac30e627">ELASTICNET</a>
 }</td></tr>
<tr class="separator:a899c5f26e201a81a2c12bb7eed9b015d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe9899e0c7ff1cf722a35bcf35283953"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953">SPLIT_ALGO</a> { <a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a5ce779f6c1df4e4ec40cd9cee88837e2">HIST</a>, 
<a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a61e77c561b3834cdc46508db24d72f90">GLOBAL_QUANTILE</a>, 
<a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a5773eabe7d91f72e535b233ca73ba5c9">SPLIT_ALGO_END</a>
 }</td></tr>
<tr class="separator:afe9899e0c7ff1cf722a35bcf35283953"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a823912afaa51f58a997564eadb6d9405"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> { <br/>
  <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405af633f697107611ea3f0f2d18986be3e6">GINI</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ab55a4e6aef097bd8f786f4ddfd1de161">ENTROPY</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a746a9f45470e731c984d37744c48432e">MSE</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a71d3454116e1aace7f91b15f56567b1e">MAE</a>, 
<br/>
  <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ae346b778011ef4f488c1c87d64c1b174">CRITERION_END</a>
<br/>
 }</td></tr>
<tr class="separator:a823912afaa51f58a997564eadb6d9405"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0dcbb2c0993e8446dffd09b5de731a26"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> { <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a7c2ef7613d7b9a655691f9f24b893c11">CSS</a>, 
<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>
 }</td></tr>
<tr class="separator:a0dcbb2c0993e8446dffd09b5de731a26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8d55de18185e36dd8f8a6d735e6a91e6"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6">SeasonalType</a> { <a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6af28ffe4c75342f4012bcf16f798e0ec3">ADDITIVE</a>, 
<a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6abc34c50dc7f29a357f52f9e5c0308226">MULTIPLICATIVE</a>
 }</td></tr>
<tr class="separator:a8d55de18185e36dd8f8a6d735e6a91e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85e691126b37f5e1dc834841cad1479c"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479c">OptimCriterion</a> { <a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca7a9fdcb8befd1162d7ba06c5bc34bd21">OPTIM_BFGS_ITER_LIMIT</a> = 0, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca80e3d3c81590a148d565b7ddb78ef590">OPTIM_MIN_PARAM_DIFF</a> = 1, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca01a4b4daad43785b0587346034b10ef5">OPTIM_MIN_ERROR_DIFF</a> = 2, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca6c4ee736abd198cfc853b82b1e3a1fcc">OPTIM_MIN_GRAD_NORM</a> = 3
 }</td></tr>
<tr class="separator:a85e691126b37f5e1dc834841cad1479c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1529da2b94c67018bb14f404f6e9aeac"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeac">Norm</a> { <a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca6527e252610c64b85fdc9fc357c979cc">L0</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072">L1</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e">L2</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca83820f75ef6d53c49873c4269fdcdc26">LINF</a>
 }</td></tr>
<tr class="separator:a1529da2b94c67018bb14f404f6e9aeac"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0473dcd69ffd2195c148d8cac87eba5f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__DbscanCpp.html#ga0473dcd69ffd2195c148d8cac87eba5f">dbscanFit</a> (const raft::handle_t &amp;handle, float *input, int n_rows, int n_cols, float eps, int min_pts, int *labels, int *core_sample_indices=nullptr, size_t max_bytes_per_batch=0, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ga0473dcd69ffd2195c148d8cac87eba5f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga611b7252f2bcb40a0093bcb3b3ce8cee"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__DbscanCpp.html#ga611b7252f2bcb40a0093bcb3b3ce8cee">dbscanFit</a> (const raft::handle_t &amp;handle, double *input, int n_rows, int n_cols, double eps, int min_pts, int *labels, int *core_sample_indices=nullptr, size_t max_bytes_per_batch=0, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ga611b7252f2bcb40a0093bcb3b3ce8cee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5cb90c6e243fbf688ee0a9f8dd0e3553"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__DbscanCpp.html#ga5cb90c6e243fbf688ee0a9f8dd0e3553">dbscanFit</a> (const raft::handle_t &amp;handle, float *input, int64_t n_rows, int64_t n_cols, float eps, int min_pts, int64_t *labels, int64_t *core_sample_indices=nullptr, size_t max_bytes_per_batch=0, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ga5cb90c6e243fbf688ee0a9f8dd0e3553"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab6ee5239b93e5ce66dd88fbc0edd259d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__DbscanCpp.html#gab6ee5239b93e5ce66dd88fbc0edd259d">dbscanFit</a> (const raft::handle_t &amp;handle, double *input, int64_t n_rows, int64_t n_cols, double eps, int min_pts, int64_t *labels, int64_t *core_sample_indices=nullptr, size_t max_bytes_per_batch=0, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:gab6ee5239b93e5ce66dd88fbc0edd259d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabb9694969393f0288a606c9184435ef9"><td align="right" class="memItemLeft" valign="top">std::string </td><td class="memItemRight" valign="bottom"><a class="el" href="group__CStringFormat.html#gabb9694969393f0288a606c9184435ef9">format</a> (const char *fmt, va_list &amp;vl)</td></tr>
<tr class="separator:gabb9694969393f0288a606c9184435ef9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad55df9da3c66646eee88f92620cef30a"><td align="right" class="memItemLeft" valign="top">std::string </td><td class="memItemRight" valign="bottom"><a class="el" href="group__CStringFormat.html#gad55df9da3c66646eee88f92620cef30a">format</a> (const char *fmt,...)</td></tr>
<tr class="separator:gad55df9da3c66646eee88f92620cef30a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5382ae5b01e8079b6e550b13d087d4fb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5382ae5b01e8079b6e550b13d087d4fb">pcaFit</a> (raft::handle_t &amp;handle, float *input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, float *mu, float *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a5382ae5b01e8079b6e550b13d087d4fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a82ec70080c3ee46d4ff21b8222868c93"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a82ec70080c3ee46d4ff21b8222868c93">pcaFit</a> (raft::handle_t &amp;handle, double *input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, double *mu, double *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a82ec70080c3ee46d4ff21b8222868c93"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8ca2904e5fd35b1a9b883c87e1c1274"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad8ca2904e5fd35b1a9b883c87e1c1274">pcaFitTransform</a> (raft::handle_t &amp;handle, float *input, float *trans_input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, float *mu, float *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ad8ca2904e5fd35b1a9b883c87e1c1274"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb11c10b247ee28f7897bb28156320e1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeb11c10b247ee28f7897bb28156320e1">pcaFitTransform</a> (raft::handle_t &amp;handle, double *input, double *trans_input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, double *mu, double *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:aeb11c10b247ee28f7897bb28156320e1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab49f1e8617076366a9be1fac04b8c92d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab49f1e8617076366a9be1fac04b8c92d">pcaInverseTransform</a> (raft::handle_t &amp;handle, float *trans_input, float *components, float *singular_vals, float *mu, float *input, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ab49f1e8617076366a9be1fac04b8c92d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6dc66b3d7ba1d41b448d4317272fbbc"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af6dc66b3d7ba1d41b448d4317272fbbc">pcaInverseTransform</a> (raft::handle_t &amp;handle, double *trans_input, double *components, double *singular_vals, double *mu, double *input, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:af6dc66b3d7ba1d41b448d4317272fbbc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9930aa036bcf52cf182f000ce355cdcd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9930aa036bcf52cf182f000ce355cdcd">pcaTransform</a> (raft::handle_t &amp;handle, float *input, float *components, float *trans_input, float *singular_vals, float *mu, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a9930aa036bcf52cf182f000ce355cdcd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac37aa9b10bb7445d9b3523dae260e681"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac37aa9b10bb7445d9b3523dae260e681">pcaTransform</a> (raft::handle_t &amp;handle, double *input, double *components, double *trans_input, double *singular_vals, double *mu, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ac37aa9b10bb7445d9b3523dae260e681"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2a071bdcbc710b1a4ca88efc02fd2489"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2a071bdcbc710b1a4ca88efc02fd2489">tsvdFit</a> (raft::handle_t &amp;handle, float *input, float *components, float *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a2a071bdcbc710b1a4ca88efc02fd2489"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:add33f23b1a15823449837dc884b13ddd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#add33f23b1a15823449837dc884b13ddd">tsvdFit</a> (raft::handle_t &amp;handle, double *input, double *components, double *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:add33f23b1a15823449837dc884b13ddd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac335d131520793dcf0831d753e1c7ab2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac335d131520793dcf0831d753e1c7ab2">tsvdInverseTransform</a> (raft::handle_t &amp;handle, float *trans_input, float *components, float *input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ac335d131520793dcf0831d753e1c7ab2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae2faa9e0c83e9270369e866281802624"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae2faa9e0c83e9270369e866281802624">tsvdInverseTransform</a> (raft::handle_t &amp;handle, double *trans_input, double *components, double *input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ae2faa9e0c83e9270369e866281802624"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1a8f7fa23231a10eb02ea2a3d4923335"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1a8f7fa23231a10eb02ea2a3d4923335">tsvdTransform</a> (raft::handle_t &amp;handle, float *input, float *components, float *trans_input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a1a8f7fa23231a10eb02ea2a3d4923335"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83f6113e72b200d0a4bef2759285a6ca"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a83f6113e72b200d0a4bef2759285a6ca">tsvdTransform</a> (raft::handle_t &amp;handle, double *input, double *components, double *trans_input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a83f6113e72b200d0a4bef2759285a6ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afba20c39f0790075843e9236fd043ca1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afba20c39f0790075843e9236fd043ca1">tsvdFitTransform</a> (raft::handle_t &amp;handle, float *input, float *trans_input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:afba20c39f0790075843e9236fd043ca1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae1a46cc3b471efc453be9e8fbecba363"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae1a46cc3b471efc453be9e8fbecba363">tsvdFitTransform</a> (raft::handle_t &amp;handle, double *input, double *trans_input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ae1a46cc3b471efc453be9e8fbecba363"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c7fcf2379a3d18e1c08840ff530eda9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5c7fcf2379a3d18e1c08840ff530eda9">set_all_rf_metrics</a> (<a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> rf_type, float accuracy, double mean_abs_error, double mean_squared_error, double median_abs_error)</td></tr>
<tr class="separator:a5c7fcf2379a3d18e1c08840ff530eda9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85f241652a9dfc89e280200e7618ed32"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85f241652a9dfc89e280200e7618ed32">set_rf_metrics_classification</a> (float accuracy)</td></tr>
<tr class="separator:a85f241652a9dfc89e280200e7618ed32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaa0b5eb27fbd28c93285b9ada72930d8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aaa0b5eb27fbd28c93285b9ada72930d8">set_rf_metrics_regression</a> (double mean_abs_error, double mean_squared_error, double median_abs_error)</td></tr>
<tr class="separator:aaa0b5eb27fbd28c93285b9ada72930d8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a390319c6e316ef242d477e8fa326f2d0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a390319c6e316ef242d477e8fa326f2d0">print</a> (const <a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> rf_metrics)</td></tr>
<tr class="separator:a390319c6e316ef242d477e8fa326f2d0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a178203e05c1c99873372e64f999a631d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a178203e05c1c99873372e64f999a631d">set_rf_params</a> (<a class="el" href="structML_1_1RF__params.html">RF_params</a> &amp;<a class="el" href="classML_1_1params.html">params</a>, int cfg_n_trees=1, bool cfg_bootstrap=true, float cfg_max_samples=1.0f, int cfg_seed=-1, int cfg_n_streams=8)</td></tr>
<tr class="separator:a178203e05c1c99873372e64f999a631d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2dc7323a0d33a6fc91f8f4f6f827f37d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2dc7323a0d33a6fc91f8f4f6f827f37d">set_all_rf_params</a> (<a class="el" href="structML_1_1RF__params.html">RF_params</a> &amp;<a class="el" href="classML_1_1params.html">params</a>, int cfg_n_trees, bool cfg_bootstrap, float cfg_max_samples, int cfg_seed, int cfg_n_streams, <a class="el" href="structML_1_1DecisionTree_1_1DecisionTreeParams.html">DecisionTree::DecisionTreeParams</a> cfg_tree_params)</td></tr>
<tr class="separator:a2dc7323a0d33a6fc91f8f4f6f827f37d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69f0169515a838c25ba3080b48ae2ceb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a69f0169515a838c25ba3080b48ae2ceb">validity_check</a> (const <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params)</td></tr>
<tr class="separator:a69f0169515a838c25ba3080b48ae2ceb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa3ded9ffe5af3b52a2b8a301a362af10"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa3ded9ffe5af3b52a2b8a301a362af10">print</a> (const <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params)</td></tr>
<tr class="separator:aa3ded9ffe5af3b52a2b8a301a362af10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa25bebb87dff8c328b2d4809f640f789"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa25bebb87dff8c328b2d4809f640f789">preprocess_labels</a> (int n_rows, std::vector&lt; int &gt; &amp;labels, std::map&lt; int, int &gt; &amp;labels_map, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aa25bebb87dff8c328b2d4809f640f789"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a05ee22c0f2c66e9bb7d60c72e5d61b32"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a05ee22c0f2c66e9bb7d60c72e5d61b32">postprocess_labels</a> (int n_rows, std::vector&lt; int &gt; &amp;labels, std::map&lt; int, int &gt; &amp;labels_map, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a05ee22c0f2c66e9bb7d60c72e5d61b32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1275db1b0385b97fbb481b719322a25"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:ab1275db1b0385b97fbb481b719322a25"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab1275db1b0385b97fbb481b719322a25">null_trees_ptr</a> (<a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&amp;forest)</td></tr>
<tr class="separator:ab1275db1b0385b97fbb481b719322a25"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47bd45d133f5b3bb3748a6e5d1c61c91"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a47bd45d133f5b3bb3748a6e5d1c61c91"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a47bd45d133f5b3bb3748a6e5d1c61c91">delete_rf_metadata</a> (<a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a47bd45d133f5b3bb3748a6e5d1c61c91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40395e030bda0e7170453320450b5f8a"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a40395e030bda0e7170453320450b5f8a"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a40395e030bda0e7170453320450b5f8a">print_rf_summary</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a40395e030bda0e7170453320450b5f8a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a983711adcb719ce812e5f5d3641f108e"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a983711adcb719ce812e5f5d3641f108e"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a983711adcb719ce812e5f5d3641f108e">print_rf_detailed</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a983711adcb719ce812e5f5d3641f108e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06b7e8387e47eea8a541aec6549279c6"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a06b7e8387e47eea8a541aec6549279c6"><td align="right" class="memTemplItemLeft" valign="top">std::string </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a06b7e8387e47eea8a541aec6549279c6">dump_rf_as_json</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a06b7e8387e47eea8a541aec6549279c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a684813418506a4839a61692008e4cfb9"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a684813418506a4839a61692008e4cfb9"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a684813418506a4839a61692008e4cfb9">build_treelite_forest</a> (<a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> *model, const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest, int num_features, int <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">task_category</a>)</td></tr>
<tr class="separator:a684813418506a4839a61692008e4cfb9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"><td align="right" class="memItemLeft" valign="top"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee">concatenate_trees</a> (std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; treelite_handles)</td></tr>
<tr class="separator:ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af142813513ee46988a79fd3dc4ab52a6"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af142813513ee46988a79fd3dc4ab52a6">compare_concat_forest_to_subforests</a> (<a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> concat_tree_handle, std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; treelite_handles)</td></tr>
<tr class="separator:af142813513ee46988a79fd3dc4ab52a6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e62adbaee80935246fc0ff937575b59"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2e62adbaee80935246fc0ff937575b59">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&amp;forest, float *input, int n_rows, int n_cols, int *labels, int n_unique_labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a2e62adbaee80935246fc0ff937575b59"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38cfdf38af3291baa8b4a5f3a33b74a9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a38cfdf38af3291baa8b4a5f3a33b74a9">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&amp;forest, double *input, int n_rows, int n_cols, int *labels, int n_unique_labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a38cfdf38af3291baa8b4a5f3a33b74a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0a63f42d57ee6287cedb49f48a6fa220"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0a63f42d57ee6287cedb49f48a6fa220">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const float *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a0a63f42d57ee6287cedb49f48a6fa220"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a014e0b6e471acfa9829c62a05de49275"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a014e0b6e471acfa9829c62a05de49275">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const double *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a014e0b6e471acfa9829c62a05de49275"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36a34da015328e0518fc6ceec5f22710"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a36a34da015328e0518fc6ceec5f22710">predictGetAll</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const float *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a36a34da015328e0518fc6ceec5f22710"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40a10f5bf0cce48a4ea54d7f33281081"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a40a10f5bf0cce48a4ea54d7f33281081">predictGetAll</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const double *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a40a10f5bf0cce48a4ea54d7f33281081"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae91cc5ebb6e5b37e754ada49a37c3f2f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae91cc5ebb6e5b37e754ada49a37c3f2f">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const int *ref_labels, int n_rows, const int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ae91cc5ebb6e5b37e754ada49a37c3f2f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeff6bb49e843ea8d5135439648e633a8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeff6bb49e843ea8d5135439648e633a8">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const int *ref_labels, int n_rows, const int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aeff6bb49e843ea8d5135439648e633a8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a666d6a8df1b8108df5b742e6ba76a035"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a666d6a8df1b8108df5b742e6ba76a035">set_rf_class_obj</a> (int max_depth, int max_leaves, float max_features, int n_bins, int split_algo, int min_samples_leaf, int min_samples_split, float min_impurity_decrease, bool bootstrap_features, bool bootstrap, int n_trees, float max_samples, int seed, <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> split_criterion, bool quantile_per_tree, int cfg_n_streams, bool use_experimental_backend, int max_batch_size)</td></tr>
<tr class="separator:a666d6a8df1b8108df5b742e6ba76a035"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a970c9a51cb7fb36680c2f2e3ad88dca4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a970c9a51cb7fb36680c2f2e3ad88dca4">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&amp;forest, float *input, int n_rows, int n_cols, float *labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a970c9a51cb7fb36680c2f2e3ad88dca4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4dfca11198fa7304d1568c6c7ff09469"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4dfca11198fa7304d1568c6c7ff09469">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&amp;forest, double *input, int n_rows, int n_cols, double *labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a4dfca11198fa7304d1568c6c7ff09469"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae9ebff9eb10e9bcf8c9e2d9b6533259b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae9ebff9eb10e9bcf8c9e2d9b6533259b">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *forest, const float *input, int n_rows, int n_cols, float *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ae9ebff9eb10e9bcf8c9e2d9b6533259b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd7a72d075a98a0f8eeb197c81554348"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afd7a72d075a98a0f8eeb197c81554348">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *forest, const double *input, int n_rows, int n_cols, double *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:afd7a72d075a98a0f8eeb197c81554348"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a04e5fbd639ed8b2820ad3a1500d26732"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a04e5fbd639ed8b2820ad3a1500d26732">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *forest, const float *ref_labels, int n_rows, const float *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a04e5fbd639ed8b2820ad3a1500d26732"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa819cc3c995f572099b9b84e0897cd76"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa819cc3c995f572099b9b84e0897cd76">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *forest, const double *ref_labels, int n_rows, const double *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aa819cc3c995f572099b9b84e0897cd76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0490fb8318421675f8f18cde8fb986a2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0490fb8318421675f8f18cde8fb986a2">TSNE_fit</a> (const raft::handle_t &amp;handle, const float *X, float *Y, const int n, const int p, const int dim=2, int n_neighbors=1023, const float theta=0.5f, const float epssq=0.0025, float perplexity=50.0f, const int perplexity_max_iter=100, const float perplexity_tol=1e-5, const float early_exaggeration=12.0f, const int exaggeration_iter=250, const float min_gain=0.01f, const float pre_learning_rate=200.0f, const float post_learning_rate=500.0f, const int max_iter=1000, const float min_grad_norm=1e-7, const float pre_momentum=0.5, const float post_momentum=0.8, const long long random_state=-1, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>, const bool initialize_embeddings=true, bool barnes_hut=true)</td></tr>
<tr class="memdesc:a0490fb8318421675f8f18cde8fb986a2"><td class="mdescLeft"> </td><td class="mdescRight">Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2).  <a href="namespaceML.html#a0490fb8318421675f8f18cde8fb986a2">More...</a><br/></td></tr>
<tr class="separator:a0490fb8318421675f8f18cde8fb986a2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c8939105827600d7e9fcc435fb08c2b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9c8939105827600d7e9fcc435fb08c2b">brute_force_knn</a> (raft::handle_t &amp;handle, std::vector&lt; float * &gt; &amp;input, std::vector&lt; int &gt; &amp;sizes, int D, float *search_items, int n, int64_t *res_I, float *res_D, int k, bool rowMajorIndex=false, bool rowMajorQuery=false, <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9">MetricType</a> metric=MetricType::METRIC_L2, float metric_arg=2.0f, bool expanded=false)</td></tr>
<tr class="memdesc:a9c8939105827600d7e9fcc435fb08c2b"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances.  <a href="namespaceML.html#a9c8939105827600d7e9fcc435fb08c2b">More...</a><br/></td></tr>
<tr class="separator:a9c8939105827600d7e9fcc435fb08c2b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a181e3084eb03bbcfdcde71c281141555"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a181e3084eb03bbcfdcde71c281141555">knn_classify</a> (raft::handle_t &amp;handle, int *out, int64_t *knn_indices, std::vector&lt; int * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a181e3084eb03bbcfdcde71c281141555"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a knn classification using a given a vector of label arrays. This supports multilabel classification by classifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn.  <a href="namespaceML.html#a181e3084eb03bbcfdcde71c281141555">More...</a><br/></td></tr>
<tr class="separator:a181e3084eb03bbcfdcde71c281141555"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a876ab255e2fc9f989d251f3ff57af5d5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a876ab255e2fc9f989d251f3ff57af5d5">knn_regress</a> (raft::handle_t &amp;handle, float *out, int64_t *knn_indices, std::vector&lt; float * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a876ab255e2fc9f989d251f3ff57af5d5"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a knn regression using a given a vector of label arrays. This supports multilabel regression by clasifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn.  <a href="namespaceML.html#a876ab255e2fc9f989d251f3ff57af5d5">More...</a><br/></td></tr>
<tr class="separator:a876ab255e2fc9f989d251f3ff57af5d5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8260b0b9f0efd7893d8b1c925c6839f0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8260b0b9f0efd7893d8b1c925c6839f0">knn_class_proba</a> (raft::handle_t &amp;handle, std::vector&lt; float * &gt; &amp;out, int64_t *knn_indices, std::vector&lt; int * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a8260b0b9f0efd7893d8b1c925c6839f0"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to compute knn class probabilities using a vector of device arrays containing discrete class labels. Note that the output is a vector, which is.  <a href="namespaceML.html#a8260b0b9f0efd7893d8b1c925c6839f0">More...</a><br/></td></tr>
<tr class="separator:a8260b0b9f0efd7893d8b1c925c6839f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga751d8a984b4aacd46234f7a8017f30aa"><td class="memTemplParams" colspan="2">template&lt;typename math_t &gt; </td></tr>
<tr class="memitem:ga751d8a984b4aacd46234f7a8017f30aa"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga751d8a984b4aacd46234f7a8017f30aa">RPROJfit</a> (const raft::handle_t &amp;handle, <a class="el" href="structML_1_1rand__mat.html">rand_mat</a>&lt; math_t &gt; *random_matrix, <a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:ga751d8a984b4aacd46234f7a8017f30aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5ba9ec2edbeb657dd2247d0207647fb2"><td class="memTemplParams" colspan="2">template&lt;typename math_t &gt; </td></tr>
<tr class="memitem:ga5ba9ec2edbeb657dd2247d0207647fb2"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga5ba9ec2edbeb657dd2247d0207647fb2">RPROJtransform</a> (const raft::handle_t &amp;handle, math_t *input, <a class="el" href="structML_1_1rand__mat.html">rand_mat</a>&lt; math_t &gt; *random_matrix, math_t *output, <a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:ga5ba9ec2edbeb657dd2247d0207647fb2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacb2b3ebad5d3f97745d7d8d8e57d8345"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#gacb2b3ebad5d3f97745d7d8d8e57d8345">johnson_lindenstrauss_min_dim</a> (size_t n_samples, double eps)</td></tr>
<tr class="separator:gacb2b3ebad5d3f97745d7d8d8e57d8345"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a236db2676ab7c1363895c81faa085a"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7a236db2676ab7c1363895c81faa085a">divide_by_mask_build_index</a> (const raft::handle_t &amp;handle, const bool *d_mask, int *d_index, int batch_size)</td></tr>
<tr class="separator:a7a236db2676ab7c1363895c81faa085a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac30d243b4af52a353b388781f6c80bbd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac30d243b4af52a353b388781f6c80bbd">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const float *d_in, const bool *d_mask, const int *d_index, float *d_out0, float *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:ac30d243b4af52a353b388781f6c80bbd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8664a4caa2bb7efe45a4772fef29dc6a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8664a4caa2bb7efe45a4772fef29dc6a">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const double *d_in, const bool *d_mask, const int *d_index, double *d_out0, double *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:a8664a4caa2bb7efe45a4772fef29dc6a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a77087155e5d034998297612c318b44c4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a77087155e5d034998297612c318b44c4">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const int *d_in, const bool *d_mask, const int *d_index, int *d_out0, int *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:a77087155e5d034998297612c318b44c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a96e538801438dbf2cb14b387bbfb5a66"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a96e538801438dbf2cb14b387bbfb5a66">divide_by_min_build_index</a> (const raft::handle_t &amp;handle, const float *d_matrix, int *d_batch, int *d_index, int *h_size, int batch_size, int n_sub)</td></tr>
<tr class="separator:a96e538801438dbf2cb14b387bbfb5a66"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1ec36247a6875e497c2258a27da253e8"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1ec36247a6875e497c2258a27da253e8">divide_by_min_build_index</a> (const raft::handle_t &amp;handle, const double *d_matrix, int *d_batch, int *d_index, int *h_size, int batch_size, int n_sub)</td></tr>
<tr class="separator:a1ec36247a6875e497c2258a27da253e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2c70b44dbd2190b2b78f5b79b2374428"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2c70b44dbd2190b2b78f5b79b2374428">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const float *d_in, const int *d_batch, const int *d_index, float **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a2c70b44dbd2190b2b78f5b79b2374428"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a806f5807932256b6be674a37bd993dd9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a806f5807932256b6be674a37bd993dd9">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const double *d_in, const int *d_batch, const int *d_index, double **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a806f5807932256b6be674a37bd993dd9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a266431bebb4a84c70458265ea26b393b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a266431bebb4a84c70458265ea26b393b">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const int *d_in, const int *d_batch, const int *d_index, int **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a266431bebb4a84c70458265ea26b393b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a27ed4fdb2f62155d0a1fd81f1405a779"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a27ed4fdb2f62155d0a1fd81f1405a779">build_division_map</a> (const raft::handle_t &amp;handle, const int *const *hd_id, const int *h_size, int *d_id_to_pos, int *d_id_to_model, int batch_size, int n_sub)</td></tr>
<tr class="separator:a27ed4fdb2f62155d0a1fd81f1405a779"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb8f25b52e0576997c85d1488367ab76"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeb8f25b52e0576997c85d1488367ab76">merge_series</a> (const raft::handle_t &amp;handle, const float *const *hd_in, const int *d_id_to_pos, const int *d_id_to_sub, float *d_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:aeb8f25b52e0576997c85d1488367ab76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a03e79871ae0209450671f11bcd8965fe"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a03e79871ae0209450671f11bcd8965fe">merge_series</a> (const raft::handle_t &amp;handle, const double *const *hd_in, const int *d_id_to_pos, const int *d_id_to_sub, double *d_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a03e79871ae0209450671f11bcd8965fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad048e7644ca470414dc9c7fca5f2e189"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad048e7644ca470414dc9c7fca5f2e189">pack</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, double *param_vec)</td></tr>
<tr class="separator:ad048e7644ca470414dc9c7fca5f2e189"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a62e41ec81cdf10cea7be42c97eca6b32"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a62e41ec81cdf10cea7be42c97eca6b32">unpack</a> (raft::handle_t &amp;handle, <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, const double *param_vec)</td></tr>
<tr class="separator:a62e41ec81cdf10cea7be42c97eca6b32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa0653c7b782547550d2d8df07038e28a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa0653c7b782547550d2d8df07038e28a">batched_diff</a> (raft::handle_t &amp;handle, double *d_y_diff, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order)</td></tr>
<tr class="separator:aa0653c7b782547550d2d8df07038e28a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8d434323e4d805be8320a5d517bbd8b9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8d434323e4d805be8320a5d517bbd8b9">batched_loglike</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const double *d_params, double *loglike, double *d_vs, bool trans=true, bool host_loglike=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0, int fc_steps=0, double *d_fc=nullptr, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:a8d434323e4d805be8320a5d517bbd8b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab751422ded5ed3ec53f5f138d8bdcca4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab751422ded5ed3ec53f5f138d8bdcca4">batched_loglike</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *loglike, double *d_vs, bool trans=true, bool host_loglike=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0, int fc_steps=0, double *d_fc=nullptr, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:ab751422ded5ed3ec53f5f138d8bdcca4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38169d12d519a05e0e6c255efc45d004"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a38169d12d519a05e0e6c255efc45d004">batched_loglike_grad</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const double *d_x, double *d_grad, double h, bool trans=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0)</td></tr>
<tr class="separator:a38169d12d519a05e0e6c255efc45d004"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af1794d3b91c3c67dc5072a12910c48d2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af1794d3b91c3c67dc5072a12910c48d2">predict</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, int start, int end, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *d_y_p, bool pre_diff=true, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:af1794d3b91c3c67dc5072a12910c48d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a904aa5ac2206f2403f430ca7fd135f4f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a904aa5ac2206f2403f430ca7fd135f4f">information_criterion</a> (raft::handle_t &amp;handle, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *ic, int ic_type)</td></tr>
<tr class="separator:a904aa5ac2206f2403f430ca7fd135f4f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a492e6cc8eeb77f760b7abf1c5d37801b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a492e6cc8eeb77f760b7abf1c5d37801b">estimate_x0</a> (raft::handle_t &amp;handle, <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order)</td></tr>
<tr class="separator:a492e6cc8eeb77f760b7abf1c5d37801b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b41fea6f2923aac90b27f01c5f9149e"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7b41fea6f2923aac90b27f01c5f9149e">batched_kalman_filter</a> (raft::handle_t &amp;handle, const double *d_ys_b, int nobs, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, double *d_loglike, double *d_vs, int fc_steps=0, double *d_fc=nullptr, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:a7b41fea6f2923aac90b27f01c5f9149e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1b3ecb77a2af6ef294f2b05eca4037ee"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1b3ecb77a2af6ef294f2b05eca4037ee">batched_jones_transform</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, bool isInv, const double *h_params, double *h_Tparams)</td></tr>
<tr class="separator:a1b3ecb77a2af6ef294f2b05eca4037ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af0f446810d4972e9bee95fca756cb958"><td align="right" class="memItemLeft" valign="top">auto </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af0f446810d4972e9bee95fca756cb958">thrust_exec_policy</a> (std::shared_ptr&lt; <a class="el" href="namespaceMLCommon.html#a74b62e512ed5877e0bb8314eb629bfda">deviceAllocator</a> &gt; allocator, cudaStream_t stream) -&gt; std::unique_ptr&lt; decltype(thrust::cuda::par(_decltypeHelper)), std::function&lt; void(decltype(thrust::cuda::par(_decltypeHelper)) *)&gt;&gt;</td></tr>
<tr class="memdesc:af0f446810d4972e9bee95fca756cb958"><td class="mdescLeft"> </td><td class="mdescRight">Returns a unique_ptr to a Thrust CUDA execution policy that uses the passed in allocator for temporary memory allocation.  <a href="namespaceML.html#af0f446810d4972e9bee95fca756cb958">More...</a><br/></td></tr>
<tr class="separator:af0f446810d4972e9bee95fca756cb958"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d769926cc27c80a2daa3779c606c133"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9d769926cc27c80a2daa3779c606c133">convert_level_to_spdlog</a> (int level)</td></tr>
<tr class="separator:a9d769926cc27c80a2daa3779c606c133"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aacfa74158f3a2d08f6ddae02dbfb2992"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aacfa74158f3a2d08f6ddae02dbfb2992">PUSH_RANGE</a> (const char *name)</td></tr>
<tr class="memdesc:aacfa74158f3a2d08f6ddae02dbfb2992"><td class="mdescLeft"> </td><td class="mdescRight">Push a named nvtx range.  <a href="namespaceML.html#aacfa74158f3a2d08f6ddae02dbfb2992">More...</a><br/></td></tr>
<tr class="separator:aacfa74158f3a2d08f6ddae02dbfb2992"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a516be7eeb210dc391738e9761a886533"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a516be7eeb210dc391738e9761a886533">POP_RANGE</a> ()</td></tr>
<tr class="separator:a516be7eeb210dc391738e9761a886533"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9597fa4e87eb201ef8bbe7e8b1c5dcab"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9597fa4e87eb201ef8bbe7e8b1c5dcab">is_dev_ptr</a> (const void *p)</td></tr>
<tr class="separator:a9597fa4e87eb201ef8bbe7e8b1c5dcab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae9e9f22920ecd0dd7ab05981dd3a0cac"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae9e9f22920ecd0dd7ab05981dd3a0cac">get_device</a> (const void *ptr)</td></tr>
<tr class="separator:ae9e9f22920ecd0dd7ab05981dd3a0cac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ea5c03024c5683984f17d889421f40c"><td align="right" class="memItemLeft" valign="top">cudaMemoryType </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2ea5c03024c5683984f17d889421f40c">memory_type</a> (const void *p)</td></tr>
<tr class="separator:a2ea5c03024c5683984f17d889421f40c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a13b2600cf250418d851752f64d633860"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a13b2600cf250418d851752f64d633860">is_device_or_managed_type</a> (const void *p)</td></tr>
<tr class="separator:a13b2600cf250418d851752f64d633860"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7181e4d6d170b0aa91dc7a368abf3d1c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7181e4d6d170b0aa91dc7a368abf3d1c">handleMap</a></td></tr>
<tr class="memdesc:a7181e4d6d170b0aa91dc7a368abf3d1c"><td class="mdescLeft"> </td><td class="mdescRight">Static handle map instance (see <a class="el" href="cumlHandle_8cpp.html">cumlHandle.cpp</a>)  <a href="namespaceML.html#a7181e4d6d170b0aa91dc7a368abf3d1c">More...</a><br/></td></tr>
<tr class="separator:a7181e4d6d170b0aa91dc7a368abf3d1c"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4ac020f9f913af2af87de5e462b72aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac020f9f913af2af87de5e462b72aba">◆ </a></span>knn_indices_dense_t</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef int64_t <a class="el" href="namespaceML.html#a4ac020f9f913af2af87de5e462b72aba">ML::knn_indices_dense_t</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a59bd3f642cc2f46bedc2c7059cac837a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bd3f642cc2f46bedc2c7059cac837a">◆ </a></span>knn_indices_sparse_t</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef int <a class="el" href="namespaceML.html#a59bd3f642cc2f46bedc2c7059cac837a">ML::knn_indices_sparse_t</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a239d146c5a5545dd84e3d0b6e305f631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239d146c5a5545dd84e3d0b6e305f631">◆ </a></span>paramsPCA</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a> <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">ML::paramsPCA</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9ff6828291243eca3956818d2f309339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff6828291243eca3956818d2f309339">◆ </a></span>paramsPCAMG</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a>&lt;<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a>&gt; <a class="el" href="namespaceML.html#a9ff6828291243eca3956818d2f309339">ML::paramsPCAMG</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ab2bffedf6f8d520e216a6542ebf6a0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bffedf6f8d520e216a6542ebf6a0f1">◆ </a></span>paramsTSVD</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a> <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">ML::paramsTSVD</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae3b799705dfc8991beaf24c9a906bc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b799705dfc8991beaf24c9a906bc76">◆ </a></span>paramsTSVDMG</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a>&lt;<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a>&gt; <a class="el" href="namespaceML.html#ae3b799705dfc8991beaf24c9a906bc76">ML::paramsTSVDMG</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="acbf0352d6a255f990fcdf949b898d6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf0352d6a255f990fcdf949b898d6af">◆ </a></span>RandomForestClassifierD</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;double, int&gt; <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">ML::RandomForestClassifierD</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a36df48edc11fcd68dd8b6f4a76526e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36df48edc11fcd68dd8b6f4a76526e7b">◆ </a></span>RandomForestClassifierF</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;float, int&gt; <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">ML::RandomForestClassifierF</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a64f2117024176a6fab67a1a6b8925243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f2117024176a6fab67a1a6b8925243">◆ </a></span>RandomForestRegressorD</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;double, double&gt; <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">ML::RandomForestRegressorD</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a79048a796facf156e926834d97bec78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79048a796facf156e926834d97bec78f">◆ </a></span>RandomForestRegressorF</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;float, float&gt; <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">ML::RandomForestRegressorF</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a823912afaa51f58a997564eadb6d9405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823912afaa51f58a997564eadb6d9405">◆ </a></span>CRITERION</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">ML::CRITERION</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405af633f697107611ea3f0f2d18986be3e6"></a>GINI </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ab55a4e6aef097bd8f786f4ddfd1de161"></a>ENTROPY </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a746a9f45470e731c984d37744c48432e"></a>MSE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a71d3454116e1aace7f91b15f56567b1e"></a>MAE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ae346b778011ef4f488c1c87d64c1b174"></a>CRITERION_END </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a0dcbb2c0993e8446dffd09b5de731a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcbb2c0993e8446dffd09b5de731a26">◆ </a></span>LoglikeMethod</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">ML::LoglikeMethod</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0dcbb2c0993e8446dffd09b5de731a26a7c2ef7613d7b9a655691f9f24b893c11"></a>CSS </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab"></a>MLE </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a67da49ce109878bcdbb29a8777d28de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67da49ce109878bcdbb29a8777d28de1">◆ </a></span>loss_funct</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1">ML::loss_funct</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1ad3c28e4d0ab8ed2b4c69c0483c6ffea4"></a>SQRD_LOSS </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1a007e4d0f43a45d8d9be3dde194ea410a"></a>HINGE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1ad24128f8a7b16f59075a28323f13803d"></a>LOG </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a1adf3fea9cf9cde96ecf353b43818079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf3fea9cf9cde96ecf353b43818079">◆ </a></span>lr_type</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079">ML::lr_type</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a5ccc94f0f9ce653134966e2377c71ca1"></a>OPTIMAL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079aabfea584e2f24b9920a5fb3058dd06bb"></a>CONSTANT </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a98a91ed2cd2ff227d0393c406e09a106"></a>INVSCALING </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a8108470840df674d6403e12c0d2ac63a"></a>ADAPTIVE </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a4d9fd2e8fe0cfbbd81877eee212b88d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9fd2e8fe0cfbbd81877eee212b88d9">◆ </a></span>MetricType</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9">ML::MetricType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9a138628cbf0d89bc28f2dd159f426c13d"></a>METRIC_INNER_PRODUCT </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9a5e87bd6f2a6c86ad23937eedf66de99b"></a>METRIC_L2 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9a6d9ec7c577a546e75c72ee872241ef4e"></a>METRIC_L1 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9aa01f9bc4910d9f004046489a11dc815e"></a>METRIC_Linf </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ab136e195c4dd9de8a55edaa0830ddf2f"></a>METRIC_Lp </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ae507c1b9eb779a39b742fa8e3e22cd0e"></a>METRIC_Canberra </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9a2124363d5cceb96ec8c9d87e0e9ece05"></a>METRIC_BrayCurtis </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ad4265672a802bf53d58db72de56ddd22"></a>METRIC_JensenShannon </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ae401fdab977404f1b08e85985f7b4bf8"></a>METRIC_Cosine </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ad4bc32758f26d167d264e7574429b024"></a>METRIC_Correlation </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a9a3879adb63715cec17550171436f6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3879adb63715cec17550171436f6ab">◆ </a></span>mg_solver</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">ML::mg_solver</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba38769546eb5536bd58d5eb9922c3e0bf"></a>COV_EIG_DQ </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba3a077c1d31d8e7f29a92eb7ea002daad"></a>COV_EIG_JACOBI </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba66c35cd8077f7e1db5faefbc048a646a"></a>QR </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a1529da2b94c67018bb14f404f6e9aeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1529da2b94c67018bb14f404f6e9aeac">◆ </a></span>Norm</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeac">ML::Norm</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca6527e252610c64b85fdc9fc357c979cc"></a>L0 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072"></a>L1 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e"></a>L2 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca83820f75ef6d53c49873c4269fdcdc26"></a>LINF </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a85e691126b37f5e1dc834841cad1479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e691126b37f5e1dc834841cad1479c">◆ </a></span>OptimCriterion</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479c">ML::OptimCriterion</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca7a9fdcb8befd1162d7ba06c5bc34bd21"></a>OPTIM_BFGS_ITER_LIMIT </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca80e3d3c81590a148d565b7ddb78ef590"></a>OPTIM_MIN_PARAM_DIFF </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca01a4b4daad43785b0587346034b10ef5"></a>OPTIM_MIN_ERROR_DIFF </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca6c4ee736abd198cfc853b82b1e3a1fcc"></a>OPTIM_MIN_GRAD_NORM </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a899c5f26e201a81a2c12bb7eed9b015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899c5f26e201a81a2c12bb7eed9b015d">◆ </a></span>penalty</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015d">ML::penalty</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a899c5f26e201a81a2c12bb7eed9b015daf8cf4476d6fa69254aa96e2a9b385b07"></a>NONE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072"></a>L1 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e"></a>L2 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a899c5f26e201a81a2c12bb7eed9b015da80cad9123fc734ada9ef3a33ac30e627"></a>ELASTICNET </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a4d83b99fe769e2e9bf3596bb1604ab4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d83b99fe769e2e9bf3596bb1604ab4f">◆ </a></span>RF_type</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">ML::RF_type</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d83b99fe769e2e9bf3596bb1604ab4fa9d8edfe721557c504d925e3bcace2edf"></a>CLASSIFICATION </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d83b99fe769e2e9bf3596bb1604ab4fa2864cd9bbe2aa57118c71b9c717c3586"></a>REGRESSION </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a8d55de18185e36dd8f8a6d735e6a91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d55de18185e36dd8f8a6d735e6a91e6">◆ </a></span>SeasonalType</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6">ML::SeasonalType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d55de18185e36dd8f8a6d735e6a91e6af28ffe4c75342f4012bcf16f798e0ec3"></a>ADDITIVE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d55de18185e36dd8f8a6d735e6a91e6abc34c50dc7f29a357f52f9e5c0308226"></a>MULTIPLICATIVE </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a7324898185a2fc9a9145f9bad555049b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7324898185a2fc9a9145f9bad555049b">◆ </a></span>solver</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049b">ML::solver</a> : int</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">COV_EIG_DQ</td><td>covariance of input will be used along with eigen decomposition using divide and conquer method for symmetric matrices </td></tr>
<tr><td class="paramname">COV_EIG_JACOBI</td><td>covariance of input will be used along with eigen decomposition using jacobi method for symmetric matrices </td></tr>
</table>
</dd>
</dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7324898185a2fc9a9145f9bad555049ba38769546eb5536bd58d5eb9922c3e0bf"></a>COV_EIG_DQ </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7324898185a2fc9a9145f9bad555049ba3a077c1d31d8e7f29a92eb7ea002daad"></a>COV_EIG_JACOBI </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="afe9899e0c7ff1cf722a35bcf35283953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9899e0c7ff1cf722a35bcf35283953">◆ </a></span>SPLIT_ALGO</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953">ML::SPLIT_ALGO</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a5ce779f6c1df4e4ec40cd9cee88837e2"></a>HIST </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a61e77c561b3834cdc46508db24d72f90"></a>GLOBAL_QUANTILE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a5773eabe7d91f72e535b233ca73ba5c9"></a>SPLIT_ALGO_END </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="af60801cb5c9adac3f6f5bd4bd43aa2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60801cb5c9adac3f6f5bd4bd43aa2f7">◆ </a></span>task_category</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">ML::task_category</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af60801cb5c9adac3f6f5bd4bd43aa2f7a88b80439ca4076839158d63d31271315"></a>REGRESSION_MODEL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af60801cb5c9adac3f6f5bd4bd43aa2f7a9c8a19e179622826abd959f7639c7006"></a>CLASSIFICATION_MODEL </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa0653c7b782547550d2d8df07038e28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0653c7b782547550d2d8df07038e28a">◆ </a></span>batched_diff()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_diff </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_y_diff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the differenced series (seasonal and/or non-seasonal differences)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_y_diff</td><td>Differenced series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Original series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a1b3ecb77a2af6ef294f2b05eca4037ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3ecb77a2af6ef294f2b05eca4037ee">◆ </a></span>batched_jones_transform()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_jones_transform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>isInv</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>h_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_Tparams</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Convenience function for batched "jones transform" used in ARIMA to ensure certain properties of the AR and MA parameters (takes host array and returns host array)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series analyzed. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">isInv</td><td>Do the inverse transform? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h_params</td><td>ARIMA parameters by batch (mu, ar, ma) (host) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">h_Tparams</td><td>Transformed ARIMA parameters (expects pre-allocated array of size (p+q)*batch_size) (host) </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a7b41fea6f2923aac90b27f01c5f9149e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b41fea6f2923aac90b27f01c5f9149e">◆ </a></span>batched_kalman_filter()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_kalman_filter </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_ys_b</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nobs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>level</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_upper</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>An ARIMA specialized batched kalman filter to evaluate ARMA parameters and provide the resulting prediction as well as loglikelihood fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_ys_b</td><td>Batched time series Shape (nobs, batch_size) (col-major, device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of samples per time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of series making up the batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_loglike</td><td>Resulting log-likelihood (per series) (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>Residual between the prediction and the original series. shape=(nobs-d-s*D, batch_size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ab751422ded5ed3ec53f5f138d8bdcca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab751422ded5ed3ec53f5f138d8bdcca4">◆ </a></span>batched_loglike() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_loglike </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> </td>
<td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>truncate</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>level</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_upper</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the loglikelihood of the given parameter on the given time series in a batched context.</p>
<dl class="section note"><dt>Note</dt><dd>: this overload should be used when the parameters are already unpacked to avoid useless packing / unpacking</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Log-Likelihood of the model per series </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>The residual between model and original signal. shape = (n_obs-d-s*D, batch_size) (device) Note: no output when using CSS estimation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a8d434323e4d805be8320a5d517bbd8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d434323e4d805be8320a5d517bbd8b9">◆ </a></span>batched_loglike() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_loglike </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> </td>
<td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>truncate</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>level</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_upper</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the loglikelihood of the given parameter on the given time series in a batched context.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_params</td><td>Parameters to evaluate grouped by series: [mu0, ar.., ma.., mu1, ..] (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Log-Likelihood of the model per series </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>The residual between model and original signal. shape = (n_obs-d-s*D, batch_size) (device) Note: no output when using CSS estimation </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a38169d12d519a05e0e6c255efc45d004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38169d12d519a05e0e6c255efc45d004">◆ </a></span>batched_loglike_grad()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_loglike_grad </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_x</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_grad</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>h</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> </td>
<td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>truncate</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the gradient of the log-likelihood</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_x</td><td>Parameters grouped by series </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_grad</td><td>Gradient to compute </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Finite-differencing step size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a9c8939105827600d7e9fcc435fb08c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8939105827600d7e9fcc435fb08c2b">◆ </a></span>brute_force_knn()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::brute_force_knn </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>sizes</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>D</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>search_items</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>res_I</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>res_D</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>rowMajorIndex</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>rowMajorQuery</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9">MetricType</a> </td>
<td class="paramname"><em>metric</em> = <code>MetricType::METRIC_L2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>metric_arg</em> = <code>2.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>expanded</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>vector of pointers to the input arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>vector of sizes of input arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>the dimensionality of the arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">search_items</td><td>array of items to search of dimensionality D </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in search_items </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">res_I</td><td>the resulting index array of size n * k </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">res_D</td><td>the resulting distance array of size n * k </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the number of nearest neighbors to return </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rowMajorIndex</td><td>are the index arrays in row-major order? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">rowMajorQuery</td><td>are the query arrays in row-major order? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Euclidean (L2) is used by default </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">metric_arg</td><td>the value of <code>p</code> for Minkowski (l-p) distances. This is ignored if the metric_type is not Minkowski. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">expanded</td><td>should lp-based distances be returned in their expanded form (e.g., without raising to the 1/p power). </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a27ed4fdb2f62155d0a1fd81f1405a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ed4fdb2f62155d0a1fd81f1405a779">◆ </a></span>build_division_map()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::build_division_map </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int *const * </td>
<td class="paramname"><em>hd_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>h_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_id_to_pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_id_to_model</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Build a map to associate each batch member with a model and index in the associated sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">hd_id</td><td>Host array of pointers to device arrays containing the indices of the members of each sub-batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h_size</td><td>Host array containing the size of each sub-batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_id_to_pos</td><td>Device array containing the position of each member in its new sub-batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_id_to_model</td><td>Device array associating each member with its sub-batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a684813418506a4839a61692008e4cfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684813418506a4839a61692008e4cfb9">◆ </a></span>build_treelite_forest()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::build_treelite_forest </td>
<td>(</td>
<td class="paramtype"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> * </td>
<td class="paramname"><em>model</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>task_category</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af142813513ee46988a79fd3dc4ab52a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142813513ee46988a79fd3dc4ab52a6">◆ </a></span>compare_concat_forest_to_subforests()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::compare_concat_forest_to_subforests </td>
<td>(</td>
<td class="paramtype"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> </td>
<td class="paramname"><em>concat_tree_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; </td>
<td class="paramname"><em>treelite_handles</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee">◆ </a></span>concatenate_trees()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> ML::concatenate_trees </td>
<td>(</td>
<td class="paramtype">std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; </td>
<td class="paramname"><em>treelite_handles</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9d769926cc27c80a2daa3779c606c133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d769926cc27c80a2daa3779c606c133">◆ </a></span>convert_level_to_spdlog()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int ML::convert_level_to_spdlog </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>level</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a47bd45d133f5b3bb3748a6e5d1c61c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bd45d133f5b3bb3748a6e5d1c61c91">◆ </a></span>delete_rf_metadata()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::delete_rf_metadata </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a7a236db2676ab7c1363895c81faa085a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a236db2676ab7c1363895c81faa085a">◆ </a></span>divide_by_mask_build_index()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int ML::divide_by_mask_build_index </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool * </td>
<td class="paramname"><em>d_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch division by mask step 1: build an index of the position of each series in its new batch and measure the size of each sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_mask</td><td>Boolean mask </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of 'true' series in the mask </dd></dl>
</div>
</div>
<a id="a8664a4caa2bb7efe45a4772fef29dc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8664a4caa2bb7efe45a4772fef29dc6a">◆ </a></span>divide_by_mask_execute() <span class="overload">[1/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_mask_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool * </td>
<td class="paramname"><em>d_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_out0</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_out1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac30d243b4af52a353b388781f6c80bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d243b4af52a353b388781f6c80bbd">◆ </a></span>divide_by_mask_execute() <span class="overload">[2/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_mask_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool * </td>
<td class="paramname"><em>d_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>d_out0</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>d_out1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch division by mask step 2: create both sub-batches from the mask and index</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input batch. Each series is a contiguous chunk </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_mask</td><td>Boolean mask </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_out0</td><td>The sub-batch for the 'false' members </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_out1</td><td>The sub-batch for the 'true' members </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of data points per series </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a77087155e5d034998297612c318b44c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77087155e5d034998297612c318b44c4">◆ </a></span>divide_by_mask_execute() <span class="overload">[3/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_mask_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool * </td>
<td class="paramname"><em>d_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_out0</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_out1</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a1ec36247a6875e497c2258a27da253e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec36247a6875e497c2258a27da253e8">◆ </a></span>divide_by_min_build_index() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_build_index </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_matrix</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>h_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a96e538801438dbf2cb14b387bbfb5a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e538801438dbf2cb14b387bbfb5a66">◆ </a></span>divide_by_min_build_index() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_build_index </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>d_matrix</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>h_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch division by minimum value step 1: build an index of which sub-batch each series belongs to, an index of the position of each series in its new batch, and measure the size of each sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_matrix</td><td>Matrix of the values to minimize Shape: (batch_size, n_sub) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_batch</td><td>Which sub-batch each series belongs to </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">h_size</td><td>Size of each sub-batch (host) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a806f5807932256b6be674a37bd993dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806f5807932256b6be674a37bd993dd9">◆ </a></span>divide_by_min_execute() <span class="overload">[1/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double ** </td>
<td class="paramname"><em>hd_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2c70b44dbd2190b2b78f5b79b2374428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c70b44dbd2190b2b78f5b79b2374428">◆ </a></span>divide_by_min_execute() <span class="overload">[2/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float ** </td>
<td class="paramname"><em>hd_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batch division by minimum value step 2: create all the sub-batches</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input batch. Each series is a contiguous chunk </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_batch</td><td>Which sub-batch each series belongs to </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_index</td><td>Index of each series in its new sub-batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">hd_out</td><td>Host array of pointers to device arrays of each sub-batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of data points per series </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a266431bebb4a84c70458265ea26b393b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266431bebb4a84c70458265ea26b393b">◆ </a></span>divide_by_min_execute() <span class="overload">[3/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::divide_by_min_execute </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_batch</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int ** </td>
<td class="paramname"><em>hd_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a06b7e8387e47eea8a541aec6549279c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b7e8387e47eea8a541aec6549279c6">◆ </a></span>dump_rf_as_json()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::string ML::dump_rf_as_json </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a492e6cc8eeb77f760b7abf1c5d37801b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492e6cc8eeb77f760b7abf1c5d37801b">◆ </a></span>estimate_x0()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::estimate_x0 </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Provide initial estimates to ARIMA parameters mu, AR, and MA</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a38cfdf38af3291baa8b4a5f3a33b74a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cfdf38af3291baa8b4a5f3a33b74a9">◆ </a></span>fit() <span class="overload">[1/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_unique_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2e62adbaee80935246fc0ff937575b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e62adbaee80935246fc0ff937575b59">◆ </a></span>fit() <span class="overload">[2/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_unique_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a4dfca11198fa7304d1568c6c7ff09469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfca11198fa7304d1568c6c7ff09469">◆ </a></span>fit() <span class="overload">[3/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a970c9a51cb7fb36680c2f2e3ad88dca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970c9a51cb7fb36680c2f2e3ad88dca4">◆ </a></span>fit() <span class="overload">[4/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae9e9f22920ecd0dd7ab05981dd3a0cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e9f22920ecd0dd7ab05981dd3a0cac">◆ </a></span>get_device()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int ML::get_device </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>ptr</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a904aa5ac2206f2403f430ca7fd135f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904aa5ac2206f2403f430ca7fd135f4f">◆ </a></span>information_criterion()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::information_criterion </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>ic</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ic_type</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute an information criterion (AIC, AICc, BIC)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ic</td><td>Array where to write the information criteria Shape: (batch_size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ic_type</td><td>Type of information criterion wanted. 0: AIC, 1: AICc, 2: BIC </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a9597fa4e87eb201ef8bbe7e8b1c5dcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597fa4e87eb201ef8bbe7e8b1c5dcab">◆ </a></span>is_dev_ptr()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool ML::is_dev_ptr </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>p</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a13b2600cf250418d851752f64d633860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b2600cf250418d851752f64d633860">◆ </a></span>is_device_or_managed_type()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool ML::is_device_or_managed_type </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>p</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a8260b0b9f0efd7893d8b1c925c6839f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8260b0b9f0efd7893d8b1c925c6839f0">◆ </a></span>knn_class_proba()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_class_proba </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_index_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_query_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to compute knn class probabilities using a vector of device arrays containing discrete class labels. Note that the output is a vector, which is. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>vector of output arrays on device. vector size = n_outputs. Each array should have size(n_samples, n_classes) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>array on device of knn indices (size n_samples * k) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of labels on device (size n_samples) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of labels in y </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of rows in knn_indices and out </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a181e3084eb03bbcfdcde71c281141555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181e3084eb03bbcfdcde71c281141555">◆ </a></span>knn_classify()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_classify </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_index_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_query_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a knn classification using a given a vector of label arrays. This supports multilabel classification by classifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output array on device (size n_samples * size of y vector) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>index array on device resulting from knn query (size n_samples * k) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>vector of label arrays on device vector size is number of (size n_samples) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of vertices in index (eg. size of each y array) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of samples in knn_indices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a876ab255e2fc9f989d251f3ff57af5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876ab255e2fc9f989d251f3ff57af5d5">◆ </a></span>knn_regress()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_regress </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_index_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_query_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a knn regression using a given a vector of label arrays. This supports multilabel regression by clasifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output array on device (size n_samples) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>array on device of knn indices (size n_samples * k) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of labels on device (size n_samples) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of vertices in index (eg. size of each y array) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of samples in knn_indices and out </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a2ea5c03024c5683984f17d889421f40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea5c03024c5683984f17d889421f40c">◆ </a></span>memory_type()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">cudaMemoryType ML::memory_type </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>p</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a03e79871ae0209450671f11bcd8965fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e79871ae0209450671f11bcd8965fe">◆ </a></span>merge_series() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::merge_series </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double *const * </td>
<td class="paramname"><em>hd_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_id_to_pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_id_to_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aeb8f25b52e0576997c85d1488367ab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8f25b52e0576997c85d1488367ab76">◆ </a></span>merge_series() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::merge_series </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float *const * </td>
<td class="paramname"><em>hd_in</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_id_to_pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>d_id_to_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>d_out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_sub</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Merge multiple sub-batches into one batch according to the maps that associate each id in the unique batch to a sub-batch and a position in this sub-batch.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">hd_in</td><td>Host array of pointers to device arrays containing the sub-batches </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_id_to_pos</td><td>Device array containing the position of each member in its new sub-batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_id_to_sub</td><td>Device array associating each member with its sub-batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output merged batch </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations (or forecasts) per series </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ab1275db1b0385b97fbb481b719322a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1275db1b0385b97fbb481b719322a25">◆ </a></span>null_trees_ptr()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::null_trees_ptr </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&amp; </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ad048e7644ca470414dc9c7fca5f2e189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad048e7644ca470414dc9c7fca5f2e189">◆ </a></span>pack()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pack </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>param_vec</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Pack separate parameter arrays into a compact array</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Parameter structure </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">param_vec</td><td>Compact parameter array </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a82ec70080c3ee46d4ff21b8222868c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ec70080c3ee46d4ff21b8222868c93">◆ </a></span>pcaFit() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFit </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a5382ae5b01e8079b6e550b13d087d4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5382ae5b01e8079b6e550b13d087d4fb">◆ </a></span>pcaFit() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFit </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aeb11c10b247ee28f7897bb28156320e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb11c10b247ee28f7897bb28156320e1">◆ </a></span>pcaFitTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFitTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ad8ca2904e5fd35b1a9b883c87e1c1274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ca2904e5fd35b1a9b883c87e1c1274">◆ </a></span>pcaFitTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFitTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af6dc66b3d7ba1d41b448d4317272fbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dc66b3d7ba1d41b448d4317272fbbc">◆ </a></span>pcaInverseTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaInverseTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ab49f1e8617076366a9be1fac04b8c92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49f1e8617076366a9be1fac04b8c92d">◆ </a></span>pcaInverseTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaInverseTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac37aa9b10bb7445d9b3523dae260e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37aa9b10bb7445d9b3523dae260e681">◆ </a></span>pcaTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9930aa036bcf52cf182f000ce355cdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9930aa036bcf52cf182f000ce355cdcd">◆ </a></span>pcaTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a516be7eeb210dc391738e9761a886533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516be7eeb210dc391738e9761a886533">◆ </a></span>POP_RANGE()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::POP_RANGE </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Pop the latest range </p>
</div>
</div>
<a id="a05ee22c0f2c66e9bb7d60c72e5d61b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ee22c0f2c66e9bb7d60c72e5d61b32">◆ </a></span>postprocess_labels()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::postprocess_labels </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::map&lt; int, int &gt; &amp; </td>
<td class="paramname"><em>labels_map</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a014e0b6e471acfa9829c62a05de49275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014e0b6e471acfa9829c62a05de49275">◆ </a></span>predict() <span class="overload">[1/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a0a63f42d57ee6287cedb49f48a6fa220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a63f42d57ee6287cedb49f48a6fa220">◆ </a></span>predict() <span class="overload">[2/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="afd7a72d075a98a0f8eeb197c81554348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7a72d075a98a0f8eeb197c81554348">◆ </a></span>predict() <span class="overload">[3/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae9ebff9eb10e9bcf8c9e2d9b6533259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ebff9eb10e9bcf8c9e2d9b6533259b">◆ </a></span>predict() <span class="overload">[4/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af1794d3b91c3c67dc5072a12910c48d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1794d3b91c3c67dc5072a12910c48d2">◆ </a></span>predict() <span class="overload">[5/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_obs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>start</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>end</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_y_p</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>pre_diff</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>level</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_upper</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batched in-sample and out-of-sample prediction of a time-series given all the model parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Batched Time series to predict. Shape: (num_samples, batch size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Index to start the prediction </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Index to end the prediction (excluded) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_y_p</td><td>Prediction output (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_diff</td><td>Whether to use pre-differencing </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a40a10f5bf0cce48a4ea54d7f33281081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a10f5bf0cce48a4ea54d7f33281081">◆ </a></span>predictGetAll() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predictGetAll </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a36a34da015328e0518fc6ceec5f22710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a34da015328e0518fc6ceec5f22710">◆ </a></span>predictGetAll() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predictGetAll </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa25bebb87dff8c328b2d4809f640f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25bebb87dff8c328b2d4809f640f789">◆ </a></span>preprocess_labels()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::preprocess_labels </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::map&lt; int, int &gt; &amp; </td>
<td class="paramname"><em>labels_map</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a390319c6e316ef242d477e8fa326f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390319c6e316ef242d477e8fa326f2d0">◆ </a></span>print() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::print </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td>
<td class="paramname"><em>rf_metrics</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa3ded9ffe5af3b52a2b8a301a362af10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ded9ffe5af3b52a2b8a301a362af10">◆ </a></span>print() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::print </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a983711adcb719ce812e5f5d3641f108e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983711adcb719ce812e5f5d3641f108e">◆ </a></span>print_rf_detailed()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::print_rf_detailed </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a40395e030bda0e7170453320450b5f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40395e030bda0e7170453320450b5f8a">◆ </a></span>print_rf_summary()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::print_rf_summary </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aacfa74158f3a2d08f6ddae02dbfb2992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfa74158f3a2d08f6ddae02dbfb2992">◆ </a></span>PUSH_RANGE()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::PUSH_RANGE </td>
<td>(</td>
<td class="paramtype">const char * </td>
<td class="paramname"><em>name</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Push a named nvtx range. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">name</td><td>range name </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aeff6bb49e843ea8d5135439648e633a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff6bb49e843ea8d5135439648e633a8">◆ </a></span>score() <span class="overload">[1/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae91cc5ebb6e5b37e754ada49a37c3f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91cc5ebb6e5b37e754ada49a37c3f2f">◆ </a></span>score() <span class="overload">[2/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa819cc3c995f572099b9b84e0897cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819cc3c995f572099b9b84e0897cd76">◆ </a></span>score() <span class="overload">[3/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a04e5fbd639ed8b2820ad3a1500d26732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e5fbd639ed8b2820ad3a1500d26732">◆ </a></span>score() <span class="overload">[4/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a5c7fcf2379a3d18e1c08840ff530eda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7fcf2379a3d18e1c08840ff530eda9">◆ </a></span>set_all_rf_metrics()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_all_rf_metrics </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> </td>
<td class="paramname"><em>rf_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>accuracy</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_abs_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_squared_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>median_abs_error</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2dc7323a0d33a6fc91f8f4f6f827f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc7323a0d33a6fc91f8f4f6f827f37d">◆ </a></span>set_all_rf_params()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::set_all_rf_params </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_trees</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cfg_bootstrap</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>cfg_max_samples</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_seed</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_streams</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1DecisionTree_1_1DecisionTreeParams.html">DecisionTree::DecisionTreeParams</a> </td>
<td class="paramname"><em>cfg_tree_params</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a666d6a8df1b8108df5b742e6ba76a035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666d6a8df1b8108df5b742e6ba76a035">◆ </a></span>set_rf_class_obj()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__params.html">RF_params</a> ML::set_rf_class_obj </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_depth</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_leaves</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>max_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_bins</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>split_algo</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>min_samples_leaf</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>min_samples_split</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>min_impurity_decrease</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>bootstrap_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>bootstrap</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_trees</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>max_samples</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>seed</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> </td>
<td class="paramname"><em>split_criterion</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>quantile_per_tree</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_streams</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>use_experimental_backend</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_batch_size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a85f241652a9dfc89e280200e7618ed32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f241652a9dfc89e280200e7618ed32">◆ </a></span>set_rf_metrics_classification()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_rf_metrics_classification </td>
<td>(</td>
<td class="paramtype">float </td>
<td class="paramname"><em>accuracy</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aaa0b5eb27fbd28c93285b9ada72930d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0b5eb27fbd28c93285b9ada72930d8">◆ </a></span>set_rf_metrics_regression()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_rf_metrics_regression </td>
<td>(</td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_abs_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_squared_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>median_abs_error</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a178203e05c1c99873372e64f999a631d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178203e05c1c99873372e64f999a631d">◆ </a></span>set_rf_params()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::set_rf_params </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_trees</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cfg_bootstrap</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>cfg_max_samples</em> = <code>1.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_seed</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_streams</em> = <code>8</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af0f446810d4972e9bee95fca756cb958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f446810d4972e9bee95fca756cb958">◆ </a></span>thrust_exec_policy()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">auto ML::thrust_exec_policy </td>
<td>(</td>
<td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespaceMLCommon.html#a74b62e512ed5877e0bb8314eb629bfda">deviceAllocator</a> &gt; </td>
<td class="paramname"><em>allocator</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">cudaStream_t </td>
<td class="paramname"><em>stream</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> -&gt; std::unique_ptr&lt;
    decltype(thrust::cuda::par(_decltypeHelper)),
    std::function&lt;void(decltype(thrust::cuda::par(_decltypeHelper))*)&gt;&gt; </td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a unique_ptr to a Thrust CUDA execution policy that uses the passed in allocator for temporary memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>The allocator to use </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream that the allocator will use</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Thrust execution policy that will use allocator for temporary memory allocation. </dd></dl>
</div>
</div>
<a id="a0490fb8318421675f8f18cde8fb986a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0490fb8318421675f8f18cde8fb986a2">◆ </a></span>TSNE_fit()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::TSNE_fit </td>
<td>(</td>
<td class="paramtype">const raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>Y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>p</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>dim</em> = <code>2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_neighbors</em> = <code>1023</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>theta</em> = <code>0.5f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>epssq</em> = <code>0.0025</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>perplexity</em> = <code>50.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>perplexity_max_iter</em> = <code>100</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>perplexity_tol</em> = <code>1e-5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>early_exaggeration</em> = <code>12.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>exaggeration_iter</em> = <code>250</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>min_gain</em> = <code>0.01f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>pre_learning_rate</em> = <code>200.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>post_learning_rate</em> = <code>500.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>max_iter</em> = <code>1000</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>min_grad_norm</em> = <code>1e-7</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>pre_momentum</em> = <code>0.5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>post_momentum</em> = <code>0.8</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const long long </td>
<td class="paramname"><em>random_state</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool </td>
<td class="paramname"><em>initialize_embeddings</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>barnes_hut</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2). </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The GPU handle. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>The dataset you want to apply TSNE on. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The final embedding. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows in data X. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Number of columns in data X. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of output dimensions for embeddings Y. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_neighbors</td><td>Number of nearest neighbors used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>Float between 0 and 1. Tradeoff for speed (0) vs accuracy (1) for Barnes Hut only. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">epssq</td><td>A tiny jitter to promote numerical stability. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity</td><td>How many nearest neighbors are used during construction of Pij. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity_max_iter</td><td>Number of iterations used to construct Pij. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity_tol</td><td>The small tolerance used for Pij to ensure numerical stability. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">early_exaggeration</td><td>How much early pressure you want the clusters in TSNE to spread out more. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">exaggeration_iter</td><td>How many iterations you want the early pressure to run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_gain</td><td>Rounds up small gradient updates. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_learning_rate</td><td>The learning rate during exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">post_learning_rate</td><td>The learning rate after exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations TSNE should run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_grad_norm</td><td>The smallest gradient norm TSNE should terminate on. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_momentum</td><td>The momentum used during the exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">post_momentum</td><td>The momentum used after the exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">random_state</td><td>Set this to -1 for pure random intializations or &gt;= 0 for reproducible outputs. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>verbosity level for logging messages during execution </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">initialize_embeddings</td><td>Whether to overwrite the current Y vector with random noise. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut</td><td>Whether to use the fast Barnes Hut or use the slower exact version.</td></tr>
</table>
</dd>
</dl>
<p>The CUDA implementation is derived from the excellent CannyLabs open source implementation here: <a href="https://github.com/CannyLab/tsne-cuda/">https://github.com/CannyLab/tsne-cuda/</a>. The CannyLabs code is licensed according to the conditions in cuml/cpp/src/tsne/cannylabs_tsne_license.txt. A full description of their approach is available in their article t-SNE-CUDA: GPU-Accelerated t-SNE and its Applications to Modern Data (<a href="https://arxiv.org/abs/1807.11824">https://arxiv.org/abs/1807.11824</a>). </p>
</div>
</div>
<a id="add33f23b1a15823449837dc884b13ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add33f23b1a15823449837dc884b13ddd">◆ </a></span>tsvdFit() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFit </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2a071bdcbc710b1a4ca88efc02fd2489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a071bdcbc710b1a4ca88efc02fd2489">◆ </a></span>tsvdFit() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFit </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae1a46cc3b471efc453be9e8fbecba363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a46cc3b471efc453be9e8fbecba363">◆ </a></span>tsvdFitTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="afba20c39f0790075843e9236fd043ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba20c39f0790075843e9236fd043ca1">◆ </a></span>tsvdFitTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae2faa9e0c83e9270369e866281802624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2faa9e0c83e9270369e866281802624">◆ </a></span>tsvdInverseTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdInverseTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac335d131520793dcf0831d753e1c7ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac335d131520793dcf0831d753e1c7ab2">◆ </a></span>tsvdInverseTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdInverseTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a83f6113e72b200d0a4bef2759285a6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f6113e72b200d0a4bef2759285a6ca">◆ </a></span>tsvdTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a1a8f7fa23231a10eb02ea2a3d4923335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8f7fa23231a10eb02ea2a3d4923335">◆ </a></span>tsvdTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdTransform </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a62e41ec81cdf10cea7be42c97eca6b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e41ec81cdf10cea7be42c97eca6b32">◆ </a></span>unpack()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::unpack </td>
<td>(</td>
<td class="paramtype">raft::handle_t &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>param_vec</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Unpack a compact array into separate parameter arrays</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">params</td><td>Parameter structure </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">param_vec</td><td>Compact parameter array </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a69f0169515a838c25ba3080b48ae2ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0169515a838c25ba3080b48ae2ceb">◆ </a></span>validity_check()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::validity_check </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7181e4d6d170b0aa91dc7a368abf3d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7181e4d6d170b0aa91dc7a368abf3d1c">◆ </a></span>handleMap</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a> ML::handleMap</td>
</tr>
</table>
</div><div class="memdoc">
<p>Static handle map instance (see <a class="el" href="cumlHandle_8cpp.html">cumlHandle.cpp</a>) </p>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"/></a> 1.8.20
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
