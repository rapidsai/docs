<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>cuML C++ API: ML Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcuml</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (22.04)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcuml/nightly">nightly (22.08)</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">stable (22.06)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuml/legacy">legacy (22.04)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> |
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ML Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceML_1_1CD"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1CD.html">CD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Datasets"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Datasets.html">Datasets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Dbscan"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Dbscan.html">Dbscan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1DT"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1DT.html">DT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Explainer"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Explainer.html">Explainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1fil"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1fil.html">fil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1GLM"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1GLM.html">GLM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1HDBSCAN"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1HDBSCAN.html">HDBSCAN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1HoltWinters"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1HoltWinters.html">HoltWinters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Internals"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Internals.html">Internals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1kmeans"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1kmeans.html">kmeans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1KNN"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1KNN.html">KNN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Metrics"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Metrics.html">Metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1OLS"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1OLS.html">OLS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1PCA"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1PCA.html">PCA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Ridge"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Ridge.html">Ridge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Solver"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Solver.html">Solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Sparse"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Sparse.html">Sparse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Spectral"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Spectral.html">Spectral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1Stationarity"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Stationarity.html">Stationarity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1SVM"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1SVM.html">SVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1TSVD"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1TSVD.html">TSVD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:namespaceML_1_1UMAP"><td align="right" class="memItemLeft" valign="top"> &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1UMAP.html">UMAP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1knn__graph.html">knn_graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main Logging class for cuML library.  <a href="classML_1_1Logger.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__dense__inputs__t.html">manifold_dense_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__inputs__t.html">manifold_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__precomputed__knn__inputs__t.html">manifold_precomputed_knn_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1manifold__sparse__inputs__t.html">manifold_sparse_inputs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1OptimParams.html">OptimParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1params.html">params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">structure for pca parameters. Ref: <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html</a>  <a href="classML_1_1paramsPCATemplate.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsSolver.html">paramsSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1PatternSetter.html">PatternSetter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RAII based pattern setter for <a class="el" href="classML_1_1Logger.html" title="The main Logging class for cuML library.">Logger</a> class.  <a href="classML_1_1PatternSetter.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1pinned__host__vector.html">pinned_host_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1rand__mat.html">rand_mat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RF__params.html">RF_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1SimpleMat.html">SimpleMat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1SimpleMatOwning.html">SimpleMatOwning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1SimpleSparseMat.html">SimpleSparseMat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1SimpleVecOwning.html">SimpleVecOwning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1Tensor.html">Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1TSNEParams.html">TSNEParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab2bffedf6f8d520e216a6542ebf6a0f1"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a></td></tr>
<tr class="separator:ab2bffedf6f8d520e216a6542ebf6a0f1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a239d146c5a5545dd84e3d0b6e305f631"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a></td></tr>
<tr class="separator:a239d146c5a5545dd84e3d0b6e305f631"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9ff6828291243eca3956818d2f309339"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a>&lt; <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9ff6828291243eca3956818d2f309339">paramsPCAMG</a></td></tr>
<tr class="separator:a9ff6828291243eca3956818d2f309339"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae3b799705dfc8991beaf24c9a906bc76"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a>&lt; <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae3b799705dfc8991beaf24c9a906bc76">paramsTSVDMG</a></td></tr>
<tr class="separator:ae3b799705dfc8991beaf24c9a906bc76"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a36df48edc11fcd68dd8b6f4a76526e7b"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; float, int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a></td></tr>
<tr class="separator:a36df48edc11fcd68dd8b6f4a76526e7b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acbf0352d6a255f990fcdf949b898d6af"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; double, int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a></td></tr>
<tr class="separator:acbf0352d6a255f990fcdf949b898d6af"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a79048a796facf156e926834d97bec78f"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; float, float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a></td></tr>
<tr class="separator:a79048a796facf156e926834d97bec78f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a64f2117024176a6fab67a1a6b8925243"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; double, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a></td></tr>
<tr class="separator:a64f2117024176a6fab67a1a6b8925243"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4ac020f9f913af2af87de5e462b72aba"><td align="right" class="memItemLeft" valign="top">typedef int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4ac020f9f913af2af87de5e462b72aba">knn_indices_dense_t</a></td></tr>
<tr class="separator:a4ac020f9f913af2af87de5e462b72aba"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a59bd3f642cc2f46bedc2c7059cac837a"><td align="right" class="memItemLeft" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a59bd3f642cc2f46bedc2c7059cac837a">knn_indices_sparse_t</a></td></tr>
<tr class="separator:a59bd3f642cc2f46bedc2c7059cac837a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7324898185a2fc9a9145f9bad555049b"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049b">solver</a> : int { <a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049ba38769546eb5536bd58d5eb9922c3e0bf">solver::COV_EIG_DQ</a>, 
<a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049ba3a077c1d31d8e7f29a92eb7ea002daad">solver::COV_EIG_JACOBI</a>
 }</td></tr>
<tr class="separator:a7324898185a2fc9a9145f9bad555049b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9a3879adb63715cec17550171436f6ab"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a> { <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba38769546eb5536bd58d5eb9922c3e0bf">mg_solver::COV_EIG_DQ</a>, 
<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba3a077c1d31d8e7f29a92eb7ea002daad">mg_solver::COV_EIG_JACOBI</a>, 
<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6aba66c35cd8077f7e1db5faefbc048a646a">mg_solver::QR</a>
 }</td></tr>
<tr class="separator:a9a3879adb63715cec17550171436f6ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4d83b99fe769e2e9bf3596bb1604ab4f"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> { <a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4fa9d8edfe721557c504d925e3bcace2edf">CLASSIFICATION</a>, 
<a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4fa2864cd9bbe2aa57118c71b9c717c3586">REGRESSION</a>
 }</td></tr>
<tr class="separator:a4d83b99fe769e2e9bf3596bb1604ab4f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af60801cb5c9adac3f6f5bd4bd43aa2f7"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">task_category</a> { <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7a88b80439ca4076839158d63d31271315">REGRESSION_MODEL</a> = 1, 
<a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7a9c8a19e179622826abd959f7639c7006">CLASSIFICATION_MODEL</a> = 2
 }</td></tr>
<tr class="separator:af60801cb5c9adac3f6f5bd4bd43aa2f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aacbc7e98d26a8d5e8b51055651d423e2"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aacbc7e98d26a8d5e8b51055651d423e2">TSNE_ALGORITHM</a> { <a class="el" href="namespaceML.html#aacbc7e98d26a8d5e8b51055651d423e2a7457fc662d7dbaabc355693f5dcb1d02">EXACT</a>, 
<a class="el" href="namespaceML.html#aacbc7e98d26a8d5e8b51055651d423e2a260246ddd4c5d6b1c3602dd0abb7231c">BARNES_HUT</a>, 
<a class="el" href="namespaceML.html#aacbc7e98d26a8d5e8b51055651d423e2a4d99b41e47ccb1820e1b593afbc1e561">FFT</a>
 }</td></tr>
<tr class="separator:aacbc7e98d26a8d5e8b51055651d423e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga134c8dc1d94a4ee420679aec61849e2b"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga134c8dc1d94a4ee420679aec61849e2b">random_matrix_type</a> { <a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2baa7bee409e76fac7544d660db7e2eb7c0">unset</a>, 
<a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2bad1e6d312a4b10fe213eac82ffb1cdd72">dense</a>, 
<a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2baca3f848ed01f4ea23129374f48c98293">sparse</a>
 }</td></tr>
<tr class="separator:ga134c8dc1d94a4ee420679aec61849e2b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1adf3fea9cf9cde96ecf353b43818079"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079">lr_type</a> { <a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a5ccc94f0f9ce653134966e2377c71ca1">OPTIMAL</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079aabfea584e2f24b9920a5fb3058dd06bb">CONSTANT</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a98a91ed2cd2ff227d0393c406e09a106">INVSCALING</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a8108470840df674d6403e12c0d2ac63a">ADAPTIVE</a>
 }</td></tr>
<tr class="separator:a1adf3fea9cf9cde96ecf353b43818079"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a67da49ce109878bcdbb29a8777d28de1"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1">loss_funct</a> { <a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1ad3c28e4d0ab8ed2b4c69c0483c6ffea4">SQRD_LOSS</a>, 
<a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1a007e4d0f43a45d8d9be3dde194ea410a">HINGE</a>, 
<a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1ad24128f8a7b16f59075a28323f13803d">LOG</a>
 }</td></tr>
<tr class="separator:a67da49ce109878bcdbb29a8777d28de1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a899c5f26e201a81a2c12bb7eed9b015d"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015d">penalty</a> { <a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015daf8cf4476d6fa69254aa96e2a9b385b07">NONE</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072">L1</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e">L2</a>, 
<a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015da80cad9123fc734ada9ef3a33ac30e627">ELASTICNET</a>
 }</td></tr>
<tr class="separator:a899c5f26e201a81a2c12bb7eed9b015d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a823912afaa51f58a997564eadb6d9405"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405af633f697107611ea3f0f2d18986be3e6">GINI</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ab55a4e6aef097bd8f786f4ddfd1de161">ENTROPY</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a746a9f45470e731c984d37744c48432e">MSE</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a71d3454116e1aace7f91b15f56567b1e">MAE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a5dad58efccd3863342cf2663e989a194">POISSON</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ad414050e85fc8a16b5fd1f1839bc4b90">GAMMA</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405acb60653800a061d296b3df110079c769">INVERSE_GAUSSIAN</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ae346b778011ef4f488c1c87d64c1b174">CRITERION_END</a>
<br>
 }</td></tr>
<tr class="separator:a823912afaa51f58a997564eadb6d9405"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0dcbb2c0993e8446dffd09b5de731a26"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> { <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a7c2ef7613d7b9a655691f9f24b893c11">CSS</a>, 
<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>
 }</td></tr>
<tr class="separator:a0dcbb2c0993e8446dffd09b5de731a26"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8d55de18185e36dd8f8a6d735e6a91e6"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6">SeasonalType</a> { <a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6af28ffe4c75342f4012bcf16f798e0ec3">ADDITIVE</a>, 
<a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6abc34c50dc7f29a357f52f9e5c0308226">MULTIPLICATIVE</a>
 }</td></tr>
<tr class="separator:a8d55de18185e36dd8f8a6d735e6a91e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a85e691126b37f5e1dc834841cad1479c"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479c">OptimCriterion</a> { <a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca7a9fdcb8befd1162d7ba06c5bc34bd21">OPTIM_BFGS_ITER_LIMIT</a> = 0, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca80e3d3c81590a148d565b7ddb78ef590">OPTIM_MIN_PARAM_DIFF</a> = 1, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca01a4b4daad43785b0587346034b10ef5">OPTIM_MIN_ERROR_DIFF</a> = 2, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca6c4ee736abd198cfc853b82b1e3a1fcc">OPTIM_MIN_GRAD_NORM</a> = 3
 }</td></tr>
<tr class="separator:a85e691126b37f5e1dc834841cad1479c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1529da2b94c67018bb14f404f6e9aeac"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeac">Norm</a> { <a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca6527e252610c64b85fdc9fc357c979cc">L0</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072">L1</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e">L2</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca83820f75ef6d53c49873c4269fdcdc26">LINF</a>
 }</td></tr>
<tr class="separator:a1529da2b94c67018bb14f404f6e9aeac"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad2244eba7d9251930ae2519d556f18ea"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad2244eba7d9251930ae2519d556f18ea">STORAGE_ORDER</a> { <a class="el" href="namespaceML.html#ad2244eba7d9251930ae2519d556f18eaab5f45c1dae8374d1665f17565b583163">COL_MAJOR</a> = 0, 
<a class="el" href="namespaceML.html#ad2244eba7d9251930ae2519d556f18eaa45fa3fee7bc6693bf050cbc6a1b7c94e">ROW_MAJOR</a> = 1
 }</td></tr>
<tr class="separator:ad2244eba7d9251930ae2519d556f18ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ababb040d6ea66983187527a3cc132714"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ababb040d6ea66983187527a3cc132714">hdbscan</a> (const raft::handle_t &amp;handle, const float *X, size_t m, size_t n, raft::distance::DistanceType metric, <a class="el" href="classML_1_1HDBSCAN_1_1Common_1_1HDBSCANParams.html">HDBSCAN::Common::HDBSCANParams</a> &amp;<a class="el" href="classML_1_1params.html">params</a>, <a class="el" href="classML_1_1HDBSCAN_1_1Common_1_1hdbscan__output.html">HDBSCAN::Common::hdbscan_output</a>&lt; int, float &gt; &amp;out)</td></tr>
<tr class="separator:ababb040d6ea66983187527a3cc132714"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a08a0cbc81f9a9cd7ef8fb78657cf2224"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a08a0cbc81f9a9cd7ef8fb78657cf2224">build_condensed_hierarchy</a> (const raft::handle_t &amp;handle, const int *children, const float *delta, const int *sizes, int min_cluster_size, int n_leaves, <a class="el" href="classML_1_1HDBSCAN_1_1Common_1_1CondensedHierarchy.html">HDBSCAN::Common::CondensedHierarchy</a>&lt; int, float &gt; &amp;condensed_tree)</td></tr>
<tr class="separator:a08a0cbc81f9a9cd7ef8fb78657cf2224"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a355e1514f3c1be413991cf73fc2dfb14"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a355e1514f3c1be413991cf73fc2dfb14">_extract_clusters</a> (const raft::handle_t &amp;handle, size_t n_leaves, int n_edges, int *parents, int *children, float *lambdas, int *sizes, int *labels, float *probabilities, <a class="el" href="namespaceML_1_1HDBSCAN_1_1Common.html#a4f669ad45ee808dc58e4d8e81d14535b">HDBSCAN::Common::CLUSTER_SELECTION_METHOD</a> cluster_selection_method, bool allow_single_cluster, int max_cluster_size, float cluster_selection_epsilon)</td></tr>
<tr class="separator:a355e1514f3c1be413991cf73fc2dfb14"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2e906b2839782feeb92f9f8d6b72bcad"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2e906b2839782feeb92f9f8d6b72bcad">single_linkage_pairwise</a> (const raft::handle_t &amp;handle, const float *X, size_t m, size_t n, raft::hierarchy::linkage_output&lt; int, float &gt; *out, raft::distance::DistanceType metric, int n_clusters=5)</td></tr>
<tr class="memdesc:a2e906b2839782feeb92f9f8d6b72bcad"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes single-linkage hierarchical clustering on a dense input feature matrix and outputs the labels, dendrogram, and minimum spanning tree. Connectivities are constructed using the full n^2 pairwise distance matrix. This can be very fast for smaller datasets when there is enough memory available.  <a href="namespaceML.html#a2e906b2839782feeb92f9f8d6b72bcad">More...</a><br></td></tr>
<tr class="separator:a2e906b2839782feeb92f9f8d6b72bcad"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0262446094debc247669f955e6f13e5f"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0262446094debc247669f955e6f13e5f">single_linkage_neighbors</a> (const raft::handle_t &amp;handle, const float *X, size_t m, size_t n, raft::hierarchy::linkage_output&lt; int, float &gt; *out, raft::distance::DistanceType metric=raft::distance::DistanceType::L2Unexpanded, int c=15, int n_clusters=5)</td></tr>
<tr class="memdesc:a0262446094debc247669f955e6f13e5f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes single-linkage hierarchical clustering on a dense input feature matrix and outputs the labels, dendrogram, and minimum spanning tree. Connectivities are constructed using a k-nearest neighbors graph. While this strategy enables the algorithm to scale to much higher numbers of rows, it comes with the downside that additional knn steps may need to be executed to connect an otherwise unconnected k-nn graph.  <a href="namespaceML.html#a0262446094debc247669f955e6f13e5f">More...</a><br></td></tr>
<tr class="separator:a0262446094debc247669f955e6f13e5f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab6638b428d61f67a7054b60c37ca3172"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab6638b428d61f67a7054b60c37ca3172">single_linkage_pairwise</a> (const raft::handle_t &amp;handle, const float *X, size_t m, size_t n, raft::hierarchy::linkage_output&lt; int64_t, float &gt; *out, raft::distance::DistanceType metric, int n_clusters=5)</td></tr>
<tr class="separator:ab6638b428d61f67a7054b60c37ca3172"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gabb9694969393f0288a606c9184435ef9"><td align="right" class="memItemLeft" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CStringFormat.html#gabb9694969393f0288a606c9184435ef9">format</a> (const char *fmt, va_list &amp;vl)</td></tr>
<tr class="separator:gabb9694969393f0288a606c9184435ef9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gad55df9da3c66646eee88f92620cef30a"><td align="right" class="memItemLeft" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CStringFormat.html#gad55df9da3c66646eee88f92620cef30a">format</a> (const char *fmt,...)</td></tr>
<tr class="separator:gad55df9da3c66646eee88f92620cef30a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5382ae5b01e8079b6e550b13d087d4fb"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5382ae5b01e8079b6e550b13d087d4fb">pcaFit</a> (raft::handle_t &amp;handle, float *input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, float *mu, float *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a5382ae5b01e8079b6e550b13d087d4fb"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a82ec70080c3ee46d4ff21b8222868c93"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a82ec70080c3ee46d4ff21b8222868c93">pcaFit</a> (raft::handle_t &amp;handle, double *input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, double *mu, double *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a82ec70080c3ee46d4ff21b8222868c93"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad8ca2904e5fd35b1a9b883c87e1c1274"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad8ca2904e5fd35b1a9b883c87e1c1274">pcaFitTransform</a> (raft::handle_t &amp;handle, float *input, float *trans_input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, float *mu, float *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ad8ca2904e5fd35b1a9b883c87e1c1274"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aeb11c10b247ee28f7897bb28156320e1"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeb11c10b247ee28f7897bb28156320e1">pcaFitTransform</a> (raft::handle_t &amp;handle, double *input, double *trans_input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, double *mu, double *noise_vars, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:aeb11c10b247ee28f7897bb28156320e1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab49f1e8617076366a9be1fac04b8c92d"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab49f1e8617076366a9be1fac04b8c92d">pcaInverseTransform</a> (raft::handle_t &amp;handle, float *trans_input, float *components, float *singular_vals, float *mu, float *input, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ab49f1e8617076366a9be1fac04b8c92d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af6dc66b3d7ba1d41b448d4317272fbbc"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af6dc66b3d7ba1d41b448d4317272fbbc">pcaInverseTransform</a> (raft::handle_t &amp;handle, double *trans_input, double *components, double *singular_vals, double *mu, double *input, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:af6dc66b3d7ba1d41b448d4317272fbbc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9930aa036bcf52cf182f000ce355cdcd"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9930aa036bcf52cf182f000ce355cdcd">pcaTransform</a> (raft::handle_t &amp;handle, float *input, float *components, float *trans_input, float *singular_vals, float *mu, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a9930aa036bcf52cf182f000ce355cdcd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac37aa9b10bb7445d9b3523dae260e681"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac37aa9b10bb7445d9b3523dae260e681">pcaTransform</a> (raft::handle_t &amp;handle, double *input, double *components, double *trans_input, double *singular_vals, double *mu, const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:ac37aa9b10bb7445d9b3523dae260e681"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2a071bdcbc710b1a4ca88efc02fd2489"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2a071bdcbc710b1a4ca88efc02fd2489">tsvdFit</a> (raft::handle_t &amp;handle, float *input, float *components, float *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a2a071bdcbc710b1a4ca88efc02fd2489"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:add33f23b1a15823449837dc884b13ddd"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#add33f23b1a15823449837dc884b13ddd">tsvdFit</a> (raft::handle_t &amp;handle, double *input, double *components, double *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:add33f23b1a15823449837dc884b13ddd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac335d131520793dcf0831d753e1c7ab2"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac335d131520793dcf0831d753e1c7ab2">tsvdInverseTransform</a> (raft::handle_t &amp;handle, float *trans_input, float *components, float *input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ac335d131520793dcf0831d753e1c7ab2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae2faa9e0c83e9270369e866281802624"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae2faa9e0c83e9270369e866281802624">tsvdInverseTransform</a> (raft::handle_t &amp;handle, double *trans_input, double *components, double *input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ae2faa9e0c83e9270369e866281802624"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1a8f7fa23231a10eb02ea2a3d4923335"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1a8f7fa23231a10eb02ea2a3d4923335">tsvdTransform</a> (raft::handle_t &amp;handle, float *input, float *components, float *trans_input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a1a8f7fa23231a10eb02ea2a3d4923335"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a83f6113e72b200d0a4bef2759285a6ca"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a83f6113e72b200d0a4bef2759285a6ca">tsvdTransform</a> (raft::handle_t &amp;handle, double *input, double *components, double *trans_input, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a83f6113e72b200d0a4bef2759285a6ca"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afba20c39f0790075843e9236fd043ca1"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afba20c39f0790075843e9236fd043ca1">tsvdFitTransform</a> (raft::handle_t &amp;handle, float *input, float *trans_input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:afba20c39f0790075843e9236fd043ca1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae1a46cc3b471efc453be9e8fbecba363"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae1a46cc3b471efc453be9e8fbecba363">tsvdFitTransform</a> (raft::handle_t &amp;handle, double *input, double *trans_input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ae1a46cc3b471efc453be9e8fbecba363"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5c7fcf2379a3d18e1c08840ff530eda9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5c7fcf2379a3d18e1c08840ff530eda9">set_all_rf_metrics</a> (<a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> rf_type, float accuracy, double mean_abs_error, double mean_squared_error, double median_abs_error)</td></tr>
<tr class="separator:a5c7fcf2379a3d18e1c08840ff530eda9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a85f241652a9dfc89e280200e7618ed32"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85f241652a9dfc89e280200e7618ed32">set_rf_metrics_classification</a> (float accuracy)</td></tr>
<tr class="separator:a85f241652a9dfc89e280200e7618ed32"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaa0b5eb27fbd28c93285b9ada72930d8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aaa0b5eb27fbd28c93285b9ada72930d8">set_rf_metrics_regression</a> (double mean_abs_error, double mean_squared_error, double median_abs_error)</td></tr>
<tr class="separator:aaa0b5eb27fbd28c93285b9ada72930d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a390319c6e316ef242d477e8fa326f2d0"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a390319c6e316ef242d477e8fa326f2d0">print</a> (const <a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> rf_metrics)</td></tr>
<tr class="separator:a390319c6e316ef242d477e8fa326f2d0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa25bebb87dff8c328b2d4809f640f789"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa25bebb87dff8c328b2d4809f640f789">preprocess_labels</a> (int n_rows, std::vector&lt; int &gt; &amp;labels, std::map&lt; int, int &gt; &amp;labels_map, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aa25bebb87dff8c328b2d4809f640f789"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a05ee22c0f2c66e9bb7d60c72e5d61b32"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a05ee22c0f2c66e9bb7d60c72e5d61b32">postprocess_labels</a> (int n_rows, std::vector&lt; int &gt; &amp;labels, std::map&lt; int, int &gt; &amp;labels_map, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a05ee22c0f2c66e9bb7d60c72e5d61b32"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a47bd45d133f5b3bb3748a6e5d1c61c91"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a47bd45d133f5b3bb3748a6e5d1c61c91"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a47bd45d133f5b3bb3748a6e5d1c61c91">delete_rf_metadata</a> (<a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a47bd45d133f5b3bb3748a6e5d1c61c91"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a365ba29d7ab5eef114015814d9d610ea"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a365ba29d7ab5eef114015814d9d610ea"><td align="right" class="memTemplItemLeft" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a365ba29d7ab5eef114015814d9d610ea">get_rf_summary_text</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a365ba29d7ab5eef114015814d9d610ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8af17368b9e59dd87348191cb9129388"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a8af17368b9e59dd87348191cb9129388"><td align="right" class="memTemplItemLeft" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8af17368b9e59dd87348191cb9129388">get_rf_detailed_text</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a8af17368b9e59dd87348191cb9129388"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a20b4def2d270c337188e8d3a27bd04df"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a20b4def2d270c337188e8d3a27bd04df"><td align="right" class="memTemplItemLeft" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a20b4def2d270c337188e8d3a27bd04df">get_rf_json</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a20b4def2d270c337188e8d3a27bd04df"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afbfb9c47569c55ab326bf282f8dba1e9"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:afbfb9c47569c55ab326bf282f8dba1e9"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#afbfb9c47569c55ab326bf282f8dba1e9">build_treelite_forest</a> (<a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> *model, const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest, int num_features)</td></tr>
<tr class="separator:afbfb9c47569c55ab326bf282f8dba1e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"><td align="right" class="memItemLeft" valign="top"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee">concatenate_trees</a> (std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; treelite_handles)</td></tr>
<tr class="separator:ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af142813513ee46988a79fd3dc4ab52a6"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af142813513ee46988a79fd3dc4ab52a6">compare_concat_forest_to_subforests</a> (<a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> concat_tree_handle, std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; treelite_handles)</td></tr>
<tr class="separator:af142813513ee46988a79fd3dc4ab52a6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2e62adbaee80935246fc0ff937575b59"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2e62adbaee80935246fc0ff937575b59">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&amp;forest, float *input, int n_rows, int n_cols, int *labels, int n_unique_labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a2e62adbaee80935246fc0ff937575b59"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a38cfdf38af3291baa8b4a5f3a33b74a9"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a38cfdf38af3291baa8b4a5f3a33b74a9">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&amp;forest, double *input, int n_rows, int n_cols, int *labels, int n_unique_labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a38cfdf38af3291baa8b4a5f3a33b74a9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0a63f42d57ee6287cedb49f48a6fa220"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0a63f42d57ee6287cedb49f48a6fa220">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const float *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a0a63f42d57ee6287cedb49f48a6fa220"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a014e0b6e471acfa9829c62a05de49275"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a014e0b6e471acfa9829c62a05de49275">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const double *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a014e0b6e471acfa9829c62a05de49275"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae91cc5ebb6e5b37e754ada49a37c3f2f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae91cc5ebb6e5b37e754ada49a37c3f2f">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const int *ref_labels, int n_rows, const int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ae91cc5ebb6e5b37e754ada49a37c3f2f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aeff6bb49e843ea8d5135439648e633a8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeff6bb49e843ea8d5135439648e633a8">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const int *ref_labels, int n_rows, const int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aeff6bb49e843ea8d5135439648e633a8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa769073009de30a12fdfc939d9501d3c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__params.html">RF_params</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa769073009de30a12fdfc939d9501d3c">set_rf_params</a> (int max_depth, int max_leaves, float max_features, int max_n_bins, int min_samples_leaf, int min_samples_split, float min_impurity_decrease, bool bootstrap, int n_trees, float max_samples, uint64_t seed, <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> split_criterion, int cfg_n_streams, int max_batch_size)</td></tr>
<tr class="separator:aa769073009de30a12fdfc939d9501d3c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a970c9a51cb7fb36680c2f2e3ad88dca4"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a970c9a51cb7fb36680c2f2e3ad88dca4">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&amp;forest, float *input, int n_rows, int n_cols, float *labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a970c9a51cb7fb36680c2f2e3ad88dca4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4dfca11198fa7304d1568c6c7ff09469"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4dfca11198fa7304d1568c6c7ff09469">fit</a> (const raft::handle_t &amp;user_handle, <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&amp;forest, double *input, int n_rows, int n_cols, double *labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a4dfca11198fa7304d1568c6c7ff09469"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9ebff9eb10e9bcf8c9e2d9b6533259b"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae9ebff9eb10e9bcf8c9e2d9b6533259b">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *forest, const float *input, int n_rows, int n_cols, float *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ae9ebff9eb10e9bcf8c9e2d9b6533259b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afd7a72d075a98a0f8eeb197c81554348"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afd7a72d075a98a0f8eeb197c81554348">predict</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *forest, const double *input, int n_rows, int n_cols, double *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:afd7a72d075a98a0f8eeb197c81554348"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a04e5fbd639ed8b2820ad3a1500d26732"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a04e5fbd639ed8b2820ad3a1500d26732">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *forest, const float *ref_labels, int n_rows, const float *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a04e5fbd639ed8b2820ad3a1500d26732"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa819cc3c995f572099b9b84e0897cd76"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa819cc3c995f572099b9b84e0897cd76">score</a> (const raft::handle_t &amp;user_handle, const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *forest, const double *ref_labels, int n_rows, const double *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aa819cc3c995f572099b9b84e0897cd76"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a410f1cf88e4867ba6793a7f98e98210c"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a410f1cf88e4867ba6793a7f98e98210c">TSNE_fit</a> (const raft::handle_t &amp;handle, float *X, float *Y, int n, int p, int64_t *knn_indices, float *knn_dists, <a class="el" href="structML_1_1TSNEParams.html">TSNEParams</a> &amp;<a class="el" href="classML_1_1params.html">params</a>, float *kl_div=nullptr)</td></tr>
<tr class="memdesc:a410f1cf88e4867ba6793a7f98e98210c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dimensionality reduction via TSNE using Barnes-Hut, Fourier Interpolation, or naive methods. or brute force O(N^2).  <a href="namespaceML.html#a410f1cf88e4867ba6793a7f98e98210c">More...</a><br></td></tr>
<tr class="separator:a410f1cf88e4867ba6793a7f98e98210c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9e76eb2f3473269bd00296408c41689d"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9e76eb2f3473269bd00296408c41689d">TSNE_fit_sparse</a> (const raft::handle_t &amp;handle, int *indptr, int *indices, float *data, float *Y, int nnz, int n, int p, int *knn_indices, float *knn_dists, <a class="el" href="structML_1_1TSNEParams.html">TSNEParams</a> &amp;<a class="el" href="classML_1_1params.html">params</a>, float *kl_div=nullptr)</td></tr>
<tr class="memdesc:a9e76eb2f3473269bd00296408c41689d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2).  <a href="namespaceML.html#a9e76eb2f3473269bd00296408c41689d">More...</a><br></td></tr>
<tr class="separator:a9e76eb2f3473269bd00296408c41689d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5bcb25fe2fd014d74ea5afb5eae005d3"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5bcb25fe2fd014d74ea5afb5eae005d3">brute_force_knn</a> (const raft::handle_t &amp;handle, std::vector&lt; float * &gt; &amp;input, std::vector&lt; int &gt; &amp;sizes, int D, float *search_items, int n, int64_t *res_I, float *res_D, int k, bool rowMajorIndex=false, bool rowMajorQuery=false, raft::distance::DistanceType metric=raft::distance::DistanceType::L2Expanded, float metric_arg=2.0f)</td></tr>
<tr class="memdesc:a5bcb25fe2fd014d74ea5afb5eae005d3"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flat C++ API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances.  <a href="namespaceML.html#a5bcb25fe2fd014d74ea5afb5eae005d3">More...</a><br></td></tr>
<tr class="separator:a5bcb25fe2fd014d74ea5afb5eae005d3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abfedc6e55f224b411a05f5e53a4c496e"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#abfedc6e55f224b411a05f5e53a4c496e">rbc_build_index</a> (const raft::handle_t &amp;handle, raft::spatial::knn::BallCoverIndex&lt; int64_t, float, uint32_t &gt; &amp;index)</td></tr>
<tr class="separator:abfedc6e55f224b411a05f5e53a4c496e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:af71753070b33e0cfa23bbe45676da531"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af71753070b33e0cfa23bbe45676da531">rbc_knn_query</a> (const raft::handle_t &amp;handle, raft::spatial::knn::BallCoverIndex&lt; int64_t, float, uint32_t &gt; &amp;index, uint32_t k, const float *search_items, uint32_t n_search_items, int64_t *out_inds, float *out_dists)</td></tr>
<tr class="separator:af71753070b33e0cfa23bbe45676da531"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0b04906cf66614c52cc3cf4b63f272a2"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a0b04906cf66614c52cc3cf4b63f272a2">approx_knn_build_index</a> (raft::handle_t &amp;handle, raft::spatial::knn::knnIndex *index, raft::spatial::knn::knnIndexParam *<a class="el" href="classML_1_1params.html">params</a>, raft::distance::DistanceType metric, float metricArg, float *index_array, int n, int D)</td></tr>
<tr class="memdesc:a0b04906cf66614c52cc3cf4b63f272a2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flat C++ API function to build an approximate nearest neighbors index from an index array and a set of parameters.  <a href="namespaceML.html#a0b04906cf66614c52cc3cf4b63f272a2">More...</a><br></td></tr>
<tr class="separator:a0b04906cf66614c52cc3cf4b63f272a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7e753b531173235ace7c5c84b8400127"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7e753b531173235ace7c5c84b8400127">approx_knn_search</a> (raft::handle_t &amp;handle, float *distances, int64_t *indices, raft::spatial::knn::knnIndex *index, int k, float *query_array, int n)</td></tr>
<tr class="memdesc:a7e753b531173235ace7c5c84b8400127"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flat C++ API function to perform an approximate nearest neighbors search from previously built index and a query array.  <a href="namespaceML.html#a7e753b531173235ace7c5c84b8400127">More...</a><br></td></tr>
<tr class="separator:a7e753b531173235ace7c5c84b8400127"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a181e3084eb03bbcfdcde71c281141555"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a181e3084eb03bbcfdcde71c281141555">knn_classify</a> (raft::handle_t &amp;handle, int *out, int64_t *knn_indices, std::vector&lt; int * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a181e3084eb03bbcfdcde71c281141555"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flat C++ API function to perform a knn classification using a given a vector of label arrays. This supports multilabel classification by classifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn.  <a href="namespaceML.html#a181e3084eb03bbcfdcde71c281141555">More...</a><br></td></tr>
<tr class="separator:a181e3084eb03bbcfdcde71c281141555"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a876ab255e2fc9f989d251f3ff57af5d5"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a876ab255e2fc9f989d251f3ff57af5d5">knn_regress</a> (raft::handle_t &amp;handle, float *out, int64_t *knn_indices, std::vector&lt; float * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a876ab255e2fc9f989d251f3ff57af5d5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flat C++ API function to perform a knn regression using a given a vector of label arrays. This supports multilabel regression by clasifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn.  <a href="namespaceML.html#a876ab255e2fc9f989d251f3ff57af5d5">More...</a><br></td></tr>
<tr class="separator:a876ab255e2fc9f989d251f3ff57af5d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8260b0b9f0efd7893d8b1c925c6839f0"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8260b0b9f0efd7893d8b1c925c6839f0">knn_class_proba</a> (raft::handle_t &amp;handle, std::vector&lt; float * &gt; &amp;out, int64_t *knn_indices, std::vector&lt; int * &gt; &amp;y, size_t n_index_rows, size_t n_query_rows, int k)</td></tr>
<tr class="memdesc:a8260b0b9f0efd7893d8b1c925c6839f0"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flat C++ API function to compute knn class probabilities using a vector of device arrays containing discrete class labels. Note that the output is a vector, which is.  <a href="namespaceML.html#a8260b0b9f0efd7893d8b1c925c6839f0">More...</a><br></td></tr>
<tr class="separator:a8260b0b9f0efd7893d8b1c925c6839f0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga751d8a984b4aacd46234f7a8017f30aa"><td class="memTemplParams" colspan="2">template&lt;typename math_t &gt; </td></tr>
<tr class="memitem:ga751d8a984b4aacd46234f7a8017f30aa"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga751d8a984b4aacd46234f7a8017f30aa">RPROJfit</a> (const raft::handle_t &amp;handle, <a class="el" href="structML_1_1rand__mat.html">rand_mat</a>&lt; math_t &gt; *random_matrix, <a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:ga751d8a984b4aacd46234f7a8017f30aa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ga5ba9ec2edbeb657dd2247d0207647fb2"><td class="memTemplParams" colspan="2">template&lt;typename math_t &gt; </td></tr>
<tr class="memitem:ga5ba9ec2edbeb657dd2247d0207647fb2"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga5ba9ec2edbeb657dd2247d0207647fb2">RPROJtransform</a> (const raft::handle_t &amp;handle, math_t *input, <a class="el" href="structML_1_1rand__mat.html">rand_mat</a>&lt; math_t &gt; *random_matrix, math_t *output, <a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:ga5ba9ec2edbeb657dd2247d0207647fb2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:gacb2b3ebad5d3f97745d7d8d8e57d8345"><td align="right" class="memItemLeft" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#gacb2b3ebad5d3f97745d7d8d8e57d8345">johnson_lindenstrauss_min_dim</a> (size_t n_samples, double eps)</td></tr>
<tr class="separator:gacb2b3ebad5d3f97745d7d8d8e57d8345"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7a236db2676ab7c1363895c81faa085a"><td align="right" class="memItemLeft" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7a236db2676ab7c1363895c81faa085a">divide_by_mask_build_index</a> (const raft::handle_t &amp;handle, const bool *d_mask, int *d_index, int batch_size)</td></tr>
<tr class="separator:a7a236db2676ab7c1363895c81faa085a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac30d243b4af52a353b388781f6c80bbd"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac30d243b4af52a353b388781f6c80bbd">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const float *d_in, const bool *d_mask, const int *d_index, float *d_out0, float *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:ac30d243b4af52a353b388781f6c80bbd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8664a4caa2bb7efe45a4772fef29dc6a"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8664a4caa2bb7efe45a4772fef29dc6a">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const double *d_in, const bool *d_mask, const int *d_index, double *d_out0, double *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:a8664a4caa2bb7efe45a4772fef29dc6a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a77087155e5d034998297612c318b44c4"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a77087155e5d034998297612c318b44c4">divide_by_mask_execute</a> (const raft::handle_t &amp;handle, const int *d_in, const bool *d_mask, const int *d_index, int *d_out0, int *d_out1, int batch_size, int n_obs)</td></tr>
<tr class="separator:a77087155e5d034998297612c318b44c4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a96e538801438dbf2cb14b387bbfb5a66"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a96e538801438dbf2cb14b387bbfb5a66">divide_by_min_build_index</a> (const raft::handle_t &amp;handle, const float *d_matrix, int *d_batch, int *d_index, int *h_size, int batch_size, int n_sub)</td></tr>
<tr class="separator:a96e538801438dbf2cb14b387bbfb5a66"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1ec36247a6875e497c2258a27da253e8"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1ec36247a6875e497c2258a27da253e8">divide_by_min_build_index</a> (const raft::handle_t &amp;handle, const double *d_matrix, int *d_batch, int *d_index, int *h_size, int batch_size, int n_sub)</td></tr>
<tr class="separator:a1ec36247a6875e497c2258a27da253e8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2c70b44dbd2190b2b78f5b79b2374428"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2c70b44dbd2190b2b78f5b79b2374428">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const float *d_in, const int *d_batch, const int *d_index, float **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a2c70b44dbd2190b2b78f5b79b2374428"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a806f5807932256b6be674a37bd993dd9"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a806f5807932256b6be674a37bd993dd9">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const double *d_in, const int *d_batch, const int *d_index, double **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a806f5807932256b6be674a37bd993dd9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a266431bebb4a84c70458265ea26b393b"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a266431bebb4a84c70458265ea26b393b">divide_by_min_execute</a> (const raft::handle_t &amp;handle, const int *d_in, const int *d_batch, const int *d_index, int **hd_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a266431bebb4a84c70458265ea26b393b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a27ed4fdb2f62155d0a1fd81f1405a779"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a27ed4fdb2f62155d0a1fd81f1405a779">build_division_map</a> (const raft::handle_t &amp;handle, const int *const *hd_id, const int *h_size, int *d_id_to_pos, int *d_id_to_model, int batch_size, int n_sub)</td></tr>
<tr class="separator:a27ed4fdb2f62155d0a1fd81f1405a779"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aeb8f25b52e0576997c85d1488367ab76"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aeb8f25b52e0576997c85d1488367ab76">merge_series</a> (const raft::handle_t &amp;handle, const float *const *hd_in, const int *d_id_to_pos, const int *d_id_to_sub, float *d_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:aeb8f25b52e0576997c85d1488367ab76"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a03e79871ae0209450671f11bcd8965fe"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a03e79871ae0209450671f11bcd8965fe">merge_series</a> (const raft::handle_t &amp;handle, const double *const *hd_in, const int *d_id_to_pos, const int *d_id_to_sub, double *d_out, int batch_size, int n_sub, int n_obs)</td></tr>
<tr class="separator:a03e79871ae0209450671f11bcd8965fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad048e7644ca470414dc9c7fca5f2e189"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad048e7644ca470414dc9c7fca5f2e189">pack</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, double *param_vec)</td></tr>
<tr class="separator:ad048e7644ca470414dc9c7fca5f2e189"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a62e41ec81cdf10cea7be42c97eca6b32"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a62e41ec81cdf10cea7be42c97eca6b32">unpack</a> (raft::handle_t &amp;handle, <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, const double *param_vec)</td></tr>
<tr class="separator:a62e41ec81cdf10cea7be42c97eca6b32"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3a7c252319fa102dfaead500dbaa83ee"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a3a7c252319fa102dfaead500dbaa83ee">detect_missing</a> (raft::handle_t &amp;handle, const double *d_y, int n_elem)</td></tr>
<tr class="separator:a3a7c252319fa102dfaead500dbaa83ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa0653c7b782547550d2d8df07038e28a"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa0653c7b782547550d2d8df07038e28a">batched_diff</a> (raft::handle_t &amp;handle, double *d_y_diff, const double *d_y, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order)</td></tr>
<tr class="separator:aa0653c7b782547550d2d8df07038e28a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2fe6393b8a440eef88c0625396b30ab4"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2fe6393b8a440eef88c0625396b30ab4">batched_loglike</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;arima_mem, const double *d_y, const double *d_exog, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const double *d_params, double *loglike, bool trans=true, bool host_loglike=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0)</td></tr>
<tr class="separator:a2fe6393b8a440eef88c0625396b30ab4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aef259891fbd2c5be70a80bffa1c6f6ed"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aef259891fbd2c5be70a80bffa1c6f6ed">batched_loglike</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;arima_mem, const double *d_y, const double *d_exog, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *loglike, bool trans=true, bool host_loglike=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0, int fc_steps=0, double *d_fc=nullptr, const double *d_exog_fut=nullptr, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:aef259891fbd2c5be70a80bffa1c6f6ed"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac1827cfd4f77f39642b2d63ac3673a7f"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac1827cfd4f77f39642b2d63ac3673a7f">batched_loglike_grad</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;arima_mem, const double *d_y, const double *d_exog, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const double *d_x, double *d_grad, double h, bool trans=true, <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a> method=<a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a>, int truncate=0)</td></tr>
<tr class="separator:ac1827cfd4f77f39642b2d63ac3673a7f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab23b1b968627b8696bb2732a7f1c569b"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab23b1b968627b8696bb2732a7f1c569b">predict</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;arima_mem, const double *d_y, const double *d_exog, const double *d_exog_fut, int batch_size, int n_obs, int start, int end, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *d_y_p, bool pre_diff=true, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:ab23b1b968627b8696bb2732a7f1c569b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a929e4be9e31499ba403e35147a042dd3"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a929e4be9e31499ba403e35147a042dd3">information_criterion</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;arima_mem, const double *d_y, const double *d_exog, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *ic, int ic_type)</td></tr>
<tr class="separator:a929e4be9e31499ba403e35147a042dd3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a10c3cbeb4482a0ad20bb49530c5845a1"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a10c3cbeb4482a0ad20bb49530c5845a1">estimate_x0</a> (raft::handle_t &amp;handle, <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const double *d_y, const double *d_exog, int batch_size, int n_obs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, bool missing)</td></tr>
<tr class="separator:a10c3cbeb4482a0ad20bb49530c5845a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7c87177379d64bd5756f863e78d02920"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7c87177379d64bd5756f863e78d02920">batched_kalman_filter</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;arima_mem, const double *d_ys, const double *d_exog, int nobs, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, double *d_loglike, double *d_pred, int fc_steps=0, double *d_fc=nullptr, const double *d_exog_fut=nullptr, double level=0, double *d_lower=nullptr, double *d_upper=nullptr)</td></tr>
<tr class="separator:a7c87177379d64bd5756f863e78d02920"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a65319ca6c214573f7c2f450af1587b10"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a65319ca6c214573f7c2f450af1587b10">batched_jones_transform</a> (raft::handle_t &amp;handle, const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;arima_mem, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, bool isInv, const double *h_params, double *h_Tparams)</td></tr>
<tr class="separator:a65319ca6c214573f7c2f450af1587b10"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9d769926cc27c80a2daa3779c606c133"><td align="right" class="memItemLeft" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9d769926cc27c80a2daa3779c606c133">convert_level_to_spdlog</a> (int level)</td></tr>
<tr class="separator:a9d769926cc27c80a2daa3779c606c133"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a98c6eb4be0b83cb7e0fdceb1890bff09"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a98c6eb4be0b83cb7e0fdceb1890bff09">PUSH_RANGE</a> (const char *name, cudaStream_t stream)</td></tr>
<tr class="memdesc:a98c6eb4be0b83cb7e0fdceb1890bff09"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronize CUDA stream and push a named nvtx range.  <a href="namespaceML.html#a98c6eb4be0b83cb7e0fdceb1890bff09">More...</a><br></td></tr>
<tr class="separator:a98c6eb4be0b83cb7e0fdceb1890bff09"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7a0bba9857ed5cdfd28c6801397bd629"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7a0bba9857ed5cdfd28c6801397bd629">POP_RANGE</a> (cudaStream_t stream)</td></tr>
<tr class="memdesc:a7a0bba9857ed5cdfd28c6801397bd629"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronize CUDA stream and pop the latest nvtx range.  <a href="namespaceML.html#a7a0bba9857ed5cdfd28c6801397bd629">More...</a><br></td></tr>
<tr class="separator:a7a0bba9857ed5cdfd28c6801397bd629"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aacfa74158f3a2d08f6ddae02dbfb2992"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aacfa74158f3a2d08f6ddae02dbfb2992">PUSH_RANGE</a> (const char *name)</td></tr>
<tr class="memdesc:aacfa74158f3a2d08f6ddae02dbfb2992"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push a named nvtx range.  <a href="namespaceML.html#aacfa74158f3a2d08f6ddae02dbfb2992">More...</a><br></td></tr>
<tr class="separator:aacfa74158f3a2d08f6ddae02dbfb2992"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a516be7eeb210dc391738e9761a886533"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a516be7eeb210dc391738e9761a886533">POP_RANGE</a> ()</td></tr>
<tr class="separator:a516be7eeb210dc391738e9761a886533"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ade93a97a74c6066275732d53b89a7924"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade93a97a74c6066275732d53b89a7924"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#ade93a97a74c6066275732d53b89a7924">col_ref</a> (const <a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a>&lt; T &gt; &amp;mat, <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;mask_vec, int c)</td></tr>
<tr class="separator:ade93a97a74c6066275732d53b89a7924"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a411091b6638707f057c286963fdb2020"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a411091b6638707f057c286963fdb2020"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a411091b6638707f057c286963fdb2020">col_slice</a> (const <a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a>&lt; T &gt; &amp;mat, <a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a>&lt; T &gt; &amp;mask_mat, int c_from, int c_to)</td></tr>
<tr class="separator:a411091b6638707f057c286963fdb2020"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa26eb6f901f60a627870dab82f51163f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa26eb6f901f60a627870dab82f51163f"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa26eb6f901f60a627870dab82f51163f">dot</a> (const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;u, const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;v, T *tmp_dev, cudaStream_t stream)</td></tr>
<tr class="separator:aa26eb6f901f60a627870dab82f51163f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7d821c8424317cc8e30a01b0865c7065"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d821c8424317cc8e30a01b0865c7065"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7d821c8424317cc8e30a01b0865c7065">squaredNorm</a> (const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;u, T *tmp_dev, cudaStream_t stream)</td></tr>
<tr class="separator:a7d821c8424317cc8e30a01b0865c7065"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a67d0763a9020f84d5b37e00b1521aaaa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67d0763a9020f84d5b37e00b1521aaaa"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a67d0763a9020f84d5b37e00b1521aaaa">nrmMax</a> (const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;u, T *tmp_dev, cudaStream_t stream)</td></tr>
<tr class="separator:a67d0763a9020f84d5b37e00b1521aaaa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab19bed3d33dd9a3768cc92ecba4efd77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab19bed3d33dd9a3768cc92ecba4efd77"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab19bed3d33dd9a3768cc92ecba4efd77">nrm2</a> (const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;u, T *tmp_dev, cudaStream_t stream)</td></tr>
<tr class="separator:ab19bed3d33dd9a3768cc92ecba4efd77"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a41fe9550f11d82b97c1af6ffdb216483"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41fe9550f11d82b97c1af6ffdb216483"><td align="right" class="memTemplItemLeft" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a41fe9550f11d82b97c1af6ffdb216483">nrm1</a> (const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;u, T *tmp_dev, cudaStream_t stream)</td></tr>
<tr class="separator:a41fe9550f11d82b97c1af6ffdb216483"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a50e65dec1cbb50a447d4d3165fb50aa3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50e65dec1cbb50a447d4d3165fb50aa3"><td align="right" class="memTemplItemLeft" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a50e65dec1cbb50a447d4d3165fb50aa3">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a50e65dec1cbb50a447d4d3165fb50aa3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a42d8744a9a6b6bdce6e93cc5369e413f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42d8744a9a6b6bdce6e93cc5369e413f"><td align="right" class="memTemplItemLeft" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a42d8744a9a6b6bdce6e93cc5369e413f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a>&lt; T &gt; &amp;mat)</td></tr>
<tr class="separator:a42d8744a9a6b6bdce6e93cc5369e413f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acbff3f13c07b3d57dbacc60b3646655f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbff3f13c07b3d57dbacc60b3646655f"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#acbff3f13c07b3d57dbacc60b3646655f">check_csr</a> (const <a class="el" href="structML_1_1SimpleSparseMat.html">SimpleSparseMat</a>&lt; T &gt; &amp;mat, cudaStream_t stream)</td></tr>
<tr class="separator:acbff3f13c07b3d57dbacc60b3646655f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae35e676e51ff45e1c239f3ca6387796e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae35e676e51ff45e1c239f3ca6387796e"><td align="right" class="memTemplItemLeft" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae35e676e51ff45e1c239f3ca6387796e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structML_1_1SimpleSparseMat.html">SimpleSparseMat</a>&lt; T &gt; &amp;mat)</td></tr>
<tr class="separator:ae35e676e51ff45e1c239f3ca6387796e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a57fd5e0a140f0ee4ccef55173c038c97"><td align="right" class="memItemLeft" valign="top"><a class="el" href="cuml__api_8h.html#a8df780989bb7721c053f639cd9845911">cumlError_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a57fd5e0a140f0ee4ccef55173c038c97">knn_search</a> (const <a class="el" href="cuml__api_8h.html#a30e042c19d08153b33363b358c223156">cumlHandle_t</a> handle, float **input, int *sizes, int n_params, int D, float *search_items, int n, int64_t *res_I, float *res_D, int k, bool rowMajorIndex, bool rowMajorQuery, int metric_type, float metric_arg, bool expanded)</td></tr>
<tr class="memdesc:a57fd5e0a140f0ee4ccef55173c038c97"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flat C API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances.  <a href="namespaceML.html#a57fd5e0a140f0ee4ccef55173c038c97">More...</a><br></td></tr>
<tr class="separator:a57fd5e0a140f0ee4ccef55173c038c97"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae9e9f22920ecd0dd7ab05981dd3a0cac"><td align="right" class="memItemLeft" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae9e9f22920ecd0dd7ab05981dd3a0cac">get_device</a> (const void *ptr)</td></tr>
<tr class="separator:ae9e9f22920ecd0dd7ab05981dd3a0cac"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2ea5c03024c5683984f17d889421f40c"><td align="right" class="memItemLeft" valign="top">cudaMemoryType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2ea5c03024c5683984f17d889421f40c">memory_type</a> (const void *p)</td></tr>
<tr class="separator:a2ea5c03024c5683984f17d889421f40c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a13b2600cf250418d851752f64d633860"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a13b2600cf250418d851752f64d633860">is_device_or_managed_type</a> (const void *p)</td></tr>
<tr class="separator:a13b2600cf250418d851752f64d633860"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7181e4d6d170b0aa91dc7a368abf3d1c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7181e4d6d170b0aa91dc7a368abf3d1c">handleMap</a></td></tr>
<tr class="memdesc:a7181e4d6d170b0aa91dc7a368abf3d1c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static handle map instance (see <a class="el" href="cumlHandle_8cpp.html">cumlHandle.cpp</a>)  <a href="namespaceML.html#a7181e4d6d170b0aa91dc7a368abf3d1c">More...</a><br></td></tr>
<tr class="separator:a7181e4d6d170b0aa91dc7a368abf3d1c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4ac020f9f913af2af87de5e462b72aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac020f9f913af2af87de5e462b72aba">&nbsp;</a></span>knn_indices_dense_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef int64_t <a class="el" href="namespaceML.html#a4ac020f9f913af2af87de5e462b72aba">ML::knn_indices_dense_t</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a59bd3f642cc2f46bedc2c7059cac837a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bd3f642cc2f46bedc2c7059cac837a">&nbsp;</a></span>knn_indices_sparse_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef int <a class="el" href="namespaceML.html#a59bd3f642cc2f46bedc2c7059cac837a">ML::knn_indices_sparse_t</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a239d146c5a5545dd84e3d0b6e305f631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239d146c5a5545dd84e3d0b6e305f631">&nbsp;</a></span>paramsPCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a> <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">ML::paramsPCA</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ff6828291243eca3956818d2f309339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff6828291243eca3956818d2f309339">&nbsp;</a></span>paramsPCAMG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a>&lt;<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a>&gt; <a class="el" href="namespaceML.html#a9ff6828291243eca3956818d2f309339">ML::paramsPCAMG</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2bffedf6f8d520e216a6542ebf6a0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bffedf6f8d520e216a6542ebf6a0f1">&nbsp;</a></span>paramsTSVD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a> <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">ML::paramsTSVD</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3b799705dfc8991beaf24c9a906bc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b799705dfc8991beaf24c9a906bc76">&nbsp;</a></span>paramsTSVDMG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a>&lt;<a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">mg_solver</a>&gt; <a class="el" href="namespaceML.html#ae3b799705dfc8991beaf24c9a906bc76">ML::paramsTSVDMG</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="acbf0352d6a255f990fcdf949b898d6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf0352d6a255f990fcdf949b898d6af">&nbsp;</a></span>RandomForestClassifierD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;double, int&gt; <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">ML::RandomForestClassifierD</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a36df48edc11fcd68dd8b6f4a76526e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36df48edc11fcd68dd8b6f4a76526e7b">&nbsp;</a></span>RandomForestClassifierF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;float, int&gt; <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">ML::RandomForestClassifierF</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a64f2117024176a6fab67a1a6b8925243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f2117024176a6fab67a1a6b8925243">&nbsp;</a></span>RandomForestRegressorD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;double, double&gt; <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">ML::RandomForestRegressorD</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a79048a796facf156e926834d97bec78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79048a796facf156e926834d97bec78f">&nbsp;</a></span>RandomForestRegressorF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;float, float&gt; <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">ML::RandomForestRegressorF</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a823912afaa51f58a997564eadb6d9405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823912afaa51f58a997564eadb6d9405">&nbsp;</a></span>CRITERION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">ML::CRITERION</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405af633f697107611ea3f0f2d18986be3e6"></a>GINI&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ab55a4e6aef097bd8f786f4ddfd1de161"></a>ENTROPY&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a746a9f45470e731c984d37744c48432e"></a>MSE&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a71d3454116e1aace7f91b15f56567b1e"></a>MAE&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a5dad58efccd3863342cf2663e989a194"></a>POISSON&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ad414050e85fc8a16b5fd1f1839bc4b90"></a>GAMMA&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405acb60653800a061d296b3df110079c769"></a>INVERSE_GAUSSIAN&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ae346b778011ef4f488c1c87d64c1b174"></a>CRITERION_END&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a0dcbb2c0993e8446dffd09b5de731a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcbb2c0993e8446dffd09b5de731a26">&nbsp;</a></span>LoglikeMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">ML::LoglikeMethod</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0dcbb2c0993e8446dffd09b5de731a26a7c2ef7613d7b9a655691f9f24b893c11"></a>CSS&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab"></a>MLE&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a67da49ce109878bcdbb29a8777d28de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67da49ce109878bcdbb29a8777d28de1">&nbsp;</a></span>loss_funct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1">ML::loss_funct</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1ad3c28e4d0ab8ed2b4c69c0483c6ffea4"></a>SQRD_LOSS&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1a007e4d0f43a45d8d9be3dde194ea410a"></a>HINGE&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1ad24128f8a7b16f59075a28323f13803d"></a>LOG&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a1adf3fea9cf9cde96ecf353b43818079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf3fea9cf9cde96ecf353b43818079">&nbsp;</a></span>lr_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079">ML::lr_type</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a5ccc94f0f9ce653134966e2377c71ca1"></a>OPTIMAL&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079aabfea584e2f24b9920a5fb3058dd06bb"></a>CONSTANT&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a98a91ed2cd2ff227d0393c406e09a106"></a>INVSCALING&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a8108470840df674d6403e12c0d2ac63a"></a>ADAPTIVE&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a9a3879adb63715cec17550171436f6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3879adb63715cec17550171436f6ab">&nbsp;</a></span>mg_solver</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a9a3879adb63715cec17550171436f6ab">ML::mg_solver</a></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba38769546eb5536bd58d5eb9922c3e0bf"></a>COV_EIG_DQ&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba3a077c1d31d8e7f29a92eb7ea002daad"></a>COV_EIG_JACOBI&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9a3879adb63715cec17550171436f6aba66c35cd8077f7e1db5faefbc048a646a"></a>QR&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a1529da2b94c67018bb14f404f6e9aeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1529da2b94c67018bb14f404f6e9aeac">&nbsp;</a></span>Norm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeac">ML::Norm</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca6527e252610c64b85fdc9fc357c979cc"></a>L0&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072"></a>L1&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e"></a>L2&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca83820f75ef6d53c49873c4269fdcdc26"></a>LINF&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a85e691126b37f5e1dc834841cad1479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e691126b37f5e1dc834841cad1479c">&nbsp;</a></span>OptimCriterion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479c">ML::OptimCriterion</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca7a9fdcb8befd1162d7ba06c5bc34bd21"></a>OPTIM_BFGS_ITER_LIMIT&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca80e3d3c81590a148d565b7ddb78ef590"></a>OPTIM_MIN_PARAM_DIFF&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca01a4b4daad43785b0587346034b10ef5"></a>OPTIM_MIN_ERROR_DIFF&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca6c4ee736abd198cfc853b82b1e3a1fcc"></a>OPTIM_MIN_GRAD_NORM&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a899c5f26e201a81a2c12bb7eed9b015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899c5f26e201a81a2c12bb7eed9b015d">&nbsp;</a></span>penalty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015d">ML::penalty</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a899c5f26e201a81a2c12bb7eed9b015daf8cf4476d6fa69254aa96e2a9b385b07"></a>NONE&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072"></a>L1&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e"></a>L2&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a899c5f26e201a81a2c12bb7eed9b015da80cad9123fc734ada9ef3a33ac30e627"></a>ELASTICNET&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a4d83b99fe769e2e9bf3596bb1604ab4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d83b99fe769e2e9bf3596bb1604ab4f">&nbsp;</a></span>RF_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">ML::RF_type</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d83b99fe769e2e9bf3596bb1604ab4fa9d8edfe721557c504d925e3bcace2edf"></a>CLASSIFICATION&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d83b99fe769e2e9bf3596bb1604ab4fa2864cd9bbe2aa57118c71b9c717c3586"></a>REGRESSION&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a8d55de18185e36dd8f8a6d735e6a91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d55de18185e36dd8f8a6d735e6a91e6">&nbsp;</a></span>SeasonalType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6">ML::SeasonalType</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d55de18185e36dd8f8a6d735e6a91e6af28ffe4c75342f4012bcf16f798e0ec3"></a>ADDITIVE&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d55de18185e36dd8f8a6d735e6a91e6abc34c50dc7f29a357f52f9e5c0308226"></a>MULTIPLICATIVE&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="a7324898185a2fc9a9145f9bad555049b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7324898185a2fc9a9145f9bad555049b">&nbsp;</a></span>solver</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#a7324898185a2fc9a9145f9bad555049b">ML::solver</a> : int</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">COV_EIG_DQ</td><td>covariance of input will be used along with eigen decomposition using divide and conquer method for symmetric matrices </td></tr>
    <tr><td class="paramname">COV_EIG_JACOBI</td><td>covariance of input will be used along with eigen decomposition using jacobi method for symmetric matrices </td></tr>
  </tbody></table>
  </dd>
</dl>
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7324898185a2fc9a9145f9bad555049ba38769546eb5536bd58d5eb9922c3e0bf"></a>COV_EIG_DQ&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7324898185a2fc9a9145f9bad555049ba3a077c1d31d8e7f29a92eb7ea002daad"></a>COV_EIG_JACOBI&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="ad2244eba7d9251930ae2519d556f18ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2244eba7d9251930ae2519d556f18ea">&nbsp;</a></span>STORAGE_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#ad2244eba7d9251930ae2519d556f18ea">ML::STORAGE_ORDER</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad2244eba7d9251930ae2519d556f18eaab5f45c1dae8374d1665f17565b583163"></a>COL_MAJOR&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2244eba7d9251930ae2519d556f18eaa45fa3fee7bc6693bf050cbc6a1b7c94e"></a>ROW_MAJOR&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="af60801cb5c9adac3f6f5bd4bd43aa2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60801cb5c9adac3f6f5bd4bd43aa2f7">&nbsp;</a></span>task_category</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">ML::task_category</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af60801cb5c9adac3f6f5bd4bd43aa2f7a88b80439ca4076839158d63d31271315"></a>REGRESSION_MODEL&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af60801cb5c9adac3f6f5bd4bd43aa2f7a9c8a19e179622826abd959f7639c7006"></a>CLASSIFICATION_MODEL&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<a id="aacbc7e98d26a8d5e8b51055651d423e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbc7e98d26a8d5e8b51055651d423e2">&nbsp;</a></span>TSNE_ALGORITHM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">enum <a class="el" href="namespaceML.html#aacbc7e98d26a8d5e8b51055651d423e2">ML::TSNE_ALGORITHM</a></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<table class="fieldtable">
<tbody><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aacbc7e98d26a8d5e8b51055651d423e2a7457fc662d7dbaabc355693f5dcb1d02"></a>EXACT&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacbc7e98d26a8d5e8b51055651d423e2a260246ddd4c5d6b1c3602dd0abb7231c"></a>BARNES_HUT&nbsp;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacbc7e98d26a8d5e8b51055651d423e2a4d99b41e47ccb1820e1b593afbc1e561"></a>FFT&nbsp;</td><td class="fielddoc"></td></tr>
</tbody></table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a355e1514f3c1be413991cf73fc2dfb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355e1514f3c1be413991cf73fc2dfb14">&nbsp;</a></span>_extract_clusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::_extract_clusters </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>lambdas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>probabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML_1_1HDBSCAN_1_1Common.html#a4f669ad45ee808dc58e4d8e81d14535b">HDBSCAN::Common::CLUSTER_SELECTION_METHOD</a>&nbsp;</td>
          <td class="paramname"><em>cluster_selection_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>allow_single_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_cluster_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>cluster_selection_epsilon</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b04906cf66614c52cc3cf4b63f272a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b04906cf66614c52cc3cf4b63f272a2">&nbsp;</a></span>approx_knn_build_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::approx_knn_build_index </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::spatial::knn::knnIndex *&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::spatial::knn::knnIndexParam *&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::distance::DistanceType&nbsp;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>metricArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>index_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>D</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Flat C++ API function to build an approximate nearest neighbors index from an index array and a set of parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>index to be built </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>parametrization of the index to be built </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Euclidean (L2) is used by default </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metricArg</td><td>metric argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index_array</td><td>the index array to build the index with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in the index array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>the dimensionality of the index array </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a7e753b531173235ace7c5c84b8400127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e753b531173235ace7c5c84b8400127">&nbsp;</a></span>approx_knn_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::approx_knn_search </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::spatial::knn::knnIndex *&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>query_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Flat C++ API function to perform an approximate nearest neighbors search from previously built index and a query array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>distances of the nearest neighbors toward their query point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>indices of the nearest neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index to perform a search with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the number of nearest neighbors to search for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">query_array</td><td>the query to perform a search with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in the query array </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="aa0653c7b782547550d2d8df07038e28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0653c7b782547550d2d8df07038e28a">&nbsp;</a></span>batched_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::batched_diff </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_y_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Compute the differenced series (seasonal and/or non-seasonal differences)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_y_diff</td><td>Differenced series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Original series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a65319ca6c214573f7c2f450af1587b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65319ca6c214573f7c2f450af1587b10">&nbsp;</a></span>batched_jones_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::batched_jones_transform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>arima_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>isInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>h_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>h_Tparams</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Convenience function for batched "jones transform" used in ARIMA to ensure certain properties of the AR and MA parameters (takes host array and returns host array)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arima_mem</td><td>Pre-allocated temporary memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series analyzed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isInv</td><td>Do the inverse transform? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_params</td><td>ARIMA parameters by batch (mu, ar, ma) (host) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h_Tparams</td><td>Transformed ARIMA parameters (expects pre-allocated array of size (p+q)*batch_size) (host) </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a7c87177379d64bd5756f863e78d02920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c87177379d64bd5756f863e78d02920">&nbsp;</a></span>batched_kalman_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::batched_kalman_filter </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>arima_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>nobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_loglike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_fc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog_fut</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_upper</em> = <code>nullptr</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>An ARIMA specialized batched kalman filter to evaluate ARMA parameters and provide the resulting prediction as well as loglikelihood fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arima_mem</td><td>Pre-allocated temporary memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_ys</td><td>Batched time series Shape (nobs, batch_size) (col-major, device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog</td><td>Batched exogenous variables Shape (nobs, n_exog * batch_size) (col-major, device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of samples per time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of series making up the batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_loglike</td><td>Resulting log-likelihood (per series) (device) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_pred</td><td>Predictions shape=(nobs-d-s*D, batch_size) (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog_fut</td><td>Future values of exogenous variables Shape (fc_steps, n_exog * batch_size) (col-major, device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="aef259891fbd2c5be70a80bffa1c6f6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef259891fbd2c5be70a80bffa1c6f6ed">&nbsp;</a></span>batched_loglike() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::batched_loglike </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>arima_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>loglike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>trans</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a>&nbsp;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>truncate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_fc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog_fut</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_upper</em> = <code>nullptr</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Compute the loglikelihood of the given parameter on the given time series in a batched context.</p>
<dl class="section note"><dt>Note</dt><dd>: this overload should be used when the parameters are already unpacked to avoid useless packing / unpacking</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arima_mem</td><td>Pre-allocated temporary memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog</td><td>Exogenous variables: shape = (n_obs, n_exog * batch_size) and expects column major data layout. (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Log-Likelihood of the model per series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog_fut</td><td>Future values of exogenous variables Shape (fc_steps, n_exog * batch_size) (col-major, device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a2fe6393b8a440eef88c0625396b30ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe6393b8a440eef88c0625396b30ab4">&nbsp;</a></span>batched_loglike() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::batched_loglike </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>arima_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>loglike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>trans</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a>&nbsp;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>truncate</em> = <code>0</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Compute the loglikelihood of the given parameter on the given time series in a batched context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arima_mem</td><td>Pre-allocated temporary memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog</td><td>Exogenous variables: shape = (n_obs, n_exog * batch_size) and expects column major data layout. (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_params</td><td>Parameters to evaluate grouped by series: [mu0, ar.., ma.., mu1, ..] (device) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Log-Likelihood of the model per series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ac1827cfd4f77f39642b2d63ac3673a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1827cfd4f77f39642b2d63ac3673a7f">&nbsp;</a></span>batched_loglike_grad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::batched_loglike_grad </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>arima_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>trans</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26">LoglikeMethod</a>&nbsp;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="namespaceML.html#a0dcbb2c0993e8446dffd09b5de731a26a92f2a8dd8be6748c2cd43657a28232ab">MLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>truncate</em> = <code>0</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Compute the gradient of the log-likelihood</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arima_mem</td><td>Pre-allocated temporary memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog</td><td>Exogenous variables: shape = (n_obs, n_exog * batch_size) and expects column major data layout. (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations in a time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_x</td><td>Parameters grouped by series </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_grad</td><td>Gradient to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Finite-differencing step size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Whether to use sum-of-squares or Kalman filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate</td><td>For CSS, start the sum-of-squares after a given number of observations </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a5bcb25fe2fd014d74ea5afb5eae005d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcb25fe2fd014d74ea5afb5eae005d3">&nbsp;</a></span>brute_force_knn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::brute_force_knn </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float * &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>search_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"><em>res_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>res_D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>rowMajorIndex</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>rowMajorQuery</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::distance::DistanceType&nbsp;</td>
          <td class="paramname"><em>metric</em> = <code>raft::distance::DistanceType::L2Expanded</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>metric_arg</em> = <code>2.0f</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Flat C++ API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>vector of pointers to the input arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>vector of sizes of input arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>the dimensionality of the arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">search_items</td><td>array of items to search of dimensionality D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in search_items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res_I</td><td>the resulting index array of size n * k </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res_D</td><td>the resulting distance array of size n * k </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the number of nearest neighbors to return </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowMajorIndex</td><td>are the index arrays in row-major order? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowMajorQuery</td><td>are the query arrays in row-major order? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Euclidean (L2) is used by default </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metric_arg</td><td>the value of <code>p</code> for Minkowski (l-p) distances. This is ignored if the metric_type is not Minkowski. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a08a0cbc81f9a9cd7ef8fb78657cf2224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a0cbc81f9a9cd7ef8fb78657cf2224">&nbsp;</a></span>build_condensed_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::build_condensed_hierarchy </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>min_cluster_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classML_1_1HDBSCAN_1_1Common_1_1CondensedHierarchy.html">HDBSCAN::Common::CondensedHierarchy</a>&lt; int, float &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>condensed_tree</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a27ed4fdb2f62155d0a1fd81f1405a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ed4fdb2f62155d0a1fd81f1405a779">&nbsp;</a></span>build_division_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::build_division_map </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *const *&nbsp;</td>
          <td class="paramname"><em>hd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>h_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_id_to_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_id_to_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_sub</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Build a map to associate each batch member with a model and index in the associated sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hd_id</td><td>Host array of pointers to device arrays containing the indices of the members of each sub-batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_size</td><td>Host array containing the size of each sub-batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_id_to_pos</td><td>Device array containing the position of each member in its new sub-batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_id_to_model</td><td>Device array associating each member with its sub-batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="afbfb9c47569c55ab326bf282f8dba1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfb9c47569c55ab326bf282f8dba1e9">&nbsp;</a></span>build_treelite_forest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::build_treelite_forest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> *&nbsp;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>num_features</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="acbff3f13c07b3d57dbacc60b3646655f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbff3f13c07b3d57dbacc60b3646655f">&nbsp;</a></span>check_csr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::check_csr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleSparseMat.html">SimpleSparseMat</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ade93a97a74c6066275732d53b89a7924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade93a97a74c6066275732d53b89a7924">&nbsp;</a></span>col_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::col_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>mask_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>c</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a411091b6638707f057c286963fdb2020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411091b6638707f057c286963fdb2020">&nbsp;</a></span>col_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::col_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>mask_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>c_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>c_to</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="af142813513ee46988a79fd3dc4ab52a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142813513ee46988a79fd3dc4ab52a6">&nbsp;</a></span>compare_concat_forest_to_subforests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::compare_concat_forest_to_subforests </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a>&nbsp;</td>
          <td class="paramname"><em>concat_tree_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt;&nbsp;</td>
          <td class="paramname"><em>treelite_handles</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee">&nbsp;</a></span>concatenate_trees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> ML::concatenate_trees </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt;&nbsp;</td>
          <td class="paramname"><em>treelite_handles</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d769926cc27c80a2daa3779c606c133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d769926cc27c80a2daa3779c606c133">&nbsp;</a></span>convert_level_to_spdlog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int ML::convert_level_to_spdlog </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a47bd45d133f5b3bb3748a6e5d1c61c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bd45d133f5b3bb3748a6e5d1c61c91">&nbsp;</a></span>delete_rf_metadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::delete_rf_metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&nbsp;</td>
          <td class="paramname"><em>forest</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a7c252319fa102dfaead500dbaa83ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7c252319fa102dfaead500dbaa83ee">&nbsp;</a></span>detect_missing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool ML::detect_missing </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_elem</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Detect missing observations in a time series</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elem</td><td>Total number of elements in the dataset </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a7a236db2676ab7c1363895c81faa085a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a236db2676ab7c1363895c81faa085a">&nbsp;</a></span>divide_by_mask_build_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int ML::divide_by_mask_build_index </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&nbsp;</td>
          <td class="paramname"><em>d_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Batch division by mask step 1: build an index of the position of each series in its new batch and measure the size of each sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mask</td><td>Boolean mask </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of 'true' series in the mask </dd></dl>

</div>
</div>
<a id="a8664a4caa2bb7efe45a4772fef29dc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8664a4caa2bb7efe45a4772fef29dc6a">&nbsp;</a></span>divide_by_mask_execute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::divide_by_mask_execute </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&nbsp;</td>
          <td class="paramname"><em>d_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_out1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ac30d243b4af52a353b388781f6c80bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d243b4af52a353b388781f6c80bbd">&nbsp;</a></span>divide_by_mask_execute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::divide_by_mask_execute </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&nbsp;</td>
          <td class="paramname"><em>d_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>d_out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>d_out1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Batch division by mask step 2: create both sub-batches from the mask and index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input batch. Each series is a contiguous chunk </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mask</td><td>Boolean mask </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out0</td><td>The sub-batch for the 'false' members </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out1</td><td>The sub-batch for the 'true' members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of data points per series </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a77087155e5d034998297612c318b44c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77087155e5d034998297612c318b44c4">&nbsp;</a></span>divide_by_mask_execute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::divide_by_mask_execute </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&nbsp;</td>
          <td class="paramname"><em>d_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_out0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_out1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ec36247a6875e497c2258a27da253e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec36247a6875e497c2258a27da253e8">&nbsp;</a></span>divide_by_min_build_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::divide_by_min_build_index </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>h_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_sub</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a96e538801438dbf2cb14b387bbfb5a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e538801438dbf2cb14b387bbfb5a66">&nbsp;</a></span>divide_by_min_build_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::divide_by_min_build_index </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>d_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>h_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_sub</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Batch division by minimum value step 1: build an index of which sub-batch each series belongs to, an index of the position of each series in its new batch, and measure the size of each sub-batch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_matrix</td><td>Matrix of the values to minimize Shape: (batch_size, n_sub) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_batch</td><td>Which sub-batch each series belongs to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_index</td><td>Index of each series in its new batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h_size</td><td>Size of each sub-batch (host) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a806f5807932256b6be674a37bd993dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806f5807932256b6be674a37bd993dd9">&nbsp;</a></span>divide_by_min_execute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::divide_by_min_execute </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"><em>hd_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c70b44dbd2190b2b78f5b79b2374428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c70b44dbd2190b2b78f5b79b2374428">&nbsp;</a></span>divide_by_min_execute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::divide_by_min_execute </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&nbsp;</td>
          <td class="paramname"><em>hd_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Batch division by minimum value step 2: create all the sub-batches</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input batch. Each series is a contiguous chunk </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_batch</td><td>Which sub-batch each series belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_index</td><td>Index of each series in its new sub-batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hd_out</td><td>Host array of pointers to device arrays of each sub-batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of data points per series </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a266431bebb4a84c70458265ea26b393b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266431bebb4a84c70458265ea26b393b">&nbsp;</a></span>divide_by_min_execute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::divide_by_min_execute </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"><em>hd_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="aa26eb6f901f60a627870dab82f51163f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26eb6f901f60a627870dab82f51163f">&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">T ML::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"><em>tmp_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a10c3cbeb4482a0ad20bb49530c5845a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c3cbeb4482a0ad20bb49530c5845a1">&nbsp;</a></span>estimate_x0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::estimate_x0 </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>missing</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Provide initial estimates to ARIMA parameters mu, AR, and MA</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog</td><td>Exogenous variables. Shape = (n_obs, n_exog * batch_size) (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">missing</td><td>Are there missing observations? </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a38cfdf38af3291baa8b4a5f3a33b74a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cfdf38af3291baa8b4a5f3a33b74a9">&nbsp;</a></span>fit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::fit </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&amp;&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_unique_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a>&nbsp;</td>
          <td class="paramname"><em>rf_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e62adbaee80935246fc0ff937575b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e62adbaee80935246fc0ff937575b59">&nbsp;</a></span>fit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::fit </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&amp;&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_unique_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a>&nbsp;</td>
          <td class="paramname"><em>rf_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a4dfca11198fa7304d1568c6c7ff09469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfca11198fa7304d1568c6c7ff09469">&nbsp;</a></span>fit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::fit </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&amp;&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a>&nbsp;</td>
          <td class="paramname"><em>rf_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a970c9a51cb7fb36680c2f2e3ad88dca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970c9a51cb7fb36680c2f2e3ad88dca4">&nbsp;</a></span>fit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::fit </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&amp;&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a>&nbsp;</td>
          <td class="paramname"><em>rf_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9e9f22920ecd0dd7ab05981dd3a0cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e9f22920ecd0dd7ab05981dd3a0cac">&nbsp;</a></span>get_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int ML::get_device </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a8af17368b9e59dd87348191cb9129388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af17368b9e59dd87348191cb9129388">&nbsp;</a></span>get_rf_detailed_text()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::string ML::get_rf_detailed_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&nbsp;</td>
          <td class="paramname"><em>forest</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a20b4def2d270c337188e8d3a27bd04df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b4def2d270c337188e8d3a27bd04df">&nbsp;</a></span>get_rf_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::string ML::get_rf_json </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&nbsp;</td>
          <td class="paramname"><em>forest</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a365ba29d7ab5eef114015814d9d610ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365ba29d7ab5eef114015814d9d610ea">&nbsp;</a></span>get_rf_summary_text()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::string ML::get_rf_summary_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&nbsp;</td>
          <td class="paramname"><em>forest</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ababb040d6ea66983187527a3cc132714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababb040d6ea66983187527a3cc132714">&nbsp;</a></span>hdbscan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::hdbscan </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::distance::DistanceType&nbsp;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classML_1_1HDBSCAN_1_1Common_1_1HDBSCANParams.html">HDBSCAN::Common::HDBSCANParams</a> &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classML_1_1HDBSCAN_1_1Common_1_1hdbscan__output.html">HDBSCAN::Common::hdbscan_output</a>&lt; int, float &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>out</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Executes <a class="el" href="namespaceML_1_1HDBSCAN.html">HDBSCAN</a> clustering on an mxn-dimensional input array, X.</p>
<p>Note that while the algorithm is generally deterministic and should provide matching results between RAPIDS and the Scikit-learn Contrib versions, the construction of the k-nearest neighbors graph and minimum spanning tree can introduce differences between the two algorithms, especially when several nearest neighbors around a point might have the same distance. While the differences in the minimum spanning trees alone might be subtle, they can (and often will) lead to some points being assigned different cluster labels between the two implementations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>raft handle for resource reuse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>array (size m, n) on device in row-major format </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in X </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of columns in X </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">metric</td><td>distance metric to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>struct of configuration hyper-parameters </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out</td><td>struct of output data and arrays on device </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a929e4be9e31499ba403e35147a042dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929e4be9e31499ba403e35147a042dd3">&nbsp;</a></span>information_criterion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::information_criterion </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>arima_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>ic_type</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Compute an information criterion (AIC, AICc, BIC)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arima_mem</td><td>Pre-allocated temporary memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (n_obs, batch_size) and expects column major data layout. (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog</td><td>Exogenous variables. Shape = (n_obs, n_exog * batch_size) (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ic</td><td>Array where to write the information criteria Shape: (batch_size) (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ic_type</td><td>Type of information criterion wanted. 0: AIC, 1: AICc, 2: BIC </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a13b2600cf250418d851752f64d633860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b2600cf250418d851752f64d633860">&nbsp;</a></span>is_device_or_managed_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool ML::is_device_or_managed_type </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a8260b0b9f0efd7893d8b1c925c6839f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8260b0b9f0efd7893d8b1c925c6839f0">&nbsp;</a></span>knn_class_proba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::knn_class_proba </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float * &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"><em>knn_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int * &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_index_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_query_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>k</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Flat C++ API function to compute knn class probabilities using a vector of device arrays containing discrete class labels. Note that the output is a vector, which is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>vector of output arrays on device. vector size = n_outputs. Each array should have size(n_samples, n_classes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>array on device of knn indices (size n_samples * k) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of labels on device (size n_samples) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of labels in y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of rows in knn_indices and out </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a181e3084eb03bbcfdcde71c281141555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181e3084eb03bbcfdcde71c281141555">&nbsp;</a></span>knn_classify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::knn_classify </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"><em>knn_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int * &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_index_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_query_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>k</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Flat C++ API function to perform a knn classification using a given a vector of label arrays. This supports multilabel classification by classifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output array on device (size n_samples * size of y vector) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>index array on device resulting from knn query (size n_samples * k) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>vector of label arrays on device vector size is number of (size n_samples) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of vertices in index (eg. size of each y array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of samples in knn_indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a876ab255e2fc9f989d251f3ff57af5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876ab255e2fc9f989d251f3ff57af5d5">&nbsp;</a></span>knn_regress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::knn_regress </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"><em>knn_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float * &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_index_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n_query_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>k</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Flat C++ API function to perform a knn regression using a given a vector of label arrays. This supports multilabel regression by clasifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>RAFT handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output array on device (size n_samples) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>array on device of knn indices (size n_samples * k) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>array of labels on device (size n_samples) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_index_rows</td><td>number of vertices in index (eg. size of each y array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_query_rows</td><td>number of samples in knn_indices and out </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a57fd5e0a140f0ee4ccef55173c038c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fd5e0a140f0ee4ccef55173c038c97">&nbsp;</a></span>knn_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="cuml__api_8h.html#a8df780989bb7721c053f639cd9845911">cumlError_t</a> ML::knn_search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cuml__api_8h.html#a30e042c19d08153b33363b358c223156">cumlHandle_t</a>&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>search_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"><em>res_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>res_D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>rowMajorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>rowMajorQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>metric_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>metric_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>expanded</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Flat C API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>an array of pointers to the input arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>an array of sizes of input arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_params</td><td>array size of input and sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>the dimensionality of the arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">search_items</td><td>array of items to search of dimensionality D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of rows in search_items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res_I</td><td>the resulting index array of size n * k </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res_D</td><td>the resulting distance array of size n * k </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the number of nearest neighbors to return </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowMajorIndex</td><td>is the index array in row major layout? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowMajorQuery</td><td>is the query array in row major layout? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metric_type</td><td>distance metric to use. Specify the metric using the integer value of the enum <code>ML::MetricType</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metric_arg</td><td>the value of <code>p</code> for Minkowski (l-p) distances. This is ignored if the metric_type is not Minkowski. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expanded</td><td>should lp-based distances be returned in their expanded form (e.g., without raising to the 1/p power). </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a2ea5c03024c5683984f17d889421f40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea5c03024c5683984f17d889421f40c">&nbsp;</a></span>memory_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">cudaMemoryType ML::memory_type </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a03e79871ae0209450671f11bcd8965fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e79871ae0209450671f11bcd8965fe">&nbsp;</a></span>merge_series() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::merge_series </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const *&nbsp;</td>
          <td class="paramname"><em>hd_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_id_to_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_id_to_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb8f25b52e0576997c85d1488367ab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8f25b52e0576997c85d1488367ab76">&nbsp;</a></span>merge_series() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::merge_series </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *const *&nbsp;</td>
          <td class="paramname"><em>hd_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_id_to_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>d_id_to_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Merge multiple sub-batches into one batch according to the maps that associate each id in the unique batch to a sub-batch and a position in this sub-batch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hd_in</td><td>Host array of pointers to device arrays containing the sub-batches </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_id_to_pos</td><td>Device array containing the position of each member in its new sub-batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_id_to_sub</td><td>Device array associating each member with its sub-batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output merged batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_sub</td><td>Number of sub-batches </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of observations (or forecasts) per series </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a41fe9550f11d82b97c1af6ffdb216483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fe9550f11d82b97c1af6ffdb216483">&nbsp;</a></span>nrm1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">T ML::nrm1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"><em>tmp_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ab19bed3d33dd9a3768cc92ecba4efd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19bed3d33dd9a3768cc92ecba4efd77">&nbsp;</a></span>nrm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">T ML::nrm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"><em>tmp_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a67d0763a9020f84d5b37e00b1521aaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d0763a9020f84d5b37e00b1521aaaa">&nbsp;</a></span>nrmMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">T ML::nrmMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"><em>tmp_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a42d8744a9a6b6bdce6e93cc5369e413f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d8744a9a6b6bdce6e93cc5369e413f">&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::ostream&amp; ML::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleDenseMat.html">SimpleDenseMat</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>mat</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ae35e676e51ff45e1c239f3ca6387796e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35e676e51ff45e1c239f3ca6387796e">&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::ostream&amp; ML::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleSparseMat.html">SimpleSparseMat</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>mat</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a50e65dec1cbb50a447d4d3165fb50aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e65dec1cbb50a447d4d3165fb50aa3">&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::ostream&amp; ML::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>v</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ad048e7644ca470414dc9c7fca5f2e189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad048e7644ca470414dc9c7fca5f2e189">&nbsp;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pack </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>param_vec</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Pack separate parameter arrays into a compact array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Parameter structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">param_vec</td><td>Compact parameter array </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a82ec70080c3ee46d4ff21b8222868c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ec70080c3ee46d4ff21b8222868c93">&nbsp;</a></span>pcaFit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pcaFit </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>explained_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>explained_var_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>noise_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a5382ae5b01e8079b6e550b13d087d4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5382ae5b01e8079b6e550b13d087d4fb">&nbsp;</a></span>pcaFit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pcaFit </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>explained_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>explained_var_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>noise_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb11c10b247ee28f7897bb28156320e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb11c10b247ee28f7897bb28156320e1">&nbsp;</a></span>pcaFitTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pcaFitTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>explained_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>explained_var_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>noise_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8ca2904e5fd35b1a9b883c87e1c1274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ca2904e5fd35b1a9b883c87e1c1274">&nbsp;</a></span>pcaFitTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pcaFitTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>explained_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>explained_var_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>noise_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="af6dc66b3d7ba1d41b448d4317272fbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dc66b3d7ba1d41b448d4317272fbbc">&nbsp;</a></span>pcaInverseTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pcaInverseTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ab49f1e8617076366a9be1fac04b8c92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49f1e8617076366a9be1fac04b8c92d">&nbsp;</a></span>pcaInverseTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pcaInverseTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ac37aa9b10bb7445d9b3523dae260e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37aa9b10bb7445d9b3523dae260e681">&nbsp;</a></span>pcaTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pcaTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a9930aa036bcf52cf182f000ce355cdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9930aa036bcf52cf182f000ce355cdcd">&nbsp;</a></span>pcaTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::pcaTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a516be7eeb210dc391738e9761a886533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516be7eeb210dc391738e9761a886533">&nbsp;</a></span>POP_RANGE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::POP_RANGE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">
<p>Pop the latest range </p>

</div>
</div>
<a id="a7a0bba9857ed5cdfd28c6801397bd629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0bba9857ed5cdfd28c6801397bd629">&nbsp;</a></span>POP_RANGE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::POP_RANGE </td>
          <td>(</td>
          <td class="paramtype">cudaStream_t&nbsp;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Synchronize CUDA stream and pop the latest nvtx range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">stream</td><td>stream to synchronize </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a05ee22c0f2c66e9bb7d60c72e5d61b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ee22c0f2c66e9bb7d60c72e5d61b32">&nbsp;</a></span>postprocess_labels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::postprocess_labels </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>labels_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a014e0b6e471acfa9829c62a05de49275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014e0b6e471acfa9829c62a05de49275">&nbsp;</a></span>predict() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::predict </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a63f42d57ee6287cedb49f48a6fa220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a63f42d57ee6287cedb49f48a6fa220">&nbsp;</a></span>predict() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::predict </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="afd7a72d075a98a0f8eeb197c81554348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7a72d075a98a0f8eeb197c81554348">&nbsp;</a></span>predict() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::predict </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9ebff9eb10e9bcf8c9e2d9b6533259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ebff9eb10e9bcf8c9e2d9b6533259b">&nbsp;</a></span>predict() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::predict </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ab23b1b968627b8696bb2732a7f1c569b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23b1b968627b8696bb2732a7f1c569b">&nbsp;</a></span>predict() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::predict </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAMemory.html">ARIMAMemory</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>arima_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>d_exog_fut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_y_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>pre_diff</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_lower</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>d_upper</em> = <code>nullptr</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Batched in-sample and out-of-sample prediction of a time-series given all the model parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arima_mem</td><td>Pre-allocated temporary memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Batched Time series to predict. Shape: (num_samples, batch size) (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog</td><td>Exogenous variables. Shape = (n_obs, n_exog * batch_size) (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_exog_fut</td><td>Future values of exogenous variables Shape: (end - n_obs, batch_size) (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_obs</td><td>Number of samples per time series (all series must be identical) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Index to start the prediction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Index to end the prediction (excluded) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_y_p</td><td>Prediction output (device) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pre_diff</td><td>Whether to use pre-differencing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Confidence level for prediction intervals. 0 to skip the computation. Else 0 &lt; level &lt; 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_lower</td><td>Lower limit of the prediction interval </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_upper</td><td>Upper limit of the prediction interval </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="aa25bebb87dff8c328b2d4809f640f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25bebb87dff8c328b2d4809f640f789">&nbsp;</a></span>preprocess_labels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::preprocess_labels </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>labels_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a390319c6e316ef242d477e8fa326f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390319c6e316ef242d477e8fa326f2d0">&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a>&nbsp;</td>
          <td class="paramname"><em>rf_metrics</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="aacfa74158f3a2d08f6ddae02dbfb2992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfa74158f3a2d08f6ddae02dbfb2992">&nbsp;</a></span>PUSH_RANGE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::PUSH_RANGE </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Push a named nvtx range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>range name </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a98c6eb4be0b83cb7e0fdceb1890bff09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c6eb4be0b83cb7e0fdceb1890bff09">&nbsp;</a></span>PUSH_RANGE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::PUSH_RANGE </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Synchronize CUDA stream and push a named nvtx range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">name</td><td>range name </td></tr>
    <tr><td class="paramname">stream</td><td>stream to synchronize </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="abfedc6e55f224b411a05f5e53a4c496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfedc6e55f224b411a05f5e53a4c496e">&nbsp;</a></span>rbc_build_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::rbc_build_index </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::spatial::knn::BallCoverIndex&lt; int64_t, float, uint32_t &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>index</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="af71753070b33e0cfa23bbe45676da531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71753070b33e0cfa23bbe45676da531">&nbsp;</a></span>rbc_knn_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::rbc_knn_query </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::spatial::knn::BallCoverIndex&lt; int64_t, float, uint32_t &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>search_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"><em>n_search_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"><em>out_inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>out_dists</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="aeff6bb49e843ea8d5135439648e633a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff6bb49e843ea8d5135439648e633a8">&nbsp;</a></span>score() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>ref_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ae91cc5ebb6e5b37e754ada49a37c3f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91cc5ebb6e5b37e754ada49a37c3f2f">&nbsp;</a></span>score() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>ref_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="aa819cc3c995f572099b9b84e0897cd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819cc3c995f572099b9b84e0897cd76">&nbsp;</a></span>score() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>ref_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a04e5fbd639ed8b2820ad3a1500d26732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e5fbd639ed8b2820ad3a1500d26732">&nbsp;</a></span>score() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>user_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&nbsp;</td>
          <td class="paramname"><em>forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>ref_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c7fcf2379a3d18e1c08840ff530eda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7fcf2379a3d18e1c08840ff530eda9">&nbsp;</a></span>set_all_rf_metrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_all_rf_metrics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a>&nbsp;</td>
          <td class="paramname"><em>rf_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>mean_abs_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>mean_squared_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>median_abs_error</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a85f241652a9dfc89e280200e7618ed32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f241652a9dfc89e280200e7618ed32">&nbsp;</a></span>set_rf_metrics_classification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_rf_metrics_classification </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>accuracy</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa0b5eb27fbd28c93285b9ada72930d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0b5eb27fbd28c93285b9ada72930d8">&nbsp;</a></span>set_rf_metrics_regression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_rf_metrics_regression </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>mean_abs_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>mean_squared_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"><em>median_abs_error</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="aa769073009de30a12fdfc939d9501d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa769073009de30a12fdfc939d9501d3c">&nbsp;</a></span>set_rf_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="structML_1_1RF__params.html">RF_params</a> ML::set_rf_params </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>max_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_n_bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>min_samples_leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>min_samples_split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>min_impurity_decrease</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>bootstrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_trees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a>&nbsp;</td>
          <td class="paramname"><em>split_criterion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>cfg_n_streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>max_batch_size</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a0262446094debc247669f955e6f13e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0262446094debc247669f955e6f13e5f">&nbsp;</a></span>single_linkage_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::single_linkage_neighbors </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::hierarchy::linkage_output&lt; int, float &gt; *&nbsp;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::distance::DistanceType&nbsp;</td>
          <td class="paramname"><em>metric</em> = <code>raft::distance::DistanceType::L2Unexpanded</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>c</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_clusters</em> = <code>5</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Computes single-linkage hierarchical clustering on a dense input feature matrix and outputs the labels, dendrogram, and minimum spanning tree. Connectivities are constructed using a k-nearest neighbors graph. While this strategy enables the algorithm to scale to much higher numbers of rows, it comes with the downside that additional knn steps may need to be executed to connect an otherwise unconnected k-nn graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>raft handle to encapsulate expensive resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>dense feature matrix on device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Must be supported by the dense pairwise distances API. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>container object for output arrays </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>the optimal value of k is guaranteed to be at least log(n) + c where c is some constant. This constant can usually be set to a fairly low value, like 15, and still maintain good performance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_clusters</td><td>number of clusters to cut from resulting dendrogram </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="a2e906b2839782feeb92f9f8d6b72bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e906b2839782feeb92f9f8d6b72bcad">&nbsp;</a></span>single_linkage_pairwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::single_linkage_pairwise </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::hierarchy::linkage_output&lt; int, float &gt; *&nbsp;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::distance::DistanceType&nbsp;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_clusters</em> = <code>5</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Computes single-linkage hierarchical clustering on a dense input feature matrix and outputs the labels, dendrogram, and minimum spanning tree. Connectivities are constructed using the full n^2 pairwise distance matrix. This can be very fast for smaller datasets when there is enough memory available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>raft handle to encapsulate expensive resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>dense feature matrix on device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>distance metric to use. Must be supported by the dense pairwise distances API. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>container object for output arrays </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_clusters</td><td>number of clusters to cut from resulting dendrogram </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ab6638b428d61f67a7054b60c37ca3172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6638b428d61f67a7054b60c37ca3172">&nbsp;</a></span>single_linkage_pairwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::single_linkage_pairwise </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::hierarchy::linkage_output&lt; int64_t, float &gt; *&nbsp;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::distance::DistanceType&nbsp;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n_clusters</em> = <code>5</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d821c8424317cc8e30a01b0865c7065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d821c8424317cc8e30a01b0865c7065">&nbsp;</a></span>squaredNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">T ML::squaredNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structML_1_1SimpleVec.html">SimpleVec</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"><em>tmp_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a410f1cf88e4867ba6793a7f98e98210c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410f1cf88e4867ba6793a7f98e98210c">&nbsp;</a></span>TSNE_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::TSNE_fit </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"><em>knn_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>knn_dists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1TSNEParams.html">TSNEParams</a> &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>kl_div</em> = <code>nullptr</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Dimensionality reduction via TSNE using Barnes-Hut, Fourier Interpolation, or naive methods. or brute force O(N^2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The GPU handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>The row-major dataset in device memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The column-major final embedding in device memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows in data X. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Number of columns in data X. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>Array containing nearest neighors indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knn_dists</td><td>Array containing nearest neighors distances. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Parameters for TSNE model </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">kl_div</td><td>(optional) KL divergence output</td></tr>
  </tbody></table>
  </dd>
</dl>
<p>The CUDA implementation is derived from the excellent CannyLabs open source implementation here: <a href="https://github.com/CannyLab/tsne-cuda/">https://github.com/CannyLab/tsne-cuda/</a>. The CannyLabs code is licensed according to the conditions in cuml/cpp/src/tsne/cannylabs_tsne_license.txt. A full description of their approach is available in their article t-SNE-CUDA: GPU-Accelerated t-SNE and its Applications to Modern Data (<a href="https://arxiv.org/abs/1807.11824">https://arxiv.org/abs/1807.11824</a>). </p>

</div>
</div>
<a id="a9e76eb2f3473269bd00296408c41689d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e76eb2f3473269bd00296408c41689d">&nbsp;</a></span>TSNE_fit_sparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::TSNE_fit_sparse </td>
          <td>(</td>
          <td class="paramtype">const raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>indptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"><em>knn_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>knn_dists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1TSNEParams.html">TSNEParams</a> &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>kl_div</em> = <code>nullptr</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The GPU handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indptr</td><td>indptr of CSR dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>indices of CSR dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data of CSR dataset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The final embedding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnz</td><td>The number of non-zero entries in the CSR. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows in data X. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Number of columns in data X. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knn_indices</td><td>Array containing nearest neighors indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knn_dists</td><td>Array containing nearest neighors distances. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Parameters for TSNE model </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">kl_div</td><td>(optional) KL divergence output</td></tr>
  </tbody></table>
  </dd>
</dl>
<p>The CUDA implementation is derived from the excellent CannyLabs open source implementation here: <a href="https://github.com/CannyLab/tsne-cuda/">https://github.com/CannyLab/tsne-cuda/</a>. The CannyLabs code is licensed according to the conditions in cuml/cpp/src/tsne/cannylabs_tsne_license.txt. A full description of their approach is available in their article t-SNE-CUDA: GPU-Accelerated t-SNE and its Applications to Modern Data (<a href="https://arxiv.org/abs/1807.11824">https://arxiv.org/abs/1807.11824</a>). </p>

</div>
</div>
<a id="add33f23b1a15823449837dc884b13ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add33f23b1a15823449837dc884b13ddd">&nbsp;</a></span>tsvdFit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::tsvdFit </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a071bdcbc710b1a4ca88efc02fd2489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a071bdcbc710b1a4ca88efc02fd2489">&nbsp;</a></span>tsvdFit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::tsvdFit </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1a46cc3b471efc453be9e8fbecba363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a46cc3b471efc453be9e8fbecba363">&nbsp;</a></span>tsvdFitTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::tsvdFitTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>explained_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>explained_var_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="afba20c39f0790075843e9236fd043ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba20c39f0790075843e9236fd043ca1">&nbsp;</a></span>tsvdFitTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::tsvdFitTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>explained_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>explained_var_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>singular_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2faa9e0c83e9270369e866281802624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2faa9e0c83e9270369e866281802624">&nbsp;</a></span>tsvdInverseTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::tsvdInverseTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="ac335d131520793dcf0831d753e1c7ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac335d131520793dcf0831d753e1c7ab2">&nbsp;</a></span>tsvdInverseTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::tsvdInverseTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a83f6113e72b200d0a4bef2759285a6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f6113e72b200d0a4bef2759285a6ca">&nbsp;</a></span>tsvdTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::tsvdTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a8f7fa23231a10eb02ea2a3d4923335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8f7fa23231a10eb02ea2a3d4923335">&nbsp;</a></span>tsvdTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::tsvdTransform </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"><em>trans_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceML.html#ab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;&nbsp;</td>
          <td class="paramname"><em>prms</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

</div>
</div>
<a id="a62e41ec81cdf10cea7be42c97eca6b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e41ec81cdf10cea7be42c97eca6b32">&nbsp;</a></span>unpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void ML::unpack </td>
          <td>(</td>
          <td class="paramtype">raft::handle_t &amp;&nbsp;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;&nbsp;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"><em>param_vec</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div><div class="memdoc">
<p>Unpack a compact array into separate parameter arrays</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">params</td><td>Parameter structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Batch size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param_vec</td><td>Compact parameter array </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7181e4d6d170b0aa91dc7a368abf3d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7181e4d6d170b0aa91dc7a368abf3d1c">&nbsp;</a></span>handleMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a> ML::handleMap</td>
        </tr>
      </tbody></table>
</div><div class="memdoc">

<p>Static handle map instance (see <a class="el" href="cumlHandle_8cpp.html">cumlHandle.cpp</a>) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>