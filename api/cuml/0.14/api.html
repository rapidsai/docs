<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en">
 <!--<![endif]-->
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   cuML API Reference — cuml 0.14.0 documentation
  </title>
  <script src="_static/js/modernizr.min.js" type="text/javascript">
  </script>
  <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript">
  </script>
  <script src="_static/jquery.js">
  </script>
  <script src="_static/underscore.js">
  </script>
  <script src="_static/doctools.js">
  </script>
  <script src="_static/language_data.js">
  </script>
  <script src="_static/js/theme.js" type="text/javascript">
  </script>
  <link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
  <link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
  <link href="_static/params.css" rel="stylesheet" type="text/css"/>
  <link href="genindex.html" rel="index" title="Index"/>
  <link href="search.html" rel="search" title="Search"/>
  <link href="index.html" rel="prev" title="Welcome to cuML’s documentation!"/>
  <link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/>
 </head>
 <body class="wy-body-for-nav">
  <div class="wy-grid-for-nav">
   <nav class="wy-nav-side" data-toggle="wy-nav-shift">
    <div class="wy-side-scroll">
     <div class="wy-side-nav-search">
      <div id="rapids-sphinx-container">
       <div class="rapids-home-container">
        <a class="rapids-home-container__home-btn" href="/api">
         Home
        </a>
       </div>
       <div class="rapids-selector__container rapids-selector--hidden">
        <div class="rapids-selector__selected">
         cuml
        </div>
        <div class="rapids-selector__menu">
         <a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">
          clx
         </a>
         <a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">
          cudf
         </a>
         <a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">
          cugraph
         </a>
         <a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cuml/stable/api.html">
          cuml
         </a>
         <a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">
          cusignal
         </a>
         <a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">
          cuspatial
         </a>
         <a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">
          cuxfilter
         </a>
         <a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">
          libcudf
         </a>
         <a class="rapids-selector__menu-item" href="/api/libnvstrings/stable/annotated.html">
          libnvstrings
         </a>
         <a class="rapids-selector__menu-item" href="/api/nvstrings/stable/api.html">
          nvstrings
         </a>
         <a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">
          rmm
         </a>
        </div>
       </div>
       <div class="rapids-selector__container rapids-selector--hidden">
        <div class="rapids-selector__selected">
         nightly (0.14)
        </div>
        <div class="rapids-selector__menu">
         <a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cuml/nightly/api.html">
          nightly (0.14)
         </a>
         <a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">
          stable (0.13)
         </a>
         <a class="rapids-selector__menu-item" href="/api/cuml/legacy/api.html">
          legacy (0.12)
         </a>
        </div>
       </div>
      </div>
      <div role="search">
       <form action="search.html" class="wy-form" id="rtd-search-form" method="get">
        <input name="q" placeholder="Search docs" type="text"/>
        <input name="check_keywords" type="hidden" value="yes"/>
        <input name="area" type="hidden" value="default"/>
       </form>
      </div>
     </div>
     <div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
      <p class="caption">
       <span class="caption-text">
        Contents:
       </span>
      </p>
      <ul class="current">
       <li class="toctree-l1 current">
        <a class="current reference internal" href="#">
         cuML API Reference
        </a>
        <ul>
         <li class="toctree-l2">
          <a class="reference internal" href="#datatype-configuration">
           Datatype Configuration
          </a>
          <ul>
           <li class="toctree-l3">
            <a class="reference internal" href="#output-type">
             Output Type
            </a>
           </li>
          </ul>
         </li>
         <li class="toctree-l2">
          <a class="reference internal" href="#preprocessing-metrics-and-utilities">
           Preprocessing, Metrics, and Utilities
          </a>
          <ul>
           <li class="toctree-l3">
            <a class="reference internal" href="#model-selection-and-data-splitting">
             Model Selection and Data Splitting
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#label-encoding">
             Label Encoding
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#dataset-generation-single-gpu">
             Dataset Generation (Single-GPU)
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#dataset-generation-dask-based-multi-gpu">
             Dataset Generation (Dask-based Multi-GPU)
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#metrics">
             Metrics
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#benchmarking">
             Benchmarking
            </a>
           </li>
          </ul>
         </li>
         <li class="toctree-l2">
          <a class="reference internal" href="#regression-and-classification">
           Regression and Classification
          </a>
          <ul>
           <li class="toctree-l3">
            <a class="reference internal" href="#linear-regression">
             Linear Regression
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#logistic-regression">
             Logistic Regression
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#ridge-regression">
             Ridge Regression
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#lasso-regression">
             Lasso Regression
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#elasticnet-regression">
             ElasticNet Regression
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#mini-batch-sgd-classifier">
             Mini Batch SGD Classifier
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#mini-batch-sgd-regressor">
             Mini Batch SGD Regressor
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#stochastic-gradient-descent">
             Stochastic Gradient Descent
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#random-forest">
             Random Forest
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#forest-inferencing">
             Forest Inferencing
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#coordinate-descent">
             Coordinate Descent
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#quasi-newton">
             Quasi-Newton
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#support-vector-machines">
             Support Vector Machines
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#nearest-neighbors-classification">
             Nearest Neighbors Classification
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#nearest-neighbors-regression">
             Nearest Neighbors Regression
            </a>
           </li>
          </ul>
         </li>
         <li class="toctree-l2">
          <a class="reference internal" href="#clustering">
           Clustering
          </a>
          <ul>
           <li class="toctree-l3">
            <a class="reference internal" href="#k-means-clustering">
             K-Means Clustering
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#dbscan">
             DBSCAN
            </a>
           </li>
          </ul>
         </li>
         <li class="toctree-l2">
          <a class="reference internal" href="#dimensionality-reduction-and-manifold-learning">
           Dimensionality Reduction and Manifold Learning
          </a>
          <ul>
           <li class="toctree-l3">
            <a class="reference internal" href="#principal-component-analysis">
             Principal Component Analysis
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#truncated-svd">
             Truncated SVD
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#umap">
             UMAP
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#random-projections">
             Random Projections
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#tsne">
             TSNE
            </a>
           </li>
          </ul>
         </li>
         <li class="toctree-l2">
          <a class="reference internal" href="#neighbors">
           Neighbors
          </a>
          <ul>
           <li class="toctree-l3">
            <a class="reference internal" href="#nearest-neighbors">
             Nearest Neighbors
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#id10">
             Nearest Neighbors Classification
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#id12">
             Nearest Neighbors Regression
            </a>
           </li>
          </ul>
         </li>
         <li class="toctree-l2">
          <a class="reference internal" href="#time-series">
           Time Series
          </a>
          <ul>
           <li class="toctree-l3">
            <a class="reference internal" href="#holtwinters">
             HoltWinters
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#arima">
             ARIMA
            </a>
           </li>
          </ul>
         </li>
         <li class="toctree-l2">
          <a class="reference internal" href="#multi-node-multi-gpu-algorithms">
           Multi-Node, Multi-GPU Algorithms
          </a>
          <ul>
           <li class="toctree-l3">
            <a class="reference internal" href="#id16">
             K-Means Clustering
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#id17">
             Nearest Neighbors
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#id18">
             Principal Component Analysis
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#id21">
             Random Forest
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#id22">
             Truncated SVD
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#linear-models">
             Linear Models
            </a>
           </li>
           <li class="toctree-l3">
            <a class="reference internal" href="#dask-base-classes-and-mixins">
             Dask Base Classes and Mixins
            </a>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </div>
    </div>
   </nav>
   <section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
    <nav aria-label="top navigation" class="wy-nav-top">
     <i class="fa fa-bars" data-toggle="wy-nav-top">
     </i>
     <a href="index.html">
      cuml
     </a>
    </nav>
    <div class="wy-nav-content">
     <div class="rst-content">
      <div aria-label="breadcrumbs navigation" role="navigation">
       <ul class="wy-breadcrumbs">
        <li>
         <a href="index.html">
          Docs
         </a>
         »
        </li>
        <li>
         cuML API Reference
        </li>
        <li class="wy-breadcrumbs-aside">
         <a href="_sources/api.rst.txt" rel="nofollow">
          View page source
         </a>
        </li>
       </ul>
       <hr/>
      </div>
      <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
       <div itemprop="articleBody">
        <div class="section" id="cuml-api-reference">
         <h1>
          cuML API Reference
          <a class="headerlink" href="#cuml-api-reference" title="Permalink to this headline">
           ¶
          </a>
         </h1>
         <div class="section" id="datatype-configuration">
          <h2>
           Datatype Configuration
           <a class="headerlink" href="#datatype-configuration" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="output-type">
           <h3>
            Output Type
            <a class="headerlink" href="#output-type" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <blockquote>
            <div>
             <dl class="method">
              <dt id="cuml.utils.memory_utils.set_global_output_type">
               <code class="sig-prename descclassname">
                memory_utils.
               </code>
               <code class="sig-name descname">
                set_global_output_type
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                output_type
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.utils.memory_utils.set_global_output_type" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Method to set cuML’s single GPU estimators global output type.
It will be used by all estimators unless overriden in their initialization
with their own output_type parameter. Can also be overriden by the context
manager method
                <cite>
                 using_output_type
                </cite>
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    output_type
                   </strong>
                   <span class="classifier">
                    {‘input’, ‘cudf’, ‘cupy’, ‘numba’, numpy’} (default = ‘input’)  # noqa
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Desired output type of results and attributes of the estimators.
‘input’ will mean that the parameters and methods will mirror the
format of the data sent to the estimators/methods. ‘cudf’ will
return cuDF Series for single dimensional results and DataFrames
for the rest. ‘cupy’ will return CuPy ndarrays. ‘numpy’ will return
NumPy ndarrays.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <p class="rubric">
                Notes
               </p>
               <p>
                ‘cupy’ and ‘numba’ options (as well as ‘input’ when using Numba and CuPy
ndarrays for input) have the least overhead. cuDF add memory consumption
and processing time needed to build the Series and DataFrames. ‘numpy’ has
the biggest overhead due to the need to transfer data to CPU memory.
               </p>
               <p>
                cuML is transitioning to support this parameter for all its estimators.
Currently the following single GPU estimators have this new behavior:
               </p>
               <ul class="simple">
                <li>
                 <p>
                  DBSCAN
                 </p>
                </li>
                <li>
                 <p>
                  KMeans
                 </p>
                </li>
               </ul>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.utils.memory_utils.using_output_type">
               <code class="sig-prename descclassname">
                memory_utils.
               </code>
               <code class="sig-name descname">
                using_output_type
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                output_type
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.utils.memory_utils.using_output_type" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Context manager method to set cuML’s global output type inside a
                <cite>
                 with
                </cite>
                statement. It gets reset to the prior value it had once the
                <cite>
                 with
                </cite>
                code
block is executer.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    output_type
                   </strong>
                   <span class="classifier">
                    {‘input’, ‘cudf’, ‘cupy’, ‘numba’, numpy’} (default = ‘input’)  # noqa
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Desired output type of results and attributes of the estimators.
‘input’ will mean that the parameters and methods will mirror the
format of the data sent to the estimators/methods. ‘cudf’ will
return cuDF Series for single dimensional results and DataFrames
for the rest. ‘cupy’ will return CuPy ndarrays. ‘numpy’ will return
NumPy ndarrays.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </div>
           </blockquote>
          </div>
         </div>
         <div class="section" id="preprocessing-metrics-and-utilities">
          <h2>
           Preprocessing, Metrics, and Utilities
           <a class="headerlink" href="#preprocessing-metrics-and-utilities" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="model-selection-and-data-splitting">
           <h3>
            Model Selection and Data Splitting
            <a class="headerlink" href="#model-selection-and-data-splitting" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <blockquote>
            <div>
             <dl class="method">
              <dt id="cuml.preprocessing.model_selection.train_test_split">
               <code class="sig-prename descclassname">
                model_selection.
               </code>
               <code class="sig-name descname">
                train_test_split
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                test_size: Union[float
               </em>
               ,
               <em class="sig-param">
                int] = None
               </em>
               ,
               <em class="sig-param">
                train_size: Union[float
               </em>
               ,
               <em class="sig-param">
                int] = None
               </em>
               ,
               <em class="sig-param">
                shuffle: bool = True
               </em>
               ,
               <em class="sig-param">
                random_state: Union[int
               </em>
               ,
               <em class="sig-param">
                cupy.random.generator.RandomState
               </em>
               ,
               <em class="sig-param">
                numpy.random.mtrand.RandomState] = None
               </em>
               ,
               <em class="sig-param">
                seed: Union[int
               </em>
               ,
               <em class="sig-param">
                cupy.random.generator.RandomState
               </em>
               ,
               <em class="sig-param">
                numpy.random.mtrand.RandomState] = None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.preprocessing.model_selection.train_test_split" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Partitions device data into four collated objects, mimicking
Scikit-learn’s
                <cite>
                 train_test_split
                </cite>
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    cudf.DataFrame or cuda_array_interface compliant device array
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Data to split, has shape (n_samples, n_features)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    str, cudf.Series or cuda_array_interface compliant device array
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Set of labels for the data, either a series of shape (n_samples) or
the string label of a column in X (if it is a cuDF DataFrame)
containing the labels
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    train_size
                   </strong>
                   <span class="classifier">
                    float or int, optional
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If float, represents the proportion [0, 1] of the data
to be assigned to the training set. If an int, represents the number
of instances to be assigned to the training set. Defaults to 0.8
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    shuffle
                   </strong>
                   <span class="classifier">
                    bool, optional
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether or not to shuffle inputs before splitting
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    random_state
                   </strong>
                   <span class="classifier">
                    int, CuPy RandomState or NumPy RandomState optional
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If shuffle is true, seeds the generator. Unseeded by default
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    seed: random_state
                   </strong>
                   <span class="classifier">
                    int, CuPy RandomState or NumPy RandomState optional
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Deprecated in favor of
                    <cite>
                     random_state
                    </cite>
                    .
If shuffle is true, seeds the generator. Unseeded by default
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_train, X_test, y_train, y_test
                   </strong>
                   <span class="classifier">
                    cudf.DataFrame
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Partitioned dataframes. If
                    <cite>
                     y
                    </cite>
                    was provided as a column name, the
column was dropped from the
                    <a href="#id1">
                     <span class="problematic" id="id2">
                      `
                     </span>
                    </a>
                    X`s
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <p class="rubric">
                Examples
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">from</span> <span class="nn">cuml.preprocessing.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Generate some sample data</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'x'</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
                     <span class="s1">'y'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">})</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Original data: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> elements'</span><span class="p">)</span>

<span class="c1"># Suppose we want an 80/20 split</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">,</span>
                                                    <span class="n">train_size</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'X_train: </span><span class="si">{</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> elements'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'X_test: </span><span class="si">{</span><span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> elements'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'y_train: </span><span class="si">{</span><span class="n">y_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> elements'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'y_test: </span><span class="si">{</span><span class="n">y_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> elements'</span><span class="p">)</span>

<span class="c1"># Alternatively, if our labels are stored separately</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'y'</span><span class="p">]</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">'y'</span><span class="p">])</span>

<span class="c1"># we can also do</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span>
                                                    <span class="n">train_size</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
</pre>
                </div>
               </div>
               <p>
                Output:
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="n">Original</span> <span class="n">data</span><span class="p">:</span> <span class="mi">10</span> <span class="n">elements</span>
<span class="n">X_train</span><span class="p">:</span> <span class="mi">8</span> <span class="n">elements</span>
<span class="n">X_test</span><span class="p">:</span> <span class="mi">2</span> <span class="n">elements</span>
<span class="n">y_train</span><span class="p">:</span> <span class="mi">8</span> <span class="n">elements</span>
<span class="n">y_test</span><span class="p">:</span> <span class="mi">2</span> <span class="n">elements</span>
</pre>
                </div>
               </div>
              </dd>
             </dl>
            </div>
           </blockquote>
          </div>
          <div class="section" id="label-encoding">
           <h3>
            Label Encoding
            <a class="headerlink" href="#label-encoding" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <blockquote>
            <div>
             <dl class="class">
              <dt id="cuml.preprocessing.LabelEncoder">
               <em class="property">
                class
               </em>
               <code class="sig-prename descclassname">
                cuml.preprocessing.
               </code>
               <code class="sig-name descname">
                LabelEncoder
               </code>
               <a class="headerlink" href="#cuml.preprocessing.LabelEncoder" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                An nvcategory based implementation of ordinal label encoding
               </p>
               <p class="rubric">
                Examples
               </p>
               <p>
                Converting a categorical implementation to a numerical one
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">({</span><span class="s1">'category'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">]})</span>

<span class="c1"># There are two functionally equivalent ways to do this</span>
<span class="n">le</span> <span class="o">=</span> <span class="n">LabelEncoder</span><span class="p">()</span>
<span class="n">le</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">category</span><span class="p">)</span>  <span class="c1"># le = le.fit(data.category) also works</span>
<span class="n">encoded</span> <span class="o">=</span> <span class="n">le</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">category</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>

<span class="c1"># This method is preferred</span>
<span class="n">le</span> <span class="o">=</span> <span class="n">LabelEncoder</span><span class="p">()</span>
<span class="n">encoded</span> <span class="o">=</span> <span class="n">le</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">category</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>

<span class="c1"># We can assign this to a new column</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">encoded</span><span class="o">=</span><span class="n">encoded</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>

<span class="c1"># We can also encode more data</span>
<span class="n">test_data</span> <span class="o">=</span> <span class="n">Series</span><span class="p">([</span><span class="s1">'c'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">])</span>
<span class="n">encoded</span> <span class="o">=</span> <span class="n">le</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>

<span class="c1"># After train, ordinal label can be inverse_transform() back to</span>
<span class="c1"># string labels</span>
<span class="n">ord_label</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ord_label</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">from_cudf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">str_label</span> <span class="o">=</span> <span class="n">le</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">ord_label</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">str_label</span><span class="p">)</span>
</pre>
                </div>
               </div>
               <p>
                Output:
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">3</span>
<span class="n">dtype</span><span class="p">:</span> <span class="n">int64</span>

<span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">3</span>
<span class="n">dtype</span><span class="p">:</span> <span class="n">int32</span>

<span class="n">category</span>  <span class="n">encoded</span>
<span class="mi">0</span>         <span class="n">a</span>        <span class="mi">0</span>
<span class="mi">1</span>         <span class="n">b</span>        <span class="mi">1</span>
<span class="mi">2</span>         <span class="n">c</span>        <span class="mi">2</span>
<span class="mi">3</span>         <span class="n">d</span>        <span class="mi">3</span>

<span class="mi">0</span>    <span class="mi">2</span>
<span class="mi">1</span>    <span class="mi">0</span>
<span class="n">dtype</span><span class="p">:</span> <span class="n">int64</span>

<span class="mi">0</span>    <span class="n">a</span>
<span class="mi">1</span>    <span class="n">a</span>
<span class="mi">2</span>    <span class="n">b</span>
<span class="mi">3</span>    <span class="n">c</span>
<span class="mi">4</span>    <span class="n">b</span>
<span class="n">dtype</span><span class="p">:</span> <span class="nb">object</span>
</pre>
                </div>
               </div>
               <p class="rubric">
                Methods
               </p>
               <table class="longtable docutils align-default">
                <colgroup>
                 <col style="width: 10%"/>
                 <col style="width: 90%"/>
                </colgroup>
                <tbody>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.preprocessing.LabelEncoder.fit" title="cuml.preprocessing.LabelEncoder.fit">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       fit
                      </span>
                     </code>
                    </a>
                   </p>
                  </td>
                  <td>
                   <p>
                   </p>
                  </td>
                 </tr>
                 <tr class="row-even">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.preprocessing.LabelEncoder.fit_transform" title="cuml.preprocessing.LabelEncoder.fit_transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       fit_transform
                      </span>
                     </code>
                    </a>
                   </p>
                  </td>
                  <td>
                   <p>
                   </p>
                  </td>
                 </tr>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.preprocessing.LabelEncoder.inverse_transform" title="cuml.preprocessing.LabelEncoder.inverse_transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       inverse_transform
                      </span>
                     </code>
                    </a>
                   </p>
                  </td>
                  <td>
                   <p>
                   </p>
                  </td>
                 </tr>
                 <tr class="row-even">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.preprocessing.LabelEncoder.transform" title="cuml.preprocessing.LabelEncoder.transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       transform
                      </span>
                     </code>
                    </a>
                   </p>
                  </td>
                  <td>
                   <p>
                   </p>
                  </td>
                 </tr>
                </tbody>
               </table>
               <dl class="method">
                <dt id="cuml.preprocessing.LabelEncoder.fit">
                 <code class="sig-name descname">
                  fit
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y: cudf.core.series.Series
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 → 'LabelEncoder'
                 <a class="headerlink" href="#cuml.preprocessing.LabelEncoder.fit" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Fit a LabelEncoder (nvcategory) instance to a set of categories
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      cudf.Series
                     </span>
                    </dt>
                    <dd>
                     <p>
                      Series containing the categories to be encoded. It’s elements
may or may not be unique
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      self
                     </strong>
                     <span class="classifier">
                      LabelEncoder
                     </span>
                    </dt>
                    <dd>
                     <p>
                      A fitted instance of itself to allow method chaining
                     </p>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.preprocessing.LabelEncoder.fit_transform">
                 <code class="sig-name descname">
                  fit_transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y: cudf.core.series.Series
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 → cudf.core.series.Series
                 <a class="headerlink" href="#cuml.preprocessing.LabelEncoder.fit_transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Simultaneously fit and transform an input
                 </p>
                 <p>
                  This is functionally equivalent to (but faster than)
                  <cite>
                   LabelEncoder().fit(y).transform(y)
                  </cite>
                 </p>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.preprocessing.LabelEncoder.inverse_transform">
                 <code class="sig-name descname">
                  inverse_transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y: cudf.core.series.Series
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 → cudf.core.series.Series
                 <a class="headerlink" href="#cuml.preprocessing.LabelEncoder.inverse_transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Revert ordinal label to original label
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      cudf.Series, dtype=int32
                     </span>
                    </dt>
                    <dd>
                     <p>
                      Ordinal labels to be reverted
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      reverted
                     </strong>
                     <span class="classifier">
                      cudf.Series
                     </span>
                    </dt>
                    <dd>
                     <p>
                      Reverted labels
                     </p>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.preprocessing.LabelEncoder.transform">
                 <code class="sig-name descname">
                  transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y: cudf.core.series.Series
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 → cudf.core.series.Series
                 <a class="headerlink" href="#cuml.preprocessing.LabelEncoder.transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Transform an input into its categorical keys.
                 </p>
                 <p>
                  This is intended for use with small inputs relative to the size of the
dataset. For fitting and transforming an entire dataset, prefer
                  <cite>
                   fit_transform
                  </cite>
                  .
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      cudf.Series
                     </span>
                    </dt>
                    <dd>
                     <p>
                      Input keys to be transformed. Its values should match the
categories given to
                      <cite>
                       fit
                      </cite>
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      encoded
                     </strong>
                     <span class="classifier">
                      cudf.Series
                     </span>
                    </dt>
                    <dd>
                     <p>
                      The ordinally encoded input series
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-odd">
                   Raises
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     KeyError
                    </dt>
                    <dd>
                     <p>
                      if a category appears that was not seen in
                      <cite>
                       fit
                      </cite>
                     </p>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="class">
              <dt id="cuml.preprocessing.LabelBinarizer">
               <em class="property">
                class
               </em>
               <code class="sig-prename descclassname">
                cuml.preprocessing.
               </code>
               <code class="sig-name descname">
                LabelBinarizer
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                neg_label=0
               </em>
               ,
               <em class="sig-param">
                pos_label=1
               </em>
               ,
               <em class="sig-param">
                sparse_output=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.preprocessing.LabelBinarizer" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                A multi-class dummy encoder for labels.
               </p>
               <p class="rubric">
                Examples
               </p>
               <p>
                Create an array with labels and dummy encode them
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">from</span> <span class="nn">cuml.preprocessing</span> <span class="kn">import</span> <span class="n">LabelBinarizer</span>

<span class="n">labels</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">lb</span> <span class="o">=</span> <span class="n">LabelBinarizer</span><span class="p">()</span>

<span class="n">encoded</span> <span class="o">=</span> <span class="n">lb</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>

<span class="n">decoded</span> <span class="o">=</span> <span class="n">lb</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">decoded</span><span class="p">)</span>
</pre>
                </div>
               </div>
               <p>
                Output:
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]]</span>

 <span class="p">[</span> <span class="mi">0</span>  <span class="mi">5</span> <span class="mi">10</span>  <span class="mi">7</span>  <span class="mi">2</span>  <span class="mi">4</span>  <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">4</span>  <span class="mi">3</span>  <span class="mi">2</span>  <span class="mi">1</span><span class="p">]</span>
</pre>
                </div>
               </div>
               <p class="rubric">
                Methods
               </p>
               <table class="longtable docutils align-default">
                <colgroup>
                 <col style="width: 10%"/>
                 <col style="width: 90%"/>
                </colgroup>
                <tbody>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.preprocessing.LabelBinarizer.fit" title="cuml.preprocessing.LabelBinarizer.fit">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       fit
                      </span>
                     </code>
                    </a>
                    (self, y)
                   </p>
                  </td>
                  <td>
                   <p>
                    Fit label binarizer
                   </p>
                  </td>
                 </tr>
                 <tr class="row-even">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.preprocessing.LabelBinarizer.fit_transform" title="cuml.preprocessing.LabelBinarizer.fit_transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       fit_transform
                      </span>
                     </code>
                    </a>
                    (self, y)
                   </p>
                  </td>
                  <td>
                   <p>
                    Fit label binarizer and transform multi-class labels to their dummy-encoded representation.
                   </p>
                  </td>
                 </tr>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.preprocessing.LabelBinarizer.inverse_transform" title="cuml.preprocessing.LabelBinarizer.inverse_transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       inverse_transform
                      </span>
                     </code>
                    </a>
                    (self, y[, threshold])
                   </p>
                  </td>
                  <td>
                   <p>
                    Transform binary labels back to original multi-class labels
                   </p>
                  </td>
                 </tr>
                 <tr class="row-even">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.preprocessing.LabelBinarizer.transform" title="cuml.preprocessing.LabelBinarizer.transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       transform
                      </span>
                     </code>
                    </a>
                    (self, y)
                   </p>
                  </td>
                  <td>
                   <p>
                    Transform multi-class labels to their dummy-encoded representation labels.
                   </p>
                  </td>
                 </tr>
                </tbody>
               </table>
               <dl class="method">
                <dt id="cuml.preprocessing.LabelBinarizer.fit">
                 <code class="sig-name descname">
                  fit
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.preprocessing.LabelBinarizer.fit" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Fit label binarizer
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      array of shape [n_samples,] or [n_samples, n_classes]
                     </span>
                    </dt>
                    <dd>
                     <p>
                      Target values. The 2-d matrix should only contain 0 and 1,
represents multilabel classification.
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      self
                     </strong>
                     <span class="classifier">
                      returns an instance of self.
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.preprocessing.LabelBinarizer.fit_transform">
                 <code class="sig-name descname">
                  fit_transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.preprocessing.LabelBinarizer.fit_transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Fit label binarizer and transform multi-class labels to their
dummy-encoded representation.
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      array of shape [n_samples,] or [n_samples, n_classes]
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      arr
                     </strong>
                     <span class="classifier">
                      array with encoded labels
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.preprocessing.LabelBinarizer.inverse_transform">
                 <code class="sig-name descname">
                  inverse_transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y
                 </em>
                 ,
                 <em class="sig-param">
                  threshold=None
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.preprocessing.LabelBinarizer.inverse_transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Transform binary labels back to original multi-class labels
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      array of shape [n_samples, n_classes]
                     </span>
                    </dt>
                    <dd>
                    </dd>
                    <dt>
                     <strong>
                      threshold
                     </strong>
                     <span class="classifier">
                      float this value is currently ignored
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      arr
                     </strong>
                     <span class="classifier">
                      array with original labels
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.preprocessing.LabelBinarizer.transform">
                 <code class="sig-name descname">
                  transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.preprocessing.LabelBinarizer.transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Transform multi-class labels to their dummy-encoded representation
labels.
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      array of shape [n_samples,] or [n_samples, n_classes]
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      arr
                     </strong>
                     <span class="classifier">
                      array with encoded labels
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="class">
              <dt id="cuml.dask.preprocessing.LabelBinarizer">
               <em class="property">
                class
               </em>
               <code class="sig-prename descclassname">
                cuml.dask.preprocessing.
               </code>
               <code class="sig-name descname">
                LabelBinarizer
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                client=None
               </em>
               ,
               <em class="sig-param">
                **kwargs
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.preprocessing.LabelBinarizer" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                A distributed version of LabelBinarizer for one-hot encoding
a collection of labels.
               </p>
               <p class="rubric">
                Examples
               </p>
               <p>
                Create an array with labels and dummy encode them
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">from</span> <span class="nn">cuml.dask.preprocessing</span> <span class="kn">import</span> <span class="n">LabelBinarizer</span>

<span class="kn">from</span> <span class="nn">dask_cuda</span> <span class="kn">import</span> <span class="n">LocalCUDACluster</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">import</span> <span class="nn">dask</span>

<span class="n">cluster</span> <span class="o">=</span> <span class="n">LocalCUDACluster</span><span class="p">()</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>

<span class="n">labels</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

<span class="n">lb</span> <span class="o">=</span> <span class="n">LabelBinarizer</span><span class="p">()</span>

<span class="n">encoded</span> <span class="o">=</span> <span class="n">lb</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">encoded</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>

<span class="n">decoded</span> <span class="o">=</span> <span class="n">lb</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">decoded</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
</pre>
                </div>
               </div>
               <p>
                Output:
               </p>
               <div class="highlight-default notranslate">
                <div class="highlight">
                 <pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]]</span>

 <span class="p">[</span> <span class="mi">0</span>  <span class="mi">5</span> <span class="mi">10</span>  <span class="mi">7</span>  <span class="mi">2</span>  <span class="mi">4</span>  <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">4</span>  <span class="mi">3</span>  <span class="mi">2</span>  <span class="mi">1</span><span class="p">]</span>
</pre>
                </div>
               </div>
               <p class="rubric">
                Methods
               </p>
               <table class="longtable docutils align-default">
                <colgroup>
                 <col style="width: 10%"/>
                 <col style="width: 90%"/>
                </colgroup>
                <tbody>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.dask.preprocessing.LabelBinarizer.fit" title="cuml.dask.preprocessing.LabelBinarizer.fit">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       fit
                      </span>
                     </code>
                    </a>
                    (self, y)
                   </p>
                  </td>
                  <td>
                   <p>
                    Fit label binarizer`
                   </p>
                  </td>
                 </tr>
                 <tr class="row-even">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.dask.preprocessing.LabelBinarizer.fit_transform" title="cuml.dask.preprocessing.LabelBinarizer.fit_transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       fit_transform
                      </span>
                     </code>
                    </a>
                    (self, y)
                   </p>
                  </td>
                  <td>
                   <p>
                    Fit the label encoder and return transformed labels
                   </p>
                  </td>
                 </tr>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.dask.preprocessing.LabelBinarizer.inverse_transform" title="cuml.dask.preprocessing.LabelBinarizer.inverse_transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       inverse_transform
                      </span>
                     </code>
                    </a>
                    (self, y[, threshold])
                   </p>
                  </td>
                  <td>
                   <p>
                    Invert a set of encoded labels back to original labels
                   </p>
                  </td>
                 </tr>
                 <tr class="row-even">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.dask.preprocessing.LabelBinarizer.transform" title="cuml.dask.preprocessing.LabelBinarizer.transform">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       transform
                      </span>
                     </code>
                    </a>
                    (self, y)
                   </p>
                  </td>
                  <td>
                   <p>
                    Transform and return encoded labels
                   </p>
                  </td>
                 </tr>
                </tbody>
               </table>
               <dl class="method">
                <dt id="cuml.dask.preprocessing.LabelBinarizer.fit">
                 <code class="sig-name descname">
                  fit
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.dask.preprocessing.LabelBinarizer.fit" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Fit label binarizer`
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      Dask.Array of shape [n_samples,] or [n_samples, n_classes]
                     </span>
                    </dt>
                    <dd>
                     <p>
                      chunked by row.
Target values. The 2-d matrix should only contain 0 and 1,
represents multilabel classification.
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      self
                     </strong>
                     <span class="classifier">
                      returns an instance of self.
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.dask.preprocessing.LabelBinarizer.fit_transform">
                 <code class="sig-name descname">
                  fit_transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.dask.preprocessing.LabelBinarizer.fit_transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Fit the label encoder and return transformed labels
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      Dask.Array of shape [n_samples,] or [n_samples, n_classes]
                     </span>
                    </dt>
                    <dd>
                     <p>
                      target values. The 2-d matrix should only contain 0 and 1,
represents multilabel classification.
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      arr
                     </strong>
                     <span class="classifier">
                      Dask.Array backed by CuPy arrays containing encoded labels
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.dask.preprocessing.LabelBinarizer.inverse_transform">
                 <code class="sig-name descname">
                  inverse_transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y
                 </em>
                 ,
                 <em class="sig-param">
                  threshold=None
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.dask.preprocessing.LabelBinarizer.inverse_transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Invert a set of encoded labels back to original labels
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      Dask.Array of shape [n_samples, n_classes] containing encoded
                     </span>
                    </dt>
                    <dd>
                     <p>
                      labels
                     </p>
                    </dd>
                    <dt>
                     <strong>
                      threshold
                     </strong>
                     <span class="classifier">
                      float This value is currently ignored
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      arr
                     </strong>
                     <span class="classifier">
                      Dask.Array backed by CuPy arrays containing original labels
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.dask.preprocessing.LabelBinarizer.transform">
                 <code class="sig-name descname">
                  transform
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  y
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.dask.preprocessing.LabelBinarizer.transform" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Transform and return encoded labels
                 </p>
                 <dl class="field-list simple">
                  <dt class="field-odd">
                   Parameters
                  </dt>
                  <dd class="field-odd">
                   <dl class="simple">
                    <dt>
                     <strong>
                      y
                     </strong>
                     <span class="classifier">
                      Dask.Array of shape [n_samples,] or [n_samples, n_classes]
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                  <dt class="field-even">
                   Returns
                  </dt>
                  <dd class="field-even">
                   <dl class="simple">
                    <dt>
                     <strong>
                      arr
                     </strong>
                     <span class="classifier">
                      Dask.Array backed by CuPy arrays containing encoded labels
                     </span>
                    </dt>
                    <dd>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.preprocessing.label_binarize">
               <code class="sig-prename descclassname">
                preprocessing.
               </code>
               <code class="sig-name descname">
                label_binarize
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                classes
               </em>
               ,
               <em class="sig-param">
                neg_label=0
               </em>
               ,
               <em class="sig-param">
                pos_label=1
               </em>
               ,
               <em class="sig-param">
                sparse_output=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.preprocessing.label_binarize" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                A stateless helper function to dummy encode multi-class labels.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like of size [n_samples,] or [n_samples, n_classes]
                   </span>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    classes
                   </strong>
                   <span class="classifier">
                    the set of unique classes in the input
                   </span>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    neg_label
                   </strong>
                   <span class="classifier">
                    integer the negative value for transformed output
                   </span>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    pos_label
                   </strong>
                   <span class="classifier">
                    integer the positive value for transformed output
                   </span>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    sparse_output
                   </strong>
                   <span class="classifier">
                    bool whether to return sparse array
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </div>
           </blockquote>
          </div>
          <div class="section" id="dataset-generation-single-gpu">
           <h3>
            Dataset Generation (Single-GPU)
            <a class="headerlink" href="#dataset-generation-single-gpu" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <blockquote>
            <div>
             <dl class="method">
              <dt id="cuml.datasets.make_blobs">
               <code class="sig-prename descclassname">
                datasets.
               </code>
               <code class="sig-name descname">
                make_blobs
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                n_samples=100
               </em>
               ,
               <em class="sig-param">
                n_features=2
               </em>
               ,
               <em class="sig-param">
                centers=None
               </em>
               ,
               <em class="sig-param">
                cluster_std=1.0
               </em>
               ,
               <em class="sig-param">
                center_box=(-10.0
               </em>
               ,
               <em class="sig-param">
                10.0)
               </em>
               ,
               <em class="sig-param">
                shuffle=True
               </em>
               ,
               <em class="sig-param">
                random_state=None
               </em>
               ,
               <em class="sig-param">
                dtype=u'single'
               </em>
               ,
               <em class="sig-param">
                handle=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.datasets.make_blobs" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Generator of datasets composed of isotropic Gaussian distributed clusters
in GPU.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    n_samples
                   </strong>
                   <span class="classifier">
                    int (default = 100)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Total number of points equally divided among clusters. Alternatively,
it is the total number of rows of the dataset and labels.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_features
                   </strong>
                   <span class="classifier">
                    int, optional (default=2)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of features for each sample. Alternatively, the number of
columns in the resulting dataset.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    centers
                   </strong>
                   <span class="classifier">
                    int or array-like (device or host) shape = (n_samples, n_features)  # noqa
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of centers to generate, or the fixed center locations.
If centers is None, 3 centers are generated.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    cluster_std
                   </strong>
                   <span class="classifier">
                    float or array-like (device or host) (default = 1.0)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The standard deviation of the clusters.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    center_box
                   </strong>
                   <span class="classifier">
                    tuple of floats (min, max), optional (default = (-10.0, 10.0))
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The bounding box for cluster centers when generated at random.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    shuffle
                   </strong>
                   <span class="classifier">
                    boolean, optional (default=True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether to shuffle the samples.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    random_state
                   </strong>
                   <span class="classifier">
                    int, RandomState instance or None (default)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Seed for the random number generator for dataset creation
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    handle
                   </strong>
                   <span class="classifier">
                    cuml.Handle
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If it is None, a new one is created just for this class
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <p class="rubric">
                Examples
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">make_blobs</span>

<span class="n">data</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">())</span>
</pre>
                </div>
               </div>
               <p>
                Output:
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="p">[[</span><span class="o">-</span><span class="mf">6.4611025</span>   <span class="mf">2.980582</span>  <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">1.8473494</span>   <span class="mf">6.4483595</span> <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">0.48936838</span>  <span class="mf">5.255189</span>  <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">6.0078964</span>   <span class="mf">0.59910655</span><span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">3.7753344</span>   <span class="mf">7.0041647</span> <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">0.6350849</span>   <span class="mf">5.1219263</span> <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">4.675709</span>    <span class="mf">3.0528255</span> <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">5.933864</span>    <span class="mf">2.0036478</span> <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">0.11404657</span>  <span class="mf">4.69242</span>   <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.23619342</span>  <span class="mf">4.699105</span>  <span class="p">]]</span>

<span class="p">[</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]</span>
</pre>
                </div>
               </div>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.datasets.make_regression">
               <code class="sig-prename descclassname">
                datasets.
               </code>
               <code class="sig-name descname">
                make_regression
               </code>
               <span class="sig-paren">
                (
               </span>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.datasets.make_regression" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Generate a random regression problem.
               </p>
               <p>
                See
                <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_regression.html">
                 https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_regression.html
                </a>
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    n_samples
                   </strong>
                   <span class="classifier">
                    int, optional (default=100)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of samples.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_features
                   </strong>
                   <span class="classifier">
                    int, optional (default=2)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of features.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_informative
                   </strong>
                   <span class="classifier">
                    int, optional (default=2)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of informative features, i.e., the number of features used
to build the linear model used to generate the output.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_targets
                   </strong>
                   <span class="classifier">
                    int, optional (default=1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of regression targets, i.e., the dimension of the y output
vector associated with a sample. By default, the output is a scalar.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    bias
                   </strong>
                   <span class="classifier">
                    float, optional (default=0.0)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The bias term in the underlying linear model.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    effective_rank
                   </strong>
                   <span class="classifier">
                    int or None, optional (default=None)
                   </span>
                  </dt>
                  <dd>
                   <dl class="simple">
                    <dt>
                     if not None:
                    </dt>
                    <dd>
                     <p>
                      The approximate number of singular vectors required to explain most
of the input data by linear combinations. Using this kind of
singular spectrum in the input allows the generator to reproduce
the correlations often observed in practice.
                     </p>
                    </dd>
                    <dt>
                     if None:
                    </dt>
                    <dd>
                     <p>
                      The input set is well conditioned, centered and gaussian with
unit variance.
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt>
                   <strong>
                    tail_strength
                   </strong>
                   <span class="classifier">
                    float between 0.0 and 1.0, optional (default=0.5)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The relative importance of the fat noisy tail of the singular values
profile if
                    <cite>
                     effective_rank
                    </cite>
                    is not None.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    noise
                   </strong>
                   <span class="classifier">
                    float, optional (default=0.0)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The standard deviation of the gaussian noise applied to the output.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    shuffle
                   </strong>
                   <span class="classifier">
                    boolean, optional (default=True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Shuffle the samples and the features.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    coef
                   </strong>
                   <span class="classifier">
                    boolean, optional (default=False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If True, the coefficients of the underlying linear model are returned.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    random_state
                   </strong>
                   <span class="classifier">
                    int, RandomState instance or None (default)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Seed for the random number generator for dataset creation.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    dtype: string or numpy dtype (default: ‘single’)
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    Type of the data. Possible values: float32, float64, ‘single’, ‘float’
or ‘double’.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    handle: cuml.Handle
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    If it is None, a new one is created just for this function call
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    out
                   </strong>
                   <span class="classifier">
                    device array of shape [n_samples, n_features]
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The input samples.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    values
                   </strong>
                   <span class="classifier">
                    device array of shape [n_samples, n_targets]
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The output values.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    coef
                   </strong>
                   <span class="classifier">
                    device array of shape [n_features, n_targets], optional
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The coefficient of the underlying linear model. It is returned only if
coef is True.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </div>
           </blockquote>
          </div>
          <div class="section" id="dataset-generation-dask-based-multi-gpu">
           <h3>
            Dataset Generation (Dask-based Multi-GPU)
            <a class="headerlink" href="#dataset-generation-dask-based-multi-gpu" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <blockquote>
            <div>
             <span class="target" id="module-cuml.dask.datasets.blobs">
             </span>
             <dl class="function">
              <dt id="cuml.dask.datasets.blobs.make_blobs">
               <code class="sig-prename descclassname">
                cuml.dask.datasets.blobs.
               </code>
               <code class="sig-name descname">
                make_blobs
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                nrows
               </em>
               ,
               <em class="sig-param">
                ncols
               </em>
               ,
               <em class="sig-param">
                centers=8
               </em>
               ,
               <em class="sig-param">
                n_parts=None
               </em>
               ,
               <em class="sig-param">
                cluster_std=1.0
               </em>
               ,
               <em class="sig-param">
                center_box=(-10
               </em>
               ,
               <em class="sig-param">
                10)
               </em>
               ,
               <em class="sig-param">
                random_state=None
               </em>
               ,
               <em class="sig-param">
                verbose=False
               </em>
               ,
               <em class="sig-param">
                dtype=&lt;class 'numpy.float32'&gt;
               </em>
               ,
               <em class="sig-param">
                output='dataframe'
               </em>
               ,
               <em class="sig-param">
                order='F'
               </em>
               ,
               <em class="sig-param">
                shuffle=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.datasets.blobs.make_blobs" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Makes labeled dask.Dataframe and dask_cudf.Dataframes containing blobs
for a randomly generated set of centroids.
               </p>
               <p>
                This function calls
                <cite>
                 make_blobs
                </cite>
                from Scikitlearn on each Dask worker
and aggregates them into a single Dask Dataframe.
               </p>
               <p>
                For more information on Scikit-learn’s
                <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_blobs.html">
                 make_blobs:
                </a>
                .
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    nrows
                   </strong>
                   <span class="classifier">
                    int
                   </span>
                  </dt>
                  <dd>
                   <p>
                    number of rows
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    ncols
                   </strong>
                   <span class="classifier">
                    int
                   </span>
                  </dt>
                  <dd>
                   <p>
                    number of features
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_centers
                   </strong>
                   <span class="classifier">
                    int (default = 8)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    number of centers to generate
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_parts
                   </strong>
                   <span class="classifier">
                    int (default = None)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    number of partitions to generate (this can be greater
than the number of workers)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    cluster_std
                   </strong>
                   <span class="classifier">
                    float (default = 1.0)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    standard deviation of points around centroid
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    center_box
                   </strong>
                   <span class="classifier">
                    tuple (int, int) (default = (-10, 10))
                   </span>
                  </dt>
                  <dd>
                   <p>
                    the bounding box which constrains all the centroids
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    random_state
                   </strong>
                   <span class="classifier">
                    int (default = None)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    sets random seed (or use None to reinitialize each time)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    verbose
                   </strong>
                   <span class="classifier">
                    bool (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    enables / disables verbose printing.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    dtype
                   </strong>
                   <span class="classifier">
                    dtype (default = np.float32)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    datatype to generate
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    output
                   </strong>
                   <span class="classifier">
                    str (default = ‘dataframe’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    whether to generate dask array or
dask dataframe output. Default will be array in the future.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   (dask.Dataframe for X, dask.Series for labels)
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <span class="target" id="module-cuml.dask.datasets.regression">
             </span>
             <dl class="function">
              <dt id="cuml.dask.datasets.regression.make_low_rank_matrix">
               <code class="sig-prename descclassname">
                cuml.dask.datasets.regression.
               </code>
               <code class="sig-name descname">
                make_low_rank_matrix
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                n_samples=100
               </em>
               ,
               <em class="sig-param">
                n_features=100
               </em>
               ,
               <em class="sig-param">
                effective_rank=10
               </em>
               ,
               <em class="sig-param">
                tail_strength=0.5
               </em>
               ,
               <em class="sig-param">
                random_state=None
               </em>
               ,
               <em class="sig-param">
                n_parts=1
               </em>
               ,
               <em class="sig-param">
                n_samples_per_part=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.datasets.regression.make_low_rank_matrix" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Generate a mostly low rank matrix with bell-shaped singular values
               </p>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl>
                  <dt>
                   <strong>
                    n_samples
                   </strong>
                   <span class="classifier">
                    int, optional (default=100)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of samples.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_features
                   </strong>
                   <span class="classifier">
                    int, optional (default=100)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of features.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    effective_rank
                   </strong>
                   <span class="classifier">
                    int, optional (default=10)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The approximate number of singular vectors required to explain most of
the data by linear combinations.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    tail_strength
                   </strong>
                   <span class="classifier">
                    float between 0.0 and 1.0, optional (default=0.5)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The relative importance of the fat noisy tail of the singular values
profile.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    random_state
                   </strong>
                   <span class="classifier">
                    int, CuPy RandomState instance, Dask RandomState instance
                   </span>
                  </dt>
                  <dd>
                   <blockquote>
                    <div>
                     <p>
                      or None (default)
                     </p>
                    </div>
                   </blockquote>
                   <p>
                    Determines random number generation for dataset creation. Pass an int
for reproducible output across multiple function calls.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_parts
                   </strong>
                   <span class="classifier">
                    int, optional (default=1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of parts of work.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask-CuPy array of shape [n_samples, n_features]
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The matrix.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="function">
              <dt id="cuml.dask.datasets.regression.make_regression">
               <code class="sig-prename descclassname">
                cuml.dask.datasets.regression.
               </code>
               <code class="sig-name descname">
                make_regression
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                n_samples=100
               </em>
               ,
               <em class="sig-param">
                n_features=100
               </em>
               ,
               <em class="sig-param">
                n_informative=10
               </em>
               ,
               <em class="sig-param">
                n_targets=1
               </em>
               ,
               <em class="sig-param">
                bias=0.0
               </em>
               ,
               <em class="sig-param">
                effective_rank=None
               </em>
               ,
               <em class="sig-param">
                tail_strength=0.5
               </em>
               ,
               <em class="sig-param">
                noise=0.0
               </em>
               ,
               <em class="sig-param">
                shuffle=False
               </em>
               ,
               <em class="sig-param">
                coef=False
               </em>
               ,
               <em class="sig-param">
                random_state=None
               </em>
               ,
               <em class="sig-param">
                n_parts=1
               </em>
               ,
               <em class="sig-param">
                n_samples_per_part=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.datasets.regression.make_regression" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Generate a random regression problem.
The input set can either be well conditioned (by default) or have a low
rank-fat tail singular profile.
               </p>
               <p>
                The output is generated by applying a (potentially biased) random linear
regression model with “n_informative” nonzero regressors to the previously
generated input and some gaussian centered noise with some adjustable
scale.
               </p>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl>
                  <dt>
                   <strong>
                    n_samples
                   </strong>
                   <span class="classifier">
                    int, optional (default=100)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of samples.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_features
                   </strong>
                   <span class="classifier">
                    int, optional (default=100)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of features.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_informative
                   </strong>
                   <span class="classifier">
                    int, optional (default=10)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of informative features, i.e., the number of features used
to build the linear model used to generate the output.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_targets
                   </strong>
                   <span class="classifier">
                    int, optional (default=1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of regression targets, i.e., the dimension of the y output
vector associated with a sample. By default, the output is a scalar.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    bias
                   </strong>
                   <span class="classifier">
                    float, optional (default=0.0)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The bias term in the underlying linear model.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    effective_rank
                   </strong>
                   <span class="classifier">
                    int or None, optional (default=None)
                   </span>
                  </dt>
                  <dd>
                   <dl class="simple">
                    <dt>
                     if not None:
                    </dt>
                    <dd>
                     <p>
                      The approximate number of singular vectors required to explain most
of the input data by linear combinations. Using this kind of
singular spectrum in the input allows the generator to reproduce
the correlations often observed in practice.
                     </p>
                    </dd>
                    <dt>
                     if None:
                    </dt>
                    <dd>
                     <p>
                      The input set is well conditioned, centered and gaussian with
unit variance.
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt>
                   <strong>
                    tail_strength
                   </strong>
                   <span class="classifier">
                    float between 0.0 and 1.0, optional (default=0.5)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The relative importance of the fat noisy tail of the singular values
profile if “effective_rank” is not None.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    noise
                   </strong>
                   <span class="classifier">
                    float, optional (default=0.0)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The standard deviation of the gaussian noise applied to the output.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    shuffle
                   </strong>
                   <span class="classifier">
                    boolean, optional (default=False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Shuffle the samples and the features.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    coef
                   </strong>
                   <span class="classifier">
                    boolean, optional (default=False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If True, the coefficients of the underlying linear model are returned.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    random_state
                   </strong>
                   <span class="classifier">
                    int, CuPy RandomState instance, Dask RandomState instance
                   </span>
                  </dt>
                  <dd>
                   <blockquote>
                    <div>
                     <p>
                      or None (default)
                     </p>
                    </div>
                   </blockquote>
                   <p>
                    Determines random number generation for dataset creation. Pass an int
for reproducible output across multiple function calls.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_parts
                   </strong>
                   <span class="classifier">
                    int, optional (default=1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of parts of work.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl>
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask-CuPy array of shape [n_samples, n_features]
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The input samples.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    Dask-CuPy array of shape [n_samples] or [n_samples, n_targets]
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The output values.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    coef
                   </strong>
                   <span class="classifier">
                    Dask-CuPy array of shape [n_features]
                   </span>
                  </dt>
                  <dd>
                   <blockquote>
                    <div>
                     <p>
                      or [n_features, n_targets], optional
                     </p>
                    </div>
                   </blockquote>
                   <p>
                    The coefficient of the underlying linear model. It is returned only if
coef is True.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </div>
           </blockquote>
          </div>
          <div class="section" id="metrics">
           <h3>
            Metrics
            <a class="headerlink" href="#metrics" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <blockquote>
            <div>
             <span class="target" id="module-cuml.metrics.regression">
             </span>
             <dl class="function">
              <dt id="cuml.metrics.regression.mean_absolute_error">
               <code class="sig-prename descclassname">
                cuml.metrics.regression.
               </code>
               <code class="sig-name descname">
                mean_absolute_error
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                *args
               </em>
               ,
               <em class="sig-param">
                **kwargs
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.metrics.regression.mean_absolute_error" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Mean absolute error regression loss
               </p>
               <p>
                Be careful when using this metric with float32 inputs as the result can be
slightly incorrect because of floating point precision if the input is
large enough. float64 will have lower numerical error.
               </p>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y_true
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or (n_samples, n_outputs)
Ground truth (correct) target values.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y_pred
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or (n_samples, n_outputs)
Estimated target values.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    sample_weight
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,), optional
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Sample weights.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    multioutput
                   </strong>
                   <span class="classifier">
                    string in [‘raw_values’, ‘uniform_average’]
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or array-like of shape (n_outputs)
Defines aggregating of multiple output values.
Array-like value defines weights used to average errors.
‘raw_values’ :
Returns a full set of errors in case of multioutput input.
‘uniform_average’ :
Errors of all outputs are averaged with uniform weight.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl>
                  <dt>
                   <strong>
                    loss
                   </strong>
                   <span class="classifier">
                    float or ndarray of floats
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If multioutput is ‘raw_values’, then mean absolute error is returned
for each output separately. If multioutput is ‘uniform_average’ or an
ndarray of weights, then the weighted average of all output errors is
returned.
                   </p>
                   <p>
                    MAE output is non-negative floating point. The best value is 0.0.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="function">
              <dt id="cuml.metrics.regression.mean_squared_error">
               <code class="sig-prename descclassname">
                cuml.metrics.regression.
               </code>
               <code class="sig-name descname">
                mean_squared_error
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                *args
               </em>
               ,
               <em class="sig-param">
                **kwargs
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.metrics.regression.mean_squared_error" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Mean squared error regression loss
               </p>
               <p>
                Be careful when using this metric with float32 inputs as the result can be
slightly incorrect because of floating point precision if the input is
large enough. float64 will have lower numerical error.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y_true
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or (n_samples, n_outputs)
Ground truth (correct) target values.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y_pred
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or (n_samples, n_outputs)
Estimated target values.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    sample_weight
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,), optional
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Sample weights.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    multioutput
                   </strong>
                   <span class="classifier">
                    string in [‘raw_values’, ‘uniform_average’]
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or array-like of shape (n_outputs)
Defines aggregating of multiple output values.
Array-like value defines weights used to average errors.
‘raw_values’ :
Returns a full set of errors in case of multioutput input.
‘uniform_average’ :
Errors of all outputs are averaged with uniform weight.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    squared
                   </strong>
                   <span class="classifier">
                    boolean value, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If True returns MSE value, if False returns RMSE value.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    loss
                   </strong>
                   <span class="classifier">
                    float or ndarray of floats
                   </span>
                  </dt>
                  <dd>
                   <p>
                    A non-negative floating point value (the best value is 0.0), or an
array of floating point values, one for each individual target.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="function">
              <dt id="cuml.metrics.regression.mean_squared_log_error">
               <code class="sig-prename descclassname">
                cuml.metrics.regression.
               </code>
               <code class="sig-name descname">
                mean_squared_log_error
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                *args
               </em>
               ,
               <em class="sig-param">
                **kwargs
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.metrics.regression.mean_squared_log_error" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Mean squared log error regression loss
               </p>
               <p>
                Be careful when using this metric with float32 inputs as the result can be
slightly incorrect because of floating point precision if the input is
large enough. float64 will have lower numerical error.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y_true
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or (n_samples, n_outputs)
Ground truth (correct) target values.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y_pred
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or (n_samples, n_outputs)
Estimated target values.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    sample_weight
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,), optional
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Sample weights.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    multioutput
                   </strong>
                   <span class="classifier">
                    string in [‘raw_values’, ‘uniform_average’]
                   </span>
                  </dt>
                  <dd>
                   <p>
                    or array-like of shape (n_outputs)
Defines aggregating of multiple output values.
Array-like value defines weights used to average errors.
‘raw_values’ :
Returns a full set of errors in case of multioutput input.
‘uniform_average’ :
Errors of all outputs are averaged with uniform weight.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    squared
                   </strong>
                   <span class="classifier">
                    boolean value, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If True returns MSE value, if False returns RMSE value.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    loss
                   </strong>
                   <span class="classifier">
                    float or ndarray of floats
                   </span>
                  </dt>
                  <dd>
                   <p>
                    A non-negative floating point value (the best value is 0.0), or an
array of floating point values, one for each individual target.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="function">
              <dt id="cuml.metrics.regression.r2_score">
               <code class="sig-prename descclassname">
                cuml.metrics.regression.
               </code>
               <code class="sig-name descname">
                r2_score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                y_hat
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               ,
               <em class="sig-param">
                handle=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.metrics.regression.r2_score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Calculates r2 score between y and y_hat
               </p>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <blockquote>
                    <div>
                     <p>
                      Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                     </p>
                    </div>
                   </blockquote>
                   <dl class="simple">
                    <dt>
                     y_hat
                     <span class="classifier">
                      array-like (device or host) shape = (n_samples, 1)
                     </span>
                    </dt>
                    <dd>
                     <p>
                      Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                     </p>
                    </dd>
                    <dt>
                     convert_dtype
                     <span class="classifier">
                      bool, optional (default = False)
                     </span>
                    </dt>
                    <dd>
                     <p>
                      When set to True, the fit method will, when necessary, convert
y_hat to be the same data type as y if they differ. This
will increase memory used for the method.
                     </p>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    trustworthiness score
                   </strong>
                   <span class="classifier">
                    double
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Trustworthiness of the low-dimensional embedding
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <span class="target" id="module-cuml.metrics.accuracy">
             </span>
             <dl class="function">
              <dt id="cuml.metrics.accuracy.accuracy_score">
               <code class="sig-prename descclassname">
                cuml.metrics.accuracy.
               </code>
               <code class="sig-name descname">
                accuracy_score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                ground_truth
               </em>
               ,
               <em class="sig-param">
                predictions
               </em>
               ,
               <em class="sig-param">
                handle=None
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.metrics.accuracy.accuracy_score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Calcuates the accuracy score of a classification model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    handle
                   </strong>
                   <span class="classifier">
                    cuml.Handle
                   </span>
                  </dt>
                  <dd>
                   <dl class="simple">
                    <dt>
                     prediction
                     <span class="classifier">
                      NumPy ndarray or Numba device
                     </span>
                    </dt>
                    <dd>
                     <p>
                      The labels predicted by the model for the test dataset
                     </p>
                    </dd>
                    <dt>
                     ground_truth
                     <span class="classifier">
                      NumPy ndarray, Numba device
                     </span>
                    </dt>
                    <dd>
                     <p>
                      The ground truth labels of the test dataset
                     </p>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   float
                  </dt>
                  <dd>
                   <p>
                    The accuracy of the model used for prediction
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <span class="target" id="module-cuml.metrics.trustworthiness">
             </span>
             <dl class="function">
              <dt id="cuml.metrics.trustworthiness.trustworthiness">
               <code class="sig-prename descclassname">
                cuml.metrics.trustworthiness.
               </code>
               <code class="sig-name descname">
                trustworthiness
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                X_embedded
               </em>
               ,
               <em class="sig-param">
                handle=None
               </em>
               ,
               <em class="sig-param">
                n_neighbors=5
               </em>
               ,
               <em class="sig-param">
                metric=u'euclidean'
               </em>
               ,
               <em class="sig-param">
                should_downcast=True
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               ,
               <em class="sig-param">
                batch_size=512
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.metrics.trustworthiness.trustworthiness" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Expresses to what extent the local structure is retained in embedding.
The score is defined in the range [0, 1].
               </p>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl>
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <blockquote>
                    <div>
                     <p>
                      Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                     </p>
                    </div>
                   </blockquote>
                   <dl class="simple">
                    <dt>
                     X_embedded
                     <span class="classifier">
                      array-like (device or host) shape= (n_samples, n_features)
                     </span>
                    </dt>
                    <dd>
                     <p>
                      Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                     </p>
                    </dd>
                    <dt>
                     n_neighbors
                     <span class="classifier">
                      int, optional (default: 5)
                     </span>
                    </dt>
                    <dd>
                     <p>
                      Number of neighbors considered
                     </p>
                    </dd>
                    <dt>
                     convert_dtype
                     <span class="classifier">
                      bool, optional (default = False)
                     </span>
                    </dt>
                    <dd>
                     <p>
                      When set to True, the trustworthiness method will automatically
convert the inputs to np.float32.
                     </p>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    trustworthiness score
                   </strong>
                   <span class="classifier">
                    double
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Trustworthiness of the low-dimensional embedding
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <span class="target" id="module-cuml.metrics.cluster.adjustedrandindex">
             </span>
             <dl class="function">
              <dt id="cuml.metrics.cluster.adjustedrandindex.adjusted_rand_score">
               <code class="sig-prename descclassname">
                cuml.metrics.cluster.adjustedrandindex.
               </code>
               <code class="sig-name descname">
                adjusted_rand_score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                labels_true
               </em>
               ,
               <em class="sig-param">
                labels_pred
               </em>
               ,
               <em class="sig-param">
                handle=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.metrics.cluster.adjustedrandindex.adjusted_rand_score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Adjusted_rand_score is a clustering similarity metric based on the Rand
index and is corrected for chance.
               </p>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl>
                  <dt>
                   <strong>
                    labels_true
                   </strong>
                   <span class="classifier">
                    Ground truth labels to be used as a reference
                   </span>
                  </dt>
                  <dd>
                   <p>
                    labels_pred : Array of predicted labels used to evaluate the model
                   </p>
                   <p>
                    handle : cuml.Handle
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   float
                  </dt>
                  <dd>
                   <p>
                    The adjusted rand index value between -1.0 and 1.0
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <span class="target" id="module-cuml.metrics.cluster.entropy">
             </span>
             <dl class="function">
              <dt id="cuml.metrics.cluster.entropy.cython_entropy">
               <code class="sig-prename descclassname">
                cuml.metrics.cluster.entropy.
               </code>
               <code class="sig-name descname">
                cython_entropy
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                clustering
               </em>
               ,
               <em class="sig-param">
                base=None
               </em>
               ,
               <em class="sig-param">
                handle=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.metrics.cluster.entropy.cython_entropy" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Computes the entropy of a distribution for given probability values.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    clustering
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples,)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Clustering of labels. Probabilities are computed based on occurrences
of labels. For instance, to represent a fair coin (2 equally possible
outcomes), the clustering could be [0,1]. For a biased coin with 2/3
probability for tail, the clustering could be [0, 0, 1].
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    base: float, optional
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    The logarithmic base to use, defaults to e (natural logarithm).
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    handle
                   </strong>
                   <span class="classifier">
                    cuml.Handle
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Specifies the cuml.handle that holds internal CUDA state for
computations in this model. Most importantly, this specifies the CUDA
stream that will be used for the model’s computations, so users can
run different models concurrently in different streams by creating
handles in several streams.
If it is None, a new one is created.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    S
                   </strong>
                   <span class="classifier">
                    float
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The calculated entropy.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </div>
           </blockquote>
          </div>
          <div class="section" id="benchmarking">
           <h3>
            Benchmarking
            <a class="headerlink" href="#benchmarking" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <blockquote>
            <div>
             <span class="target" id="module-cuml.benchmark.algorithms">
             </span>
             <dl class="class">
              <dt id="cuml.benchmark.algorithms.AlgorithmPair">
               <em class="property">
                class
               </em>
               <code class="sig-prename descclassname">
                cuml.benchmark.algorithms.
               </code>
               <code class="sig-name descname">
                AlgorithmPair
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                cpu_class
               </em>
               ,
               <em class="sig-param">
                cuml_class
               </em>
               ,
               <em class="sig-param">
                shared_args
               </em>
               ,
               <em class="sig-param">
                cuml_args={}
               </em>
               ,
               <em class="sig-param">
                cpu_args={}
               </em>
               ,
               <em class="sig-param">
                name=None
               </em>
               ,
               <em class="sig-param">
                accepts_labels=True
               </em>
               ,
               <em class="sig-param">
                cpu_data_prep_hook=None
               </em>
               ,
               <em class="sig-param">
                cuml_data_prep_hook=None
               </em>
               ,
               <em class="sig-param">
                accuracy_function=None
               </em>
               ,
               <em class="sig-param">
                bench_func=&lt;function fit&gt;
               </em>
               ,
               <em class="sig-param">
                setup_cpu_func=None
               </em>
               ,
               <em class="sig-param">
                setup_cuml_func=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.algorithms.AlgorithmPair" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Wraps a cuML algorithm and (optionally) a cpu-based algorithm
(typically scikit-learn, but does not need to be as long as it offers
                <cite>
                 fit
                </cite>
                and
                <cite>
                 predict
                </cite>
                or
                <cite>
                 transform
                </cite>
                methods).
Provides mechanisms to run each version with default arguments.
If no CPU-based version of the algorithm is available, pass None for the
cpu_class when instantiating
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    cpu_class
                   </strong>
                   <span class="classifier">
                    class
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Class for CPU version of algorithm. Set to None if not available.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    cuml_class
                   </strong>
                   <span class="classifier">
                    class
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Class for cuML algorithm
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    shared_args
                   </strong>
                   <span class="classifier">
                    dict
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Arguments passed to both implementations’s initializer
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    cuml_args
                   </strong>
                   <span class="classifier">
                    dict
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Arguments
                    <em>
                     only
                    </em>
                    passed to cuml’s initializer
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    cpu_args dict
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    Arguments
                    <em>
                     only
                    </em>
                    passed to sklearn’s initializer
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    accepts_labels
                   </strong>
                   <span class="classifier">
                    boolean
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If True, the fit methods expects both X and y
inputs. Otherwise, it expects only an X input.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    data_prep_hook
                   </strong>
                   <span class="classifier">
                    function (data -&gt; data)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Optional function to run on input data before passing to fit
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    accuracy_function
                   </strong>
                   <span class="classifier">
                    function (y_test, y_pred)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Function that returns a scalar representing accuracy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    bench_func
                   </strong>
                   <span class="classifier">
                    custom function to perform fit/predict/transform
                   </span>
                  </dt>
                  <dd>
                   <p>
                    calls.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <p class="rubric">
                Methods
               </p>
               <table class="longtable docutils align-default">
                <colgroup>
                 <col style="width: 10%"/>
                 <col style="width: 90%"/>
                </colgroup>
                <tbody>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.benchmark.algorithms.AlgorithmPair.run_cpu" title="cuml.benchmark.algorithms.AlgorithmPair.run_cpu">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       run_cpu
                      </span>
                     </code>
                    </a>
                    (self, data, \*\*override_args)
                   </p>
                  </td>
                  <td>
                   <p>
                    Runs the cpu-based algorithm’s fit method on specified data
                   </p>
                  </td>
                 </tr>
                 <tr class="row-even">
                  <td>
                   <p>
                    <a class="reference internal" href="#cuml.benchmark.algorithms.AlgorithmPair.run_cuml" title="cuml.benchmark.algorithms.AlgorithmPair.run_cuml">
                     <code class="xref py py-obj docutils literal notranslate">
                      <span class="pre">
                       run_cuml
                      </span>
                     </code>
                    </a>
                    (self, data, \*\*override_args)
                   </p>
                  </td>
                  <td>
                   <p>
                    Runs the cuml-based algorithm’s fit method on specified data
                   </p>
                  </td>
                 </tr>
                </tbody>
               </table>
               <table class="docutils align-default">
                <colgroup>
                 <col style="width: 58%"/>
                 <col style="width: 42%"/>
                </colgroup>
                <tbody>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <strong>
                     setup_cpu
                    </strong>
                   </p>
                  </td>
                  <td>
                  </td>
                 </tr>
                 <tr class="row-even">
                  <td>
                   <p>
                    <strong>
                     setup_cuml
                    </strong>
                   </p>
                  </td>
                  <td>
                  </td>
                 </tr>
                </tbody>
               </table>
               <dl class="method">
                <dt id="cuml.benchmark.algorithms.AlgorithmPair.run_cpu">
                 <code class="sig-name descname">
                  run_cpu
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  data
                 </em>
                 ,
                 <em class="sig-param">
                  **override_args
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.benchmark.algorithms.AlgorithmPair.run_cpu" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Runs the cpu-based algorithm’s fit method on specified data
                 </p>
                </dd>
               </dl>
               <dl class="method">
                <dt id="cuml.benchmark.algorithms.AlgorithmPair.run_cuml">
                 <code class="sig-name descname">
                  run_cuml
                 </code>
                 <span class="sig-paren">
                  (
                 </span>
                 <em class="sig-param">
                  self
                 </em>
                 ,
                 <em class="sig-param">
                  data
                 </em>
                 ,
                 <em class="sig-param">
                  **override_args
                 </em>
                 <span class="sig-paren">
                  )
                 </span>
                 <a class="headerlink" href="#cuml.benchmark.algorithms.AlgorithmPair.run_cuml" title="Permalink to this definition">
                  ¶
                 </a>
                </dt>
                <dd>
                 <p>
                  Runs the cuml-based algorithm’s fit method on specified data
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="function">
              <dt id="cuml.benchmark.algorithms.algorithm_by_name">
               <code class="sig-prename descclassname">
                cuml.benchmark.algorithms.
               </code>
               <code class="sig-name descname">
                algorithm_by_name
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                name
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.algorithms.algorithm_by_name" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the algorithm pair with the name ‘name’ (case-insensitive)
               </p>
              </dd>
             </dl>
             <dl class="function">
              <dt id="cuml.benchmark.algorithms.all_algorithms">
               <code class="sig-prename descclassname">
                cuml.benchmark.algorithms.
               </code>
               <code class="sig-name descname">
                all_algorithms
               </code>
               <span class="sig-paren">
                (
               </span>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.algorithms.all_algorithms" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns all defined AlgorithmPair objects
               </p>
              </dd>
             </dl>
             <span class="target" id="module-cuml.benchmark.runners">
             </span>
             <p>
              Wrappers to run ML benchmarks
             </p>
             <dl class="class">
              <dt id="cuml.benchmark.runners.AccuracyComparisonRunner">
               <em class="property">
                class
               </em>
               <code class="sig-prename descclassname">
                cuml.benchmark.runners.
               </code>
               <code class="sig-name descname">
                AccuracyComparisonRunner
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                bench_rows
               </em>
               ,
               <em class="sig-param">
                bench_dims
               </em>
               ,
               <em class="sig-param">
                dataset_name='blobs'
               </em>
               ,
               <em class="sig-param">
                input_type='numpy'
               </em>
               ,
               <em class="sig-param">
                test_fraction=0.1
               </em>
               ,
               <em class="sig-param">
                n_reps=1
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.runners.AccuracyComparisonRunner" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Wrapper to run an algorithm with multiple dataset sizes
and compute accuracy and speedup of cuml relative to sklearn
baseline.
               </p>
              </dd>
             </dl>
             <dl class="class">
              <dt id="cuml.benchmark.runners.BenchmarkTimer">
               <em class="property">
                class
               </em>
               <code class="sig-prename descclassname">
                cuml.benchmark.runners.
               </code>
               <code class="sig-name descname">
                BenchmarkTimer
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                reps=1
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.runners.BenchmarkTimer" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Provides a context manager that runs a code block
                <cite>
                 reps
                </cite>
                times
and records results to the instance variable
                <cite>
                 timings
                </cite>
                . Use like:
               </p>
               <div class="highlight-python notranslate">
                <div class="highlight">
                 <pre><span></span><span class="n">timer</span> <span class="o">=</span> <span class="n">BenchmarkTimer</span><span class="p">(</span><span class="n">rep</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">timer</span><span class="o">.</span><span class="n">benchmark_runs</span><span class="p">():</span>
    <span class="o">...</span> <span class="n">do</span> <span class="n">something</span> <span class="o">...</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">timer</span><span class="o">.</span><span class="n">timings</span><span class="p">))</span>
</pre>
                </div>
               </div>
               <p class="rubric">
                Methods
               </p>
               <table class="docutils align-default">
                <colgroup>
                 <col style="width: 64%"/>
                 <col style="width: 36%"/>
                </colgroup>
                <tbody>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <strong>
                     benchmark_runs
                    </strong>
                   </p>
                  </td>
                  <td>
                  </td>
                 </tr>
                </tbody>
               </table>
              </dd>
             </dl>
             <dl class="class">
              <dt id="cuml.benchmark.runners.SpeedupComparisonRunner">
               <em class="property">
                class
               </em>
               <code class="sig-prename descclassname">
                cuml.benchmark.runners.
               </code>
               <code class="sig-name descname">
                SpeedupComparisonRunner
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                bench_rows
               </em>
               ,
               <em class="sig-param">
                bench_dims
               </em>
               ,
               <em class="sig-param">
                dataset_name='blobs'
               </em>
               ,
               <em class="sig-param">
                input_type='numpy'
               </em>
               ,
               <em class="sig-param">
                n_reps=1
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.runners.SpeedupComparisonRunner" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Wrapper to run an algorithm with multiple dataset sizes
and compute speedup of cuml relative to sklearn baseline.
               </p>
               <p class="rubric">
                Methods
               </p>
               <table class="docutils align-default">
                <colgroup>
                 <col style="width: 41%"/>
                 <col style="width: 59%"/>
                </colgroup>
                <tbody>
                 <tr class="row-odd">
                  <td>
                   <p>
                    <strong>
                     run
                    </strong>
                   </p>
                  </td>
                  <td>
                  </td>
                 </tr>
                </tbody>
               </table>
              </dd>
             </dl>
             <dl class="function">
              <dt id="cuml.benchmark.runners.run_variations">
               <code class="sig-prename descclassname">
                cuml.benchmark.runners.
               </code>
               <code class="sig-name descname">
                run_variations
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                algos, dataset_name, bench_rows, bench_dims, param_override_list=[{}], cuml_param_override_list=[{}], input_type='numpy', test_fraction=0.1, run_cpu=True, raise_on_error=False, n_reps=1
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.runners.run_variations" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Runs each algo in
                <cite>
                 algos
                </cite>
                once per
                <cite>
                 bench_rows X bench_dims X params_override_list X cuml_param_override_list
                </cite>
                combination and returns a dataframe containing timing and accuracy data.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    algos
                   </strong>
                   <span class="classifier">
                    str or list
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Name of algorithms to run and evaluate
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    dataset_name
                   </strong>
                   <span class="classifier">
                    str
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Name of dataset to use
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    bench_rows
                   </strong>
                   <span class="classifier">
                    list of int
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dataset row counts to test
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    bench_dims
                   </strong>
                   <span class="classifier">
                    list of int
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dataset column counts to test
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    param_override_list
                   </strong>
                   <span class="classifier">
                    list of dict
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dicts containing parameters to pass to __init__.
Each dict specifies parameters to override in one run of the algorithm.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    cuml_param_override_list
                   </strong>
                   <span class="classifier">
                    list of dict
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dicts containing parameters to pass to __init__ of the cuml algo only.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    test_fraction
                   </strong>
                   <span class="classifier">
                    float
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The fraction of data to use for testing.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    run_cpu
                   </strong>
                   <span class="classifier">
                    boolean
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If True, run the cpu-based algorithm for comparison
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <span class="target" id="module-cuml.benchmark.datagen">
             </span>
             <p>
              Data generators for cuML benchmarks
             </p>
             <p>
              The main entry point for consumers is gen_data, which
wraps the underlying data generators.
             </p>
             <p>
              Notes when writing new generators:
             </p>
             <dl class="simple">
              <dt>
               Each generator is a function that accepts:
              </dt>
              <dd>
               <ul class="simple">
                <li>
                 <p>
                  n_samples (set to 0 for ‘default’)
                 </p>
                </li>
                <li>
                 <p>
                  n_features (set to 0 for ‘default’)
                 </p>
                </li>
                <li>
                 <p>
                  random_state
                 </p>
                </li>
                <li>
                 <p>
                  (and optional generator-specific parameters)
                 </p>
                </li>
               </ul>
              </dd>
             </dl>
             <p>
              The function should return a 2-tuple (X, y), where X is a Pandas
dataframe and y is a Pandas series. If the generator does not produce
labels, it can return (X, None)
             </p>
             <p>
              A set of helper functions (convert_*) can convert these to alternative
formats. Future revisions may support generating cudf dataframes or
GPU arrays directly instead.
             </p>
             <dl class="attribute">
              <dt id="cuml.benchmark.datagen.gen_data">
               <code class="sig-prename descclassname">
                cuml.benchmark.datagen.
               </code>
               <code class="sig-name descname">
                gen_data
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                dataset_name
               </em>
               ,
               <em class="sig-param">
                dataset_format
               </em>
               ,
               <em class="sig-param">
                n_samples=0
               </em>
               ,
               <em class="sig-param">
                n_features=0
               </em>
               ,
               <em class="sig-param">
                random_state=42
               </em>
               ,
               <em class="sig-param">
                test_fraction=0.0
               </em>
               ,
               <em class="sig-param">
                **kwargs
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.datagen.gen_data" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns a tuple of data from the specified generator.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    dataset_name
                   </strong>
                   <span class="classifier">
                    str
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dataset to use. Can be a synthetic generator (blobs or regression)
or a specified dataset (higgs currently, others coming soon)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    dataset_format
                   </strong>
                   <span class="classifier">
                    str
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Type of data to return. (One of cudf, numpy, pandas, gpuarray)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_samples
                   </strong>
                   <span class="classifier">
                    int
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Number of samples to include in training set (regardless of test split)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    test_fraction
                   </strong>
                   <span class="classifier">
                    float
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Fraction of the dataset to partition randomly into the test set.
If this is 0.0, no test set will be created.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="function">
              <dt id="cuml.benchmark.datagen.load_higgs">
               <code class="sig-prename descclassname">
                cuml.benchmark.datagen.
               </code>
               <code class="sig-name descname">
                load_higgs
               </code>
               <span class="sig-paren">
                (
               </span>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.benchmark.datagen.load_higgs" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the Higgs Boson dataset as an X, y tuple of dataframes.
               </p>
              </dd>
             </dl>
            </div>
           </blockquote>
          </div>
         </div>
         <div class="section" id="regression-and-classification">
          <h2>
           Regression and Classification
           <a class="headerlink" href="#regression-and-classification" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="linear-regression">
           <h3>
            Linear Regression
            <a class="headerlink" href="#linear-regression" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.LinearRegression">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              LinearRegression
             </code>
             <a class="headerlink" href="#cuml.LinearRegression" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              LinearRegression is a simple machine learning model where the response y is
modelled by a linear combination of the predictors in X.
             </p>
             <p>
              cuML’s LinearRegression expects either a cuDF DataFrame or a NumPy matrix
and provides 2 algorithms SVD and Eig to fit a linear model. SVD is more
stable, but Eig (default) is much faster.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  algorithm
                 </strong>
                 <span class="classifier">
                  ‘eig’ or ‘svd’ (default = ‘eig’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Eig uses a eigendecomposition of the covariance matrix, and is much
faster.
SVD is slower, but guaranteed to be stable.
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, LinearRegression tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  normalize
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  This parameter is ignored when
                  <cite>
                   fit_intercept
                  </cite>
                  is set to False.
If True, the predictors in X will be normalized by dividing by it’s
L2 norm.
If False, no scaling will be done.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              LinearRegression suffers from multicollinearity (when columns are
correlated with each other), and variance explosions from outliers.
Consider using Ridge Regression to fix the multicollinearity problem, and
consider maybe first DBSCAN to remove the outliers, or statistical analysis
to filter possible outliers.
             </p>
             <p>
              <strong>
               Applications of LinearRegression
              </strong>
             </p>
             <blockquote>
              <div>
               <p>
                LinearRegression is used in regression tasks where one wants to predict
say sales or house prices. It is also used in extrapolation or time
series tasks, dynamic systems modelling and many other machine learning
tasks. This model should be first tried if the machine learning problem
is a regression task (predicting a continuous variable).
               </p>
              </div>
             </blockquote>
             <p>
              For additional information, see
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html">
               scikitlearn’s OLS documentation
              </a>
              .
             </p>
             <p>
              For an additional example see
              <a class="reference external" href="https://github.com/rapidsai/notebooks/blob/branch-0.12/cuml/linear_regression_demo.ipynb">
               the OLS notebook
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cudf</span>

<span class="c1"># Both import methods supported</span>
<span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">cuml.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="n">lr</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">(</span><span class="n">fit_intercept</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">"eig"</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="mf">11.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="p">)</span>

<span class="n">reg</span> <span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Coefficients:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Intercept:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">intercept_</span><span class="p">)</span>

<span class="n">X_new</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">preds</span> <span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Predictions:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Coefficients</span><span class="p">:</span>

            <span class="mi">0</span> <span class="mf">1.0000001</span>
            <span class="mi">1</span> <span class="mf">1.9999998</span>

<span class="n">Intercept</span><span class="p">:</span>
            <span class="mf">3.0</span>

<span class="n">Predictions</span><span class="p">:</span>

            <span class="mi">0</span> <span class="mf">15.999999</span>
            <span class="mi">1</span> <span class="mf">14.999999</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  coef_
                 </strong>
                 <span class="classifier">
                  array, shape (n_features)
                 </span>
                </dt>
                <dd>
                 <p>
                  The estimated coefficients for the linear regression model.
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The independent term. If
                  <cite>
                   fit_intercept_
                  </cite>
                  is False, will be 0.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LinearRegression.fit" title="cuml.LinearRegression.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LinearRegression.get_param_names" title="cuml.LinearRegression.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LinearRegression.predict" title="cuml.LinearRegression.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts
                  <cite>
                   y
                  </cite>
                  values for
                  <cite>
                   X
                  </cite>
                  .
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.LinearRegression.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LinearRegression.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.LinearRegression.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LinearRegression.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.LinearRegression.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LinearRegression.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts
                <cite>
                 y
                </cite>
                values for
                <cite>
                 X
                </cite>
                .
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   y: cuDF DataFrame
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="logistic-regression">
           <h3>
            Logistic Regression
            <a class="headerlink" href="#logistic-regression" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.LogisticRegression">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              LogisticRegression
             </code>
             <a class="headerlink" href="#cuml.LogisticRegression" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              LogisticRegression is a linear model that is used to model probability of
occurrence of certain events, for example probability of success or fail of
an event.
             </p>
             <p>
              cuML’s LogisticRegression can take array-like objects, either in host as
NumPy arrays or in device (as Numba or
              <cite>
               __cuda_array_interface__
              </cite>
              compliant), in addition to cuDF objects.
It provides both single-class (using sigmoid loss) and multiple-class
(using softmax loss) variants, depending on the input variables
             </p>
             <p>
              Only one solver option is currently available: Quasi-Newton (QN)
algorithms. Even though it is presented as a single option, this solver
resolves to two different algorithms underneath:
             </p>
             <ul class="simple">
              <li>
               <p>
                Orthant-Wise Limited Memory Quasi-Newton (OWL-QN) if there is l1
regularization
               </p>
              </li>
              <li>
               <p>
                Limited Memory BFGS (L-BFGS) otherwise.
               </p>
              </li>
             </ul>
             <p>
              Note that, just like in Scikit-learn, the bias will not be regularized.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  penalty: ‘none’, ‘l1’, ‘l2’, ‘elasticnet’ (default = ‘l2’)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Used to specify the norm used in the penalization.
If ‘none’ or ‘l2’ are selected, then L-BFGS solver will be used.
If ‘l1’ is selected, solver OWL-QN will be used.
If ‘elasticnet’ is selected, OWL-QN will be used if l1_ratio &gt; 0,
otherwise L-BFGS will be used.
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol: float (default = 1e-4)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The training process will stop if current_loss &gt; previous_loss - tol
                 </p>
                </dd>
                <dt>
                 <strong>
                  C: float (default = 1.0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Inverse of regularization strength; must be a positive float.
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept: boolean (default = True)
                 </strong>
                </dt>
                <dd>
                 <p>
                  If True, the model tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  class_weight: None
                 </strong>
                </dt>
                <dd>
                 <p>
                  Custom class weighs are currently not supported.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_iter: int (default = 1000)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Maximum number of iterations taken for the solvers to converge.
                 </p>
                </dd>
                <dt>
                 <strong>
                  linesearch_max_iter: int (default = 50)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Max number of linesearch iterations per outer iteration used in the
lbfgs and owl QN solvers.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose: int (optional, default 0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Controls verbosity level of logging.
                 </p>
                </dd>
                <dt>
                 <strong>
                  l1_ratio: float or None, optional (default=None)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The Elastic-Net mixing parameter, with
                  <cite>
                   0 &lt;= l1_ratio &lt;= 1
                  </cite>
                 </p>
                </dd>
                <dt>
                 <strong>
                  solver: ‘qn’, ‘lbfgs’, ‘owl’ (default=’qn’).
                 </strong>
                </dt>
                <dd>
                 <p>
                  Algorithm to use in the optimization problem. Currently only
                  <cite>
                   qn
                  </cite>
                  is
supported, which automatically selects either L-BFGS or OWL-QN
depending on the conditions of the l1 regularization described
above. Options ‘lbfgs’ and ‘owl’ are just convenience values that
end up using the same solver following the same rules.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              cuML’s LogisticRegression uses a different solver that the equivalent
Scikit-learn, except when there is no penalty and
              <cite>
               solver=lbfgs
              </cite>
              is
used in Scikit-learn. This can cause (smaller) differences in the
coefficients and predictions of the model, similar to
using different solvers in Scikit-learn.
             </p>
             <p>
              For additional information, see Scikit-learn’s LogistRegression
&lt;
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html">
               https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html
              </a>
              &gt;`_.
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Both import methods supported</span>
<span class="c1"># from cuml import LogisticRegression</span>
<span class="kn">from</span> <span class="nn">cuml.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="p">)</span>

<span class="n">reg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Coefficients:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">coef_</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Intercept:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">intercept_</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">())</span>

<span class="n">X_new</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">preds</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Predictions:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Coefficients</span><span class="p">:</span>
            <span class="mf">0.22309814</span>
            <span class="mf">0.21012752</span>
<span class="n">Intercept</span><span class="p">:</span>
            <span class="o">-</span><span class="mf">0.7548761</span>
<span class="n">Predictions</span><span class="p">:</span>
            <span class="mi">0</span>    <span class="mf">0.0</span>
            <span class="mi">1</span>    <span class="mf">1.0</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  coef_: dev array, dim (n_classes, n_features) or (n_classes, n_features+1)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The estimated coefficients for the linear regression model.
Note: this includes the intercept as the last column if fit_intercept
is True
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept_: device array (n_classes, 1)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The independent term. If
                  <a href="#id23">
                   <span class="problematic" id="id24">
                    fit_intercept_
                   </span>
                  </a>
                  is False, will be 0.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LogisticRegression.decision_function" title="cuml.LogisticRegression.decision_function">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     decision_function
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Gives confidence score for X
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LogisticRegression.fit" title="cuml.LogisticRegression.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LogisticRegression.get_param_names" title="cuml.LogisticRegression.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LogisticRegression.predict" title="cuml.LogisticRegression.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LogisticRegression.predict_log_proba" title="cuml.LogisticRegression.predict_log_proba">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict_log_proba
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the log class probabilities for each class in X
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LogisticRegression.predict_proba" title="cuml.LogisticRegression.predict_proba">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict_proba
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the class probabilities for each class in X
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.LogisticRegression.score" title="cuml.LogisticRegression.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Calculates the accuracy metric score of the model for X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.LogisticRegression.decision_function">
               <code class="sig-name descname">
                decision_function
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LogisticRegression.decision_function" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Gives confidence score for X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    Returns
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    ———-
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    y: array-like (device)
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_classes)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.LogisticRegression.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LogisticRegression.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.LogisticRegression.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LogisticRegression.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.LogisticRegression.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LogisticRegression.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   y: cuDF DataFrame
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.LogisticRegression.predict_log_proba">
               <code class="sig-name descname">
                predict_log_proba
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LogisticRegression.predict_log_proba" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the log class probabilities for each class in X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    Returns
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    ———-
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    y: array-like (device)
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_classes)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.LogisticRegression.predict_proba">
               <code class="sig-name descname">
                predict_proba
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LogisticRegression.predict_proba" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the class probabilities for each class in X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    Returns
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    ———-
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    y: array-like (device)
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_classes)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.LogisticRegression.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.LogisticRegression.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Calculates the accuracy metric score of the model for X.
               </p>
               <dl class="simple">
                <dt>
                 X
                 <span class="classifier">
                  array-like (device or host) shape = (n_samples, n_features)
                 </span>
                </dt>
                <dd>
                 <p>
                  Dense matrix (floats or doubles) of shape (n_samples, n_features).
Observations for which labels score will be calculated.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                 </p>
                </dd>
                <dt>
                 y
                 <span class="classifier">
                  array-like (device or host) shape = (n_samples, 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Dense vector (floats or doubles) of shape (n_samples, 1).
Ground truth labels to compare predictions to for the score.
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="ridge-regression">
           <h3>
            Ridge Regression
            <a class="headerlink" href="#ridge-regression" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.Ridge">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              Ridge
             </code>
             <a class="headerlink" href="#cuml.Ridge" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Ridge extends LinearRegression by providing L2 regularization on the
coefficients when predicting response y with a linear combination of the
predictors in X. It can reduce the variance of the predictors, and improves
the conditioning of the problem.
             </p>
             <p>
              cuML’s Ridge can take array-like objects, either in host as
NumPy arrays or in device (as Numba or
              <cite>
               __cuda_array_interface__
              </cite>
              compliant), in addition to cuDF objects. It provides 3
algorithms: SVD, Eig and CD to fit a linear model. In general SVD uses
significantly more memory and is slower than Eig. If using CUDA 10.1,
the memory difference is even bigger than in the other supported CUDA
versions. However, SVD is more stable than Eig (default). CD uses
Coordinate Descent and can be faster when data is large.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  alpha
                 </strong>
                 <span class="classifier">
                  float or double
                 </span>
                </dt>
                <dd>
                 <p>
                  Regularization strength - must be a positive float. Larger values
specify stronger regularization. Array input will be supported later.
                 </p>
                </dd>
                <dt>
                 <strong>
                  solver
                 </strong>
                 <span class="classifier">
                  ‘eig’ or ‘svd’ or ‘cd’ (default = ‘eig’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Eig uses a eigendecomposition of the covariance matrix, and is much
faster.
SVD is slower, but guaranteed to be stable.
CD or Coordinate Descent is very fast and is suitable for large
problems.
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, Ridge tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  normalize
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the predictors in X will be normalized by dividing by it’s L2
norm.
If False, no scaling will be done.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              Ridge provides L2 regularization. This means that the coefficients can
shrink to become very small, but not zero. This can cause issues of
interpretability on the coefficients.
Consider using Lasso, or thresholding small coefficients to zero.
             </p>
             <p>
              <strong>
               Applications of Ridge
              </strong>
             </p>
             <blockquote>
              <div>
               <p>
                Ridge Regression is used in the same way as LinearRegression, but does
not suffer from multicollinearity issues.  Ridge is used in insurance
premium prediction, stock market analysis and much more.
               </p>
              </div>
             </blockquote>
             <p>
              For additional docs, see
              <a class="reference external" href="https://github.com/rapidsai/notebooks/blob/master/cuml/ridge_regression_demo.ipynb">
               Scikit-learn’s Ridge Regression
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cudf</span>

<span class="c1"># Both import methods supported</span>
<span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">cuml.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>

<span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-5</span><span class="p">])</span>
<span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">fit_intercept</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">solver</span> <span class="o">=</span> <span class="s2">"eig"</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="mf">11.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="p">)</span>

<span class="n">result_ridge</span> <span class="o">=</span> <span class="n">ridge</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Coefficients:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_ridge</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Intercept:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_ridge</span><span class="o">.</span><span class="n">intercept_</span><span class="p">)</span>

<span class="n">X_new</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">preds</span> <span class="o">=</span> <span class="n">result_ridge</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Predictions:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Coefficients</span><span class="p">:</span>

            <span class="mi">0</span> <span class="mf">1.0000001</span>
            <span class="mi">1</span> <span class="mf">1.9999998</span>

<span class="n">Intercept</span><span class="p">:</span>
            <span class="mf">3.0</span>

<span class="n">Preds</span><span class="p">:</span>

            <span class="mi">0</span> <span class="mf">15.999999</span>
            <span class="mi">1</span> <span class="mf">14.999999</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  coef_
                 </strong>
                 <span class="classifier">
                  array, shape (n_features)
                 </span>
                </dt>
                <dd>
                 <p>
                  The estimated coefficients for the linear regression model.
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The independent term. If
                  <a href="#id25">
                   <span class="problematic" id="id26">
                    fit_intercept_
                   </span>
                  </a>
                  is False, will be 0.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.Ridge.fit" title="cuml.Ridge.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.Ridge.get_param_names" title="cuml.Ridge.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.Ridge.predict" title="cuml.Ridge.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.Ridge.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.Ridge.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.Ridge.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.Ridge.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.Ridge.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.Ridge.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   y: cuDF DataFrame
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="lasso-regression">
           <h3>
            Lasso Regression
            <a class="headerlink" href="#lasso-regression" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.Lasso">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              Lasso
             </code>
             <a class="headerlink" href="#cuml.Lasso" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Lasso extends LinearRegression by providing L1 regularization on the
coefficients when predicting response y with a linear combination of the
predictors in X. It can zero some of the coefficients for feature
selection and improves the conditioning of the problem.
             </p>
             <p>
              cuML’s Lasso can take array-like objects, either in host as
NumPy arrays or in device (as Numba or
              <cite>
               __cuda_array_interface__
              </cite>
              compliant), in addition to cuDF objects. It uses coordinate descent to fit
a linear model.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  alpha
                 </strong>
                 <span class="classifier">
                  float or double
                 </span>
                </dt>
                <dd>
                 <p>
                  Constant that multiplies the L1 term. Defaults to 1.0.
alpha = 0 is equivalent to an ordinary least square, solved by the
LinearRegression class.
For numerical reasons, using alpha = 0 with the Lasso class is not
advised.
Given this, you should use the LinearRegression class.
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, Lasso tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  normalize
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the predictors in X will be normalized by dividing by it’s L2
norm.
If False, no scaling will be done.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_iter
                 </strong>
                 <span class="classifier">
                  int
                 </span>
                </dt>
                <dd>
                 <p>
                  The maximum number of iterations
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float, optional
                 </span>
                </dt>
                <dd>
                 <p>
                  The tolerance for the optimization: if the updates are smaller than
tol, the optimization code checks the dual gap for optimality and
continues until it is smaller than tol.
                 </p>
                </dd>
                <dt>
                 <strong>
                  selection
                 </strong>
                 <span class="classifier">
                  ‘cyclic’, ‘random’ (default = ‘cyclic’)
                 </span>
                </dt>
                <dd>
                 <p>
                  If set to ‘random’, a random coefficient is updated every iteration
rather than looping over features sequentially by default.
This (setting to ‘random’) often leads to significantly faster
convergence especially when tol is higher than 1e-4.
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">from</span> <span class="nn">cuml.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span>

<span class="n">ls</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="p">)</span>

<span class="n">result_lasso</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Coefficients:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_lasso</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"intercept:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_lasso</span><span class="o">.</span><span class="n">intercept_</span><span class="p">)</span>

<span class="n">X_new</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">preds</span> <span class="o">=</span> <span class="n">result_lasso</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Coefficients</span><span class="p">:</span>

            <span class="mi">0</span> <span class="mf">0.85</span>
            <span class="mi">1</span> <span class="mf">0.0</span>

<span class="n">Intercept</span><span class="p">:</span>
            <span class="mf">0.149999</span>

<span class="n">Preds</span><span class="p">:</span>

            <span class="mi">0</span> <span class="mf">2.7</span>
            <span class="mi">1</span> <span class="mf">1.85</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  coef_
                 </strong>
                 <span class="classifier">
                  array, shape (n_features)
                 </span>
                </dt>
                <dd>
                 <p>
                  The estimated coefficients for the linear regression model.
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The independent term. If
                  <a href="#id27">
                   <span class="problematic" id="id28">
                    fit_intercept_
                   </span>
                  </a>
                  is False, will be 0.
                 </p>
                </dd>
                <dt>
                 <strong>
                  For additional docs, see `scikitlearn’s Lasso
                 </strong>
                </dt>
                <dd>
                </dd>
                <dt>
                 <strong>
                  &lt;https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html&gt;`_.
                 </strong>
                </dt>
                <dd>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.Lasso.fit" title="cuml.Lasso.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.Lasso.get_params" title="cuml.Lasso.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self[, deep])
                 </p>
                </td>
                <td>
                 <p>
                  Scikit-learn style function that returns the estimator parameters.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.Lasso.predict" title="cuml.Lasso.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.Lasso.set_params" title="cuml.Lasso.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, **params)
                 </p>
                </td>
                <td>
                 <p>
                  Sklearn style set parameter state to dictionary of params.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.Lasso.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.Lasso.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the transform method will, when necessary,
convert y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.Lasso.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                deep=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.Lasso.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Scikit-learn style function that returns the estimator parameters.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    deep
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.Lasso.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.Lasso.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   y: cuDF DataFrame
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.Lasso.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                **params
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.Lasso.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Sklearn style set parameter state to dictionary of params.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    params
                   </strong>
                   <span class="classifier">
                    dict of new params
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="elasticnet-regression">
           <h3>
            ElasticNet Regression
            <a class="headerlink" href="#elasticnet-regression" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.ElasticNet">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              ElasticNet
             </code>
             <a class="headerlink" href="#cuml.ElasticNet" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              ElasticNet extends LinearRegression with combined L1 and L2 regularizations
on the coefficients when predicting response y with a linear combination of
the predictors in X. It can reduce the variance of the predictors, force
some coefficients to be small, and improves the conditioning of the
problem.
             </p>
             <p>
              cuML’s ElasticNet an array-like object or cuDF DataFrame, uses coordinate
descent to fit a linear model.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  alpha
                 </strong>
                 <span class="classifier">
                  float or double
                 </span>
                </dt>
                <dd>
                 <p>
                  Constant that multiplies the L1 term. Defaults to 1.0.
alpha = 0 is equivalent to an ordinary least square, solved by the
LinearRegression object.
For numerical reasons, using alpha = 0 with the Lasso object is not
advised.
Given this, you should use the LinearRegression object.
                 </p>
                </dd>
                <dt>
                 <strong>
                  l1_ratio: The ElasticNet mixing parameter, with 0 &lt;= l1_ratio &lt;= 1.
                 </strong>
                </dt>
                <dd>
                 <p>
                  For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is
an L1 penalty.
For 0 &lt; l1_ratio &lt; 1, the penalty is a combination of L1 and L2.
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, Lasso tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  normalize
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the predictors in X will be normalized by dividing by it’s L2
norm.
If False, no scaling will be done.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_iter
                 </strong>
                 <span class="classifier">
                  int
                 </span>
                </dt>
                <dd>
                 <p>
                  The maximum number of iterations
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float, optional
                 </span>
                </dt>
                <dd>
                 <p>
                  The tolerance for the optimization: if the updates are smaller than
tol, the optimization code checks the dual gap for optimality and
continues until it is smaller than tol.
                 </p>
                </dd>
                <dt>
                 <strong>
                  selection
                 </strong>
                 <span class="classifier">
                  str, default ‘cyclic’
                 </span>
                </dt>
                <dd>
                 <p>
                  If set to ‘random’, a random coefficient is updated every iteration
rather than looping over features sequentially by default.
This (setting to ‘random’) often leads to significantly faster
convergence especially when tol is higher than 1e-4.
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">from</span> <span class="nn">cuml.linear_model</span> <span class="kn">import</span> <span class="n">ElasticNet</span>

<span class="n">enet</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="p">)</span>

<span class="n">result_enet</span> <span class="o">=</span> <span class="n">enet</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Coefficients:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_enet</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"intercept:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_enet</span><span class="o">.</span><span class="n">intercept_</span><span class="p">)</span>

<span class="n">X_new</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">preds</span> <span class="o">=</span> <span class="n">result_enet</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Coefficients</span><span class="p">:</span>

            <span class="mi">0</span> <span class="mf">0.448408</span>
            <span class="mi">1</span> <span class="mf">0.443341</span>

<span class="n">Intercept</span><span class="p">:</span>
            <span class="mf">0.1082506</span>

<span class="n">Preds</span><span class="p">:</span>

            <span class="mi">0</span> <span class="mf">3.67018</span>
            <span class="mi">1</span> <span class="mf">3.22177</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  coef_
                 </strong>
                 <span class="classifier">
                  array, shape (n_features)
                 </span>
                </dt>
                <dd>
                 <p>
                  The estimated coefficients for the linear regression model.
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The independent term. If
                  <a href="#id29">
                   <span class="problematic" id="id30">
                    fit_intercept_
                   </span>
                  </a>
                  is False, will be 0.
                 </p>
                </dd>
                <dt>
                 <strong>
                  For additional docs, see `scikitlearn’s ElasticNet
                 </strong>
                </dt>
                <dd>
                </dd>
                <dt>
                 <strong>
                  &lt;https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.ElasticNet.html&gt;`_.
                 </strong>
                </dt>
                <dd>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ElasticNet.fit" title="cuml.ElasticNet.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ElasticNet.get_params" title="cuml.ElasticNet.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self[, deep])
                 </p>
                </td>
                <td>
                 <p>
                  Scikit-learn style function that returns the estimator parameters.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ElasticNet.predict" title="cuml.ElasticNet.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ElasticNet.set_params" title="cuml.ElasticNet.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, **params)
                 </p>
                </td>
                <td>
                 <p>
                  Sklearn style set parameter state to dictionary of params.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.ElasticNet.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ElasticNet.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the transform method will, when necessary,
convert y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ElasticNet.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                deep=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ElasticNet.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Scikit-learn style function that returns the estimator parameters.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    deep
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ElasticNet.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ElasticNet.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   y: cuDF DataFrame
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ElasticNet.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                **params
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ElasticNet.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Sklearn style set parameter state to dictionary of params.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    params
                   </strong>
                   <span class="classifier">
                    dict of new params
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="mini-batch-sgd-classifier">
           <h3>
            Mini Batch SGD Classifier
            <a class="headerlink" href="#mini-batch-sgd-classifier" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.MBSGDClassifier">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              MBSGDClassifier
             </code>
             <a class="headerlink" href="#cuml.MBSGDClassifier" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Linear models (linear SVM, logistic regression, or linear regression)
fitted by minimizing a regularized empirical loss with mini-batch SGD.
             </p>
             <dl class="field-list">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl>
                <dt>
                 <strong>
                  loss
                 </strong>
                 <span class="classifier">
                  {‘hinge’, ‘log’, ‘squared_loss’} (default = ‘squared_loss’)
                 </span>
                </dt>
                <dd>
                 <p>
                  ‘hinge’ uses linear SVM
                 </p>
                 <p>
                  ‘log’ uses logistic regression
                 </p>
                 <p>
                  ‘squared_loss’ uses linear regression
                 </p>
                </dd>
                <dt>
                 <strong>
                  penalty: {‘none’, ‘l1’, ‘l2’, ‘elasticnet’} (default = ‘none’)
                 </strong>
                </dt>
                <dd>
                 <p>
                  ‘none’ does not perform any regularization
                 </p>
                 <p>
                  ‘l1’ performs L1 norm (Lasso) which minimizes the sum of the abs value
of coefficients
                 </p>
                 <p>
                  ‘l2’ performs L2 norm (Ridge) which minimizes the sum of the square of
the coefficients
                 </p>
                 <p>
                  ‘elasticnet’ performs Elastic Net regularization which is a weighted
average of L1 and L2 norms
                 </p>
                </dd>
                <dt>
                 <strong>
                  alpha: float (default = 0.0001)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The constant value which decides the degree of regularization
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the model tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  epochs
                 </strong>
                 <span class="classifier">
                  int (default = 1000)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of times the model should iterate through the entire dataset
during training (default = 1000)
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float (default = 1e-3)
                 </span>
                </dt>
                <dd>
                 <p>
                  The training process will stop if current_loss &gt; previous_loss - tol
                 </p>
                </dd>
                <dt>
                 <strong>
                  shuffle
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  True, shuffles the training data after each epoch
False, does not shuffle the training data after each epoch
                 </p>
                </dd>
                <dt>
                 <strong>
                  eta0
                 </strong>
                 <span class="classifier">
                  float (default = 0.001)
                 </span>
                </dt>
                <dd>
                 <p>
                  Initial learning rate
                 </p>
                </dd>
                <dt>
                 <strong>
                  power_t
                 </strong>
                 <span class="classifier">
                  float (default = 0.5)
                 </span>
                </dt>
                <dd>
                 <p>
                  The exponent used for calculating the invscaling learning rate
                 </p>
                </dd>
                <dt>
                 <strong>
                  learning_rate
                 </strong>
                 <span class="classifier">
                  {‘optimal’, ‘constant’, ‘invscaling’, ‘adaptive’}
                 </span>
                </dt>
                <dd>
                 <p>
                  (default = ‘constant’)
                 </p>
                 <p>
                  <cite>
                   optimal
                  </cite>
                  option will be supported in a future version
                 </p>
                 <p>
                  <cite>
                   constant
                  </cite>
                  keeps the learning rate constant
                 </p>
                 <p>
                  <cite>
                   adaptive
                  </cite>
                  changes the learning rate if the training loss or the
validation accuracy does not improve for
                  <cite>
                   n_iter_no_change
                  </cite>
                  epochs.
The old learning rate is generally divided by 5
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_iter_no_change
                 </strong>
                 <span class="classifier">
                  int (default = 5)
                 </span>
                </dt>
                <dd>
                 <p>
                  the number of epochs to train without any imporvement in the model
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For additional docs, see
              <a href="#id3">
               <span class="problematic" id="id4">
                `
               </span>
              </a>
              scikit-learn’s SGDClassifier
&lt;
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html">
               https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html
              </a>
              &gt;
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">from</span> <span class="nn">cuml.linear_model</span> <span class="kn">import</span> <span class="n">MBSGDClassifier</span> <span class="k">as</span> <span class="n">cumlMBSGDClassifier</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="n">pred_data</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">pred_data</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">pred_data</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">cu_mbsgd_classifier</span> <span class="o">=</span> <span class="n">cumlMBSGClassifier</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="s1">'constant'</span><span class="p">,</span>
                                         <span class="n">eta0</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                         <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                                         <span class="n">penalty</span><span class="o">=</span><span class="s1">'l2'</span><span class="p">,</span>
                                         <span class="n">loss</span><span class="o">=</span><span class="s1">'squared_loss'</span><span class="p">,</span>
                                         <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">cu_mbsgd_classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">cu_pred</span> <span class="o">=</span> <span class="n">cu_mbsgd_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">pred_data</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">" cuML intercept : "</span><span class="p">,</span> <span class="n">cu_mbsgd_classifier</span><span class="o">.</span><span class="n">intercept_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">" cuML coef : "</span><span class="p">,</span> <span class="n">cu_mbsgd_classifier</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"cuML predictions : "</span><span class="p">,</span> <span class="n">cu_pred</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">cuML</span> <span class="n">intercept</span> <span class="p">:</span>  <span class="mf">0.7150013446807861</span>
<span class="n">cuML</span> <span class="n">coef</span> <span class="p">:</span>  <span class="mi">0</span>    <span class="mf">0.27320495</span>
            <span class="mi">1</span>     <span class="mf">0.1875956</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">float32</span>
<span class="n">cuML</span> <span class="n">predictions</span> <span class="p">:</span>  <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.MBSGDClassifier.fit" title="cuml.MBSGDClassifier.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.MBSGDClassifier.get_params" title="cuml.MBSGDClassifier.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self[, deep])
                 </p>
                </td>
                <td>
                 <p>
                  Scikit-learn style function that returns the estimator parameters.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.MBSGDClassifier.predict" title="cuml.MBSGDClassifier.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.MBSGDClassifier.set_params" title="cuml.MBSGDClassifier.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, **params)
                 </p>
                </td>
                <td>
                 <p>
                  Sklearn style set parameter state to dictionary of params.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.MBSGDClassifier.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.MBSGDClassifier.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.MBSGDClassifier.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                deep=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.MBSGDClassifier.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Scikit-learn style function that returns the estimator parameters.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    deep
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.MBSGDClassifier.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.MBSGDClassifier.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   y: cuDF DataFrame
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.MBSGDClassifier.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                **params
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.MBSGDClassifier.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Sklearn style set parameter state to dictionary of params.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    params
                   </strong>
                   <span class="classifier">
                    dict of new params
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="mini-batch-sgd-regressor">
           <h3>
            Mini Batch SGD Regressor
            <a class="headerlink" href="#mini-batch-sgd-regressor" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.MBSGDRegressor">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              MBSGDRegressor
             </code>
             <a class="headerlink" href="#cuml.MBSGDRegressor" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Linear regression model fitted by minimizing a
regularized empirical loss with mini-batch SGD.
             </p>
             <dl class="field-list">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl>
                <dt>
                 <strong>
                  loss
                 </strong>
                 <span class="classifier">
                  ‘squared_loss’ (default = ‘squared_loss’)
                 </span>
                </dt>
                <dd>
                 <p>
                  ‘squared_loss’ uses linear regression
                 </p>
                </dd>
                <dt>
                 <strong>
                  penalty: ‘none’, ‘l1’, ‘l2’, ‘elasticnet’ (default = ‘none’)
                 </strong>
                </dt>
                <dd>
                 <p>
                  ‘none’ does not perform any regularization
‘l1’ performs L1 norm (Lasso) which minimizes the sum of the abs value
of coefficients
‘l2’ performs L2 norm (Ridge) which minimizes the sum of the square of
the coefficients
‘elasticnet’ performs Elastic Net regularization which is a weighted
average of L1 and L2 norms
                 </p>
                </dd>
                <dt>
                 <strong>
                  alpha: float (default = 0.0001)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The constant value which decides the degree of regularization
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the model tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  epochs
                 </strong>
                 <span class="classifier">
                  int (default = 1000)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of times the model should iterate through the entire dataset
during training (default = 1000)
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float (default = 1e-3)
                 </span>
                </dt>
                <dd>
                 <p>
                  The training process will stop if current_loss &gt; previous_loss - tol
                 </p>
                </dd>
                <dt>
                 <strong>
                  shuffle
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  True, shuffles the training data after each epoch
False, does not shuffle the training data after each epoch
                 </p>
                </dd>
                <dt>
                 <strong>
                  eta0
                 </strong>
                 <span class="classifier">
                  float (default = 0.001)
                 </span>
                </dt>
                <dd>
                 <p>
                  Initial learning rate
                 </p>
                </dd>
                <dt>
                 <strong>
                  power_t
                 </strong>
                 <span class="classifier">
                  float (default = 0.5)
                 </span>
                </dt>
                <dd>
                 <p>
                  The exponent used for calculating the invscaling learning rate
                 </p>
                </dd>
                <dt>
                 <strong>
                  learning_rate
                 </strong>
                 <span class="classifier">
                  {‘optimal’, ‘constant’, ‘invscaling’, ‘adaptive’}
                 </span>
                </dt>
                <dd>
                 <p>
                  (default = ‘constant’)
                 </p>
                 <p>
                  <cite>
                   optimal
                  </cite>
                  option will be supported in a future version
                 </p>
                 <p>
                  <cite>
                   constant
                  </cite>
                  keeps the learning rate constant
                 </p>
                 <p>
                  <cite>
                   adaptive
                  </cite>
                  changes the learning rate if the training loss or the
validation accuracy does not improve for
                  <cite>
                   n_iter_no_change
                  </cite>
                  epochs.
The old learning rate is generally divided by 5
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_iter_no_change
                 </strong>
                 <span class="classifier">
                  int (default = 5)
                 </span>
                </dt>
                <dd>
                 <p>
                  the number of epochs to train without any imporvement in the model
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For additional docs, see
              <a href="#id5">
               <span class="problematic" id="id6">
                `
               </span>
              </a>
              scikitlearn’s OLS
&lt;
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDRegressor.html">
               https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDRegressor.html
              </a>
              &gt;
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">from</span> <span class="nn">cuml.linear_model</span> <span class="kn">import</span> <span class="n">MBSGDRegressor</span> <span class="k">as</span> <span class="n">cumlMBSGDRegressor</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="n">pred_data</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">pred_data</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">pred_data</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">cu_mbsgd_regressor</span> <span class="o">=</span> <span class="n">cumlMBSGDRegressor</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="s1">'constant'</span><span class="p">,</span>
                                        <span class="n">eta0</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                        <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                                        <span class="n">penalty</span><span class="o">=</span><span class="s1">'l2'</span><span class="p">,</span>
                                        <span class="n">loss</span><span class="o">=</span><span class="s1">'squared_loss'</span><span class="p">,</span>
                                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">cu_mbsgd_regressor</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">cu_pred</span> <span class="o">=</span> <span class="n">cu_mbsgd_regressor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">pred_data</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">" cuML intercept : "</span><span class="p">,</span> <span class="n">cu_mbsgd_regressor</span><span class="o">.</span><span class="n">intercept_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">" cuML coef : "</span><span class="p">,</span> <span class="n">cu_mbsgd_regressor</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"cuML predictions : "</span><span class="p">,</span> <span class="n">cu_pred</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-default notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">cuML</span> <span class="n">intercept</span> <span class="p">:</span>  <span class="mf">0.7150013446807861</span>
<span class="n">cuML</span> <span class="n">coef</span> <span class="p">:</span>  <span class="mi">0</span>    <span class="mf">0.27320495</span>
            <span class="mi">1</span>     <span class="mf">0.1875956</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">float32</span>
<span class="n">cuML</span> <span class="n">predictions</span> <span class="p">:</span>  <span class="p">[</span><span class="mf">2.4725943</span> <span class="mf">2.1993892</span><span class="p">]</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.MBSGDRegressor.fit" title="cuml.MBSGDRegressor.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.MBSGDRegressor.get_params" title="cuml.MBSGDRegressor.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self[, deep])
                 </p>
                </td>
                <td>
                 <p>
                  Scikit-learn style function that returns the estimator parameters.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.MBSGDRegressor.predict" title="cuml.MBSGDRegressor.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.MBSGDRegressor.set_params" title="cuml.MBSGDRegressor.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, **params)
                 </p>
                </td>
                <td>
                 <p>
                  Sklearn style set parameter state to dictionary of params.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.MBSGDRegressor.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.MBSGDRegressor.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.MBSGDRegressor.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                deep=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.MBSGDRegressor.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Scikit-learn style function that returns the estimator parameters.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    deep
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.MBSGDRegressor.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.MBSGDRegressor.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   y: cuDF DataFrame
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.MBSGDRegressor.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                **params
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.MBSGDRegressor.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Sklearn style set parameter state to dictionary of params.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    params
                   </strong>
                   <span class="classifier">
                    dict of new params
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="stochastic-gradient-descent">
           <h3>
            Stochastic Gradient Descent
            <a class="headerlink" href="#stochastic-gradient-descent" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.SGD">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              SGD
             </code>
             <a class="headerlink" href="#cuml.SGD" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Stochastic Gradient Descent is a very common machine learning algorithm
where one optimizes some cost function via gradient steps. This makes SGD
very attractive for large problems when the exact solution is hard or even
impossible to find.
             </p>
             <p>
              cuML’s SGD algorithm accepts a numpy matrix or a cuDF DataFrame as the
input dataset. The SGD algorithm currently works with linear regression,
ridge regression and SVM models.
             </p>
             <dl class="field-list">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl>
                <dt>
                 <strong>
                  loss
                 </strong>
                 <span class="classifier">
                  ‘hinge’, ‘log’, ‘squared_loss’ (default = ‘squared_loss’)
                 </span>
                </dt>
                <dd>
                 <p>
                  ‘hinge’ uses linear SVM
‘log’ uses logistic regression
‘squared_loss’ uses linear regression
                 </p>
                </dd>
                <dt>
                 <strong>
                  penalty: ‘none’, ‘l1’, ‘l2’, ‘elasticnet’ (default = ‘none’)
                 </strong>
                </dt>
                <dd>
                 <p>
                  ‘none’ does not perform any regularization
‘l1’ performs L1 norm (Lasso) which minimizes the sum of the abs value
of coefficients
‘l2’ performs L2 norm (Ridge) which minimizes the sum of the square of
the coefficients
‘elasticnet’ performs Elastic Net regularization which is a weighted
average of L1 and L2 norms
                 </p>
                </dd>
                <dt>
                 <strong>
                  alpha: float (default = 0.0001)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The constant value which decides the degree of regularization
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the model tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  epochs
                 </strong>
                 <span class="classifier">
                  int (default = 1000)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of times the model should iterate through the entire dataset
during training (default = 1000)
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float (default = 1e-3)
                 </span>
                </dt>
                <dd>
                 <p>
                  The training process will stop if current_loss &gt; previous_loss - tol
                 </p>
                </dd>
                <dt>
                 <strong>
                  shuffle
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  True, shuffles the training data after each epoch
False, does not shuffle the training data after each epoch
                 </p>
                </dd>
                <dt>
                 <strong>
                  eta0
                 </strong>
                 <span class="classifier">
                  float (default = 0.001)
                 </span>
                </dt>
                <dd>
                 <p>
                  Initial learning rate
                 </p>
                </dd>
                <dt>
                 <strong>
                  power_t
                 </strong>
                 <span class="classifier">
                  float (default = 0.5)
                 </span>
                </dt>
                <dd>
                 <p>
                  The exponent used for calculating the invscaling learning rate
                 </p>
                </dd>
                <dt>
                 <strong>
                  learning_rate
                 </strong>
                 <span class="classifier">
                  ‘optimal’, ‘constant’, ‘invscaling’,
                 </span>
                </dt>
                <dd>
                 <blockquote>
                  <div>
                   <p>
                    ‘adaptive’ (default = ‘constant’)
                   </p>
                  </div>
                 </blockquote>
                 <p>
                  optimal option supported in the next version
constant keeps the learning rate constant
adaptive changes the learning rate if the training loss or the
validation accuracy does not improve for n_iter_no_change epochs.
The old learning rate is generally divide by 5
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_iter_no_change
                 </strong>
                 <span class="classifier">
                  int (default = 5)
                 </span>
                </dt>
                <dd>
                 <p>
                  the number of epochs to train without any imporvement in the model
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For additional docs, see
              <a href="#id7">
               <span class="problematic" id="id8">
                `
               </span>
              </a>
              scikitlearn’s OLS
&lt;
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html">
               https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html
              </a>
              &gt;
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">from</span> <span class="nn">cuml.solvers</span> <span class="kn">import</span> <span class="n">SGD</span> <span class="k">as</span> <span class="n">cumlSGD</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="n">pred_data</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">pred_data</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">pred_data</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">cu_sgd</span> <span class="o">=</span> <span class="n">cumlSGD</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">lrate</span><span class="p">,</span> <span class="n">eta0</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">penalty</span><span class="o">=</span><span class="n">penalty</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="n">loss</span><span class="p">)</span>
<span class="n">cu_sgd</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">cu_pred</span> <span class="o">=</span> <span class="n">cu_sgd</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">pred_data</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">" cuML intercept : "</span><span class="p">,</span> <span class="n">cu_sgd</span><span class="o">.</span><span class="n">intercept_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">" cuML coef : "</span><span class="p">,</span> <span class="n">cu_sgd</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"cuML predictions : "</span><span class="p">,</span> <span class="n">cu_pred</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">cuML</span> <span class="n">intercept</span> <span class="p">:</span>  <span class="mf">0.004561662673950195</span>
<span class="n">cuML</span> <span class="n">coef</span> <span class="p">:</span>  <span class="mi">0</span>      <span class="mf">0.9834546</span>
            <span class="mi">1</span>    <span class="mf">0.010128272</span>
           <span class="n">dtype</span><span class="p">:</span> <span class="n">float32</span>
<span class="n">cuML</span> <span class="n">predictions</span> <span class="p">:</span>  <span class="p">[</span><span class="mf">3.0055666</span> <span class="mf">2.0221121</span><span class="p">]</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.SGD.fit" title="cuml.SGD.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.SGD.predict" title="cuml.SGD.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.SGD.predictClass" title="cuml.SGD.predictClass">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predictClass
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.SGD.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.SGD.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.SGD.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.SGD.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    Returns
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    ———-
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    y: cuDF DataFrame
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.SGD.predictClass">
               <code class="sig-name descname">
                predictClass
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.SGD.predictClass" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predictClass method will automatically
convert the input to the data type which was used to train the
model. This will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    cuDF DataFrame
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="random-forest">
           <h3>
            Random Forest
            <a class="headerlink" href="#random-forest" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.ensemble.RandomForestClassifier">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.ensemble.
             </code>
             <code class="sig-name descname">
              RandomForestClassifier
             </code>
             <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Implements a Random Forest classifier model which fits multiple decision
tree classifiers in an ensemble.
             </p>
             <p>
              Note that the underlying algorithm for tree node splits differs from that
used in scikit-learn. By default, the cuML Random Forest uses a
histogram-based algorithms to determine splits, rather than an exact
count. You can tune the size of the histograms with the n_bins parameter.
             </p>
             <p>
              <strong>
               Known Limitations
              </strong>
              : This is an early release of the cuML
Random Forest code. It contains a few known limitations:
             </p>
             <blockquote>
              <div>
               <ul class="simple">
                <li>
                 <p>
                  GPU-based inference is only supported if the model was trained
with 32-bit (float32) datatypes. CPU-based inference may be used
in this case as a slower fallback.
                 </p>
                </li>
                <li>
                 <p>
                  Very deep / very wide models may exhaust available GPU memory.
Future versions of cuML will provide an alternative algorithm to
reduce memory consumption.
                 </p>
                </li>
               </ul>
              </div>
             </blockquote>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_estimators
                 </strong>
                 <span class="classifier">
                  int (default = 100)
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of trees in the forest. (Default changed to 100 in cuML 0.11)
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_criterion
                 </strong>
                 <span class="classifier">
                  The criterion used to split nodes.
                 </span>
                </dt>
                <dd>
                 <p>
                  0 for GINI, 1 for ENTROPY
2 and 3 not valid for classification
(default = 0)
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_algo
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  The algorithm to determine how nodes are split in the tree.
0 for HIST and 1 for GLOBAL_QUANTILE. HIST curently uses a slower
tree-building algorithm so GLOBAL_QUANTILE is recommended for most
cases.
                 </p>
                </dd>
                <dt>
                 <strong>
                  bootstrap
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  Control bootstrapping.
If True, each tree in the forest is built
on a bootstrapped sample with replacement.
If False, sampling without replacement is done.
                 </p>
                </dd>
                <dt>
                 <strong>
                  bootstrap_features
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Control bootstrapping for features.
If features are drawn with or without replacement
                 </p>
                </dd>
                <dt>
                 <strong>
                  rows_sample
                 </strong>
                 <span class="classifier">
                  float (default = 1.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  Ratio of dataset rows used while fitting each tree.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_depth
                 </strong>
                 <span class="classifier">
                  int (default = 16)
                 </span>
                </dt>
                <dd>
                 <p>
                  Maximum tree depth. Unlimited (i.e, until leaves are pure),
if -1. Unlimited depth is not supported.
                  <em>
                   Note that this default differs from scikit-learn’s
random forest, which defaults to unlimited depth.
                  </em>
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_leaves
                 </strong>
                 <span class="classifier">
                  int (default = -1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Maximum leaf nodes per tree. Soft constraint. Unlimited,
if -1.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_features
                 </strong>
                 <span class="classifier">
                  int, float, or string (default = ‘auto’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Ratio of number of features (columns) to consider per node split.
If int then max_features/n_features.
If float then max_features is used as a fraction.
If ‘auto’ then max_features=1/sqrt(n_features).
If ‘sqrt’ then max_features=1/sqrt(n_features).
If ‘log2’ then max_features=log2(n_features)/n_features.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_bins
                 </strong>
                 <span class="classifier">
                  int (default = 8)
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of bins used by the split algorithm.
                 </p>
                </dd>
                <dt>
                 <strong>
                  min_rows_per_node
                 </strong>
                 <span class="classifier">
                  int or float (default = 2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The minimum number of samples (rows) needed to split a node.
If int then number of sample rows.
If float the min_rows_per_sample*n_rows
                 </p>
                </dd>
                <dt>
                 <strong>
                  min_impurity_decrease
                 </strong>
                 <span class="classifier">
                  float (default = 0.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  Minimum decrease in impurity requried for
node to be spilt.
                 </p>
                </dd>
                <dt>
                 <strong>
                  quantile_per_tree
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether quantile is computed for individal trees in RF.
Only relevant for GLOBAL_QUANTILE split_algo.
                 </p>
                </dd>
                <dt>
                 <strong>
                  seed
                 </strong>
                 <span class="classifier">
                  int (default = None)
                 </span>
                </dt>
                <dd>
                 <p>
                  Seed for the random number generator. Unseeded by default.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">cuml.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span> <span class="k">as</span> <span class="n">cuRFC</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">cuml_model</span> <span class="o">=</span> <span class="n">cuRFC</span><span class="p">(</span><span class="n">max_features</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                   <span class="n">n_bins</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                   <span class="n">n_estimators</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="n">cuml_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="n">cuml_predict</span> <span class="o">=</span> <span class="n">cuml_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Predicted labels : "</span><span class="p">,</span> <span class="n">cuml_predict</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-none notranslate">
              <div class="highlight">
               <pre><span></span>Predicted labels :  [0 1 0 1 0 1 0 1 0 1]
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.convert_to_fil_model" title="cuml.ensemble.RandomForestClassifier.convert_to_fil_model">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     convert_to_fil_model
                    </span>
                   </code>
                  </a>
                  (self[, output_class, …])
                 </p>
                </td>
                <td>
                 <p>
                  Create a Forest Inference (FIL) model from the trained cuML Random Forest model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.convert_to_treelite_model" title="cuml.ensemble.RandomForestClassifier.convert_to_treelite_model">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     convert_to_treelite_model
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Converts the cuML RF model to a Treelite model
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.fit" title="cuml.ensemble.RandomForestClassifier.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Perform Random Forest Classification on the input data
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.get_params" title="cuml.ensemble.RandomForestClassifier.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self[, deep])
                 </p>
                </td>
                <td>
                 <p>
                  Returns the value of all parameters required to configure this estimator as a dictionary.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.predict" title="cuml.ensemble.RandomForestClassifier.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, predict_model, …])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the labels for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.predict_proba" title="cuml.ensemble.RandomForestClassifier.predict_proba">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict_proba
                    </span>
                   </code>
                  </a>
                  (self, X[, output_class, …])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts class probabilites for X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.print_detailed" title="cuml.ensemble.RandomForestClassifier.print_detailed">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     print_detailed
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Prints the detailed information about the forest used to train and test the Random Forest model
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.print_summary" title="cuml.ensemble.RandomForestClassifier.print_summary">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     print_summary
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Prints the summary of the forest used to train and test the model
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.score" title="cuml.ensemble.RandomForestClassifier.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y[, threshold, algo, …])
                 </p>
                </td>
                <td>
                 <p>
                  Calculates the accuracy metric score of the model for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestClassifier.set_params" title="cuml.ensemble.RandomForestClassifier.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, **params)
                 </p>
                </td>
                <td>
                 <p>
                  Sets the value of parameters required to configure this estimator, it functions similar to the sklearn set_params.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.convert_to_fil_model">
               <code class="sig-name descname">
                convert_to_fil_model
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                output_class=True
               </em>
               ,
               <em class="sig-param">
                threshold=0.5
               </em>
               ,
               <em class="sig-param">
                algo=u'auto'
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format=u'auto'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.convert_to_fil_model" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Create a Forest Inference (FIL) model from the trained cuML
Random Forest model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    output_class
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
If true, return a 1 or 0 depending on whether the raw
prediction exceeds the threshold. If False, just return
the raw prediction.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     auto
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    threshold
                   </strong>
                   <span class="classifier">
                    float (default = 0.5)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Threshold used for classification. Optional and required only
while performing the predict operation on the GPU.
It is applied if output_class == True, else it is ignored
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   fil_model :
                  </dt>
                  <dd>
                   <p>
                    A Forest Inference model which can be used to perform
inferencing on the random forest model.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.convert_to_treelite_model">
               <code class="sig-name descname">
                convert_to_treelite_model
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.convert_to_treelite_model" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Converts the cuML RF model to a Treelite model
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Returns
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    tl_to_fil_model
                   </strong>
                   <span class="classifier">
                    Treelite version of this model
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Perform Random Forest Classification on the input data
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (int32) of shape (n_samples, 1).
Acceptable formats: NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
These labels should be contiguous integers from 0 to n_classes.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This will increase
memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                deep=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the value of all parameters
required to configure this estimator as a dictionary.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    deep
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                predict_model=u'GPU'
               </em>
               ,
               <em class="sig-param">
                output_class=True
               </em>
               ,
               <em class="sig-param">
                threshold=0.5
               </em>
               ,
               <em class="sig-param">
                algo=u'auto'
               </em>
               ,
               <em class="sig-param">
                num_classes=2
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format=u'auto'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the labels for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    predict_model
                   </strong>
                   <span class="classifier">
                    String (default = ‘GPU’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    ‘GPU’ to predict using the GPU, ‘CPU’ otherwise. The ‘GPU’ can only
be used if the model was trained on float32 data and
                    <cite>
                     X
                    </cite>
                    is float32
or convert_dtype is set to True. Also the ‘GPU’ should only be
used for binary classification problems.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    output_class
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
If true, return a 1 or 0 depending on whether the raw
prediction exceeds the threshold. If False, just return
the raw prediction.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     auto
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    threshold
                   </strong>
                   <span class="classifier">
                    float (default = 0.5)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Threshold used for classification. Optional and required only
while performing the predict operation on the GPU.
It is applied if output_class == True, else it is ignored
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    num_classes
                   </strong>
                   <span class="classifier">
                    int (default = 2)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    number of different classes present in the dataset
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    NumPy
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (int) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.predict_proba">
               <code class="sig-name descname">
                predict_proba
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                output_class=True
               </em>
               ,
               <em class="sig-param">
                threshold=0.5
               </em>
               ,
               <em class="sig-param">
                algo=u'auto'
               </em>
               ,
               <em class="sig-param">
                num_classes=2
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format=u'auto'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.predict_proba" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts class probabilites for X. This function uses the GPU
implementation of predict. Therefore, data with ‘dtype = np.float32’
and ‘num_classes = 2’ should be used while using this function.
The option to use predict_proba for multi_class classification is not
currently implemented. Please check cuml issue #1679 for more
information.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    output_class: boolean (default = True)
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
If true, return a 1 or 0 depending on whether the raw
prediction exceeds the threshold. If False, just return
the raw prediction.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     auto
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    threshold
                   </strong>
                   <span class="classifier">
                    float (default = 0.5)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Threshold used for classification. Optional and required only
while performing the predict operation on the GPU.
It is applied if output_class == True, else it is ignored
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    num_classes
                   </strong>
                   <span class="classifier">
                    int (default = 2)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    number of different classes present in the dataset
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    (same as the input datatype)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (float) of shape (n_samples, 1). The datatype of y
depend on the value of ‘output_type’ varaible specified by the
user while intializing the model.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.print_detailed">
               <code class="sig-name descname">
                print_detailed
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.print_detailed" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Prints the detailed information about the forest used to
train and test the Random Forest model
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.print_summary">
               <code class="sig-name descname">
                print_summary
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.print_summary" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Prints the summary of the forest used to train and test the model
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                threshold=0.5
               </em>
               ,
               <em class="sig-param">
                algo=u'auto'
               </em>
               ,
               <em class="sig-param">
                num_classes=2
               </em>
               ,
               <em class="sig-param">
                predict_model=u'GPU'
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format=u'auto'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Calculates the accuracy metric score of the model for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    NumPy
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (int) of shape (n_samples, 1)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     auto
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    threshold
                   </strong>
                   <span class="classifier">
                    float
                   </span>
                  </dt>
                  <dd>
                   <p>
                    threshold is used to for classification
This is optional and required only while performing the
predict operation on the GPU.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    num_classes
                   </strong>
                   <span class="classifier">
                    integer
                   </span>
                  </dt>
                  <dd>
                   <p>
                    number of different classes present in the dataset
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    boolean, default=True
                   </span>
                  </dt>
                  <dd>
                   <p>
                    whether to convert input data to correct dtype automatically
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    predict_model
                   </strong>
                   <span class="classifier">
                    String (default = ‘GPU’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    ‘GPU’ to predict using the GPU, ‘CPU’ otherwise. The ‘GPU’ can only
be used if the model was trained on float32 data and
                    <cite>
                     X
                    </cite>
                    is float32
or convert_dtype is set to True. Also the ‘GPU’ should only be
used for binary classification problems.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    accuracy
                   </strong>
                   <span class="classifier">
                    float
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Accuracy of the model [0.0 - 1.0]
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestClassifier.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                **params
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestClassifier.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Sets the value of parameters required to
configure this estimator, it functions similar to
the sklearn set_params.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    params
                   </strong>
                   <span class="classifier">
                    dict of new params
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.ensemble.RandomForestRegressor">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.ensemble.
             </code>
             <code class="sig-name descname">
              RandomForestRegressor
             </code>
             <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Implements a Random Forest regressor model which fits multiple decision
trees in an ensemble.
Note that the underlying algorithm for tree node splits differs from that
used in scikit-learn. By default, the cuML Random Forest uses a
histogram-based algorithm to determine splits, rather than an exact
count. You can tune the size of the histograms with the n_bins parameter.
             </p>
             <p>
              <strong>
               Known Limitations
              </strong>
              : This is an early release of the cuML
Random Forest code. It contains a few known limitations:
             </p>
             <blockquote>
              <div>
               <ul class="simple">
                <li>
                 <p>
                  GPU-based inference is only supported if the model was trained
with 32-bit (float32) datatypes. CPU-based inference may be used
in this case as a slower fallback.
                 </p>
                </li>
                <li>
                 <p>
                  Very deep / very wide models may exhaust available GPU memory.
Future versions of cuML will provide an alternative algorithm to
reduce memory consumption.
                 </p>
                </li>
               </ul>
              </div>
             </blockquote>
             <dl class="field-list">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl>
                <dt>
                 <strong>
                  n_estimators
                 </strong>
                 <span class="classifier">
                  int (default = 100)
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of trees in the forest. (Default changed to 100 in cuML 0.11)
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_algo
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  The algorithm to determine how nodes are split in the tree.
0 for HIST and 1 for GLOBAL_QUANTILE. HIST curently uses a slower
tree-building algorithm so GLOBAL_QUANTILE is recommended for most
cases.
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_criterion
                 </strong>
                 <span class="classifier">
                  int (default = 2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The criterion used to split nodes.
0 for GINI, 1 for ENTROPY,
2 for MSE, or 3 for MAE
0 and 1 not valid for regression
                 </p>
                </dd>
                <dt>
                 <strong>
                  bootstrap
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <dl class="simple">
                  <dt>
                   Control bootstrapping.
                  </dt>
                  <dd>
                   <p>
                    If True, each tree in the forest is built
on a bootstrapped sample with replacement.
If False, sampling without replacement is done.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt>
                 <strong>
                  bootstrap_features
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Control bootstrapping for features.
If features are drawn with or without replacement
                 </p>
                </dd>
                <dt>
                 <strong>
                  rows_sample
                 </strong>
                 <span class="classifier">
                  float (default = 1.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  Ratio of dataset rows used while fitting each tree.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_depth
                 </strong>
                 <span class="classifier">
                  int (default = 16)
                 </span>
                </dt>
                <dd>
                 <p>
                  Maximum tree depth. Unlimited (i.e, until leaves are pure),
if -1. Unlimited depth is not supported with split_algo=1.
                  <em>
                   Note that this default differs from scikit-learn’s
random forest, which defaults to unlimited depth.
                  </em>
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_leaves
                 </strong>
                 <span class="classifier">
                  int (default = -1)
                 </span>
                </dt>
                <dd>
                 <blockquote>
                  <div>
                   <p>
                    Maximum leaf nodes per tree. Soft constraint. Unlimited,
if -1.
                   </p>
                  </div>
                 </blockquote>
                 <dl class="simple">
                  <dt>
                   max_features
                   <span class="classifier">
                    int, float, or string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Ratio of number of features (columns) to consider
per node split.
If int then max_features/n_features.
If float then max_features is used as a fraction.
If ‘auto’ then max_features=1.0.
If ‘sqrt’ then max_features=1/sqrt(n_features).
If ‘log2’ then max_features=log2(n_features)/n_features.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt>
                 <strong>
                  n_bins
                 </strong>
                 <span class="classifier">
                  int (default = 8)
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of bins used by the split algorithm.
                 </p>
                </dd>
                <dt>
                 <strong>
                  min_rows_per_node
                 </strong>
                 <span class="classifier">
                  int or float (default = 2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The minimum number of samples (rows) needed to split a node.
If int then number of sample rows
If float the min_rows_per_sample*n_rows
                 </p>
                </dd>
                <dt>
                 <strong>
                  min_impurity_decrease
                 </strong>
                 <span class="classifier">
                  float (default = 0.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  The minimum decrease in impurity required for node to be split
                 </p>
                </dd>
                <dt>
                 <strong>
                  accuracy_metric
                 </strong>
                 <span class="classifier">
                  string (default = ‘mse’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Decides the metric used to evaluate the performance of the model.
for median of abs error : ‘median_ae’
for mean of abs error : ‘mean_ae’
for mean square error’ : ‘mse’
                 </p>
                </dd>
                <dt>
                 <strong>
                  quantile_per_tree
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether quantile is computed for individal trees in RF.
Only relevant for GLOBAL_QUANTILE split_algo.
                 </p>
                </dd>
                <dt>
                 <strong>
                  seed
                 </strong>
                 <span class="classifier">
                  int (default = None)
                 </span>
                </dt>
                <dd>
                 <p>
                  Seed for the random number generator. Unseeded by default. Does not
currently fully guarantee the exact same results.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">cuml.test.utils</span> <span class="kn">import</span> <span class="n">get_handle</span>
<span class="kn">from</span> <span class="nn">cuml.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestRegressor</span> <span class="k">as</span> <span class="n">curfc</span>
<span class="kn">from</span> <span class="nn">cuml.test.utils</span> <span class="kn">import</span> <span class="n">get_handle</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">40</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">cuml_model</span> <span class="o">=</span> <span class="n">curfc</span><span class="p">(</span><span class="n">max_features</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                   <span class="n">split_algo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_rows_per_node</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                   <span class="n">n_estimators</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">accuracy_metric</span><span class="o">=</span><span class="s1">'mse'</span><span class="p">)</span>
<span class="n">cuml_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="n">cuml_score</span> <span class="o">=</span> <span class="n">cuml_model</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"MSE score of cuml : "</span><span class="p">,</span> <span class="n">cuml_score</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">MSE</span> <span class="n">score</span> <span class="n">of</span> <span class="n">cuml</span> <span class="p">:</span>  <span class="mf">0.1123437201231765</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.convert_to_fil_model" title="cuml.ensemble.RandomForestRegressor.convert_to_fil_model">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     convert_to_fil_model
                    </span>
                   </code>
                  </a>
                  (self[, output_class, …])
                 </p>
                </td>
                <td>
                 <p>
                  Create a Forest Inference (FIL) model from the trained cuML Random Forest model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.convert_to_treelite_model" title="cuml.ensemble.RandomForestRegressor.convert_to_treelite_model">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     convert_to_treelite_model
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Converts the cuML RF model to a Treelite model
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.fit" title="cuml.ensemble.RandomForestRegressor.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Perform Random Forest Regression on the input data
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.get_params" title="cuml.ensemble.RandomForestRegressor.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self[, deep])
                 </p>
                </td>
                <td>
                 <p>
                  Returns the value of all parameters required to configure this estimator as a dictionary.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.predict" title="cuml.ensemble.RandomForestRegressor.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, predict_model, algo, …])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the labels for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.print_detailed" title="cuml.ensemble.RandomForestRegressor.print_detailed">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     print_detailed
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Prints the detailed information about the forest used to train and test the Random Forest model
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.print_summary" title="cuml.ensemble.RandomForestRegressor.print_summary">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     print_summary
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Prints the summary of the forest used to train and test the model
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.score" title="cuml.ensemble.RandomForestRegressor.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y[, algo, convert_dtype, …])
                 </p>
                </td>
                <td>
                 <p>
                  Calculates the accuracy metric score of the model for X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ensemble.RandomForestRegressor.set_params" title="cuml.ensemble.RandomForestRegressor.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, **params)
                 </p>
                </td>
                <td>
                 <p>
                  Sets the value of parameters required to configure this estimator, it functions similar to the sklearn set_params.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.convert_to_fil_model">
               <code class="sig-name descname">
                convert_to_fil_model
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                output_class=False
               </em>
               ,
               <em class="sig-param">
                algo=u'auto'
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format=u'auto'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.convert_to_fil_model" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Create a Forest Inference (FIL) model from the trained cuML
Random Forest model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    output_class
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
If true, return a 1 or 0 depending on whether the raw
prediction exceeds the threshold. If False, just return
the raw prediction.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     auto
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   fil_model :
                  </dt>
                  <dd>
                   <p>
                    A Forest Inference model which can be used to perform
inferencing on the random forest model.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.convert_to_treelite_model">
               <code class="sig-name descname">
                convert_to_treelite_model
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.convert_to_treelite_model" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Converts the cuML RF model to a Treelite model
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Returns
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    tl_to_fil_model
                   </strong>
                   <span class="classifier">
                    Treelite version of this model
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Perform Random Forest Regression on the input data
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (int32) of shape (n_samples, 1).
Acceptable formats: NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
These labels should be contiguous integers from 0 to n_classes.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                deep=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the value of all parameters
required to configure this estimator as a dictionary.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    deep
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                predict_model=u'GPU'
               </em>
               ,
               <em class="sig-param">
                algo=u'auto'
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format=u'auto'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the labels for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    predict_model
                   </strong>
                   <span class="classifier">
                    String (default = ‘GPU’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    ‘GPU’ to predict using the GPU, ‘CPU’ otherwise. The GPU can only
be used if the model was trained on float32 data and
                    <cite>
                     X
                    </cite>
                    is float32
or convert_dtype is set to True.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     auto
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    NumPy
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (int) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.print_detailed">
               <code class="sig-name descname">
                print_detailed
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.print_detailed" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Prints the detailed information about the forest used to
train and test the Random Forest model
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.print_summary">
               <code class="sig-name descname">
                print_summary
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.print_summary" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Prints the summary of the forest used to train and test the model
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                algo=u'auto'
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format=u'auto'
               </em>
               ,
               <em class="sig-param">
                predict_model=u'GPU'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Calculates the accuracy metric score of the model for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    NumPy
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (int) of shape (n_samples, 1)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     auto
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    boolean, default=True
                   </span>
                  </dt>
                  <dd>
                   <p>
                    whether to convert input data to correct dtype automatically
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    predict_model
                   </strong>
                   <span class="classifier">
                    String (default = ‘GPU’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    ‘GPU’ to predict using the GPU, ‘CPU’ otherwise. The GPU can only
be used if the model was trained on float32 data and
                    <cite>
                     X
                    </cite>
                    is float32
or convert_dtype is set to True.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    mean_square_error
                   </strong>
                   <span class="classifier">
                    float or
                   </span>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    median_abs_error
                   </strong>
                   <span class="classifier">
                    float or
                   </span>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    mean_abs_error
                   </strong>
                   <span class="classifier">
                    float
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ensemble.RandomForestRegressor.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                **params
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ensemble.RandomForestRegressor.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Sets the value of parameters required to
configure this estimator, it functions similar to
the sklearn set_params.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    params
                   </strong>
                   <span class="classifier">
                    dict of new params
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="forest-inferencing">
           <h3>
            Forest Inferencing
            <a class="headerlink" href="#forest-inferencing" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.ForestInference">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              ForestInference
             </code>
             <a class="headerlink" href="#cuml.ForestInference" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              ForestInference provides GPU-accelerated inference (prediction)
for random forest and boosted decision tree models.
             </p>
             <p>
              This module does not support training models. Rather, users should
train a model in another package and save it in a
treelite-compatible format. (See
              <a class="reference external" href="https://github.com/dmlc/treelite">
               https://github.com/dmlc/treelite
              </a>
              )
Currently, LightGBM, XGBoost and SKLearn GBDT and random forest models
are supported.
             </p>
             <p>
              Users typically create a ForestInference object by loading a saved model
file with ForestInference.load. It is also possible to create it from an
SKLearn model using ForestInference.load_from_sklearn. The resulting object
provides a
              <cite>
               predict
              </cite>
              method for carrying out inference.
             </p>
             <dl class="simple">
              <dt>
               <strong>
                Known limitations
               </strong>
               :
              </dt>
              <dd>
               <ul class="simple">
                <li>
                 <p>
                  A single row of data should fit into the shared memory of a thread block, 
which means that more than 12288 features are not supported.
                 </p>
                </li>
                <li>
                 <p>
                  From sklearn.ensemble, only
{RandomForest,GradientBoosting}{Classifier,Regressor} models are
supported; other sklearn.ensemble models are currently not supported.
                 </p>
                </li>
                <li>
                 <p>
                  Importing large SKLearn models can be slow, as it is done in Python.
                 </p>
                </li>
                <li>
                 <p>
                  LightGBM categorical features are not supported.
                 </p>
                </li>
                <li>
                 <p>
                  Inference uses a dense matrix format, which is efficient for many
problems but can be suboptimal for sparse datasets.
                 </p>
                </li>
                <li>
                 <p>
                  Only binary classification and regression are supported.
                 </p>
                </li>
               </ul>
              </dd>
             </dl>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For additional usage examples, see the sample notebook at
              <a class="reference external" href="https://github.com/rapidsai/notebooks/blob/branch-0.12/cuml/forest_inference_demo.ipynb">
               https://github.com/rapidsai/notebooks/blob/branch-0.12/cuml/forest_inference_demo.ipynb
              </a>
              # noqa
             </p>
             <p class="rubric">
              Examples
             </p>
             <p>
              In the example below, synthetic data is copied to the host before
inference. ForestInference can also accept a numpy array directly at the
cost of a slight performance overhead.
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="c1"># Assume that the file 'xgb.model' contains a classifier model that was</span>
<span class="c1"># previously saved by XGBoost's save_model function.</span>

<span class="kn">import</span> <span class="nn">sklearn</span><span class="o">,</span> <span class="nn">sklearn.datasets</span><span class="o">,</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">ForestInference</span>

<span class="n">model_path</span> <span class="o">=</span> <span class="s1">'xgb.model'</span>
<span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">make_classification</span><span class="p">()</span>
<span class="n">X_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)))</span>
<span class="n">fm</span> <span class="o">=</span> <span class="n">ForestInference</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">output_class</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fil_preds_gpu</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_gpu</span><span class="p">)</span>
<span class="n">accuracy_score</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span>
               <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fil_preds_gpu</span><span class="p">))</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ForestInference.load" title="cuml.ForestInference.load">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     load
                    </span>
                   </code>
                  </a>
                  (filename[, output_class, threshold, …])
                 </p>
                </td>
                <td>
                 <p>
                  Returns a FIL instance containing the forest saved in ‘filename’ This uses Treelite to load the saved model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ForestInference.load_from_randomforest" title="cuml.ForestInference.load_from_randomforest">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     load_from_randomforest
                    </span>
                   </code>
                  </a>
                  (self, model_handle[, …])
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ForestInference.load_from_sklearn" title="cuml.ForestInference.load_from_sklearn">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     load_from_sklearn
                    </span>
                   </code>
                  </a>
                  (skl_model[, output_class, …])
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ForestInference.load_from_treelite_model" title="cuml.ForestInference.load_from_treelite_model">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     load_from_treelite_model
                    </span>
                   </code>
                  </a>
                  (self, model, …[, …])
                 </p>
                </td>
                <td>
                 <p>
                  Creates a FIL model using the treelite model passed to the function.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ForestInference.predict" title="cuml.ForestInference.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, preds])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the labels for X with the loaded forest model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ForestInference.predict_proba" title="cuml.ForestInference.predict_proba">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict_proba
                    </span>
                   </code>
                  </a>
                  (self, X[, preds])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the class probabilities for X with the loaded forest model.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.ForestInference.load">
               <code class="sig-name descname">
                load
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                filename
               </em>
               ,
               <em class="sig-param">
                output_class=False
               </em>
               ,
               <em class="sig-param">
                threshold=0.50
               </em>
               ,
               <em class="sig-param">
                algo=u'AUTO'
               </em>
               ,
               <em class="sig-param">
                storage_type=u'DENSE'
               </em>
               ,
               <em class="sig-param">
                model_type=u'xgboost'
               </em>
               ,
               <em class="sig-param">
                handle=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ForestInference.load" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns a FIL instance containing the forest saved in ‘filename’
This uses Treelite to load the saved model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    filename
                   </strong>
                   <span class="classifier">
                    str
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Path to saved model file in a treelite-compatible format
(See
                    <a class="reference external" href="https://treelite.readthedocs.io/en/latest/treelite-api.html">
                     https://treelite.readthedocs.io/en/latest/treelite-api.html
                    </a>
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    output_class
                   </strong>
                   <span class="classifier">
                    bool
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If true, return a 1 or 0 depending on whether the raw prediction
exceeds the threshold. If False, just return the raw prediction.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    threshold
                   </strong>
                   <span class="classifier">
                    float
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Cutoff value above which a prediction is set to 1.0
Only used if the model is classification and output_class is True
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Which inference algorithm to use.
See documentation in FIL.load_from_treelite_model
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    storage_type
                   </strong>
                   <span class="classifier">
                    string name of the storage type
                   </span>
                  </dt>
                  <dd>
                   <p>
                    (from storage_type_t enum) for the FIL forest.
See documentation in FIL.load_from_treelite_model
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    model_type
                   </strong>
                   <span class="classifier">
                    str
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Format of saved treelite model to load.
Can be ‘xgboost’, ‘lightgbm’, or ‘protobuf’
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ForestInference.load_from_randomforest">
               <code class="sig-name descname">
                load_from_randomforest
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                model_handle
               </em>
               ,
               <em class="sig-param">
                output_class=False
               </em>
               ,
               <em class="sig-param">
                algo=u'AUTO'
               </em>
               ,
               <em class="sig-param">
                storage_type=u'DENSE'
               </em>
               ,
               <em class="sig-param">
                threshold=0.50
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ForestInference.load_from_randomforest" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ForestInference.load_from_sklearn">
               <code class="sig-name descname">
                load_from_sklearn
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                skl_model
               </em>
               ,
               <em class="sig-param">
                output_class=False
               </em>
               ,
               <em class="sig-param">
                threshold=0.50
               </em>
               ,
               <em class="sig-param">
                algo=u'AUTO'
               </em>
               ,
               <em class="sig-param">
                storage_type=u'DENSE'
               </em>
               ,
               <em class="sig-param">
                handle=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ForestInference.load_from_sklearn" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ForestInference.load_from_treelite_model">
               <code class="sig-name descname">
                load_from_treelite_model
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                model
               </em>
               ,
               <em class="sig-param">
                output_class
               </em>
               ,
               <em class="sig-param">
                algo=u'AUTO'
               </em>
               ,
               <em class="sig-param">
                threshold=0.5
               </em>
               ,
               <em class="sig-param">
                storage_type=u'DENSE'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ForestInference.load_from_treelite_model" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Creates a FIL model using the treelite model
passed to the function.
               </p>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl>
                  <dt>
                   <strong>
                    model
                   </strong>
                   <span class="classifier">
                    the trained model information in the treelite format
                   </span>
                  </dt>
                  <dd>
                   <p>
                    loaded from a saved model using the treelite API
                    <a class="reference external" href="https://treelite.readthedocs.io/en/latest/treelite-api.html">
                     https://treelite.readthedocs.io/en/latest/treelite-api.html
                    </a>
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    output_class: boolean
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    If true, return a 1 or 0 depending on whether the raw prediction
exceeds the threshold. If False, just return the raw prediction.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string name of the algo from (from algo_t enum)
                   </span>
                  </dt>
                  <dd>
                   <dl class="simple">
                    <dt>
                     ‘AUTO’ or ‘auto’ - choose the algorithm automatically;
                    </dt>
                    <dd>
                     <p>
                      currently ‘BATCH_TREE_REORG’ is used for dense storage,
and ‘NAIVE’ for sparse storage
                     </p>
                    </dd>
                   </dl>
                   <p>
                    ‘NAIVE’ or ‘naive’ - simple inference using shared memory
‘TREE_REORG’ or ‘tree_reorg’ - similar to naive but trees
                   </p>
                   <blockquote>
                    <div>
                     <p>
                      rearranged to be more coalescing-friendly
                     </p>
                    </div>
                   </blockquote>
                   <dl class="simple">
                    <dt>
                     ‘BATCH_TREE_REORG’ or ‘batch_tree_reorg’ - similar to TREE_REORG
                    </dt>
                    <dd>
                     <p>
                      but predicting multiple rows
per thread block
                     </p>
                    </dd>
                   </dl>
                  </dd>
                  <dt>
                   <strong>
                    threshold
                   </strong>
                   <span class="classifier">
                    threshold is used to for classification
                   </span>
                  </dt>
                  <dd>
                   <p>
                    applied if output_class == True, else it is ignored
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    storage_type
                   </strong>
                   <span class="classifier">
                    string name of the storage type
                   </span>
                  </dt>
                  <dd>
                   <dl>
                    <dt>
                     (from storage_type_t enum) for the FIL forest
                    </dt>
                    <dd>
                     <dl class="simple">
                      <dt>
                       ‘AUTO’ or ‘auto’ - choose the storage type automatically
                      </dt>
                      <dd>
                       <p>
                        (currently DENSE is always used)
                       </p>
                      </dd>
                     </dl>
                     <p>
                      ‘DENSE’ or ‘dense’ - create a dense forest
‘SPARSE’ or ‘sparse’ - create a sparse forest;
                     </p>
                     <blockquote>
                      <div>
                       <p>
                        requires algo=’NAIVE’ or algo=’AUTO’
                       </p>
                      </div>
                     </blockquote>
                    </dd>
                   </dl>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ForestInference.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                preds=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ForestInference.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the labels for X with the loaded forest model.
By default, the result is the raw floating point output
from the model, unless output_class was set to True
during model loading.
               </p>
               <p>
                See the documentation of ForestInference.load for details.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
For optimal performance, pass a device array with C-style layout
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    preds: gpuarray or cudf.Series, shape = (n_samples,)
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    Optional ‘out’ location to store inference results
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   GPU array of length n_samples with inference results
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   (or ‘preds’ filled with inference results if preds was specified)
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ForestInference.predict_proba">
               <code class="sig-name descname">
                predict_proba
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                preds=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ForestInference.predict_proba" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the class probabilities for X with the loaded forest model.
The result is the raw floating point output
from the model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
For optimal performance, pass a device array with C-style layout
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    preds: gpuarray or cudf.Series, shape = (n_samples,2)
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    binary probability output
Optional ‘out’ location to store inference results
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   GPU array of shape (n_samples,2) with inference results
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   (or ‘preds’ filled with inference results if preds was specified)
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="coordinate-descent">
           <h3>
            Coordinate Descent
            <a class="headerlink" href="#coordinate-descent" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.CD">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              CD
             </code>
             <a class="headerlink" href="#cuml.CD" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Coordinate Descent (CD) is a very common optimization algorithm that
minimizes along coordinate directions to find the minimum of a function.
             </p>
             <p>
              cuML’s CD algorithm accepts a numpy matrix or a cuDF DataFrame as the
input dataset.algorithm The CD algorithm currently works with linear
regression and ridge, lasso, and elastic-net penalties.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  loss
                 </strong>
                 <span class="classifier">
                  ‘squared_loss’ (Only ‘squared_loss’ is supported right now)
                 </span>
                </dt>
                <dd>
                 <p>
                  ‘squared_loss’ uses linear regression
                 </p>
                </dd>
                <dt>
                 <strong>
                  alpha: float (default = 0.0001)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The constant value which decides the degree of regularization.
‘alpha = 0’ is equivalent to an ordinary least square, solved by the
LinearRegression object.
                 </p>
                </dd>
                <dt>
                 <strong>
                  l1_ratio: float (default = 0.15)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The ElasticNet mixing parameter, with 0 &lt;= l1_ratio &lt;= 1. For
l1_ratio = 0 the penalty is an L2 penalty.
For l1_ratio = 1 it is an L1 penalty. For 0 &lt; l1_ratio &lt; 1,
the penalty is a combination of L1 and L2.
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the model tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_iter
                 </strong>
                 <span class="classifier">
                  int (default = 1000)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of times the model should iterate through the entire
dataset during training (default = 1000)
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float (default = 1e-3)
                 </span>
                </dt>
                <dd>
                 <p>
                  The tolerance for the optimization: if the updates are smaller than tol,
solver stops.
                 </p>
                </dd>
                <dt>
                 <strong>
                  shuffle
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If set to ‘True’, a random coefficient is updated every iteration rather
than looping over features sequentially by default.
This (setting to ‘True’) often leads to significantly faster convergence
especially when tol is higher than 1e-4.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">from</span> <span class="nn">cuml.solvers</span> <span class="kn">import</span> <span class="n">CD</span> <span class="k">as</span> <span class="n">cumlCD</span>

<span class="n">cd</span> <span class="o">=</span> <span class="n">cumlCD</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="mf">11.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="p">)</span>

<span class="n">reg</span> <span class="o">=</span> <span class="n">cd</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Coefficients:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"intercept:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">intercept_</span><span class="p">)</span>

<span class="n">X_new</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">preds</span> <span class="o">=</span> <span class="n">cd</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Coefficients</span><span class="p">:</span>
            <span class="mi">0</span> <span class="mf">1.0019531</span>
            <span class="mi">1</span> <span class="mf">1.9980469</span>
<span class="n">Intercept</span><span class="p">:</span>
            <span class="mf">3.0</span>
<span class="n">Preds</span><span class="p">:</span>
            <span class="mi">0</span> <span class="mf">15.997</span>
            <span class="mi">1</span> <span class="mf">14.995</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.CD.fit" title="cuml.CD.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.CD.predict" title="cuml.CD.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.CD.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.CD.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
Parameters
———-
X : array-like (device or host) shape = (n_samples, n_features)
               </p>
               <blockquote>
                <div>
                 <p>
                  Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                 </p>
                </div>
               </blockquote>
               <dl class="simple">
                <dt>
                 y
                 <span class="classifier">
                  array-like (device or host) shape = (n_samples, 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                 </p>
                </dd>
                <dt>
                 convert_dtype
                 <span class="classifier">
                  bool, optional (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.CD.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.CD.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
Parameters
———-
X : array-like (device or host) shape = (n_samples, n_features)
               </p>
               <blockquote>
                <div>
                 <p>
                  Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                 </p>
                </div>
               </blockquote>
               <dl class="simple">
                <dt>
                 convert_dtype
                 <span class="classifier">
                  bool, optional (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                 </p>
                </dd>
               </dl>
               <dl class="simple">
                <dt>
                 y: cuDF DataFrame
                </dt>
                <dd>
                 <p>
                  Dense vector (floats or doubles) of shape (n_samples, 1)
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="quasi-newton">
           <h3>
            Quasi-Newton
            <a class="headerlink" href="#quasi-newton" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.QN">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              QN
             </code>
             <a class="headerlink" href="#cuml.QN" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Quasi-Newton methods are used to either find zeroes or local maxima
and minima of functions, and used by this class to optimize a cost
function.
             </p>
             <p>
              Two algorithms are implemented underneath cuML’s QN class, and which one
is executed depends on the following rule:
             </p>
             <ul class="simple">
              <li>
               <p>
                Orthant-Wise Limited Memory Quasi-Newton (OWL-QN) if there is l1
regularization
               </p>
              </li>
              <li>
               <p>
                Limited Memory BFGS (L-BFGS) otherwise.
               </p>
              </li>
             </ul>
             <p>
              cuML’s QN class can take array-like objects, either in host as
NumPy arrays or in device (as Numba or __cuda_array_interface__ compliant).
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  loss: ‘sigmoid’, ‘softmax’, ‘squared_loss’ (default = ‘squared_loss’)
                 </strong>
                </dt>
                <dd>
                 <p>
                  ‘sigmoid’ loss used for single class logistic regression
‘softmax’ loss used for multiclass logistic regression
‘normal’ used for normal/square loss
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept: boolean (default = True)
                 </strong>
                </dt>
                <dd>
                 <p>
                  If True, the model tries to correct for the global mean of y.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  l1_strength: float (default = 0.0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  l1 regularization strength (if non-zero, will run OWL-QN, else L-BFGS).
Note, that as in Scikit-learn, the bias will not be regularized.
                 </p>
                </dd>
                <dt>
                 <strong>
                  l2_strength: float (default = 0.0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  l2 regularization strength. Note, that as in Scikit-learn, the bias
will not be regularized.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_iter: int (default = 1000)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Maximum number of iterations taken for the solvers to converge.
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol: float (default = 1e-3)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The training process will stop if current_loss &gt; previous_loss - tol
                 </p>
                </dd>
                <dt>
                 <strong>
                  linesearch_max_iter: int (default = 50)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Max number of linesearch iterations per outer iteration of the
algorithm.
                 </p>
                </dd>
                <dt>
                 <strong>
                  lbfgs_memory: int (default = 5)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Rank of the lbfgs inverse-Hessian approximation. Method will use
O(lbfgs_memory * D) memory.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose: int (optional, default 0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Controls verbosity level of logging.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              This class contains implementations of two popular Quasi-Newton methods:
             </p>
             <ul class="simple">
              <li>
               <p>
                Limited-memory Broyden Fletcher Goldfarb Shanno (L-BFGS) [Nocedal,
Wright - Numerical Optimization (1999)]
               </p>
              </li>
              <li>
               <p>
                Orthant-wise limited-memory quasi-newton (OWL-QN) [Andrew, Gao - ICML
2007]
&lt;
                <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/scalable-training-of-l1-regularized-log-linear-models/">
                 https://www.microsoft.com/en-us/research/publication/scalable-training-of-l1-regularized-log-linear-models/
                </a>
                &gt;
               </p>
              </li>
             </ul>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Both import methods supported</span>
<span class="c1"># from cuml import QN</span>
<span class="kn">from</span> <span class="nn">cuml.solvers</span> <span class="kn">import</span> <span class="n">QN</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="p">)</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">QN</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># Note: for now, the coefficients also include the intercept in the</span>
<span class="c1"># last position if fit_intercept=True</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Coefficients:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">coef_</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Intercept:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">intercept_</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">())</span>

<span class="n">X_new</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">X_new</span><span class="p">[</span><span class="s1">'col2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">preds</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Predictions:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Coefficients</span><span class="p">:</span>
            <span class="mf">10.647417</span>
            <span class="mf">0.3267412</span>
            <span class="o">-</span><span class="mf">17.158297</span>
<span class="n">Intercept</span><span class="p">:</span>
            <span class="o">-</span><span class="mf">17.158297</span>
<span class="n">Predictions</span><span class="p">:</span>
            <span class="mi">0</span>    <span class="mf">0.0</span>
            <span class="mi">1</span>    <span class="mf">1.0</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  coef_
                 </strong>
                 <span class="classifier">
                  array, shape (n_classes, n_features)
                 </span>
                </dt>
                <dd>
                 <p>
                  The estimated coefficients for the linear regression model.
Note: shape is (n_classes, n_features + 1) if fit_intercept = True.
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept_
                 </strong>
                 <span class="classifier">
                  array (n_classes, 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  The independent term. If
                  <a href="#id31">
                   <span class="problematic" id="id32">
                    fit_intercept_
                   </span>
                  </a>
                  is False, will be 0.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.QN.fit" title="cuml.QN.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.QN.get_param_names" title="cuml.QN.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.QN.predict" title="cuml.QN.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the y for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.QN.score" title="cuml.QN.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.QN.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.QN.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.QN.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.QN.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.QN.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.QN.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the y for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    Returns
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    ———-
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    y: cuDF DataFrame
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.QN.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.QN.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="support-vector-machines">
           <h3>
            Support Vector Machines
            <a class="headerlink" href="#support-vector-machines" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.svm.SVC">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.svm.
             </code>
             <code class="sig-name descname">
              SVC
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              C-Support Vector Classification
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.svm.SVC" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Currently only binary classification is supported.
             </p>
             <p>
              The solver uses the SMO method to fit the classifier. We use the Optimized
Hierarchical Decomposition [1] variant of the SMO algorithm, similar to [2]
             </p>
             <p class="rubric">
              References
             </p>
             <p>
              [1] J. Vanek et al. A GPU-Architecture Optimized Hierarchical Decomposition
Algorithm for Support VectorMachine Training, IEEE Transactions on
Parallel and Distributed Systems, vol 28, no 12, 3330, (2017)
             </p>
             <p>
              [2] Z. Wen et al. ThunderSVM: A Fast SVM Library on GPUs and CPUs, Journal
of Machine Learning Research, 19, 1-5 (2018)
              <a class="reference external" href="https://github.com/Xtra-Computing/thundersvm">
               https://github.com/Xtra-Computing/thundersvm
              </a>
             </p>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.svm.SVC.decision_function" title="cuml.svm.SVC.decision_function">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     decision_function
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Calculates the decision function values for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.svm.SVC.fit" title="cuml.svm.SVC.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y)
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.svm.SVC.predict" title="cuml.svm.SVC.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the class labels for X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.svm.SVC.decision_function">
               <code class="sig-name descname">
                decision_function
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.svm.SVC.decision_function" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Calculates the decision function values for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    cuDF Series
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.svm.SVC.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.svm.SVC.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.svm.SVC.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.svm.SVC.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the class labels for X. The returned y values are the class
labels associated to sign(decision_function(X)).
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    cuDF Series
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.svm.SVR">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.svm.
             </code>
             <code class="sig-name descname">
              SVR
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              Epsilon Support Vector Regression
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.svm.SVR" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              The solver uses the SMO method to fit the regressor. We use the Optimized
Hierarchical Decomposition [1] variant of the SMO algorithm, similar to [2]
             </p>
             <p class="rubric">
              References
             </p>
             <dl class="simple">
              <dt>
               [1] J. Vanek et al. A GPU-Architecture Optimized Hierarchical Decomposition
              </dt>
              <dd>
               <p>
                Algorithm for Support VectorMachine Training, IEEE Transactions on
Parallel and Distributed Systems, vol 28, no 12, 3330, (2017)
               </p>
              </dd>
             </dl>
             <p>
              [2] Z. Wen et al. ThunderSVM: A Fast SVM Library on GPUs and CPUs, Journal
*      of Machine Learning Research, 19, 1-5 (2018)
             </p>
             <blockquote>
              <div>
               <p>
                <a class="reference external" href="https://github.com/Xtra-Computing/thundersvm">
                 https://github.com/Xtra-Computing/thundersvm
                </a>
               </p>
              </div>
             </blockquote>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.svm.SVR.fit" title="cuml.svm.SVR.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y)
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.svm.SVR.predict" title="cuml.svm.SVR.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the values for X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.svm.SVR.score" title="cuml.svm.SVR.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y)
                 </p>
                </td>
                <td>
                 <p>
                  Return R^2 score of the prediction.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.svm.SVR.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.svm.SVR.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1).
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.svm.SVR.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.svm.SVR.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the values for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    cuDF Series
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of shape (n_samples, 1)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.svm.SVR.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.svm.SVR.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Return R^2 score of the prediction.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense vector (floats or doubles) of target values.
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   score: float R^2 score
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="nearest-neighbors-classification">
           <h3>
            Nearest Neighbors Classification
            <a class="headerlink" href="#nearest-neighbors-classification" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.neighbors.KNeighborsClassifier">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.neighbors.
             </code>
             <code class="sig-name descname">
              KNeighborsClassifier
             </code>
             <a class="headerlink" href="#cuml.neighbors.KNeighborsClassifier" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              K-Nearest Neighbors Classifier is an instance-based learning technique,
that keeps training samples around for prediction, rather than trying
to learn a generalizable set of model parameters.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_neighbors
                 </strong>
                 <span class="classifier">
                  int (default=5)
                 </span>
                </dt>
                <dd>
                 <p>
                  Default number of neighbors to query
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  boolean (default=False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print verbose logs
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cumlHandle
                 </span>
                </dt>
                <dd>
                 <p>
                  The cumlHandle resources to use
                 </p>
                </dd>
                <dt>
                 <strong>
                  algorithm
                 </strong>
                 <span class="classifier">
                  string (default=’brute’)
                 </span>
                </dt>
                <dd>
                 <p>
                  The query algorithm to use. Currently, only ‘brute’ is supported.
                 </p>
                </dd>
                <dt>
                 <strong>
                  metric
                 </strong>
                 <span class="classifier">
                  string (default=’euclidean’).
                 </span>
                </dt>
                <dd>
                 <p>
                  Distance metric to use.
                 </p>
                </dd>
                <dt>
                 <strong>
                  weights
                 </strong>
                 <span class="classifier">
                  string (default=’uniform’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Sample weights to use. Currently, only the uniform strategy is
supported.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For additional docs, see
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html">
               scikitlearn’s KNeighborsClassifier
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">from</span> <span class="nn">cuml.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                  <span class="n">n_features</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span>
  <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.80</span><span class="p">)</span>

<span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="n">knn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.fit" title="cuml.neighbors.KNeighborsClassifier.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit a GPU index for k-nearest neighbors classifier model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.get_param_names" title="cuml.neighbors.KNeighborsClassifier.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.predict" title="cuml.neighbors.KNeighborsClassifier.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Use the trained k-nearest neighbors classifier to predict the labels for X
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.predict_proba" title="cuml.neighbors.KNeighborsClassifier.predict_proba">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict_proba
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Use the trained k-nearest neighbors classifier to predict the label probabilities for X
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.score" title="cuml.neighbors.KNeighborsClassifier.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Compute the accuracy score using the given labels and the trained k-nearest neighbors classifier to predict the classes for X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.neighbors.KNeighborsClassifier.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.KNeighborsClassifier.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit a GPU index for k-nearest neighbors classifier model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_outputs)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_outputs).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.neighbors.KNeighborsClassifier.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.KNeighborsClassifier.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.neighbors.KNeighborsClassifier.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.KNeighborsClassifier.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Use the trained k-nearest neighbors classifier to
predict the labels for X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.neighbors.KNeighborsClassifier.predict_proba">
               <code class="sig-name descname">
                predict_proba
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.KNeighborsClassifier.predict_proba" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Use the trained k-nearest neighbors classifier to
predict the label probabilities for X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.neighbors.KNeighborsClassifier.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.KNeighborsClassifier.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Compute the accuracy score using the given labels and
the trained k-nearest neighbors classifier to predict
the classes for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="nearest-neighbors-regression">
           <h3>
            Nearest Neighbors Regression
            <a class="headerlink" href="#nearest-neighbors-regression" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.neighbors.KNeighborsRegressor">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.neighbors.
             </code>
             <code class="sig-name descname">
              KNeighborsRegressor
             </code>
             <a class="headerlink" href="#cuml.neighbors.KNeighborsRegressor" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              K-Nearest Neighbors Regressor is an instance-based learning technique,
that keeps training samples around for prediction, rather than trying
to learn a generalizable set of model parameters.
             </p>
             <p>
              The K-Nearest Neighbors Regressor will compute the average of the
labels for the k closest neighbors and use it as the label.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_neighbors
                 </strong>
                 <span class="classifier">
                  int (default=5)
                 </span>
                </dt>
                <dd>
                 <p>
                  Default number of neighbors to query
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  boolean (default=False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print verbose logs
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cumlHandle
                 </span>
                </dt>
                <dd>
                 <p>
                  The cumlHandle resources to use
                 </p>
                </dd>
                <dt>
                 <strong>
                  algorithm
                 </strong>
                 <span class="classifier">
                  string (default=’brute’)
                 </span>
                </dt>
                <dd>
                 <p>
                  The query algorithm to use. Currently, only ‘brute’ is supported.
                 </p>
                </dd>
                <dt>
                 <strong>
                  metric
                 </strong>
                 <span class="classifier">
                  string (default=’euclidean’).
                 </span>
                </dt>
                <dd>
                 <p>
                  Distance metric to use.
                 </p>
                </dd>
                <dt>
                 <strong>
                  weights
                 </strong>
                 <span class="classifier">
                  string (default=’uniform’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Sample weights to use. Currently, only the uniform strategy is
supported.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For additional docs, see
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html">
               scikitlearn’s KNeighborsClassifier
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">from</span> <span class="nn">cuml.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>

<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                  <span class="n">n_features</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span>
  <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.80</span><span class="p">)</span>

<span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="n">knn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">array</span><span class="p">([</span><span class="mf">3.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span>
       <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span>
       <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span> <span class="mf">3.</span>        <span class="p">,</span>
       <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span>
       <span class="mf">3.</span>        <span class="p">,</span> <span class="mf">3.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">3.</span>        <span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span>
       <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.</span>        <span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span>
       <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">])</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsRegressor.fit" title="cuml.neighbors.KNeighborsRegressor.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit a GPU index for k-nearest neighbors regression model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsRegressor.predict" title="cuml.neighbors.KNeighborsRegressor.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Use the trained k-nearest neighbors regression model to predict the labels for X
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsRegressor.score" title="cuml.neighbors.KNeighborsRegressor.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit a GPU index for k-nearest neighbors regression model.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.neighbors.KNeighborsRegressor.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.KNeighborsRegressor.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit a GPU index for k-nearest neighbors regression model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_outputs)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_outputs).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.neighbors.KNeighborsRegressor.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.KNeighborsRegressor.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Use the trained k-nearest neighbors regression model to
predict the labels for X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.neighbors.KNeighborsRegressor.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.KNeighborsRegressor.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit a GPU index for k-nearest neighbors regression model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
         </div>
         <div class="section" id="clustering">
          <h2>
           Clustering
           <a class="headerlink" href="#clustering" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="k-means-clustering">
           <h3>
            K-Means Clustering
            <a class="headerlink" href="#k-means-clustering" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.KMeans">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              KMeans
             </code>
             <a class="headerlink" href="#cuml.KMeans" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              KMeans is a basic but powerful clustering method which is optimized via
Expectation Maximization. It randomly selects K data points in X, and
computes which samples are close to these points.
For every cluster of points, a mean is computed (hence the name), and this
becomes the new centroid.
             </p>
             <p>
              cuML’s KMeans expects an array-like object or cuDF DataFrame, and supports
the scalable KMeans++ initialization method. This method is more stable
than randomly selecting K points.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_clusters
                 </strong>
                 <span class="classifier">
                  int (default = 8)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of centroids or clusters you want.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_iter
                 </strong>
                 <span class="classifier">
                  int (default = 300)
                 </span>
                </dt>
                <dd>
                 <p>
                  The more iterations of EM, the more accurate, but slower.
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float64 (default = 1e-4)
                 </span>
                </dt>
                <dd>
                 <p>
                  Stopping criterion when centroid means do not change much.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  boolean (default = 0)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, prints diagnostic information.
                 </p>
                </dd>
                <dt>
                 <strong>
                  random_state
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  If you want results to be the same when you restart Python, select a
state.
                 </p>
                </dd>
                <dt>
                 <strong>
                  init
                 </strong>
                 <span class="classifier">
                  ‘scalable-kmeans++’, ‘k-means||’ , ‘random’ or an ndarray (default = ‘scalable-k-means++’)  # noqa
                 </span>
                </dt>
                <dd>
                 <p>
                  ‘scalable-k-means++’ or ‘k-means||’: Uses fast and stable scalable
kmeans++ initialization.
‘random’: Choose ‘n_cluster’ observations (rows) at random from data
for the initial centroids. If an ndarray is passed, it should be of
shape (n_clusters, n_features) and gives the initial centers.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_init: int (default = 1)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Number of instances the k-means algorithm will be called with different seeds.
The final results will be from the instance that produces lowest inertia out
of n_init instances.
                 </p>
                </dd>
                <dt>
                 <strong>
                  oversampling_factor
                 </strong>
                 <span class="classifier">
                  float64
                 </span>
                </dt>
                <dd>
                 <p>
                  scalable k-means|| oversampling factor
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_samples_per_batch
                 </strong>
                 <span class="classifier">
                  int (default=1&lt;&lt;15)
                 </span>
                </dt>
                <dd>
                 <p>
                  maximum number of samples to use for each batch
of the pairwise distance computation.
                 </p>
                </dd>
                <dt>
                 <strong>
                  oversampling_factor
                 </strong>
                 <span class="classifier">
                  int (default = 2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The amount of points to sample
in scalable k-means++ initialization for potential centroids.
Increasing this value can lead to better initial centroids at the
cost of memory. The total number of centroids sampled in scalable
k-means++ is oversampling_factor * n_clusters * 8.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_samples_per_batch
                 </strong>
                 <span class="classifier">
                  int (default = 32768)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of data
samples to use for batches of the pairwise distance computation.
This computation is done throughout both fit predict. The default
should suit most cases. The total number of elements in the batched
pairwise distance computation is max_samples_per_batch * n_clusters.
It might become necessary to lower this number when n_clusters
becomes prohibitively large.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              KMeans requires n_clusters to be specified. This means one needs to
approximately guess or know how many clusters a dataset has. If one is not
sure, one can start with a small number of clusters, and visualize the
resulting clusters with PCA, UMAP or T-SNE, and verify that they look
appropriate.
             </p>
             <p>
              <strong>
               Applications of KMeans
              </strong>
             </p>
             <blockquote>
              <div>
               <p>
                The biggest advantage of KMeans is its speed and simplicity. That is
why KMeans is many practitioner’s first choice of a clustering
algorithm. KMeans has been extensively used when the number of clusters
is approximately known, such as in big data clustering tasks,
image segmentation and medical clustering.
               </p>
              </div>
             </blockquote>
             <p>
              For additional docs, see
              <a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">
               scikitlearn’s Kmeans
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="c1"># Both import methods supported</span>
<span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">cuml.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>

<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="k">def</span> <span class="nf">np2cudf</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="c1"># convert numpy array to cuDF dataframe</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'fea</span><span class="si">%d</span><span class="s1">'</span><span class="o">%</span><span class="n">i</span><span class="p">:</span><span class="n">df</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])})</span>
    <span class="n">pdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
      <span class="n">pdf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pdf</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]],</span>
               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np2cudf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"input:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Calling fit"</span><span class="p">)</span>
<span class="n">kmeans_float</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_gpu</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">kmeans_float</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"labels:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kmeans_float</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"cluster_centers:"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kmeans_float</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="nb">input</span><span class="p">:</span>

     <span class="mi">0</span>    <span class="mi">1</span>
 <span class="mi">0</span>  <span class="mf">1.0</span>  <span class="mf">1.0</span>
 <span class="mi">1</span>  <span class="mf">1.0</span>  <span class="mf">2.0</span>
 <span class="mi">2</span>  <span class="mf">3.0</span>  <span class="mf">2.0</span>
 <span class="mi">3</span>  <span class="mf">4.0</span>  <span class="mf">3.0</span>

<span class="n">Calling</span> <span class="n">fit</span>

<span class="n">labels</span><span class="p">:</span>

   <span class="mi">0</span>    <span class="mi">0</span>
   <span class="mi">1</span>    <span class="mi">0</span>
   <span class="mi">2</span>    <span class="mi">1</span>
   <span class="mi">3</span>    <span class="mi">1</span>

<span class="n">cluster_centers</span><span class="p">:</span>

   <span class="mi">0</span>    <span class="mi">1</span>
<span class="mi">0</span>  <span class="mf">1.0</span>  <span class="mf">1.5</span>
<span class="mi">1</span>  <span class="mf">3.5</span>  <span class="mf">2.5</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  cluster_centers_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The coordinates of the final clusters. This represents of “mean” of
each data cluster.
                 </p>
                </dd>
                <dt>
                 <strong>
                  labels_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  Which cluster each datapoint belongs to.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.KMeans.fit" title="cuml.KMeans.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Compute k-means clustering with X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.KMeans.fit_predict" title="cuml.KMeans.fit_predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_predict
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Compute cluster centers and predict cluster index for each sample.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.KMeans.fit_transform" title="cuml.KMeans.fit_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Compute clustering and transform X to cluster-distance space.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.KMeans.get_param_names" title="cuml.KMeans.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.KMeans.predict" title="cuml.KMeans.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Predict the closest cluster each sample in X belongs to.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.KMeans.score" title="cuml.KMeans.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Opposite of the value of X on the K-means objective.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.KMeans.transform" title="cuml.KMeans.transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     transform
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Transform X to a cluster-distance space.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.KMeans.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.KMeans.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Compute k-means clustering with X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.KMeans.fit_predict">
               <code class="sig-name descname">
                fit_predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.KMeans.fit_predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Compute cluster centers and predict cluster index for each sample.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.KMeans.fit_transform">
               <code class="sig-name descname">
                fit_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.KMeans.fit_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Compute clustering and transform X to cluster-distance space.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit_transform method will automatically
convert the input to the data type which was used to train the
model. This will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.KMeans.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.KMeans.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.KMeans.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.KMeans.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predict the closest cluster each sample in X belongs to.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    labels
                   </strong>
                   <span class="classifier">
                    array
                   </span>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   Which cluster each datapoint belongs to.
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.KMeans.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.KMeans.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Opposite of the value of X on the K-means objective.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   score: float
                  </dt>
                  <dd>
                   <p>
                    Opposite of the value of X on the K-means objective.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.KMeans.transform">
               <code class="sig-name descname">
                transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.KMeans.transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Transform X to a cluster-distance space.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the transform method will, when necessary,
convert the input to the data type which was used to train the
model. This will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="dbscan">
           <h3>
            DBSCAN
            <a class="headerlink" href="#dbscan" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.DBSCAN">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              DBSCAN
             </code>
             <a class="headerlink" href="#cuml.DBSCAN" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              DBSCAN is a very powerful yet fast clustering technique that finds clusters
where data is concentrated. This allows DBSCAN to generalize to many
problems if the datapoints tend to congregate in larger groups.
             </p>
             <p>
              cuML’s DBSCAN expects an array-like object or cuDF DataFrame, and
constructs an adjacency graph to compute the distances between close
neighbours.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  eps
                 </strong>
                 <span class="classifier">
                  float (default = 0.5)
                 </span>
                </dt>
                <dd>
                 <p>
                  The maximum distance between 2 points such they reside in the same
neighborhood.
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class
                 </p>
                </dd>
                <dt>
                 <strong>
                  min_samples
                 </strong>
                 <span class="classifier">
                  int (default = 5)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of samples in a neighborhood such that this group can be
considered as an important core point (including the point itself).
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  bool
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print debug spews
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_mbytes_per_batch
                 </strong>
                 <span class="classifier">
                  (optional) int64
                 </span>
                </dt>
                <dd>
                 <p>
                  Calculate batch size using no more than this number of megabytes for
the pairwise distance computation. This enables the trade-off between
runtime and memory usage for making the N^2 pairwise distance
computations more tractable for large numbers of samples.
If you are experiencing out of memory errors when running DBSCAN, you
can set this value based on the memory size of your device.
Note: this option does not set the maximum total memory used in the
DBSCAN computation and so this value will not be able to be set to
the total memory available on the device.
                 </p>
                </dd>
                <dt>
                 <strong>
                  output_type
                 </strong>
                 <span class="classifier">
                  (optional) {‘input’, ‘cudf’, ‘cupy’, ‘numpy’} default = None
                 </span>
                </dt>
                <dd>
                 <p>
                  Use it to control output type of the results and attributes.
If None it’ll inherit the output type set at the
module level, cuml.output_type. If that has not been changed, by
default the estimator will mirror the type of the data used for each
fit or predict call.
If set, the estimator will override the global option for its behavior.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              DBSCAN is very sensitive to the distance metric it is used with, and a
large assumption is that datapoints need to be concentrated in groups for
clusters to be constructed.
             </p>
             <p>
              <strong>
               Applications of DBSCAN
              </strong>
             </p>
             <blockquote>
              <div>
               <p>
                DBSCAN’s main benefit is that the number of clusters is not a
hyperparameter, and that it can find non-linearly shaped clusters.
This also allows DBSCAN to be robust to noise.
DBSCAN has been applied to analyzing particle collisions in the
Large Hadron Collider, customer segmentation in marketing analyses,
and much more.
               </p>
              </div>
             </blockquote>
             <p>
              For an additional example, see
              <a class="reference external" href="https://github.com/rapidsai/notebooks/blob/master/cuml/dbscan_demo.ipynb">
               the DBSCAN notebook
              </a>
              .
For additional docs, see
              <a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html">
               scikitlearn’s DBSCAN
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="c1"># Both import methods supported</span>
<span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">cuml.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>

<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">gdf_float</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'0'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">dbscan_float</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">min_samples</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dbscan_float</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">gdf_float</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dbscan_float</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">2</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  labels_
                 </strong>
                 <span class="classifier">
                  array-like or cuDF series
                 </span>
                </dt>
                <dd>
                 <p>
                  Which cluster each datapoint belongs to. Noisy samples are labeled as
-1. Format depends on cuml global output type and estimator
output_type.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.DBSCAN.fit" title="cuml.DBSCAN.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X[, out_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Perform DBSCAN clustering from features.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.DBSCAN.fit_predict" title="cuml.DBSCAN.fit_predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_predict
                    </span>
                   </code>
                  </a>
                  (self, X[, out_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Performs clustering on input_gdf and returns cluster labels.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.DBSCAN.get_param_names" title="cuml.DBSCAN.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.DBSCAN.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                out_dtype=u'int32'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.DBSCAN.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Perform DBSCAN clustering from features.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    out_dtype: dtype Determines the precision of the output labels array.
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    default: “int32”. Valid values are { “int32”, np.int32,
“int64”, np.int64}. When the number of samples exceed
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.DBSCAN.fit_predict">
               <code class="sig-name descname">
                fit_predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                out_dtype=u'int32'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.DBSCAN.fit_predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Performs clustering on input_gdf and returns cluster labels.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features)
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    cuDF Series, shape (n_samples)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    cluster labels
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.DBSCAN.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.DBSCAN.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
         </div>
         <div class="section" id="dimensionality-reduction-and-manifold-learning">
          <h2>
           Dimensionality Reduction and Manifold Learning
           <a class="headerlink" href="#dimensionality-reduction-and-manifold-learning" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="principal-component-analysis">
           <h3>
            Principal Component Analysis
            <a class="headerlink" href="#principal-component-analysis" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.PCA">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              PCA
             </code>
             <a class="headerlink" href="#cuml.PCA" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              PCA (Principal Component Analysis) is a fundamental dimensionality
reduction technique used to combine features in X in linear combinations
such that each new component captures the most information or variance of
the data. N_components is usually small, say at 3, where it can be used for
data visualization, data compression and exploratory analysis.
             </p>
             <p>
              cuML’s PCA expects an array-like object or cuDF DataFrame, and provides 2
algorithms Full and Jacobi. Full (default) uses a full eigendecomposition
then selects the top K eigenvectors. The Jacobi algorithm is much faster
as it iteratively tries to correct the top K eigenvectors, but might be
less accurate.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  copy
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, then copies data then removes mean from data. False might
cause data to be overwritten with its mean centered version.
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class
                 </p>
                </dd>
                <dt>
                 <strong>
                  iterated_power
                 </strong>
                 <span class="classifier">
                  int (default = 15)
                 </span>
                </dt>
                <dd>
                 <p>
                  Used in Jacobi solver. The more iterations, the more accurate, but
slower.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_components
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of top K singular vectors / values you want.
Must be &lt;= number(columns).
                 </p>
                </dd>
                <dt>
                 <strong>
                  random_state
                 </strong>
                 <span class="classifier">
                  int / None (default = None)
                 </span>
                </dt>
                <dd>
                 <p>
                  If you want results to be the same when you restart Python, select a
state.
                 </p>
                </dd>
                <dt>
                 <strong>
                  svd_solver
                 </strong>
                 <span class="classifier">
                  ‘full’ or ‘jacobi’ or ‘auto’ (default = ‘full’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Full uses a eigendecomposition of the covariance matrix then discards
components.
Jacobi is much faster as it iteratively corrects, but is less accurate.
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float (default = 1e-7)
                 </span>
                </dt>
                <dd>
                 <p>
                  Used if algorithm = “jacobi”. Smaller tolerance can increase accuracy,
but but will slow down the algorithm’s convergence.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  bool
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print debug spews
                 </p>
                </dd>
                <dt>
                 <strong>
                  whiten
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, de-correlates the components. This is done by dividing them by
the corresponding singular values then multiplying by sqrt(n_samples).
Whitening allows each component to have unit variance and removes
multi-collinearity. It might be beneficial for downstream
tasks like LinearRegression where correlated features cause problems.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              PCA considers linear combinations of features, specifically those that
maximize global variance structure. This means PCA is fantastic for global
structure analyses, but weak for local relationships. Consider UMAP or
T-SNE for a locally important embedding.
             </p>
             <p>
              <strong>
               Applications of PCA
              </strong>
             </p>
             <blockquote>
              <div>
               <p>
                PCA is used extensively in practice for data visualization and data
compression. It has been used to visualize extremely large word
embeddings like Word2Vec and GloVe in 2 or 3 dimensions, large
datasets of everyday objects and images, and used to distinguish
between cancerous cells from healthy cells.
               </p>
              </div>
             </blockquote>
             <p>
              For an additional example see
              <a class="reference external" href="https://github.com/rapidsai/notebooks/blob/master/cuml/pca_demo.ipynb">
               the PCA notebook
              </a>
              .
For additional docs, see
              <a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html">
               scikitlearn’s PCA
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="c1"># Both import methods supported</span>
<span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">cuml.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">gdf_float</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'0'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">pca_float</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">pca_float</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">gdf_float</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'components: </span><span class="si">{</span><span class="n">pca_float</span><span class="o">.</span><span class="n">components_</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'explained variance: </span><span class="si">{</span><span class="n">pca_float</span><span class="o">.</span><span class="n">_explained_variance_</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="n">exp_var</span> <span class="o">=</span> <span class="n">pca_float</span><span class="o">.</span><span class="n">_explained_variance_ratio_</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'explained variance ratio: </span><span class="si">{</span><span class="n">exp_var</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'singular values: </span><span class="si">{</span><span class="n">pca_float</span><span class="o">.</span><span class="n">_singular_values_</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'mean: </span><span class="si">{</span><span class="n">pca_float</span><span class="o">.</span><span class="n">_mean_</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'noise variance: </span><span class="si">{</span><span class="n">pca_float</span><span class="o">.</span><span class="n">_noise_variance_</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

<span class="n">trans_gdf_float</span> <span class="o">=</span> <span class="n">pca_float</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">gdf_float</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Inverse: </span><span class="si">{</span><span class="n">trans_gdf_float</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

<span class="n">input_gdf_float</span> <span class="o">=</span> <span class="n">pca_float</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">trans_gdf_float</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Input: </span><span class="si">{</span><span class="n">input_gdf_float</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">components</span><span class="p">:</span>
            <span class="mi">0</span>           <span class="mi">1</span>           <span class="mi">2</span>
            <span class="mi">0</span>  <span class="mf">0.69225764</span>  <span class="o">-</span><span class="mf">0.5102837</span> <span class="o">-</span><span class="mf">0.51028395</span>
            <span class="mi">1</span> <span class="o">-</span><span class="mf">0.72165036</span> <span class="o">-</span><span class="mf">0.48949987</span>  <span class="o">-</span><span class="mf">0.4895003</span>

<span class="n">explained</span> <span class="n">variance</span><span class="p">:</span>

            <span class="mi">0</span>   <span class="mf">8.510402</span>
            <span class="mi">1</span> <span class="mf">0.48959687</span>

<span class="n">explained</span> <span class="n">variance</span> <span class="n">ratio</span><span class="p">:</span>

             <span class="mi">0</span>   <span class="mf">0.9456003</span>
             <span class="mi">1</span> <span class="mf">0.054399658</span>

<span class="n">singular</span> <span class="n">values</span><span class="p">:</span>

           <span class="mi">0</span> <span class="mf">4.1256275</span>
           <span class="mi">1</span> <span class="mf">0.9895422</span>

<span class="n">mean</span><span class="p">:</span>

          <span class="mi">0</span> <span class="mf">2.6666667</span>
          <span class="mi">1</span> <span class="mf">2.3333333</span>
          <span class="mi">2</span> <span class="mf">2.3333333</span>

<span class="n">noise</span> <span class="n">variance</span><span class="p">:</span>

      <span class="mi">0</span>  <span class="mf">0.0</span>

<span class="n">transformed</span> <span class="n">matrix</span><span class="p">:</span>
             <span class="mi">0</span>           <span class="mi">1</span>
             <span class="mi">0</span>   <span class="o">-</span><span class="mf">2.8547091</span> <span class="o">-</span><span class="mf">0.42891636</span>
             <span class="mi">1</span> <span class="o">-</span><span class="mf">0.121316016</span>  <span class="mf">0.80743366</span>
             <span class="mi">2</span>    <span class="mf">2.9760244</span> <span class="o">-</span><span class="mf">0.37851727</span>

<span class="n">Input</span> <span class="n">Matrix</span><span class="p">:</span>
          <span class="mi">0</span>         <span class="mi">1</span>         <span class="mi">2</span>
          <span class="mi">0</span> <span class="mf">1.0000001</span> <span class="mf">3.9999993</span>       <span class="mf">4.0</span>
          <span class="mi">1</span>       <span class="mf">2.0</span> <span class="mf">2.0000002</span> <span class="mf">1.9999999</span>
          <span class="mi">2</span> <span class="mf">4.9999995</span> <span class="mf">1.0000006</span>       <span class="mf">1.0</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  components_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The top K components (VT.T[:,:n_components]) in U, S, VT = svd(X)
                 </p>
                </dd>
                <dt>
                 <strong>
                  explained_variance_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  How much each component explains the variance in the data given by S**2
                 </p>
                </dd>
                <dt>
                 <strong>
                  explained_variance_ratio_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  How much in % the variance is explained given by S**2/sum(S**2)
                 </p>
                </dd>
                <dt>
                 <strong>
                  singular_values_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The top K singular values. Remember all singular values &gt;= 0
                 </p>
                </dd>
                <dt>
                 <strong>
                  mean_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The column wise mean of X. Used to mean - center the data first.
                 </p>
                </dd>
                <dt>
                 <strong>
                  noise_variance_
                 </strong>
                 <span class="classifier">
                  float
                 </span>
                </dt>
                <dd>
                 <p>
                  From Bishop 1999’s Textbook. Used in later tasks like calculating the
estimated covariance of X.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.PCA.fit" title="cuml.PCA.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X[, y])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.PCA.fit_transform" title="cuml.PCA.fit_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, y])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and apply the dimensionality reduction on X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.PCA.get_param_names" title="cuml.PCA.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.PCA.inverse_transform" title="cuml.PCA.inverse_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     inverse_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Transform data back to its original space.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.PCA.transform" title="cuml.PCA.transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     transform
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Apply dimensionality reduction to X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.PCA.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.PCA.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    ignored
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   cluster labels
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.PCA.fit_transform">
               <code class="sig-name descname">
                fit_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.PCA.fit_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and apply the dimensionality reduction on X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    training data (floats or doubles), where n_samples is the number of
samples, and n_features is the number of features.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    ignored
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    cuDF DataFrame, shape (n_samples, n_components)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.PCA.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.PCA.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.PCA.inverse_transform">
               <code class="sig-name descname">
                inverse_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.PCA.inverse_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Transform data back to its original space.
               </p>
               <p>
                In other words, return an input X_original whose transform would be X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    New data (floats or doubles), where n_samples is the number of
samples and n_components is the number of components.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the inverse_transform method will automatically
convert the input to the data type which was used to train the
model. This will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_original
                   </strong>
                   <span class="classifier">
                    cuDF DataFrame, shape (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.PCA.transform">
               <code class="sig-name descname">
                transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.PCA.transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Apply dimensionality reduction to X.
               </p>
               <p>
                X is projected on the first principal components previously extracted
from a training set.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    New data (floats or doubles), where n_samples is the number of
samples and n_components is the number of components.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the transform method will automatically
convert the input to the data type which was used to train the
model. This will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    cuDF DataFrame, shape (n_samples, n_components)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="truncated-svd">
           <h3>
            Truncated SVD
            <a class="headerlink" href="#truncated-svd" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.TruncatedSVD">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              TruncatedSVD
             </code>
             <a class="headerlink" href="#cuml.TruncatedSVD" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              TruncatedSVD is used to compute the top K singular values and vectors of a
large matrix X. It is much faster when n_components is small, such as in
the use of PCA when 3 components is used for 3D visualization.
             </p>
             <p>
              cuML’s TruncatedSVD an array-like object or cuDF DataFrame, and provides 2
algorithms Full and Jacobi. Full (default) uses a full eigendecomposition
then selects the top K singular vectors. The Jacobi algorithm is much
faster as it iteratively tries to correct the top K singular vectors, but
might be less accurate.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  algorithm
                 </strong>
                 <span class="classifier">
                  ‘full’ or ‘jacobi’ or ‘auto’ (default = ‘full’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Full uses a eigendecomposition of the covariance matrix then discards
components.
Jacobi is much faster as it iteratively corrects, but is less accurate.
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_components
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of top K singular vectors / values you want.
Must be &lt;= number(columns).
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_iter
                 </strong>
                 <span class="classifier">
                  int (default = 15)
                 </span>
                </dt>
                <dd>
                 <p>
                  Used in Jacobi solver. The more iterations, the more accurate, but
slower.
                 </p>
                </dd>
                <dt>
                 <strong>
                  random_state
                 </strong>
                 <span class="classifier">
                  int / None (default = None)
                 </span>
                </dt>
                <dd>
                 <p>
                  If you want results to be the same when you restart Python, select a
state.
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float (default = 1e-7)
                 </span>
                </dt>
                <dd>
                 <p>
                  Used if algorithm = “jacobi”. Smaller tolerance can increase accuracy,
but but will slow down the algorithm’s convergence.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  bool
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print debug spews
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              TruncatedSVD (the randomized version [Jacobi]) is fantastic when the number
of components you want is much smaller than the number of features. The
approximation to the largest singular values and vectors is very robust,
however, this method loses a lot of accuracy when you want many, many
components.
             </p>
             <p>
              <strong>
               Applications of TruncatedSVD
              </strong>
             </p>
             <blockquote>
              <div>
               <p>
                TruncatedSVD is also known as Latent Semantic Indexing (LSI) which
tries to find topics of a word count matrix. If X previously was
centered with mean removal, TruncatedSVD is the same as TruncatedPCA.
TruncatedSVD is also used in information retrieval tasks,
recommendation systems and data compression.
               </p>
              </div>
             </blockquote>
             <p>
              For additional examples, see
              <a class="reference external" href="https://github.com/rapidsai/notebooks/blob/master/cuml/tsvd_demo.ipynb">
               the Truncated SVD  notebook
              </a>
              .
For additional documentation, see
              <a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.TruncatedSVD.html">
               scikitlearn’s TruncatedSVD docs
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="c1"># Both import methods supported</span>
<span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">TruncatedSVD</span>
<span class="kn">from</span> <span class="nn">cuml.decomposition</span> <span class="kn">import</span> <span class="n">TruncatedSVD</span>

<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">gdf_float</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'0'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">gdf_float</span><span class="p">[</span><span class="s1">'2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">tsvd_float</span> <span class="o">=</span> <span class="n">TruncatedSVD</span><span class="p">(</span><span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">"jacobi"</span><span class="p">,</span>
                          <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-9</span><span class="p">)</span>
<span class="n">tsvd_float</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">gdf_float</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'components: </span><span class="si">{</span><span class="n">tsvd_float</span><span class="o">.</span><span class="n">components_</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'explained variance: </span><span class="si">{</span><span class="n">tsvd_float</span><span class="o">.</span><span class="n">_explained_variance_</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="n">exp_var</span> <span class="o">=</span> <span class="n">tsvd_float</span><span class="o">.</span><span class="n">_explained_variance_ratio_</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'explained variance ratio: </span><span class="si">{</span><span class="n">exp_var</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'singular values: </span><span class="si">{</span><span class="n">tsvd_float</span><span class="o">.</span><span class="n">_singular_values_</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

<span class="n">trans_gdf_float</span> <span class="o">=</span> <span class="n">tsvd_float</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">gdf_float</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Transformed matrix: </span><span class="si">{</span><span class="n">trans_gdf_float</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

<span class="n">input_gdf_float</span> <span class="o">=</span> <span class="n">tsvd_float</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">trans_gdf_float</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Input matrix: </span><span class="si">{</span><span class="n">input_gdf_float</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">components</span><span class="p">:</span>            <span class="mi">0</span>           <span class="mi">1</span>          <span class="mi">2</span>
<span class="mi">0</span> <span class="mf">0.58725953</span>  <span class="mf">0.57233137</span>  <span class="mf">0.5723314</span>
<span class="mi">1</span> <span class="mf">0.80939883</span> <span class="o">-</span><span class="mf">0.41525528</span> <span class="o">-</span><span class="mf">0.4152552</span>
<span class="n">explained</span> <span class="n">variance</span><span class="p">:</span>
<span class="mi">0</span>  <span class="mf">55.33908</span>
<span class="mi">1</span> <span class="mf">16.660923</span>

<span class="n">explained</span> <span class="n">variance</span> <span class="n">ratio</span><span class="p">:</span>
<span class="mi">0</span>  <span class="mf">0.7685983</span>
<span class="mi">1</span> <span class="mf">0.23140171</span>

<span class="n">singular</span> <span class="n">values</span><span class="p">:</span>
<span class="mi">0</span>  <span class="mf">7.439024</span>
<span class="mi">1</span> <span class="mf">4.0817795</span>

<span class="n">Transformed</span> <span class="n">Matrix</span><span class="p">:</span>
<span class="mi">0</span>           <span class="mi">1</span>         <span class="mi">2</span>
<span class="mi">0</span>   <span class="mf">5.1659107</span>    <span class="o">-</span><span class="mf">2.512643</span>
<span class="mi">1</span>   <span class="mf">3.4638448</span>    <span class="o">-</span><span class="mf">0.042223275</span>
<span class="mi">2</span>    <span class="mf">4.0809603</span>   <span class="mf">3.2164836</span>

<span class="n">Input</span> <span class="n">matrix</span><span class="p">:</span>           <span class="mi">0</span>         <span class="mi">1</span>         <span class="mi">2</span>
<span class="mi">0</span>       <span class="mf">1.0</span>  <span class="mf">4.000001</span>  <span class="mf">4.000001</span>
<span class="mi">1</span> <span class="mf">2.0000005</span> <span class="mf">2.0000005</span> <span class="mf">2.0000007</span>
<span class="mi">2</span>  <span class="mf">5.000001</span> <span class="mf">0.9999999</span> <span class="mf">1.0000004</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  components_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The top K components (VT.T[:,:n_components]) in U, S, VT = svd(X)
                 </p>
                </dd>
                <dt>
                 <strong>
                  explained_variance_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  How much each component explains the variance in the data given by S**2
                 </p>
                </dd>
                <dt>
                 <strong>
                  explained_variance_ratio_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  How much in % the variance is explained given by S**2/sum(S**2)
                 </p>
                </dd>
                <dt>
                 <strong>
                  singular_values_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The top K singular values. Remember all singular values &gt;= 0
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.TruncatedSVD.fit" title="cuml.TruncatedSVD.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X[, y])
                 </p>
                </td>
                <td>
                 <p>
                  Fit LSI model on training cudf DataFrame X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.TruncatedSVD.fit_transform" title="cuml.TruncatedSVD.fit_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, y])
                 </p>
                </td>
                <td>
                 <p>
                  Fit LSI model to X and perform dimensionality reduction on X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.TruncatedSVD.get_param_names" title="cuml.TruncatedSVD.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.TruncatedSVD.inverse_transform" title="cuml.TruncatedSVD.inverse_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     inverse_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Transform X back to its original space.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.TruncatedSVD.transform" title="cuml.TruncatedSVD.transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     transform
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Perform dimensionality reduction on X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.TruncatedSVD.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.TruncatedSVD.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <blockquote>
                <div>
                 <p>
                  Fit LSI model on training cudf DataFrame X.
                 </p>
                </div>
               </blockquote>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl>
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <blockquote>
                    <div>
                     <p>
                      Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                     </p>
                    </div>
                   </blockquote>
                   <p>
                    y : ignored
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.TruncatedSVD.fit_transform">
               <code class="sig-name descname">
                fit_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.TruncatedSVD.fit_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit LSI model to X and perform dimensionality reduction on X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    ignored
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    cuDF DataFrame, shape (n_samples, n_components)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Reduced version of X as a dense cuDF DataFrame
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.TruncatedSVD.get_param_names">
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.TruncatedSVD.get_param_names" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.TruncatedSVD.inverse_transform">
               <code class="sig-name descname">
                inverse_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.TruncatedSVD.inverse_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Transform X back to its original space.
Returns a cuDF DataFrame X_original whose transform would be X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the inverse_transform method will automatically
convert the input to the data type which was used to train the
model. This will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_original
                   </strong>
                   <span class="classifier">
                    cuDF DataFrame, shape (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Note that this is always a dense cuDF DataFrame.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.TruncatedSVD.transform">
               <code class="sig-name descname">
                transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.TruncatedSVD.transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Perform dimensionality reduction on X.
Parameters
———-
X : array-like (device or host) shape = (n_samples, n_features)
               </p>
               <blockquote>
                <div>
                 <p>
                  Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                 </p>
                </div>
               </blockquote>
               <dl class="simple">
                <dt>
                 convert_dtype
                 <span class="classifier">
                  bool, optional (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  When set to True, the transform method will automatically
convert the input to the data type which was used to train the
model.
                 </p>
                </dd>
               </dl>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Returns
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    cuDF DataFrame, shape (n_samples, n_components)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Reduced version of X. This will always be a dense DataFrame.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="umap">
           <h3>
            UMAP
            <a class="headerlink" href="#umap" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.UMAP">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              UMAP
             </code>
             <a class="headerlink" href="#cuml.UMAP" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Uniform Manifold Approximation and Projection
Finds a low dimensional embedding of the data that approximates
an underlying manifold.
             </p>
             <p>
              Adapted from
              <a class="reference external" href="https://github.com/lmcinnes/umap/blob/master/umap/">
               https://github.com/lmcinnes/umap/blob/master/umap/
              </a>
              <a class="reference internal" href="#umap">
               umap
              </a>
              .py
             </p>
             <dl class="field-list">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl>
                <dt>
                 <strong>
                  n_neighbors: float (optional, default 15)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The size of local neighborhood (in terms of number of neighboring
sample points) used for manifold approximation. Larger values
result in more global views of the manifold, while smaller
values result in more local data being preserved. In general
values should be in the range 2 to 100.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_components: int (optional, default 2)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The dimension of the space to embed into. This defaults to 2 to
provide easy visualization, but can reasonably be set to any
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_epochs: int (optional, default None)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The number of training epochs to be used in optimizing the
low dimensional embedding. Larger values result in more accurate
embeddings. If None is specified a value will be selected based on
the size of the input dataset (200 for large datasets, 500 for small).
                 </p>
                </dd>
                <dt>
                 <strong>
                  learning_rate: float (optional, default 1.0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The initial learning rate for the embedding optimization.
                 </p>
                </dd>
                <dt>
                 <strong>
                  init: string (optional, default ‘spectral’)
                 </strong>
                </dt>
                <dd>
                 <dl class="simple">
                  <dt>
                   How to initialize the low dimensional embedding. Options are:
                  </dt>
                  <dd>
                   <ul class="simple">
                    <li>
                     <p>
                      ‘spectral’: use a spectral embedding of the fuzzy 1-skeleton
                     </p>
                    </li>
                    <li>
                     <p>
                      ‘random’: assign initial embedding positions at random.
                     </p>
                    </li>
                   </ul>
                  </dd>
                 </dl>
                </dd>
                <dt>
                 <strong>
                  min_dist: float (optional, default 0.1)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The effective minimum distance between embedded points. Smaller values
will result in a more clustered/clumped embedding where nearby points
on the manifold are drawn closer together, while larger values will
result on a more even dispersal of points. The value should be set
relative to the
                  <code class="docutils literal notranslate">
                   <span class="pre">
                    spread
                   </span>
                  </code>
                  value, which determines the scale at which
embedded points will be spread out.
                 </p>
                </dd>
                <dt>
                 <strong>
                  spread: float (optional, default 1.0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The effective scale of embedded points. In combination with
                  <code class="docutils literal notranslate">
                   <span class="pre">
                    min_dist
                   </span>
                  </code>
                  this determines how clustered/clumped the embedded
points are.
                 </p>
                </dd>
                <dt>
                 <strong>
                  set_op_mix_ratio: float (optional, default 1.0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Interpolate between (fuzzy) union and intersection as the set operation
used to combine local fuzzy simplicial sets to obtain a global fuzzy
simplicial sets. Both fuzzy set operations use the product t-norm.
The value of this parameter should be between 0.0 and 1.0; a value of
1.0 will use a pure fuzzy union, while 0.0 will use a pure fuzzy
intersection.
                 </p>
                </dd>
                <dt>
                 <strong>
                  local_connectivity: int (optional, default 1)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The local connectivity required – i.e. the number of nearest
neighbors that should be assumed to be connected at a local level.
The higher this value the more connected the manifold becomes
locally. In practice this should be not more than the local intrinsic
dimension of the manifold.
                 </p>
                </dd>
                <dt>
                 <strong>
                  repulsion_strength: float (optional, default 1.0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Weighting applied to negative samples in low dimensional embedding
optimization. Values higher than one will result in greater weight
being given to negative samples.
                 </p>
                </dd>
                <dt>
                 <strong>
                  negative_sample_rate: int (optional, default 5)
                 </strong>
                </dt>
                <dd>
                 <p>
                  The number of negative samples to select per positive sample
in the optimization process. Increasing this value will result
in greater repulsive force being applied, greater optimization
cost, but slightly more accuracy.
                 </p>
                </dd>
                <dt>
                 <strong>
                  transform_queue_size: float (optional, default 4.0)
                 </strong>
                </dt>
                <dd>
                 <p>
                  For transform operations (embedding new points using a trained
                  <a href="#id33">
                   <span class="problematic" id="id34">
                    model_
                   </span>
                  </a>
                  this will control how aggressively to search for nearest neighbors.
Larger values will result in slower performance but more accurate
nearest neighbor evaluation.
                 </p>
                </dd>
                <dt>
                 <strong>
                  a: float (optional, default None)
                 </strong>
                </dt>
                <dd>
                 <p>
                  More specific parameters controlling the embedding. If None these
values are set automatically as determined by
                  <code class="docutils literal notranslate">
                   <span class="pre">
                    min_dist
                   </span>
                  </code>
                  and
                  <code class="docutils literal notranslate">
                   <span class="pre">
                    spread
                   </span>
                  </code>
                  .
                 </p>
                </dd>
                <dt>
                 <strong>
                  b: float (optional, default None)
                 </strong>
                </dt>
                <dd>
                 <p>
                  More specific parameters controlling the embedding. If None these
values are set automatically as determined by
                  <code class="docutils literal notranslate">
                   <span class="pre">
                    min_dist
                   </span>
                  </code>
                  and
                  <code class="docutils literal notranslate">
                   <span class="pre">
                    spread
                   </span>
                  </code>
                  .
                 </p>
                </dd>
                <dt>
                 <strong>
                  hash_input: UMAP can hash the training input so that exact embeddings
                 </strong>
                </dt>
                <dd>
                 <p>
                  are returned when transform is called on the same data upon
which the model was trained. This enables consistent
behavior between calling model.fit_transform(X) and
calling model.fit(X).transform(X). Not that the CPU-based
UMAP reference implementation does this by default. This
feature is made optional in the GPU version due to the
significant overhead in copying memory to the host for
computing the hash. (default = False)
                 </p>
                </dd>
                <dt>
                 <strong>
                  random_state
                 </strong>
                 <span class="classifier">
                  int, RandomState instance or None, optional (default=None)
                 </span>
                </dt>
                <dd>
                 <p>
                  random_state is the seed used by the random number generator during
embedding initialization and during sampling used by the optimizer.
Note: Unfortunately, achieving a high amount of parallelism during
the optimization stage often comes at the expense of determinism,
since many floating-point additions are being made in parallel
without a deterministic ordering. This causes slightly different
results across training sessions, even when the same seed is used
for random number generation. Setting a random_state will enable
consistency of trained embeddings, allowing for reproducible results
to 3 digits of precision, but will do so at the expense of potentially
slower training and increased memory usage.
                 </p>
                </dd>
                <dt>
                 <strong>
                  callback: An instance of GraphBasedDimRedCallback class to intercept
                 </strong>
                </dt>
                <dd>
                 <p>
                  the internal state of embeddings while they are being trained.
Example of callback usage:
                 </p>
                 <blockquote>
                  <div>
                   <p>
                    from cuml.internals import GraphBasedDimRedCallback
class CustomCallback(GraphBasedDimRedCallback):
                   </p>
                   <blockquote>
                    <div>
                     <dl class="simple">
                      <dt>
                       def on_preprocess_end(self, embeddings):
                      </dt>
                      <dd>
                       <p>
                        print(embeddings.copy_to_host())
                       </p>
                      </dd>
                      <dt>
                       def on_epoch_end(self, embeddings):
                      </dt>
                      <dd>
                       <p>
                        print(embeddings.copy_to_host())
                       </p>
                      </dd>
                      <dt>
                       def on_train_end(self, embeddings):
                      </dt>
                      <dd>
                       <p>
                        print(embeddings.copy_to_host())
                       </p>
                      </dd>
                     </dl>
                    </div>
                   </blockquote>
                  </div>
                 </blockquote>
                </dd>
                <dt>
                 <strong>
                  verbose: bool (optional, default False)
                 </strong>
                </dt>
                <dd>
                 <p>
                  Controls verbosity of logging.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              This module is heavily based on Leland McInnes’ reference UMAP package.
However, there are a number of differences and features that are not yet
implemented in cuml.umap:
             </p>
             <blockquote>
              <div>
               <ul class="simple">
                <li>
                 <p>
                  Specifying the random seed
                 </p>
                </li>
                <li>
                 <p>
                  Using a non-Euclidean distance metric (support for a fixed set
of non-Euclidean metrics is planned for an upcoming release).
                 </p>
                </li>
                <li>
                 <p>
                  Using a pre-computed pairwise distance matrix (under consideration
for future releases)
                 </p>
                </li>
                <li>
                 <p>
                  Manual initialization of initial embedding positions
                 </p>
                </li>
               </ul>
              </div>
             </blockquote>
             <p>
              In addition to these missing features, you should expect to see
the final embeddings differing between cuml.umap and the reference
UMAP. In particular, the reference UMAP uses an approximate kNN
algorithm for large data sizes while cuml.umap always uses exact
kNN.
             </p>
             <p>
              Known issue: If a UMAP model has not yet been fit, it cannot be pickled.
However, after fitting, a UMAP mode.
             </p>
             <p class="rubric">
              References
             </p>
             <ul class="simple">
              <li>
               <p>
                Leland McInnes, John Healy, James Melville
UMAP: Uniform Manifold Approximation and Projection for Dimension
Reduction
                <a class="reference external" href="https://arxiv.org/abs/1802.03426">
                 https://arxiv.org/abs/1802.03426
                </a>
               </p>
              </li>
             </ul>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.UMAP.find_ab_params" title="cuml.UMAP.find_ab_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     find_ab_params
                    </span>
                   </code>
                  </a>
                  (spread, min_dist)
                 </p>
                </td>
                <td>
                 <p>
                  Function taken from UMAP-learn :
                  <a class="reference external" href="https://github.com/lmcinnes/umap">
                   https://github.com/lmcinnes/umap
                  </a>
                  Fit a, b params for the differentiable curve used in lower dimensional fuzzy simplicial complex construction.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.UMAP.fit" title="cuml.UMAP.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X[, y, convert_dtype, knn_graph])
                 </p>
                </td>
                <td>
                 <p>
                  Fit X into an embedded space.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.UMAP.fit_transform" title="cuml.UMAP.fit_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, y, convert_dtype, …])
                 </p>
                </td>
                <td>
                 <p>
                  Fit X into an embedded space and return that transformed output.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.UMAP.transform" title="cuml.UMAP.transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     transform
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype, knn_graph])
                 </p>
                </td>
                <td>
                 <p>
                  Transform X into the existing embedded space and return that transformed output.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.UMAP.find_ab_params">
               <code class="sig-name descname">
                find_ab_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                spread
               </em>
               ,
               <em class="sig-param">
                min_dist
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.UMAP.find_ab_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Function taken from UMAP-learn :
                <a class="reference external" href="https://github.com/lmcinnes/umap">
                 https://github.com/lmcinnes/umap
                </a>
                Fit a, b params for the differentiable curve used in lower
dimensional fuzzy simplicial complex construction. We want the
smooth curve (from a pre-defined family with simple gradient) that
best matches an offset exponential decay.
               </p>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.UMAP.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y=None
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                knn_graph=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.UMAP.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit X into an embedded space.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    X contains a sample per row.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    y contains a label per row.
Acceptable formats: cuDF Series, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    knn_graph
                   </strong>
                   <span class="classifier">
                    sparse array-like (device or host)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    shape=(n_samples, n_samples)
A sparse array containing the k-nearest neighbors of X,
where the columns are the nearest neighbor indices
for each row and the values are their distances.
It’s important that
                    <cite>
                     k&gt;=n_neighbors
                    </cite>
                    ,
so that UMAP can model the neighbors from this graph,
instead of building its own internally.
Users using the knn_graph parameter provide UMAP
with their own run of the KNN algorithm. This allows the user
to pick a custom distance function (sometimes useful
on certain datasets) whereas UMAP uses euclidean by default.
The custom distance function should match the metric used
to train UMAP embeedings. Storing and reusing a knn_graph
will also provide a speedup to the UMAP algorithm
when performing a grid search.
Acceptable formats: sparse SciPy ndarray, CuPy device ndarray,
CSR/COO preferred other formats will go through conversion to CSR
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.UMAP.fit_transform">
               <code class="sig-name descname">
                fit_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y=None
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                knn_graph=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.UMAP.fit_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit X into an embedded space and return that transformed
output.
               </p>
               <p>
                There is a subtle difference between calling fit_transform(X)
and calling fit().transform(). Calling fit_transform(X) will
train the embeddings on X and return the embeddings. Calling
fit(X).transform(X) will train the embeddings on X and then
run a second optimization
return the embedding after it is trained while calling
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    X contains a sample per row.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    knn_graph
                   </strong>
                   <span class="classifier">
                    sparse array-like (device or host)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    shape=(n_samples, n_samples)
A sparse array containing the k-nearest neighbors of X,
where the columns are the nearest neighbor indices
for each row and the values are their distances.
It’s important that
                    <cite>
                     k&gt;=n_neighbors
                    </cite>
                    ,
so that UMAP can model the neighbors from this graph,
instead of building its own internally.
Users using the knn_graph parameter provide UMAP
with their own run of the KNN algorithm. This allows the user
to pick a custom distance function (sometimes useful
on certain datasets) whereas UMAP uses euclidean by default.
The custom distance function should match the metric used
to train UMAP embeedings. Storing and reusing a knn_graph
will also provide a speedup to the UMAP algorithm
when performing a grid search.
Acceptable formats: sparse SciPy ndarray, CuPy device ndarray,
CSR/COO preferred other formats will go through conversion to CSR
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    array, shape (n_samples, n_components)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Embedding of the training data in low-dimensional space.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.UMAP.transform">
               <code class="sig-name descname">
                transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                knn_graph=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.UMAP.transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Transform X into the existing embedded space and return that
transformed output.
               </p>
               <p>
                Please refer to the reference UMAP implementation for information
on the differences between fit_transform() and running fit()
transform().
               </p>
               <p>
                Specifically, the transform() function is stochastic:
                <a class="reference external" href="https://github.com/lmcinnes/umap/issues/158">
                 https://github.com/lmcinnes/umap/issues/158
                </a>
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    New data to be transformed.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    knn_graph
                   </strong>
                   <span class="classifier">
                    sparse array-like (device or host)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    shape=(n_samples, n_samples)
A sparse array containing the k-nearest neighbors of X,
where the columns are the nearest neighbor indices
for each row and the values are their distances.
It’s important that
                    <cite>
                     k&gt;=n_neighbors
                    </cite>
                    ,
so that UMAP can model the neighbors from this graph,
instead of building its own internally.
Users using the knn_graph parameter provide UMAP
with their own run of the KNN algorithm. This allows the user
to pick a custom distance function (sometimes useful
on certain datasets) whereas UMAP uses euclidean by default.
The custom distance function should match the metric used
to train UMAP embeedings. Storing and reusing a knn_graph
will also provide a speedup to the UMAP algorithm
when performing a grid search.
Acceptable formats: sparse SciPy ndarray, CuPy device ndarray,
CSR/COO preferred other formats will go through conversion to CSR
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    array, shape (n_samples, n_components)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Embedding of the new data in low-dimensional space.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="random-projections">
           <h3>
            Random Projections
            <a class="headerlink" href="#random-projections" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.random_projection.GaussianRandomProjection">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.random_projection.
             </code>
             <code class="sig-name descname">
              GaussianRandomProjection
             </code>
             <a class="headerlink" href="#cuml.random_projection.GaussianRandomProjection" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Gaussian Random Projection method derivated from BaseRandomProjection
class.
             </p>
             <p>
              Random projection is a dimensionality reduction technique. Random
projection methods are powerful methods known for their simplicity,
computational efficiency and restricted model size.
This algorithm also has the advantage to preserve distances well between
any two samples and is thus suitable for methods having this requirement.
             </p>
             <p>
              The components of the random matrix are drawn from N(0, 1 / n_components).
             </p>
             <dl class="field-list">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_components
                 </strong>
                 <span class="classifier">
                  int (default = ‘auto’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Dimensionality of the target projection space. If set to ‘auto’,
the parameter is deducted thanks to Johnson–Lindenstrauss lemma.
The automatic deduction make use of the number of samples and
the eps parameter.
                 </p>
                 <p>
                  The Johnson–Lindenstrauss lemma can produce very conservative
n_components parameter as it makes no assumption on dataset structure.
                 </p>
                </dd>
                <dt>
                 <strong>
                  eps
                 </strong>
                 <span class="classifier">
                  float (default = 0.1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Error tolerance during projection. Used by Johnson–Lindenstrauss
automatic deduction when n_components is set to ‘auto’.
                 </p>
                </dd>
                <dt>
                 <strong>
                  random_state
                 </strong>
                 <span class="classifier">
                  int (default = None)
                 </span>
                </dt>
                <dd>
                 <p>
                  Seed used to initilize random generator
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              Inspired by Scikit-learn’s implementation :
              <a class="reference external" href="https://scikit-learn.org/stable/modules/random_projection.html">
               https://scikit-learn.org/stable/modules/random_projection.html
              </a>
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  gaussian_method
                 </strong>
                 <span class="classifier">
                  boolean
                 </span>
                </dt>
                <dd>
                 <p>
                  To be passed to base class in order to determine
random matrix generation method
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.random_projection.SparseRandomProjection">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.random_projection.
             </code>
             <code class="sig-name descname">
              SparseRandomProjection
             </code>
             <a class="headerlink" href="#cuml.random_projection.SparseRandomProjection" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Sparse Random Projection method derivated from BaseRandomProjection class.
             </p>
             <p>
              Random projection is a dimensionality reduction technique. Random
projection methods are powerful methods known for their simplicity,
computational efficiency and restricted model size.
This algorithm also has the advantage to preserve distances well between
any two samples and is thus suitable for methods having this requirement.
             </p>
             <p>
              Sparse random matrix is an alternative to dense random projection matrix
(e.g. Gaussian) that guarantees similar embedding quality while being much
more memory efficient and allowing faster computation of the projected data
(with sparse enough matrices).
If we note ‘s = 1 / density’ the components of the random matrix are
drawn from:
             </p>
             <blockquote>
              <div>
               <ul class="simple">
                <li>
                 <p>
                  -sqrt(s) / sqrt(n_components)   with probability 1 / 2s
                 </p>
                </li>
                <li>
                 <p>
                  0                              with probability 1 - 1 / s
                 </p>
                </li>
                <li>
                 <p>
                  +sqrt(s) / sqrt(n_components)   with probability 1 / 2s
                 </p>
                </li>
               </ul>
              </div>
             </blockquote>
             <dl class="field-list">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_components
                 </strong>
                 <span class="classifier">
                  int (default = ‘auto’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Dimensionality of the target projection space. If set to ‘auto’,
the parameter is deducted thanks to Johnson–Lindenstrauss lemma.
The automatic deduction make use of the number of samples and
the eps parameter.
                 </p>
                 <p>
                  The Johnson–Lindenstrauss lemma can produce very conservative
n_components parameter as it makes no assumption on dataset structure.
                 </p>
                </dd>
                <dt>
                 <strong>
                  density
                 </strong>
                 <span class="classifier">
                  float in range (0, 1] (default = ‘auto’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Ratio of non-zero component in the random projection matrix.
                 </p>
                 <p>
                  If density = ‘auto’, the value is set to the minimum density
as recommended by Ping Li et al.: 1 / sqrt(n_features).
                 </p>
                </dd>
                <dt>
                 <strong>
                  eps
                 </strong>
                 <span class="classifier">
                  float (default = 0.1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Error tolerance during projection. Used by Johnson–Lindenstrauss
automatic deduction when n_components is set to ‘auto’.
                 </p>
                </dd>
                <dt>
                 <strong>
                  dense_output
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If set to True transformed matrix will be dense otherwise sparse.
                 </p>
                </dd>
                <dt>
                 <strong>
                  random_state
                 </strong>
                 <span class="classifier">
                  int (default = None)
                 </span>
                </dt>
                <dd>
                 <p>
                  Seed used to initilize random generator
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              Inspired by Scikit-learn’s implementation :
              <a class="reference external" href="https://scikit-learn.org/stable/modules/random_projection.html">
               https://scikit-learn.org/stable/modules/random_projection.html
              </a>
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  gaussian_method
                 </strong>
                 <span class="classifier">
                  boolean
                 </span>
                </dt>
                <dd>
                 <p>
                  To be passed to base class in order to determine
random matrix generation method
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
           <dl class="method">
            <dt id="cuml.random_projection.johnson_lindenstrauss_min_dim">
             <code class="sig-prename descclassname">
              random_projection.
             </code>
             <code class="sig-name descname">
              johnson_lindenstrauss_min_dim
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              n_samples
             </em>
             ,
             <em class="sig-param">
              eps=0.1
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.random_projection.johnson_lindenstrauss_min_dim" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              In mathematics, the Johnson–Lindenstrauss lemma states that
high-dimensional data can be embedded into lower dimension while preserving
the distances.
             </p>
             <p>
              With p the random projection :
(1 - eps) ||u - v||^2 &lt; ||p(u) - p(v)||^2 &lt; (1 + eps) ||u - v||^2
             </p>
             <p>
              This function finds the minimum number of components to guarantee that
the embedding is inside the eps error tolerance.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_samples
                 </strong>
                 <span class="classifier">
                  int
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of samples.
                 </p>
                </dd>
                <dt>
                 <strong>
                  eps
                 </strong>
                 <span class="classifier">
                  float in (0,1) (default = 0.1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Maximum distortion rate as defined by the Johnson-Lindenstrauss lemma.
                 </p>
                </dd>
               </dl>
              </dd>
              <dt class="field-even">
               Returns
              </dt>
              <dd class="field-even">
               <dl class="simple">
                <dt>
                 <strong>
                  n_components
                 </strong>
                 <span class="classifier">
                  int
                 </span>
                </dt>
                <dd>
                 <p>
                  The minimal number of components to guarantee with good probability
an eps-embedding with n_samples.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="tsne">
           <h3>
            TSNE
            <a class="headerlink" href="#tsne" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.TSNE">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              TSNE
             </code>
             <a class="headerlink" href="#cuml.TSNE" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              TSNE (T-Distributed Stochastic Neighbor Embedding) is an extremely
powerful dimensionality reduction technique that aims to maintain
local distances between data points. It is extremely robust to whatever
dataset you give it, and is used in many areas including cancer research,
music analysis and neural network weight visualizations.
             </p>
             <p>
              Currently, cuML’s TSNE supports the fast Barnes Hut O(NlogN) TSNE
approximation (derived from CannyLabs’ BH open source CUDA code). This
allows TSNE to produce extremely fast embeddings when n_components = 2.
cuML defaults to this algorithm. A slower but more accurate Exact
algorithm is also provided.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_components
                 </strong>
                 <span class="classifier">
                  int (default 2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The output dimensionality size. Currently only size=2 is tested, but
the ‘exact’ algorithm will support greater dimensionality in future.
                 </p>
                </dd>
                <dt>
                 <strong>
                  perplexity
                 </strong>
                 <span class="classifier">
                  float (default 30.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  Larger datasets require a larger value. Consider choosing different
perplexity values from 5 to 50 and see the output differences.
                 </p>
                </dd>
                <dt>
                 <strong>
                  early_exaggeration
                 </strong>
                 <span class="classifier">
                  float (default 12.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  Controls the space between clusters. Not critical to tune this.
                 </p>
                </dd>
                <dt>
                 <strong>
                  learning_rate
                 </strong>
                 <span class="classifier">
                  float (default 200.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  The learning rate usually between (10, 1000). If this is too high,
TSNE could look like a cloud / ball of points.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_iter
                 </strong>
                 <span class="classifier">
                  int (default 1000)
                 </span>
                </dt>
                <dd>
                 <p>
                  The more epochs, the more stable/accurate the final embedding.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_iter_without_progress
                 </strong>
                 <span class="classifier">
                  int (default 300)
                 </span>
                </dt>
                <dd>
                 <p>
                  When the KL Divergence becomes too small after some iterations,
terminate TSNE early.
                 </p>
                </dd>
                <dt>
                 <strong>
                  min_grad_norm
                 </strong>
                 <span class="classifier">
                  float (default 1e-07)
                 </span>
                </dt>
                <dd>
                 <p>
                  The minimum gradient norm for when TSNE will terminate early.
                 </p>
                </dd>
                <dt>
                 <strong>
                  metric
                 </strong>
                 <span class="classifier">
                  str ‘euclidean’ only (default ‘euclidean’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Currently only supports euclidean distance. Will support cosine in
a future release.
                 </p>
                </dd>
                <dt>
                 <strong>
                  init
                 </strong>
                 <span class="classifier">
                  str ‘random’ (default ‘random’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Currently supports random intialization.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  int (default 0)
                 </span>
                </dt>
                <dd>
                 <p>
                  Level of verbosity. If &gt; 0, prints all help messages and warnings.
Most messages will be printed inside the Python Console.
                 </p>
                </dd>
                <dt>
                 <strong>
                  random_state
                 </strong>
                 <span class="classifier">
                  int (default None)
                 </span>
                </dt>
                <dd>
                 <p>
                  Setting this can allow future runs of TSNE to look mostly the same.
It is known that TSNE tends to have vastly different outputs on
many runs. Try using PCA intialization (upcoming with change #1098)
to possibly counteract this problem.
It is known that small perturbations can directly
change the result of the embedding for parallel TSNE implementations.
                 </p>
                </dd>
                <dt>
                 <strong>
                  method
                 </strong>
                 <span class="classifier">
                  str ‘barnes_hut’ or ‘exact’ (default ‘barnes_hut’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Options are either barnes_hut or exact. It is recommended that you use
the barnes hut approximation for superior O(nlogn) complexity.
                 </p>
                </dd>
                <dt>
                 <strong>
                  angle
                 </strong>
                 <span class="classifier">
                  float (default 0.5)
                 </span>
                </dt>
                <dd>
                 <p>
                  Tradeoff between accuracy and speed. Choose between (0,2 0.8) where
closer to one indicates full accuracy but slower speeds.
                 </p>
                </dd>
                <dt>
                 <strong>
                  learning_rate_method
                 </strong>
                 <span class="classifier">
                  str ‘adaptive’, ‘none’ or None (default ‘adaptive’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Either adaptive or None. Uses a special adpative method that tunes
the learning rate, early exaggeration and perplexity automatically
based on input size.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_neighbors
                 </strong>
                 <span class="classifier">
                  int (default 90)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of datapoints you want to use in the
attractive forces. Smaller values are better for preserving
local structure, whilst larger values can improve global structure
preservation. Default is 3 * 30 (perplexity)
                 </p>
                </dd>
                <dt>
                 <strong>
                  perplexity_max_iter
                 </strong>
                 <span class="classifier">
                  int (default 100)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of epochs the best gaussian bands are found for.
                 </p>
                </dd>
                <dt>
                 <strong>
                  exaggeration_iter
                 </strong>
                 <span class="classifier">
                  int (default 250)
                 </span>
                </dt>
                <dd>
                 <p>
                  To promote the growth of clusters, set this higher.
                 </p>
                </dd>
                <dt>
                 <strong>
                  pre_momentum
                 </strong>
                 <span class="classifier">
                  float (default 0.5)
                 </span>
                </dt>
                <dd>
                 <p>
                  During the exaggeration iteration, more forcefully apply gradients.
                 </p>
                </dd>
                <dt>
                 <strong>
                  post_momentum
                 </strong>
                 <span class="classifier">
                  float (default 0.8)
                 </span>
                </dt>
                <dd>
                 <p>
                  During the late phases, less forcefully apply gradients.
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  (cuML Handle, default None)
                 </span>
                </dt>
                <dd>
                 <p>
                  You can pass in a past handle that was initialized, or we will create
one for you anew!
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              References
             </p>
             <ul class="simple">
              <li>
               <p>
                van der Maaten, L.J.P.
t-Distributed Stochastic Neighbor Embedding
                <a class="reference external" href="https://lvdmaaten.github.io/tsne/">
                 https://lvdmaaten.github.io/tsne/
                </a>
               </p>
              </li>
              <li>
               <p>
                van der Maaten, L.J.P.; Hinton, G.E.
Visualizing High-Dimensional Data
Using t-SNE. Journal of Machine Learning Research 9:2579-2605, 2008.
               </p>
              </li>
              <li>
               <p>
                George C. Linderman, Manas Rachh, Jeremy G. Hoskins,
Stefan Steinerberger, Yuval Kluger Efficient Algorithms for
t-distributed Stochastic Neighborhood Embedding
               </p>
              </li>
             </ul>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <a class="reference internal" href="#cuml.TSNE.Y" title="cuml.TSNE.Y">
                  <code class="xref py py-obj docutils literal notranslate">
                   <span class="pre">
                    Y
                   </span>
                  </code>
                 </a>
                </dt>
                <dd>
                 <p>
                  TSNE.Y(self)
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.TSNE.fit" title="cuml.TSNE.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit X into an embedded space.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.TSNE.fit_transform" title="cuml.TSNE.fit_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit X into an embedded space and return that transformed output.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.TSNE.Y">
               <em class="property">
                property
               </em>
               <code class="sig-name descname">
                Y
               </code>
               <a class="headerlink" href="#cuml.TSNE.Y" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.TSNE.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.TSNE.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit X into an embedded space.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    X contains a sample per row.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.TSNE.fit_transform">
               <code class="sig-name descname">
                fit_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.TSNE.fit_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit X into an embedded space and return that transformed output.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    X contains a sample per row.
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit_transform method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    array, shape (n_samples, n_components)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Embedding of the training data in low-dimensional space.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
         </div>
         <div class="section" id="neighbors">
          <h2>
           Neighbors
           <a class="headerlink" href="#neighbors" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="nearest-neighbors">
           <h3>
            Nearest Neighbors
            <a class="headerlink" href="#nearest-neighbors" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.neighbors.NearestNeighbors">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.neighbors.
             </code>
             <code class="sig-name descname">
              NearestNeighbors
             </code>
             <a class="headerlink" href="#cuml.neighbors.NearestNeighbors" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              NearestNeighbors is an queries neighborhoods from a given set of
datapoints. Currently, cuML supports k-NN queries, which define
the neighborhood as the closest
              <cite>
               k
              </cite>
              neighbors to each query point.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_neighbors
                 </strong>
                 <span class="classifier">
                  int (default=5)
                 </span>
                </dt>
                <dd>
                 <p>
                  Default number of neighbors to query
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  boolean (default=False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print verbose logs
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cumlHandle
                 </span>
                </dt>
                <dd>
                 <p>
                  The cumlHandle resources to use
                 </p>
                </dd>
                <dt>
                 <strong>
                  algorithm
                 </strong>
                 <span class="classifier">
                  string (default=’brute’)
                 </span>
                </dt>
                <dd>
                 <p>
                  The query algorithm to use. Currently, only ‘brute’ is supported.
                 </p>
                </dd>
                <dt>
                 <strong>
                  metric
                 </strong>
                 <span class="classifier">
                  string (default=’euclidean’).
                 </span>
                </dt>
                <dd>
                 <p>
                  Distance metric to use.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For an additional example see
              <a class="reference external" href="https://github.com/rapidsai/notebook/blob/master/python/notebooks/nearest_neighbors_demo.ipynb">
               the NearestNeighbors notebook
              </a>
              .
             </p>
             <p>
              For additional docs, see
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestNeighbors.html#sklearn.neighbors.NearestNeighbors">
               scikit-learn’s NearestNeighbors
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">from</span> <span class="nn">cuml.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
<span class="kn">from</span> <span class="nn">cuml.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>

<span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                  <span class="n">n_features</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># build a cudf Dataframe</span>
<span class="n">X_cudf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_gpu_matrix</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># fit model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># get 3 nearest neighbors</span>
<span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_cudf</span><span class="p">)</span>

<span class="c1"># print results</span>
<span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-default notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">indices</span><span class="p">:</span>

     <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>
<span class="mi">0</span>    <span class="mi">0</span>  <span class="mi">14</span>  <span class="mi">21</span>
<span class="mi">1</span>    <span class="mi">1</span>  <span class="mi">19</span>   <span class="mi">8</span>
<span class="mi">2</span>    <span class="mi">2</span>   <span class="mi">9</span>  <span class="mi">23</span>
<span class="mi">3</span>    <span class="mi">3</span>  <span class="mi">14</span>  <span class="mi">21</span>
<span class="o">...</span>

<span class="mi">22</span>  <span class="mi">22</span>  <span class="mi">18</span>  <span class="mi">11</span>
<span class="mi">23</span>  <span class="mi">23</span>  <span class="mi">16</span>   <span class="mi">9</span>
<span class="mi">24</span>  <span class="mi">24</span>  <span class="mi">17</span>  <span class="mi">10</span>

<span class="n">distances</span><span class="p">:</span>

      <span class="mi">0</span>         <span class="mi">1</span>         <span class="mi">2</span>
<span class="mi">0</span>   <span class="mf">0.0</span>  <span class="mf">4.883116</span>  <span class="mf">5.570006</span>
<span class="mi">1</span>   <span class="mf">0.0</span>  <span class="mf">3.047896</span>  <span class="mf">4.105496</span>
<span class="mi">2</span>   <span class="mf">0.0</span>  <span class="mf">3.558557</span>  <span class="mf">3.567704</span>
<span class="mi">3</span>   <span class="mf">0.0</span>  <span class="mf">3.806127</span>  <span class="mf">3.880100</span>
<span class="o">...</span>

<span class="mi">22</span>  <span class="mf">0.0</span>  <span class="mf">4.210738</span>  <span class="mf">4.227068</span>
<span class="mi">23</span>  <span class="mf">0.0</span>  <span class="mf">3.357889</span>  <span class="mf">3.404269</span>
<span class="mi">24</span>  <span class="mf">0.0</span>  <span class="mf">3.428183</span>  <span class="mf">3.818043</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.NearestNeighbors.fit" title="cuml.neighbors.NearestNeighbors.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit GPU index for performing nearest neighbor queries.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.NearestNeighbors.kneighbors" title="cuml.neighbors.NearestNeighbors.kneighbors">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     kneighbors
                    </span>
                   </code>
                  </a>
                  (self[, X, n_neighbors, …])
                 </p>
                </td>
                <td>
                 <p>
                  Query the GPU index for the k nearest neighbors of column vectors in X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.neighbors.NearestNeighbors.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.NearestNeighbors.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit GPU index for performing nearest neighbor queries.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.neighbors.NearestNeighbors.kneighbors">
               <code class="sig-name descname">
                kneighbors
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X=None
               </em>
               ,
               <em class="sig-param">
                n_neighbors=None
               </em>
               ,
               <em class="sig-param">
                return_distance=True
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.neighbors.NearestNeighbors.kneighbors" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Query the GPU index for the k nearest neighbors of column vectors in X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_neighbors
                   </strong>
                   <span class="classifier">
                    Integer
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Number of neighbors to search. If not provided, the n_neighbors
from the model instance is used (default=10)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    return_distance: Boolean
                   </strong>
                  </dt>
                  <dd>
                   <p>
                    If False, distances will not be returned
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the kneighbors method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   distances: cuDF DataFrame or numpy ndarray
                  </dt>
                  <dd>
                   <p>
                    The distances of the k-nearest neighbors for each column vector
in X
                   </p>
                  </dd>
                  <dt>
                   indices: cuDF DataFrame of numpy ndarray
                  </dt>
                  <dd>
                   <p>
                    The indices of the k-nearest neighbors for each column vector in X
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="id10">
           <h3>
            Nearest Neighbors Classification
            <a class="headerlink" href="#id10" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt>
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.neighbors.
             </code>
             <code class="sig-name descname">
              KNeighborsClassifier
             </code>
            </dt>
            <dd>
             <p>
              K-Nearest Neighbors Classifier is an instance-based learning technique,
that keeps training samples around for prediction, rather than trying
to learn a generalizable set of model parameters.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_neighbors
                 </strong>
                 <span class="classifier">
                  int (default=5)
                 </span>
                </dt>
                <dd>
                 <p>
                  Default number of neighbors to query
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  boolean (default=False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print verbose logs
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cumlHandle
                 </span>
                </dt>
                <dd>
                 <p>
                  The cumlHandle resources to use
                 </p>
                </dd>
                <dt>
                 <strong>
                  algorithm
                 </strong>
                 <span class="classifier">
                  string (default=’brute’)
                 </span>
                </dt>
                <dd>
                 <p>
                  The query algorithm to use. Currently, only ‘brute’ is supported.
                 </p>
                </dd>
                <dt>
                 <strong>
                  metric
                 </strong>
                 <span class="classifier">
                  string (default=’euclidean’).
                 </span>
                </dt>
                <dd>
                 <p>
                  Distance metric to use.
                 </p>
                </dd>
                <dt>
                 <strong>
                  weights
                 </strong>
                 <span class="classifier">
                  string (default=’uniform’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Sample weights to use. Currently, only the uniform strategy is
supported.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For additional docs, see
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html">
               scikitlearn’s KNeighborsClassifier
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">from</span> <span class="nn">cuml.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                  <span class="n">n_features</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span>
  <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.80</span><span class="p">)</span>

<span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="n">knn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.fit" title="cuml.neighbors.KNeighborsClassifier.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit a GPU index for k-nearest neighbors classifier model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.get_param_names" title="cuml.neighbors.KNeighborsClassifier.get_param_names">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_param_names
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.predict" title="cuml.neighbors.KNeighborsClassifier.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Use the trained k-nearest neighbors classifier to predict the labels for X
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.predict_proba" title="cuml.neighbors.KNeighborsClassifier.predict_proba">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict_proba
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Use the trained k-nearest neighbors classifier to predict the label probabilities for X
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsClassifier.score" title="cuml.neighbors.KNeighborsClassifier.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Compute the accuracy score using the given labels and the trained k-nearest neighbors classifier to predict the classes for X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt>
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
              </dt>
              <dd>
               <p>
                Fit a GPU index for k-nearest neighbors classifier model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_outputs)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_outputs).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt>
               <code class="sig-name descname">
                get_param_names
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
              </dt>
              <dd>
              </dd>
             </dl>
             <dl class="attribute">
              <dt>
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
              </dt>
              <dd>
               <p>
                Use the trained k-nearest neighbors classifier to
predict the labels for X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt>
               <code class="sig-name descname">
                predict_proba
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
              </dt>
              <dd>
               <p>
                Use the trained k-nearest neighbors classifier to
predict the label probabilities for X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt>
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
              </dt>
              <dd>
               <p>
                Compute the accuracy score using the given labels and
the trained k-nearest neighbors classifier to predict
the classes for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="id12">
           <h3>
            Nearest Neighbors Regression
            <a class="headerlink" href="#id12" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt>
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.neighbors.
             </code>
             <code class="sig-name descname">
              KNeighborsRegressor
             </code>
            </dt>
            <dd>
             <p>
              K-Nearest Neighbors Regressor is an instance-based learning technique,
that keeps training samples around for prediction, rather than trying
to learn a generalizable set of model parameters.
             </p>
             <p>
              The K-Nearest Neighbors Regressor will compute the average of the
labels for the k closest neighbors and use it as the label.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_neighbors
                 </strong>
                 <span class="classifier">
                  int (default=5)
                 </span>
                </dt>
                <dd>
                 <p>
                  Default number of neighbors to query
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  boolean (default=False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print verbose logs
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cumlHandle
                 </span>
                </dt>
                <dd>
                 <p>
                  The cumlHandle resources to use
                 </p>
                </dd>
                <dt>
                 <strong>
                  algorithm
                 </strong>
                 <span class="classifier">
                  string (default=’brute’)
                 </span>
                </dt>
                <dd>
                 <p>
                  The query algorithm to use. Currently, only ‘brute’ is supported.
                 </p>
                </dd>
                <dt>
                 <strong>
                  metric
                 </strong>
                 <span class="classifier">
                  string (default=’euclidean’).
                 </span>
                </dt>
                <dd>
                 <p>
                  Distance metric to use.
                 </p>
                </dd>
                <dt>
                 <strong>
                  weights
                 </strong>
                 <span class="classifier">
                  string (default=’uniform’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Sample weights to use. Currently, only the uniform strategy is
supported.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              For additional docs, see
              <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html">
               scikitlearn’s KNeighborsClassifier
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">from</span> <span class="nn">cuml.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>

<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                  <span class="n">n_features</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span>
  <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.80</span><span class="p">)</span>

<span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="n">knn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">array</span><span class="p">([</span><span class="mf">3.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span>
       <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span>
       <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span> <span class="mf">3.</span>        <span class="p">,</span>
       <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span>
       <span class="mf">3.</span>        <span class="p">,</span> <span class="mf">3.</span>        <span class="p">,</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="mf">3.</span>        <span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span>
       <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.</span>        <span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span>
       <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">3.79999995</span><span class="p">,</span> <span class="mf">0.</span>        <span class="p">])</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsRegressor.fit" title="cuml.neighbors.KNeighborsRegressor.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit a GPU index for k-nearest neighbors regression model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsRegressor.predict" title="cuml.neighbors.KNeighborsRegressor.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Use the trained k-nearest neighbors regression model to predict the labels for X
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.neighbors.KNeighborsRegressor.score" title="cuml.neighbors.KNeighborsRegressor.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit a GPU index for k-nearest neighbors regression model.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt>
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
              </dt>
              <dd>
               <p>
                Fit a GPU index for k-nearest neighbors regression model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_outputs)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_outputs).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt>
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
              </dt>
              <dd>
               <p>
                Use the trained k-nearest neighbors regression model to
predict the labels for X
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt>
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               <span class="sig-paren">
                )
               </span>
              </dt>
              <dd>
               <p>
                Fit a GPU index for k-nearest neighbors regression model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    array-like (device or host) shape = (n_samples, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Acceptable formats: cuDF DataFrame, NumPy ndarray, Numba device
ndarray, cuda array interface compliant array like CuPy
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will automatically
convert the inputs to np.float32.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
         </div>
         <div class="section" id="time-series">
          <h2>
           Time Series
           <a class="headerlink" href="#time-series" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="holtwinters">
           <h3>
            HoltWinters
            <a class="headerlink" href="#holtwinters" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.ExponentialSmoothing">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.
             </code>
             <code class="sig-name descname">
              ExponentialSmoothing
             </code>
             <a class="headerlink" href="#cuml.ExponentialSmoothing" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Implements a HoltWinters time series analysis model which is used in
both forecasting future entries in a time series as well as in providing
exponential smoothing, where weights are assigned against historical
data with exponentially decreasing impact. This is done by analyzing
three components of the data: level, trend, and seasonality.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  endog
                 </strong>
                 <span class="classifier">
                  array-like (device or host)
                 </span>
                </dt>
                <dd>
                 <p>
                  Acceptable formats: cuDF DataFrame, cuDF Series,
NumPy ndarray, Numba device ndarray, cuda array interface
compliant array like CuPy.
Note: cuDF.DataFrame types assumes data is in columns,
while all other datatypes assume data is in rows.
The endogenous dataset to be operated on.
                 </p>
                </dd>
                <dt>
                 <strong>
                  seasonal
                 </strong>
                 <span class="classifier">
                  ‘additive’, ‘add’, ‘multiplicative’, ‘mul’ (default = ‘additive’)  # noqa
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether the seasonal trend should be calculated
additively or multiplicatively.
                 </p>
                </dd>
                <dt>
                 <strong>
                  seasonal_periods
                 </strong>
                 <span class="classifier">
                  int (default=2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The seasonality of the data (how often it
repeats). For monthly data this should be 12,
for weekly data, this should be 7.
                 </p>
                </dd>
                <dt>
                 <strong>
                  start_periods
                 </strong>
                 <span class="classifier">
                  int (default=2)
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of seasons to be used for seasonal seed values
                 </p>
                </dd>
                <dt>
                 <strong>
                  ts_num
                 </strong>
                 <span class="classifier">
                  int (default=1)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of different time series that were passed
in the endog param.
                 </p>
                </dd>
                <dt>
                 <strong>
                  eps
                 </strong>
                 <span class="classifier">
                  np.number &gt; 0 (default=2.24e-3)
                 </span>
                </dt>
                <dd>
                 <p>
                  The accuracy to which gradient descent should achieve.
Note that changing this value may affect the forecasted results.
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle (default=None)
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">from</span> <span class="nn">cuml</span> <span class="kn">import</span> <span class="n">ExponentialSmoothing</span>
<span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
                   <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>
                   <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span>
                   <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span>
                   <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span>
                   <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span>
                   <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">cu_hw</span> <span class="o">=</span> <span class="n">ExponentialSmoothing</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">seasonal_periods</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">cu_hw</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="n">cu_pred</span> <span class="o">=</span> <span class="n">cu_hw</span><span class="o">.</span><span class="n">forecast</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Forecasted points:'</span><span class="p">,</span> <span class="n">cu_pred</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Forecasted</span> <span class="n">points</span> <span class="p">:</span>
<span class="mi">0</span>    <span class="mf">4.000143766093652</span>
<span class="mi">1</span>    <span class="mf">5.000000163513641</span>
<span class="mi">2</span>    <span class="mf">6.000000000174092</span>
<span class="mi">3</span>    <span class="mf">7.000000000000178</span>
</pre>
              </div>
             </div>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ExponentialSmoothing.fit" title="cuml.ExponentialSmoothing.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Perform fitting on the given
                  <cite>
                   endog
                  </cite>
                  dataset.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ExponentialSmoothing.forecast" title="cuml.ExponentialSmoothing.forecast">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     forecast
                    </span>
                   </code>
                  </a>
                  (self[, h, index])
                 </p>
                </td>
                <td>
                 <p>
                  Forecasts future points based on the fitted model.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ExponentialSmoothing.get_level" title="cuml.ExponentialSmoothing.get_level">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_level
                    </span>
                   </code>
                  </a>
                  (self[, index])
                 </p>
                </td>
                <td>
                 <p>
                  Returns the level component of the model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ExponentialSmoothing.get_season" title="cuml.ExponentialSmoothing.get_season">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_season
                    </span>
                   </code>
                  </a>
                  (self[, index])
                 </p>
                </td>
                <td>
                 <p>
                  Returns the season component of the model.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ExponentialSmoothing.get_trend" title="cuml.ExponentialSmoothing.get_trend">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_trend
                    </span>
                   </code>
                  </a>
                  (self[, index])
                 </p>
                </td>
                <td>
                 <p>
                  Returns the trend component of the model.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.ExponentialSmoothing.score" title="cuml.ExponentialSmoothing.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self[, index])
                 </p>
                </td>
                <td>
                 <p>
                  Returns the score of the model.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="attribute">
              <dt id="cuml.ExponentialSmoothing.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ExponentialSmoothing.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Perform fitting on the given
                <cite>
                 endog
                </cite>
                dataset.
Calculates the level, trend, season, and SSE components.
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ExponentialSmoothing.forecast">
               <code class="sig-name descname">
                forecast
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                h=1
               </em>
               ,
               <em class="sig-param">
                index=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ExponentialSmoothing.forecast" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Forecasts future points based on the fitted model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    h
                   </strong>
                   <span class="classifier">
                    int (default=1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The number of points for each series to be forecasted.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    index
                   </strong>
                   <span class="classifier">
                    int (default=None)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The index of the time series from which you want
forecasted points. if None, then a cudf.DataFrame of
the forecasted points from all time series is returned.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    preds
                   </strong>
                   <span class="classifier">
                    cudf.DataFrame or cudf.Series
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Series of forecasted points if index is provided.
DataFrame of all forecasted points if index=None.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ExponentialSmoothing.get_level">
               <code class="sig-name descname">
                get_level
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                index=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ExponentialSmoothing.get_level" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the level component of the model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    index
                   </strong>
                   <span class="classifier">
                    int (default=None)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The index of the time series from which the level will be
returned. if None, then all level components are returned
in a cudf.Series.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    level
                   </strong>
                   <span class="classifier">
                    cudf.Series or cudf.DataFrame
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The level component of the fitted model
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ExponentialSmoothing.get_season">
               <code class="sig-name descname">
                get_season
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                index=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ExponentialSmoothing.get_season" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the season component of the model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    index
                   </strong>
                   <span class="classifier">
                    int (default=None)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The index of the time series from which the season will be
returned. if None, then all season components are returned
in a cudf.Series.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   season: cudf.Series or cudf.DataFrame
                  </dt>
                  <dd>
                   <p>
                    The season component of the fitted model
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ExponentialSmoothing.get_trend">
               <code class="sig-name descname">
                get_trend
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                index=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ExponentialSmoothing.get_trend" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the trend component of the model.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    index
                   </strong>
                   <span class="classifier">
                    int (default=None)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The index of the time series from which the trend will be
returned. if None, then all trend components are returned
in a cudf.Series.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    trend
                   </strong>
                   <span class="classifier">
                    cudf.Series or cudf.DataFrame
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The trend component of the fitted model.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.ExponentialSmoothing.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                index=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.ExponentialSmoothing.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the score of the model.
               </p>
               <dl class="simple">
                <dt>
                 <a href="#id14">
                  <span class="problematic" id="id15">
                   **
                  </span>
                 </a>
                 Note: Currently returns the SSE, rather than the gradient of the
                </dt>
                <dd>
                 <p>
                  LogLikelihood.
                  <a class="reference external" href="https://github.com/rapidsai/cuml/issues/876">
                   https://github.com/rapidsai/cuml/issues/876
                  </a>
                 </p>
                </dd>
               </dl>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    index
                   </strong>
                   <span class="classifier">
                    int (default=None)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The index of the time series from which the SSE will be
returned. if None, then all SSEs are returned in a cudf
Series.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    score
                   </strong>
                   <span class="classifier">
                    np.float32, np.float64, or cudf.Series
                   </span>
                  </dt>
                  <dd>
                   <p>
                    The SSE of the fitted model.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="arima">
           <h3>
            ARIMA
            <a class="headerlink" href="#arima" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.tsa.ARIMA">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.tsa.
             </code>
             <code class="sig-name descname">
              ARIMA
             </code>
             <a class="headerlink" href="#cuml.tsa.ARIMA" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Implements a batched ARIMA model for in- and out-of-sample
time-series prediction, with support for seasonality (SARIMA)
             </p>
             <p>
              ARIMA stands for Auto-Regressive Integrated Moving Average.
See
              <a class="reference external" href="https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average">
               https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average
              </a>
             </p>
             <p>
              This class can fit an ARIMA(p,d,q) or ARIMA(p,d,q)(P,D,Q)_s model to a
batch of time series of the same length with no missing values.
The implementation is designed to give the best performance when using
large batches of time series.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  y
                 </strong>
                 <span class="classifier">
                  dataframe or array-like (device or host)
                 </span>
                </dt>
                <dd>
                 <p>
                  The time series data, assumed to have each time series in columns.
Acceptable formats: cuDF DataFrame, cuDF Series, NumPy ndarray,
Numba device ndarray, cuda array interface compliant array like CuPy.
                 </p>
                </dd>
                <dt>
                 <strong>
                  order
                 </strong>
                 <span class="classifier">
                  Tuple[int, int, int]
                 </span>
                </dt>
                <dd>
                 <p>
                  The ARIMA order (p, d, q) of the model
                 </p>
                </dd>
                <dt>
                 <strong>
                  seasonal_order: Tuple[int, int, int, int]
                 </strong>
                </dt>
                <dd>
                 <p>
                  The seasonal ARIMA order (P, D, Q, s) of the model
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  bool or int
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to include a constant trend mu in the model
Leave to None for automatic selection based on the model order
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle: cuml.Handle
                 </strong>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this instance
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              References
             </p>
             <p>
              This class is heavily influenced by the Python library
              <cite>
               statsmodels
              </cite>
              ,
particularly
              <cite>
               statsmodels.tsa.statespace.sarimax.SARIMAX
              </cite>
              .
See
              <a class="reference external" href="https://www.statsmodels.org/stable/statespace.html">
               https://www.statsmodels.org/stable/statespace.html
              </a>
             </p>
             <p>
              Additionally the following book is a useful reference:
“Time Series Analysis by State Space Methods”,
J. Durbin, S.J. Koopman, 2nd Edition (2012).
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">cuml.tsa</span> <span class="kn">import</span> <span class="n">arima</span>

<span class="c1"># Create seasonal data with a trend, a seasonal pattern and noise</span>
<span class="n">n_obs</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">)</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">],</span>
                    <span class="p">[</span><span class="o">-</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">]])</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_obs</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">noise</span>
     <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1"># Fit a seasonal ARIMA model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">arima</span><span class="o">.</span><span class="n">ARIMA</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

<span class="c1"># Forecast</span>
<span class="n">fc</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forecast</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="p">[[</span> <span class="mf">0.55204599</span> <span class="o">-</span><span class="mf">0.25681163</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.57430705</span> <span class="o">-</span><span class="mf">0.2262438</span> <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.48120315</span> <span class="o">-</span><span class="mf">0.20583011</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.535594</span>   <span class="o">-</span><span class="mf">0.24060046</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.57207541</span> <span class="o">-</span><span class="mf">0.26695497</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.59433647</span> <span class="o">-</span><span class="mf">0.23638713</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.50123257</span> <span class="o">-</span><span class="mf">0.21597344</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.55562342</span> <span class="o">-</span><span class="mf">0.25074379</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.59210483</span> <span class="o">-</span><span class="mf">0.27709831</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.61436589</span> <span class="o">-</span><span class="mf">0.24653047</span><span class="p">]]</span>
</pre>
              </div>
             </div>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  order
                 </strong>
                 <span class="classifier">
                  Tuple[int, int, int]
                 </span>
                </dt>
                <dd>
                 <p>
                  The ARIMA order (p, d, q) of the model
                 </p>
                </dd>
                <dt>
                 <strong>
                  seasonal_order: Tuple[int, int, int, int]
                 </strong>
                </dt>
                <dd>
                 <p>
                  The seasonal ARIMA order (P, D, Q, s) of the model
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept
                 </strong>
                 <span class="classifier">
                  bool or int
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether the model includes a constant trend mu
                 </p>
                </dd>
                <dt>
                 <strong>
                  d_y: device array
                 </strong>
                </dt>
                <dd>
                 <p>
                  Time series data on device
                 </p>
                </dd>
                <dt>
                 <strong>
                  num_samples: int
                 </strong>
                </dt>
                <dd>
                 <p>
                  Number of observations
                 </p>
                </dd>
                <dt>
                 <strong>
                  batch_size: int
                 </strong>
                </dt>
                <dd>
                 <p>
                  Number of time series in the batch
                 </p>
                </dd>
                <dt>
                 <strong>
                  dtype: numpy.dtype
                 </strong>
                </dt>
                <dd>
                 <p>
                  Floating-point type of the data and parameters
                 </p>
                </dd>
                <dt>
                 <strong>
                  niter: numpy.ndarray
                 </strong>
                </dt>
                <dd>
                 <p>
                  After fitting, contains the number of iterations before convergence
for each time series.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.tsa.ARIMA.fit" title="cuml.tsa.ARIMA.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, start_params, object], …[, maxiter])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the ARIMA model to each time series.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.tsa.ARIMA.forecast" title="cuml.tsa.ARIMA.forecast">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     forecast
                    </span>
                   </code>
                  </a>
                  (self, nsteps)
                 </p>
                </td>
                <td>
                 <p>
                  Forecast the given model
                  <cite>
                   nsteps
                  </cite>
                  into the future.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.tsa.ARIMA.get_params" title="cuml.tsa.ARIMA.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Get the parameters of the model
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.tsa.ARIMA.pack" title="cuml.tsa.ARIMA.pack">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     pack
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Pack parameters of the model into a linearized vector
                  <cite>
                   x
                  </cite>
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.tsa.ARIMA.predict" title="cuml.tsa.ARIMA.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self[, start, end])
                 </p>
                </td>
                <td>
                 <p>
                  Compute in-sample and/or out-of-sample prediction for each series
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.tsa.ARIMA.set_params" title="cuml.tsa.ARIMA.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, params, object])
                 </p>
                </td>
                <td>
                 <p>
                  Set the parameters of the model
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.tsa.ARIMA.unpack" title="cuml.tsa.ARIMA.unpack">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     unpack
                    </span>
                   </code>
                  </a>
                  (self, x, numpy.ndarray])
                 </p>
                </td>
                <td>
                 <p>
                  Unpack linearized parameter vector
                  <cite>
                   x
                  </cite>
                  into the separate parameter arrays of the model
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.tsa.ARIMA.aic">
               <em class="property">
                property
               </em>
               <code class="sig-name descname">
                aic
               </code>
               <a class="headerlink" href="#cuml.tsa.ARIMA.aic" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Akaike Information Criterion
               </p>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.tsa.ARIMA.aicc">
               <em class="property">
                property
               </em>
               <code class="sig-name descname">
                aicc
               </code>
               <a class="headerlink" href="#cuml.tsa.ARIMA.aicc" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Corrected Akaike Information Criterion
               </p>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.tsa.ARIMA.bic">
               <em class="property">
                property
               </em>
               <code class="sig-name descname">
                bic
               </code>
               <a class="headerlink" href="#cuml.tsa.ARIMA.bic" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Bayesian Information Criterion
               </p>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.tsa.ARIMA.complexity">
               <em class="property">
                property
               </em>
               <code class="sig-name descname">
                complexity
               </code>
               <a class="headerlink" href="#cuml.tsa.ARIMA.complexity" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Model complexity (number of parameters)
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.tsa.ARIMA.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self, start_params: Union[Mapping[str, object], NoneType] = None, opt_disp: 'int' = -1, h: 'float' = 1e-09, maxiter=1000
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.tsa.ARIMA.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the ARIMA model to each time series.
               </p>
               <dl class="field-list">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl>
                  <dt>
                   <strong>
                    start_params
                   </strong>
                   <span class="classifier">
                    Mapping[str, object] (optional)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    A mapping (e.g dictionary) of parameter names and associated arrays
The key names are in {“mu”, “ar”, “ma”, “sar”, “sma”, “sigma2”}
The shape of the arrays are (batch_size,) for mu parameters and
(n, batch_size) for any other type, where n is the corresponding
number of parameters of this type.
Pass None for automatic estimation (recommended)
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    opt_disp
                   </strong>
                   <span class="classifier">
                    int
                   </span>
                  </dt>
                  <dd>
                   <dl class="simple">
                    <dt>
                     Fit diagnostic level (for L-BFGS solver):
                    </dt>
                    <dd>
                     <ul class="simple">
                      <li>
                       <p>
                        <cite>
                         -1
                        </cite>
                        for no output (default)
                       </p>
                      </li>
                      <li>
                       <p>
                        <cite>
                         0&lt;n&lt;100
                        </cite>
                        for output every
                        <cite>
                         n
                        </cite>
                        steps
                       </p>
                      </li>
                      <li>
                       <p>
                        <cite>
                         n&gt;100
                        </cite>
                        for more detailed output
                       </p>
                      </li>
                     </ul>
                    </dd>
                   </dl>
                  </dd>
                  <dt>
                   <strong>
                    h
                   </strong>
                   <span class="classifier">
                    float
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Finite-differencing step size. The gradient is computed
using second-order differencing:
                   </p>
                   <blockquote>
                    <div>
                     <blockquote>
                      <div>
                       <p>
                        f(x+h) - f(x - h)
                       </p>
                      </div>
                     </blockquote>
                     <dl class="simple">
                      <dt>
                       g = —————– + O(h^2)
                      </dt>
                      <dd>
                       <p>
                        2 * h
                       </p>
                      </dd>
                     </dl>
                    </div>
                   </blockquote>
                  </dd>
                  <dt>
                   <strong>
                    maxiter
                   </strong>
                   <span class="classifier">
                    int
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Maximum number of iterations of L-BFGS-B
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.tsa.ARIMA.forecast">
               <code class="sig-name descname">
                forecast
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                nsteps: 'int'
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.tsa.ARIMA.forecast" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Forecast the given model
                <cite>
                 nsteps
                </cite>
                into the future.
               </p>
               <dl class="simple">
                <dt>
                 nsteps
                 <span class="classifier">
                  int
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of steps to forecast beyond end of the given series
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.tsa.ARIMA.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               → Dict[str, numpy.ndarray]
               <a class="headerlink" href="#cuml.tsa.ARIMA.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Get the parameters of the model
               </p>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.tsa.ARIMA.llf">
               <em class="property">
                property
               </em>
               <code class="sig-name descname">
                llf
               </code>
               <a class="headerlink" href="#cuml.tsa.ARIMA.llf" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Log-likelihood of a fit model. Shape: (batch_size,)
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.tsa.ARIMA.pack">
               <code class="sig-name descname">
                pack
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               → numpy.ndarray
               <a class="headerlink" href="#cuml.tsa.ARIMA.pack" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Pack parameters of the model into a linearized vector
                <cite>
                 x
                </cite>
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.tsa.ARIMA.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                start=0
               </em>
               ,
               <em class="sig-param">
                end=None
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.tsa.ARIMA.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Compute in-sample and/or out-of-sample prediction for each series
               </p>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.tsa.ARIMA.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self, params: Mapping[str, object]
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.tsa.ARIMA.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Set the parameters of the model
               </p>
               <dl class="simple">
                <dt>
                 params: Mapping[str, np.ndarray]
                </dt>
                <dd>
                 <p>
                  A mapping (e.g dictionary) of parameter names and associated arrays
The key names are in {“mu”, “ar”, “ma”, “sar”, “sma”, “sigma2”}
The shape of the arrays are (batch_size,) for mu parameters and
(n, batch_size) for any other type, where n is the corresponding
number of parameters of this type.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="attribute">
              <dt id="cuml.tsa.ARIMA.unpack">
               <code class="sig-name descname">
                unpack
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self, x: Union[list, numpy.ndarray]
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.tsa.ARIMA.unpack" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Unpack linearized parameter vector
                <cite>
                 x
                </cite>
                into the separate
parameter arrays of the model
               </p>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
         </div>
         <div class="section" id="multi-node-multi-gpu-algorithms">
          <h2>
           Multi-Node, Multi-GPU Algorithms
           <a class="headerlink" href="#multi-node-multi-gpu-algorithms" title="Permalink to this headline">
            ¶
           </a>
          </h2>
          <div class="section" id="id16">
           <h3>
            K-Means Clustering
            <a class="headerlink" href="#id16" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.dask.cluster.KMeans">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.cluster.
             </code>
             <code class="sig-name descname">
              KMeans
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              client=None
             </em>
             ,
             <em class="sig-param">
              verbose=False
             </em>
             ,
             <em class="sig-param">
              **kwargs
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.cluster.KMeans" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Multi-Node Multi-GPU implementation of KMeans.
             </p>
             <p>
              This version minimizes data transfer by sharing only
the centroids between workers in each iteration.
             </p>
             <p>
              Predictions are done embarrassingly parallel, using cuML’s
single-GPU version.
             </p>
             <p>
              For more information on this implementation, refer to the
documentation for single-GPU K-Means.
             </p>
             <dl class="field-list">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_clusters
                 </strong>
                 <span class="classifier">
                  int (default = 8)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of centroids or clusters you want.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_iter
                 </strong>
                 <span class="classifier">
                  int (default = 300)
                 </span>
                </dt>
                <dd>
                 <p>
                  The more iterations of EM, the more accurate, but slower.
                 </p>
                </dd>
                <dt>
                 <strong>
                  tol
                 </strong>
                 <span class="classifier">
                  float (default = 1e-4)
                 </span>
                </dt>
                <dd>
                 <p>
                  Stopping criterion when centroid means do not change much.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  boolean (default = 0)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, prints diagnositc information.
                 </p>
                </dd>
                <dt>
                 <strong>
                  random_state
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  If you want results to be the same when you restart Python,
select a state.
                 </p>
                </dd>
                <dt>
                 <strong>
                  init
                 </strong>
                 <span class="classifier">
                  {‘scalable-kmeans++’, ‘k-means||’ , ‘random’ or an ndarray}
                 </span>
                </dt>
                <dd>
                 <blockquote>
                  <div>
                   <p>
                    (default = ‘scalable-k-means++’)
                   </p>
                  </div>
                 </blockquote>
                 <p>
                  ‘scalable-k-means++’ or ‘k-means||’: Uses fast and stable scalable
kmeans++ intialization.
‘random’: Choose ‘n_cluster’ observations (rows) at random
from data for the initial centroids. If an ndarray is passed,
it should be of shape (n_clusters, n_features) and gives the
initial centers.
                 </p>
                </dd>
                <dt>
                 <strong>
                  oversampling_factor
                 </strong>
                 <span class="classifier">
                  int (default = 2) The amount of points to sample
                 </span>
                </dt>
                <dd>
                 <p>
                  in scalable k-means++ initialization for potential centroids.
Increasing this value can lead to better initial centroids at the
cost of memory. The total number of centroids sampled in scalable
k-means++ is oversampling_factor * n_clusters * 8.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_samples_per_batch
                 </strong>
                 <span class="classifier">
                  int (default = 32768) The number of data
                 </span>
                </dt>
                <dd>
                 <p>
                  samples to use for batches of the pairwise distance computation.
This computation is done throughout both fit predict. The default
should suit most cases. The total number of elements in the
batched pairwise distance computation is max_samples_per_batch
* n_clusters. It might become necessary to lower this number when
n_clusters becomes prohibitively large.
                 </p>
                </dd>
               </dl>
              </dd>
              <dt class="field-even">
               Attributes
              </dt>
              <dd class="field-even">
               <dl class="simple">
                <dt>
                 <strong>
                  cluster_centers_
                 </strong>
                 <span class="classifier">
                  cuDF DataFrame or CuPy ndarray
                 </span>
                </dt>
                <dd>
                 <p>
                  The coordinates of the final clusters. This represents of “mean” of
each data cluster.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.cluster.KMeans.fit" title="cuml.dask.cluster.KMeans.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Fit a multi-node multi-GPU KMeans model
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.cluster.KMeans.fit_predict" title="cuml.dask.cluster.KMeans.fit_predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_predict
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Compute cluster centers and predict cluster index for each sample.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.cluster.KMeans.fit_transform" title="cuml.dask.cluster.KMeans.fit_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Calls fit followed by transform using a distributed KMeans model
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.cluster.KMeans.predict" title="cuml.dask.cluster.KMeans.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Predict labels for the input
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.cluster.KMeans.score" title="cuml.dask.cluster.KMeans.score">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     score
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Computes the inertia score for the trained KMeans centroids.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.cluster.KMeans.transform" title="cuml.dask.cluster.KMeans.transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     transform
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Transforms the input into the learned centroid space
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <table class="docutils align-default">
              <colgroup>
               <col style="width: 66%"/>
               <col style="width: 34%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <strong>
                   get_param_names
                  </strong>
                 </p>
                </td>
                <td>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.dask.cluster.KMeans.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.cluster.KMeans.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit a multi-node multi-GPU KMeans model
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF DataFrame or CuPy backed Dask Array
                   </span>
                  </dt>
                  <dd>
                  </dd>
                  <dt>
                   <strong>
                    Training data to cluster.
                   </strong>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.cluster.KMeans.fit_predict">
               <code class="sig-name descname">
                fit_predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.cluster.KMeans.fit_predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Compute cluster centers and predict cluster index for each sample.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF DataFrame or CuPy backed Dask Array
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Data to predict
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   result: Dask cuDF DataFrame or CuPy backed Dask Array
                  </dt>
                  <dd>
                   <p>
                    Distributed object containing predictions
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.cluster.KMeans.fit_transform">
               <code class="sig-name descname">
                fit_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.cluster.KMeans.fit_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Calls fit followed by transform using a distributed KMeans model
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF DataFrame or CuPy backed Dask Array
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Data to predict
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    delayed
                   </strong>
                   <span class="classifier">
                    bool (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether to execute as a delayed task or eager.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   result: Dask cuDF DataFrame or CuPy backed Dask Array
                  </dt>
                  <dd>
                   <p>
                    Distributed object containing the transformed data
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.cluster.KMeans.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.cluster.KMeans.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predict labels for the input
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF DataFrame or CuPy backed Dask Array
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Data to predict
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    delayed
                   </strong>
                   <span class="classifier">
                    bool (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether to do a lazy prediction (and return Delayed objects) or an
eagerly executed one.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   result: Dask cuDF DataFrame or CuPy backed Dask Array
                  </dt>
                  <dd>
                   <p>
                    Distributed object containing predictions
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.cluster.KMeans.score">
               <code class="sig-name descname">
                score
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.cluster.KMeans.score" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Computes the inertia score for the trained KMeans centroids.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask_cudf.Dataframe
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dataframe to compute score
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   Inertial score
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.cluster.KMeans.transform">
               <code class="sig-name descname">
                transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.cluster.KMeans.transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Transforms the input into the learned centroid space
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF DataFrame or CuPy backed Dask Array
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Data to predict
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    delayed
                   </strong>
                   <span class="classifier">
                    bool (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether to execute as a delayed task or eager.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   result: Dask cuDF DataFrame or CuPy backed Dask Array
                  </dt>
                  <dd>
                   <p>
                    Distributed object containing the transformed data
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="id17">
           <h3>
            Nearest Neighbors
            <a class="headerlink" href="#id17" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.dask.neighbors.NearestNeighbors">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.neighbors.
             </code>
             <code class="sig-name descname">
              NearestNeighbors
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              client=None
             </em>
             ,
             <em class="sig-param">
              streams_per_handle=0
             </em>
             ,
             <em class="sig-param">
              verbose=False
             </em>
             ,
             <em class="sig-param">
              **kwargs
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.neighbors.NearestNeighbors" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Multi-node Multi-GPU NearestNeighbors Model.
             </p>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.neighbors.NearestNeighbors.fit" title="cuml.dask.neighbors.NearestNeighbors.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Fit a multi-node multi-GPU Nearest Neighbors index
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.neighbors.NearestNeighbors.get_neighbors" title="cuml.dask.neighbors.NearestNeighbors.get_neighbors">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_neighbors
                    </span>
                   </code>
                  </a>
                  (self, n_neighbors)
                 </p>
                </td>
                <td>
                 <p>
                  Returns the default n_neighbors, initialized from the constructor, if n_neighbors is None.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.neighbors.NearestNeighbors.kneighbors" title="cuml.dask.neighbors.NearestNeighbors.kneighbors">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     kneighbors
                    </span>
                   </code>
                  </a>
                  (self[, X, n_neighbors, …])
                 </p>
                </td>
                <td>
                 <p>
                  Query the distributed nearest neighbors index
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.dask.neighbors.NearestNeighbors.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.neighbors.NearestNeighbors.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit a multi-node multi-GPU Nearest Neighbors index
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask_cudf.Dataframe
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   self: NearestNeighbors model
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.neighbors.NearestNeighbors.get_neighbors">
               <code class="sig-name descname">
                get_neighbors
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                n_neighbors
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.neighbors.NearestNeighbors.get_neighbors" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the default n_neighbors, initialized from the constructor,
if n_neighbors is None.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    n_neighbors
                   </strong>
                   <span class="classifier">
                    int
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Number of neighbors
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   n_neighbors: int
                  </dt>
                  <dd>
                   <p>
                    Default n_neighbors if parameter n_neighbors is none
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.neighbors.NearestNeighbors.kneighbors">
               <code class="sig-name descname">
                kneighbors
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X=None
               </em>
               ,
               <em class="sig-param">
                n_neighbors=None
               </em>
               ,
               <em class="sig-param">
                return_distance=True
               </em>
               ,
               <em class="sig-param">
                _return_futures=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.neighbors.NearestNeighbors.kneighbors" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Query the distributed nearest neighbors index
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask_cudf.Dataframe
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Vectors to query. If not provided, neighbors of each indexed point
are returned.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    n_neighbors
                   </strong>
                   <span class="classifier">
                    int
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Number of neighbors to query for each row in X. If not provided,
the n_neighbors on the model are used.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    return_distance
                   </strong>
                   <span class="classifier">
                    boolean (default=True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    If false, only indices are returned
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    ret
                   </strong>
                   <span class="classifier">
                    tuple (dask_cudf.DataFrame, dask_cudf.DataFrame)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    First dask-cuDF DataFrame contains distances, second conains the
indices.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="id18">
           <h3>
            Principal Component Analysis
            <a class="headerlink" href="#id18" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.dask.decomposition.PCA">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.decomposition.
             </code>
             <code class="sig-name descname">
              PCA
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              client=None
             </em>
             ,
             <em class="sig-param">
              verbose=False
             </em>
             ,
             <em class="sig-param">
              **kwargs
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.decomposition.PCA" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              PCA (Principal Component Analysis) is a fundamental dimensionality
reduction technique used to combine features in X in linear combinations
such that each new component captures the most information or variance of
the data. N_components is usually small, say at 3, where it can be used for
data visualization, data compression and exploratory analysis.
             </p>
             <p>
              cuML’s multi-node multi-gpu (MNMG) PCA expects a dask cuDF input, and
provides a “Full” algorithm. It uses a full eigendecomposition
then selects the top K eigenvectors.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_components
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of top K singular vectors / values you want.
Must be &lt;= number(columns).
                 </p>
                </dd>
                <dt>
                 <strong>
                  svd_solver
                 </strong>
                 <span class="classifier">
                  ‘full’
                 </span>
                </dt>
                <dd>
                 <p>
                  Only Full algorithm is supported since it’s significantly faster on GPU
then the other solvers including randomized SVD.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  bool
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print debug spews
                 </p>
                </dd>
                <dt>
                 <strong>
                  whiten
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, de-correlates the components. This is done by dividing them by
the corresponding singular values then multiplying by sqrt(n_samples).
Whitening allows each component to have unit variance and removes
multi-collinearity. It might be beneficial for downstream
tasks like LinearRegression where correlated features cause problems.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Notes
             </p>
             <p>
              PCA considers linear combinations of features, specifically those that
maximise global variance structure. This means PCA is fantastic for global
structure analyses, but weak for local relationships. Consider UMAP or
T-SNE for a locally important embedding.
             </p>
             <p>
              <strong>
               Applications of PCA
              </strong>
             </p>
             <blockquote>
              <div>
               <p>
                PCA is used extensively in practice for data visualization and data
compression. It has been used to visualize extremely large word
embeddings like Word2Vec and GloVe in 2 or 3 dimensions, large
datasets of everyday objects and images, and used to distinguish
between cancerous cells from healthy cells.
               </p>
              </div>
             </blockquote>
             <p>
              For an additional example see
              <a class="reference external" href="https://github.com/rapidsai/notebooks/blob/master/cuml/pca_demo.ipynb">
               the PCA notebook
              </a>
              .
For additional docs, see
              <a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html">
               scikitlearn’s PCA
              </a>
              .
             </p>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">from</span> <span class="nn">dask_cuda</span> <span class="kn">import</span> <span class="n">LocalCUDACluster</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span><span class="p">,</span> <span class="n">wait</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">cuml.dask.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">cuml.dask.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>

<span class="n">cluster</span> <span class="o">=</span> <span class="n">LocalCUDACluster</span><span class="p">(</span><span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>

<span class="n">nrows</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">ncols</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">n_parts</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">X_cudf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_parts</span><span class="p">,</span>
                <span class="n">cluster_std</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">wait</span><span class="p">(</span><span class="n">X_cudf</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Input Matrix"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_cudf</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>

<span class="n">cumlModel</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">XT</span> <span class="o">=</span> <span class="n">cumlModel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_cudf</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Transformed Input Matrix"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">XT</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Input</span> <span class="n">Matrix</span><span class="p">:</span>
          <span class="mi">0</span>         <span class="mi">1</span>         <span class="mi">2</span>
          <span class="mi">0</span> <span class="o">-</span><span class="mf">6.520953</span>  <span class="mf">0.015584</span> <span class="o">-</span><span class="mf">8.828546</span>
          <span class="mi">1</span> <span class="o">-</span><span class="mf">6.507554</span>  <span class="mf">0.016524</span> <span class="o">-</span><span class="mf">8.836799</span>
          <span class="mi">2</span> <span class="o">-</span><span class="mf">6.518214</span>  <span class="mf">0.010457</span> <span class="o">-</span><span class="mf">8.821301</span>
          <span class="mi">0</span> <span class="o">-</span><span class="mf">6.520953</span>  <span class="mf">0.015584</span> <span class="o">-</span><span class="mf">8.828546</span>
          <span class="mi">1</span> <span class="o">-</span><span class="mf">6.507554</span>  <span class="mf">0.016524</span> <span class="o">-</span><span class="mf">8.836799</span>
          <span class="mi">2</span> <span class="o">-</span><span class="mf">6.518214</span>  <span class="mf">0.010457</span> <span class="o">-</span><span class="mf">8.821301</span>

<span class="n">Transformed</span> <span class="n">Input</span> <span class="n">Matrix</span><span class="p">:</span>
                    <span class="mi">0</span>
          <span class="mi">0</span> <span class="o">-</span><span class="mf">0.003271</span>
          <span class="mi">1</span>  <span class="mf">0.011454</span>
          <span class="mi">2</span> <span class="o">-</span><span class="mf">0.008182</span>
          <span class="mi">0</span> <span class="o">-</span><span class="mf">0.003271</span>
          <span class="mi">1</span>  <span class="mf">0.011454</span>
          <span class="mi">2</span> <span class="o">-</span><span class="mf">0.008182</span>
</pre>
              </div>
             </div>
             <dl class="simple">
              <dt>
               Note: Everytime this code is run, the output will be different because
              </dt>
              <dd>
               <p>
                “make_blobs” function generates random matrices.
               </p>
              </dd>
             </dl>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  components_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The top K components (VT.T[:,:n_components]) in U, S, VT = svd(X)
                 </p>
                </dd>
                <dt>
                 <strong>
                  explained_variance_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  How much each component explains the variance in the data given by S**2
                 </p>
                </dd>
                <dt>
                 <strong>
                  explained_variance_ratio_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  How much in % the variance is explained given by S**2/sum(S**2)
                 </p>
                </dd>
                <dt>
                 <strong>
                  singular_values_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The top K singular values. Remember all singular values &gt;= 0
                 </p>
                </dd>
                <dt>
                 <strong>
                  mean_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The column wise mean of X. Used to mean - center the data first.
                 </p>
                </dd>
                <dt>
                 <strong>
                  noise_variance_
                 </strong>
                 <span class="classifier">
                  float
                 </span>
                </dt>
                <dd>
                 <p>
                  From Bishop 1999’s Textbook. Used in later tasks like calculating the
estimated covariance of X.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.decomposition.PCA.fit" title="cuml.dask.decomposition.PCA.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X[, _transform])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.decomposition.PCA.fit_transform" title="cuml.dask.decomposition.PCA.fit_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_transform
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and apply the dimensionality reduction on X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.decomposition.PCA.inverse_transform" title="cuml.dask.decomposition.PCA.inverse_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     inverse_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Transform data back to its original space.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.decomposition.PCA.transform" title="cuml.dask.decomposition.PCA.transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     transform
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Apply dimensionality reduction to X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <table class="docutils align-default">
              <colgroup>
               <col style="width: 66%"/>
               <col style="width: 34%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <strong>
                   get_param_names
                  </strong>
                 </p>
                </td>
                <td>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.dask.decomposition.PCA.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                _transform=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.decomposition.PCA.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask cuDF input
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.decomposition.PCA.fit_transform">
               <code class="sig-name descname">
                fit_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.decomposition.PCA.fit_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and apply the dimensionality reduction on X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.decomposition.PCA.inverse_transform">
               <code class="sig-name descname">
                inverse_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.decomposition.PCA.inverse_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Transform data back to its original space.
               </p>
               <p>
                In other words, return an input X_original whose transform would be X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_original
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.decomposition.PCA.transform">
               <code class="sig-name descname">
                transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.decomposition.PCA.transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Apply dimensionality reduction to X.
               </p>
               <p>
                X is projected on the first principal components previously extracted
from a training set.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="id21">
           <h3>
            Random Forest
            <a class="headerlink" href="#id21" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.dask.ensemble.RandomForestClassifier">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.ensemble.
             </code>
             <code class="sig-name descname">
              RandomForestClassifier
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              n_estimators=10
             </em>
             ,
             <em class="sig-param">
              max_depth=-1
             </em>
             ,
             <em class="sig-param">
              max_features='auto'
             </em>
             ,
             <em class="sig-param">
              n_bins=8
             </em>
             ,
             <em class="sig-param">
              split_algo=1
             </em>
             ,
             <em class="sig-param">
              split_criterion=0
             </em>
             ,
             <em class="sig-param">
              min_rows_per_node=2
             </em>
             ,
             <em class="sig-param">
              bootstrap=True
             </em>
             ,
             <em class="sig-param">
              bootstrap_features=False
             </em>
             ,
             <em class="sig-param">
              type_model='classifier'
             </em>
             ,
             <em class="sig-param">
              verbose=False
             </em>
             ,
             <em class="sig-param">
              rows_sample=1.0
             </em>
             ,
             <em class="sig-param">
              max_leaves=-1
             </em>
             ,
             <em class="sig-param">
              n_streams=4
             </em>
             ,
             <em class="sig-param">
              quantile_per_tree=False
             </em>
             ,
             <em class="sig-param">
              dtype=None
             </em>
             ,
             <em class="sig-param">
              criterion=None
             </em>
             ,
             <em class="sig-param">
              min_samples_leaf=None
             </em>
             ,
             <em class="sig-param">
              min_weight_fraction_leaf=None
             </em>
             ,
             <em class="sig-param">
              max_leaf_nodes=None
             </em>
             ,
             <em class="sig-param">
              min_impurity_decrease=None
             </em>
             ,
             <em class="sig-param">
              min_impurity_split=None
             </em>
             ,
             <em class="sig-param">
              oob_score=None
             </em>
             ,
             <em class="sig-param">
              n_jobs=None
             </em>
             ,
             <em class="sig-param">
              random_state=None
             </em>
             ,
             <em class="sig-param">
              warm_start=None
             </em>
             ,
             <em class="sig-param">
              class_weight=None
             </em>
             ,
             <em class="sig-param">
              workers=None
             </em>
             ,
             <em class="sig-param">
              client=None
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.ensemble.RandomForestClassifier" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Experimental API implementing a multi-GPU Random Forest classifier
model which fits multiple decision tree classifiers in an
ensemble. This uses Dask to partition data over multiple GPUs
(possibly on different nodes).
             </p>
             <p>
              Currently, this API makes the following assumptions:
* The set of Dask workers used between instantiation, fit,
and predict are all consistent
* Training data comes in the form of cuDF dataframes,
distributed so that each worker has at least one partition.
             </p>
             <p>
              Future versions of the API will support more flexible data
distribution and additional input types.
             </p>
             <p>
              The distributed algorithm uses an embarrassingly-parallel
approach. For a forest with N trees being built on w workers, each
worker simply builds N/w trees on the data it has available
locally. In many cases, partitioning the data so that each worker
builds trees on a subset of the total dataset works well, but
it generally requires the data to be well-shuffled in advance.
Alternatively, callers can replicate all of the data across
workers so that rf.fit receives w partitions, each containing the
same data. This would produce results approximately identical to
single-GPU fitting.
             </p>
             <p>
              Please check the single-GPU implementation of Random Forest
classifier for more information about the underlying algorithm.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_estimators
                 </strong>
                 <span class="classifier">
                  int (default = 10)
                 </span>
                </dt>
                <dd>
                 <p>
                  total number of trees in the forest (not per-worker)
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_criterion
                 </strong>
                 <span class="classifier">
                  The criterion used to split nodes.
                 </span>
                </dt>
                <dd>
                 <p>
                  0 for GINI, 1 for ENTROPY, 4 for CRITERION_END.
2 and 3 not valid for classification
(default = 0)
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_algo
                 </strong>
                 <span class="classifier">
                  0 for HIST and 1 for GLOBAL_QUANTILE
                 </span>
                </dt>
                <dd>
                 <p>
                  (default = 1)
the algorithm to determine how nodes are split in the tree.
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_criterion
                 </strong>
                 <span class="classifier">
                  The criterion used to split nodes.
                 </span>
                </dt>
                <dd>
                 <p>
                  0 for GINI, 1 for ENTROPY, 4 for CRITERION_END.
2 and 3 not valid for classification
(default = 0)
                 </p>
                </dd>
                <dt>
                 <strong>
                  bootstrap
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  Control bootstrapping.
If set, each tree in the forest is built
on a bootstrapped sample with replacement.
If false, sampling without replacement is done.
                 </p>
                </dd>
                <dt>
                 <strong>
                  bootstrap_features
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Control bootstrapping for features.
If features are drawn with or without replacement
                 </p>
                </dd>
                <dt>
                 <strong>
                  rows_sample
                 </strong>
                 <span class="classifier">
                  float (default = 1.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  Ratio of dataset rows used while fitting each tree.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_depth
                 </strong>
                 <span class="classifier">
                  int (default = -1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Maximum tree depth. Unlimited (i.e, until leaves are pure), if -1.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_leaves
                 </strong>
                 <span class="classifier">
                  int (default = -1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Maximum leaf nodes per tree. Soft constraint. Unlimited, if -1.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_features
                 </strong>
                 <span class="classifier">
                  float (default = ‘auto’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Ratio of number of features (columns) to consider
per node split.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_bins
                 </strong>
                 <span class="classifier">
                  int (default = 8)
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of bins used by the split algorithm.
                 </p>
                </dd>
                <dt>
                 <strong>
                  min_rows_per_node
                 </strong>
                 <span class="classifier">
                  int (default = 2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The minimum number of samples (rows) needed to split a node.
                 </p>
                </dd>
                <dt>
                 <strong>
                  quantile_per_tree
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether quantile is computed for individual RF trees.
Only relevant for GLOBAL_QUANTILE split_algo.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_streams
                 </strong>
                 <span class="classifier">
                  int (default = 4 )
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of parallel streams used for forest building
                 </p>
                </dd>
                <dt>
                 <strong>
                  workers
                 </strong>
                 <span class="classifier">
                  optional, list of strings
                 </span>
                </dt>
                <dd>
                 <p>
                  Dask addresses of workers to use for computation.
If None, all available Dask workers will be used.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Examples
             </p>
             <p>
              For usage examples, please see the RAPIDS notebooks repository:
              <a class="reference external" href="https://github.com/rapidsai/notebooks/blob/branch-0.12/cuml/random_forest_mnmg_demo.ipynb">
               https://github.com/rapidsai/notebooks/blob/branch-0.12/cuml/random_forest_mnmg_demo.ipynb
              </a>
             </p>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestClassifier.fit" title="cuml.dask.ensemble.RandomForestClassifier.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y[, convert_dtype])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the input data with a Random Forest classifier
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestClassifier.get_params" title="cuml.dask.ensemble.RandomForestClassifier.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self[, deep])
                 </p>
                </td>
                <td>
                 <p>
                  Returns the value of all parameters required to configure this estimator as a dictionary.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestClassifier.predict" title="cuml.dask.ensemble.RandomForestClassifier.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, output_class, algo, …])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the labels for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestClassifier.print_summary" title="cuml.dask.ensemble.RandomForestClassifier.print_summary">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     print_summary
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Print the summary of the forest used to train and test the model.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestClassifier.set_params" title="cuml.dask.ensemble.RandomForestClassifier.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, \*\*params)
                 </p>
                </td>
                <td>
                 <p>
                  Sets the value of parameters required to configure this estimator, it functions similar to the sklearn set_params.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestClassifier.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               ,
               <em class="sig-param">
                convert_dtype=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestClassifier.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the input data with a Random Forest classifier
               </p>
               <p>
                IMPORTANT: X is expected to be partitioned with at least one partition
on each Dask worker being used by the forest (self.workers).
               </p>
               <p>
                If a worker has multiple data partitions, they will be concatenated
before fitting, which will lead to additional memory usage. To minimize
memory consumption, ensure that each worker has exactly one partition.
               </p>
               <p>
                When persisting data, you can use
cuml.dask.common.utils.persist_across_workers to simplify this:
               </p>
               <div class="highlight-default notranslate">
                <div class="highlight">
                 <pre><span></span><span class="n">X_dask_cudf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">from_cudf</span><span class="p">(</span><span class="n">X_cudf</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>
<span class="n">y_dask_cudf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">from_cudf</span><span class="p">(</span><span class="n">y_cudf</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>
<span class="n">X_dask_cudf</span><span class="p">,</span> <span class="n">y_dask_cudf</span> <span class="o">=</span> <span class="n">persist_across_workers</span><span class="p">(</span><span class="n">dask_client</span><span class="p">,</span>
                                                  <span class="p">[</span><span class="n">X_dask_cudf</span><span class="p">,</span>
                                                   <span class="n">y_dask_cudf</span><span class="p">])</span>
</pre>
                </div>
               </div>
               <dl>
                <dt>
                 (this is equivalent to calling
                 <cite>
                  persist
                 </cite>
                 with the data and workers)::
                </dt>
                <dd>
                 <dl>
                  <dt>
                   X_dask_cudf, y_dask_cudf = dask_client.persist([X_dask_cudf,
                  </dt>
                  <dd>
                   <blockquote>
                    <div>
                     <p>
                      y_dask_cudf],
                     </p>
                    </div>
                   </blockquote>
                   <p>
                    workers={
X_dask_cudf=workers,
y_dask_cudf=workers
})
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask_cudf.Dataframe
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Features of training examples.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    dask_cudf.Dataframe
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense  matrix (floats or doubles) of shape (n_samples, 1)
Labels of training examples.
                    <strong>
                     y must be partitioned the same way as X
                    </strong>
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = False)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the fit method will, when necessary, convert
y to be the same data type as X if they differ. This
will increase memory used for the method.
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestClassifier.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                deep=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestClassifier.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the value of all parameters
required to configure this estimator as a dictionary.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    deep
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestClassifier.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                output_class=True
               </em>
               ,
               <em class="sig-param">
                algo='auto'
               </em>
               ,
               <em class="sig-param">
                threshold=0.5
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                predict_model='GPU'
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format='auto'
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestClassifier.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the labels for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Distributed dense matrix (floats or doubles) of shape
(n_samples, n_features).
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    output_class
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
If true, return a 1 or 0 depending on whether the raw
prediction exceeds the threshold. If False, just return
the raw prediction.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     algo
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    threshold
                   </strong>
                   <span class="classifier">
                    float (default = 0.5)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Threshold used for classification. Optional and required only
while performing the predict operation on the GPU, that is for,
predict_model=’GPU’.
It is applied if output_class == True, else it is ignored
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    predict_model
                   </strong>
                   <span class="classifier">
                    String (default = ‘GPU’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    ‘GPU’ to predict using the GPU, ‘CPU’ otherwise. The GPU can only
be used if the model was trained on float32 data and
                    <cite>
                     X
                    </cite>
                    is float32
or convert_dtype is set to True.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    delayed
                   </strong>
                   <span class="classifier">
                    bool (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether to do a lazy prediction (and return Delayed objects) or an
eagerly executed one.  It is not required  while using
predict_model=’CPU’.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe or CuPy backed Dask Array (n_rows, 1)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestClassifier.print_summary">
               <code class="sig-name descname">
                print_summary
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestClassifier.print_summary" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Print the summary of the forest used to train and test the model.
               </p>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestClassifier.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                **params
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestClassifier.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Sets the value of parameters required to
configure this estimator, it functions similar to
the sklearn set_params.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    params
                   </strong>
                   <span class="classifier">
                    dict of new params
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.dask.ensemble.RandomForestRegressor">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.ensemble.
             </code>
             <code class="sig-name descname">
              RandomForestRegressor
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              n_estimators=10
             </em>
             ,
             <em class="sig-param">
              max_depth=-1
             </em>
             ,
             <em class="sig-param">
              max_features='auto'
             </em>
             ,
             <em class="sig-param">
              n_bins=8
             </em>
             ,
             <em class="sig-param">
              split_algo=1
             </em>
             ,
             <em class="sig-param">
              split_criterion=2
             </em>
             ,
             <em class="sig-param">
              bootstrap=True
             </em>
             ,
             <em class="sig-param">
              bootstrap_features=False
             </em>
             ,
             <em class="sig-param">
              verbose=False
             </em>
             ,
             <em class="sig-param">
              min_rows_per_node=2
             </em>
             ,
             <em class="sig-param">
              rows_sample=1.0
             </em>
             ,
             <em class="sig-param">
              max_leaves=-1
             </em>
             ,
             <em class="sig-param">
              n_streams=4
             </em>
             ,
             <em class="sig-param">
              accuracy_metric='mse'
             </em>
             ,
             <em class="sig-param">
              min_samples_leaf=None
             </em>
             ,
             <em class="sig-param">
              min_weight_fraction_leaf=None
             </em>
             ,
             <em class="sig-param">
              n_jobs=None
             </em>
             ,
             <em class="sig-param">
              max_leaf_nodes=None
             </em>
             ,
             <em class="sig-param">
              min_impurity_decrease=None
             </em>
             ,
             <em class="sig-param">
              min_impurity_split=None
             </em>
             ,
             <em class="sig-param">
              oob_score=None
             </em>
             ,
             <em class="sig-param">
              random_state=None
             </em>
             ,
             <em class="sig-param">
              warm_start=None
             </em>
             ,
             <em class="sig-param">
              class_weight=None
             </em>
             ,
             <em class="sig-param">
              quantile_per_tree=False
             </em>
             ,
             <em class="sig-param">
              criterion=None
             </em>
             ,
             <em class="sig-param">
              workers=None
             </em>
             ,
             <em class="sig-param">
              client=None
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.ensemble.RandomForestRegressor" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Experimental API implementing a multi-GPU Random Forest classifier
model which fits multiple decision tree classifiers in an
ensemble. This uses Dask to partition data over multiple GPUs
(possibly on different nodes).
             </p>
             <p>
              Currently, this API makes the following assumptions:
* The set of Dask workers used between instantiation, fit,
and predict are all consistent
* Training data is comes in the form of cuDF dataframes,
distributed so that each worker has at least one partition.
             </p>
             <p>
              Future versions of the API will support more flexible data
distribution and additional input types. User-facing APIs are
expected to change in upcoming versions.
             </p>
             <p>
              The distributed algorithm uses an embarrassingly-parallel
approach. For a forest with N trees being built on w workers, each
worker simply builds N/w trees on the data it has available
locally. In many cases, partitioning the data so that each worker
builds trees on a subset of the total dataset works well, but
it generally requires the data to be well-shuffled in advance.
Alternatively, callers can replicate all of the data across
workers so that rf.fit receives w partitions, each containing the
same data. This would produce results approximately identical to
single-GPU fitting.
             </p>
             <p>
              Please check the single-GPU implementation of Random Forest
classifier for more information about the underlying algorithm.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  n_estimators
                 </strong>
                 <span class="classifier">
                  int (default = 10)
                 </span>
                </dt>
                <dd>
                 <p>
                  total number of trees in the forest (not per-worker)
                 </p>
                </dd>
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class.
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_algo
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  0 for HIST, 1 for GLOBAL_QUANTILE
The type of algorithm to be used to create the trees.
                 </p>
                </dd>
                <dt>
                 <strong>
                  split_criterion
                 </strong>
                 <span class="classifier">
                  int (default = 2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The criterion used to split nodes.
0 for GINI, 1 for ENTROPY,
2 for MSE, 3 for MAE and 4 for CRITERION_END.
0 and 1 not valid for regression
                 </p>
                </dd>
                <dt>
                 <strong>
                  bootstrap
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  Control bootstrapping.
If set, each tree in the forest is built
on a bootstrapped sample with replacement.
If false, sampling without replacement is done.
                 </p>
                </dd>
                <dt>
                 <strong>
                  bootstrap_features
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  Control bootstrapping for features.
If features are drawn with or without replacement
                 </p>
                </dd>
                <dt>
                 <strong>
                  rows_sample
                 </strong>
                 <span class="classifier">
                  float (default = 1.0)
                 </span>
                </dt>
                <dd>
                 <p>
                  Ratio of dataset rows used while fitting each tree.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_depth
                 </strong>
                 <span class="classifier">
                  int (default = -1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Maximum tree depth. Unlimited (i.e, until leaves are pure), if -1.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_leaves
                 </strong>
                 <span class="classifier">
                  int (default = -1)
                 </span>
                </dt>
                <dd>
                 <p>
                  Maximum leaf nodes per tree. Soft constraint. Unlimited, if -1.
                 </p>
                </dd>
                <dt>
                 <strong>
                  max_features
                 </strong>
                 <span class="classifier">
                  int or float or string or None (default = ‘auto’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Ratio of number of features (columns) to consider
per node split.
If int then max_features/n_features.
If float then max_features is a fraction.
If ‘auto’ then max_features=n_features which is 1.0.
If ‘sqrt’ then max_features=1/sqrt(n_features).
If ‘log2’ then max_features=log2(n_features)/n_features.
If None, then max_features=n_features which is 1.0.
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_bins
                 </strong>
                 <span class="classifier">
                  int (default = 8)
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of bins used by the split algorithm.
                 </p>
                </dd>
                <dt>
                 <strong>
                  min_rows_per_node
                 </strong>
                 <span class="classifier">
                  int or float (default = 2)
                 </span>
                </dt>
                <dd>
                 <p>
                  The minimum number of samples (rows) needed to split a node.
If int then number of sample rows
If float the min_rows_per_sample*n_rows
                 </p>
                </dd>
                <dt>
                 <strong>
                  accuracy_metric
                 </strong>
                 <span class="classifier">
                  string (default = ‘mse’)
                 </span>
                </dt>
                <dd>
                 <p>
                  Decides the metric used to evaluate the performance of the model.
for median of abs error : ‘median_ae’
for mean of abs error : ‘mean_ae’
for mean square error’ : ‘mse’
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_streams
                 </strong>
                 <span class="classifier">
                  int (default = 4 )
                 </span>
                </dt>
                <dd>
                 <p>
                  Number of parallel streams used for forest building
                 </p>
                </dd>
                <dt>
                 <strong>
                  workers
                 </strong>
                 <span class="classifier">
                  optional, list of strings
                 </span>
                </dt>
                <dd>
                 <p>
                  Dask addresses of workers to use for computation.
If None, all available Dask workers will be used.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestRegressor.fit" title="cuml.dask.ensemble.RandomForestRegressor.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y)
                 </p>
                </td>
                <td>
                 <p>
                  Fit the input data with a Random Forest regression model
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestRegressor.get_params" title="cuml.dask.ensemble.RandomForestRegressor.get_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     get_params
                    </span>
                   </code>
                  </a>
                  (self[, deep])
                 </p>
                </td>
                <td>
                 <p>
                  Returns the value of all parameters required to configure this estimator as a dictionary.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestRegressor.predict" title="cuml.dask.ensemble.RandomForestRegressor.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, predict_model, algo, …])
                 </p>
                </td>
                <td>
                 <p>
                  Predicts the regressor outputs for X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestRegressor.print_summary" title="cuml.dask.ensemble.RandomForestRegressor.print_summary">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     print_summary
                    </span>
                   </code>
                  </a>
                  (self)
                 </p>
                </td>
                <td>
                 <p>
                  Print the summary of the forest used to train and test the model.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.ensemble.RandomForestRegressor.set_params" title="cuml.dask.ensemble.RandomForestRegressor.set_params">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     set_params
                    </span>
                   </code>
                  </a>
                  (self, \*\*params)
                 </p>
                </td>
                <td>
                 <p>
                  Sets the value of parameters required to configure this estimator, it functions similar to the sklearn set_params.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestRegressor.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestRegressor.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the input data with a Random Forest regression model
               </p>
               <p>
                IMPORTANT: X is expected to be partitioned with at least one partition
on each Dask worker being used by the forest (self.workers).
               </p>
               <p>
                When persisting data, you can use
cuml.dask.common.utils.persist_across_workers to simplify this:
               </p>
               <div class="highlight-default notranslate">
                <div class="highlight">
                 <pre><span></span><span class="n">X_dask_cudf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">from_cudf</span><span class="p">(</span><span class="n">X_cudf</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>
<span class="n">y_dask_cudf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">from_cudf</span><span class="p">(</span><span class="n">y_cudf</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>
<span class="n">X_dask_cudf</span><span class="p">,</span> <span class="n">y_dask_cudf</span> <span class="o">=</span> <span class="n">persist_across_workers</span><span class="p">(</span><span class="n">dask_client</span><span class="p">,</span>
                                                  <span class="p">[</span><span class="n">X_dask_cudf</span><span class="p">,</span>
                                                   <span class="n">y_dask_cudf</span><span class="p">])</span>
</pre>
                </div>
               </div>
               <dl>
                <dt>
                 (this is equivalent to calling
                 <cite>
                  persist
                 </cite>
                 with the data and workers)::
                </dt>
                <dd>
                 <dl>
                  <dt>
                   X_dask_cudf, y_dask_cudf = dask_client.persist([X_dask_cudf,
                  </dt>
                  <dd>
                   <blockquote>
                    <div>
                     <p>
                      y_dask_cudf],
                     </p>
                    </div>
                   </blockquote>
                   <p>
                    workers={
X_dask_cudf=workers,
y_dask_cudf=workers
})
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask_cudf.Dataframe
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, n_features).
Features of training examples.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    dask_cudf.Dataframe
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Dense matrix (floats or doubles) of shape (n_samples, 1)
Labels of training examples.
y must be partitioned the same way as X
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestRegressor.get_params">
               <code class="sig-name descname">
                get_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                deep=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestRegressor.get_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Returns the value of all parameters
required to configure this estimator as a dictionary.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    deep
                   </strong>
                   <span class="classifier">
                    boolean (default = True)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestRegressor.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                predict_model='GPU'
               </em>
               ,
               <em class="sig-param">
                algo='auto'
               </em>
               ,
               <em class="sig-param">
                convert_dtype=True
               </em>
               ,
               <em class="sig-param">
                fil_sparse_format='auto'
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestRegressor.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Predicts the regressor outputs for X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Distributed dense matrix (floats or doubles) of shape
(n_samples, n_features).
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    algo
                   </strong>
                   <span class="classifier">
                    string (default = ‘auto’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This is optional and required only while performing the
predict operation on the GPU.
‘naive’ - simple inference using shared memory
‘tree_reorg’ - similar to naive but trees rearranged to be more
coalescing-friendly
‘batch_tree_reorg’ - similar to tree_reorg but predicting
multiple rows per thread block
                    <cite>
                     algo
                    </cite>
                    - choose the algorithm automatically. Currently
‘batch_tree_reorg’ is used for dense storage
and ‘naive’ for sparse storage
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    convert_dtype
                   </strong>
                   <span class="classifier">
                    bool, optional (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    When set to True, the predict method will, when necessary, convert
the input to the data type which was used to train the model. This
will increase memory used for the method.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    predict_model
                   </strong>
                   <span class="classifier">
                    String (default = ‘GPU’)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    ‘GPU’ to predict using the GPU, ‘CPU’ otherwise. The GPU can only
be used if the model was trained on float32 data and
                    <cite>
                     X
                    </cite>
                    is float32
or convert_dtype is set to True.
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    fil_sparse_format
                   </strong>
                   <span class="classifier">
                    boolean or string (default = auto)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    This variable is used to choose the type of forest that will be
created in the Forest Inference Library. It is not required
while using predict_model=’CPU’.
‘auto’ - choose the storage type automatically
(currently True is chosen by auto)
False - create a dense forest
True - create a sparse forest, requires algo=’naive’
or algo=’auto’
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    delayed
                   </strong>
                   <span class="classifier">
                    bool (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether to do a lazy prediction (and return Delayed objects) or an
eagerly executed one.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, 1)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestRegressor.print_summary">
               <code class="sig-name descname">
                print_summary
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestRegressor.print_summary" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Print the summary of the forest used to train and test the model.
               </p>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.ensemble.RandomForestRegressor.set_params">
               <code class="sig-name descname">
                set_params
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                **params
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.ensemble.RandomForestRegressor.set_params" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Sets the value of parameters required to
configure this estimator, it functions similar to
the sklearn set_params.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    params
                   </strong>
                   <span class="classifier">
                    dict of new params
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="id22">
           <h3>
            Truncated SVD
            <a class="headerlink" href="#id22" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.dask.decomposition.TruncatedSVD">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.decomposition.
             </code>
             <code class="sig-name descname">
              TruncatedSVD
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              client=None
             </em>
             ,
             <em class="sig-param">
              **kwargs
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.decomposition.TruncatedSVD" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  handle
                 </strong>
                 <span class="classifier">
                  cuml.Handle
                 </span>
                </dt>
                <dd>
                 <p>
                  If it is None, a new one is created just for this class
                 </p>
                </dd>
                <dt>
                 <strong>
                  n_components
                 </strong>
                 <span class="classifier">
                  int (default = 1)
                 </span>
                </dt>
                <dd>
                 <p>
                  The number of top K singular vectors / values you want.
Must be &lt;= number(columns).
                 </p>
                </dd>
                <dt>
                 <strong>
                  svd_solver
                 </strong>
                 <span class="classifier">
                  ‘full’
                 </span>
                </dt>
                <dd>
                 <p>
                  Only Full algorithm is supported since it’s significantly faster on GPU
then the other solvers including randomized SVD.
                 </p>
                </dd>
                <dt>
                 <strong>
                  verbose
                 </strong>
                 <span class="classifier">
                  bool
                 </span>
                </dt>
                <dd>
                 <p>
                  Whether to print debug spews
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Examples
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="kn">from</span> <span class="nn">dask_cuda</span> <span class="kn">import</span> <span class="n">LocalCUDACluster</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span><span class="p">,</span> <span class="n">wait</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">cuml.dask.decomposition</span> <span class="kn">import</span> <span class="n">TruncatedSVD</span>
<span class="kn">from</span> <span class="nn">cuml.dask.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>

<span class="n">cluster</span> <span class="o">=</span> <span class="n">LocalCUDACluster</span><span class="p">(</span><span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>

<span class="n">nrows</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">ncols</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">n_parts</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">X_cudf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_parts</span><span class="p">,</span>
                <span class="n">cluster_std</span><span class="o">=</span><span class="mf">1.8</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">wait</span><span class="p">(</span><span class="n">X_cudf</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Input Matrix"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_cudf</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>

<span class="n">cumlModel</span> <span class="o">=</span> <span class="n">TruncatedSVD</span><span class="p">(</span><span class="n">n_components</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">XT</span> <span class="o">=</span> <span class="n">cumlModel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_cudf</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Transformed Input Matrix"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">XT</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
</pre>
              </div>
             </div>
             <p>
              Output:
             </p>
             <div class="highlight-python notranslate">
              <div class="highlight">
               <pre><span></span><span class="n">Input</span> <span class="n">Matrix</span><span class="p">:</span>
                    <span class="mi">0</span>         <span class="mi">1</span>          <span class="mi">2</span>
          <span class="mi">0</span> <span class="o">-</span><span class="mf">8.519647</span> <span class="o">-</span><span class="mf">8.519222</span>  <span class="o">-</span><span class="mf">8.865648</span>
          <span class="mi">1</span> <span class="o">-</span><span class="mf">6.107700</span> <span class="o">-</span><span class="mf">8.350124</span> <span class="o">-</span><span class="mf">10.351215</span>
          <span class="mi">2</span> <span class="o">-</span><span class="mf">8.026635</span> <span class="o">-</span><span class="mf">9.442240</span>  <span class="o">-</span><span class="mf">7.561770</span>
          <span class="mi">0</span> <span class="o">-</span><span class="mf">8.519647</span> <span class="o">-</span><span class="mf">8.519222</span>  <span class="o">-</span><span class="mf">8.865648</span>
          <span class="mi">1</span> <span class="o">-</span><span class="mf">6.107700</span> <span class="o">-</span><span class="mf">8.350124</span> <span class="o">-</span><span class="mf">10.351215</span>
          <span class="mi">2</span> <span class="o">-</span><span class="mf">8.026635</span> <span class="o">-</span><span class="mf">9.442240</span>  <span class="o">-</span><span class="mf">7.561770</span>

<span class="n">Transformed</span> <span class="n">Input</span> <span class="n">Matrix</span><span class="p">:</span>
                     <span class="mi">0</span>
          <span class="mi">0</span>  <span class="mf">14.928891</span>
          <span class="mi">1</span>  <span class="mf">14.487295</span>
          <span class="mi">2</span>  <span class="mf">14.431235</span>
          <span class="mi">0</span>  <span class="mf">14.928891</span>
          <span class="mi">1</span>  <span class="mf">14.487295</span>
          <span class="mi">2</span>  <span class="mf">14.431235</span>
</pre>
              </div>
             </div>
             <dl class="simple">
              <dt>
               Note: Everytime this code is run, the output will be different because
              </dt>
              <dd>
               <p>
                “make_blobs” function generates random matrices.
               </p>
              </dd>
             </dl>
             <dl class="field-list simple">
              <dt class="field-odd">
               Attributes
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  components_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The top K components (VT.T[:,:n_components]) in U, S, VT = svd(X)
                 </p>
                </dd>
                <dt>
                 <strong>
                  explained_variance_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  How much each component explains the variance in the data given by S**2
                 </p>
                </dd>
                <dt>
                 <strong>
                  explained_variance_ratio_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  How much in % the variance is explained given by S**2/sum(S**2)
                 </p>
                </dd>
                <dt>
                 <strong>
                  singular_values_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The top K singular values. Remember all singular values &gt;= 0
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.decomposition.TruncatedSVD.fit" title="cuml.dask.decomposition.TruncatedSVD.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X[, _transform])
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.decomposition.TruncatedSVD.fit_transform" title="cuml.dask.decomposition.TruncatedSVD.fit_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit_transform
                    </span>
                   </code>
                  </a>
                  (self, X)
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and apply the dimensionality reduction on X.
                 </p>
                </td>
               </tr>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.decomposition.TruncatedSVD.inverse_transform" title="cuml.dask.decomposition.TruncatedSVD.inverse_transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     inverse_transform
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Transform data back to its original space.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.decomposition.TruncatedSVD.transform" title="cuml.dask.decomposition.TruncatedSVD.transform">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     transform
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Apply dimensionality reduction to X.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <table class="docutils align-default">
              <colgroup>
               <col style="width: 66%"/>
               <col style="width: 34%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <strong>
                   get_param_names
                  </strong>
                 </p>
                </td>
                <td>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.dask.decomposition.TruncatedSVD.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                _transform=False
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.decomposition.TruncatedSVD.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask cuDF input
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.decomposition.TruncatedSVD.fit_transform">
               <code class="sig-name descname">
                fit_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.decomposition.TruncatedSVD.fit_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and apply the dimensionality reduction on X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.decomposition.TruncatedSVD.inverse_transform">
               <code class="sig-name descname">
                inverse_transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.decomposition.TruncatedSVD.inverse_transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Transform data back to its original space.
               </p>
               <p>
                In other words, return an input X_original whose transform would be X.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_original
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.decomposition.TruncatedSVD.transform">
               <code class="sig-name descname">
                transform
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.decomposition.TruncatedSVD.transform" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Apply dimensionality reduction to X.
               </p>
               <p>
                X is projected on the first principal components previously extracted
from a training set.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X_new
                   </strong>
                   <span class="classifier">
                    dask cuDF
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="linear-models">
           <h3>
            Linear Models
            <a class="headerlink" href="#linear-models" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.dask.linear_model.LinearRegression">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.linear_model.
             </code>
             <code class="sig-name descname">
              LinearRegression
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              client=None
             </em>
             ,
             <em class="sig-param">
              verbose=False
             </em>
             ,
             <em class="sig-param">
              **kwargs
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.linear_model.LinearRegression" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              LinearRegression is a simple machine learning model where the response y is
modelled by a linear combination of the predictors in X.
             </p>
             <p>
              cuML’s dask Linear Regression (multi-node multi-gpu) expects dask cuDF
DataFrame and provides an algorithms, Eig, to fit a linear model.
And provides an eigendecomposition-based algorithm to fit a linear model.
(SVD, which is more stable than eig, will be added in an upcoming version.)
Eig algorithm is usually preferred when the X is a tall and skinny matrix.
As the number of features in X increases, the accuracy of Eig algorithm
drops.
             </p>
             <p>
              This is an experimental implementation of dask Linear Regresion. It
supports input X that has more than one column. Single column input
X will be supported after SVD algorithm is added in an upcoming version.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  algorithm
                 </strong>
                 <span class="classifier">
                  ‘eig’
                 </span>
                </dt>
                <dd>
                 <p>
                  Eig uses a eigendecomposition of the covariance matrix, and is much
faster.
SVD is slower, but guaranteed to be stable.
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  LinearRegression adds an additional term c to correct for the global
mean of y, modeling the reponse as “x * beta + c”.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  normalize
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the predictors in X will be normalized by dividing by its
L2 norm.
If False, no scaling will be done.
                 </p>
                </dd>
               </dl>
              </dd>
              <dt class="field-even">
               Attributes
              </dt>
              <dd class="field-even">
               <dl class="simple">
                <dt>
                 <strong>
                  coef_
                 </strong>
                 <span class="classifier">
                  cuDF series, shape (n_features)
                 </span>
                </dt>
                <dd>
                 <p>
                  The estimated coefficients for the linear regression model.
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The independent term. If
                  <a href="#id35">
                   <span class="problematic" id="id36">
                    fit_intercept_
                   </span>
                  </a>
                  is False, will be 0.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.linear_model.LinearRegression.fit" title="cuml.dask.linear_model.LinearRegression.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y)
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.linear_model.LinearRegression.predict" title="cuml.dask.linear_model.LinearRegression.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Make predictions for X and returns a dask collection.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <table class="docutils align-default">
              <colgroup>
               <col style="width: 66%"/>
               <col style="width: 34%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <strong>
                   get_param_names
                  </strong>
                 </p>
                </td>
                <td>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.dask.linear_model.LinearRegression.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.linear_model.LinearRegression.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Features for regression
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Labels (outcome values)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.linear_model.LinearRegression.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.linear_model.LinearRegression.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Make predictions for X and returns a dask collection.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Distributed dense matrix (floats or doubles) of shape
(n_samples, n_features).
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    delayed
                   </strong>
                   <span class="classifier">
                    bool (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether to do a lazy prediction (and return Delayed objects) or an
eagerly executed one.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, 1)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.dask.linear_model.Ridge">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.linear_model.
             </code>
             <code class="sig-name descname">
              Ridge
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              client=None
             </em>
             ,
             <em class="sig-param">
              verbose=False
             </em>
             ,
             <em class="sig-param">
              **kwargs
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.linear_model.Ridge" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
             <p>
              Ridge extends LinearRegression by providing L2 regularization on the
coefficients when predicting response y with a linear combination of the
predictors in X. It can reduce the variance of the predictors, and improves
the conditioning of the problem.
             </p>
             <p>
              cuML’s dask Ridge (multi-node multi-gpu) expects dask cuDF
DataFrame and provides an algorithms, Eig, to fit a linear model.
And provides an eigendecomposition-based algorithm to fit a linear model.
(SVD, which is more stable than eig, will be added in an upcoming version)
Eig algorithm is usually preferred when the X is a tall and skinny matrix.
As the number of features in X increases, the accuracy of Eig algorithm
drops.
             </p>
             <p>
              This is an experimental implementation of dask Ridge Regresion. It
supports input X that has more than one column. Single column input
X will be supported after SVD algorithm is added in an upcoming version.
             </p>
             <dl class="field-list simple">
              <dt class="field-odd">
               Parameters
              </dt>
              <dd class="field-odd">
               <dl class="simple">
                <dt>
                 <strong>
                  alpha
                 </strong>
                 <span class="classifier">
                  float or double
                 </span>
                </dt>
                <dd>
                 <p>
                  Regularization strength - must be a positive float. Larger values
specify stronger regularization. Array input will be supported later.
                 </p>
                </dd>
                <dt>
                 <strong>
                  solver
                 </strong>
                 <span class="classifier">
                  ‘eig’
                 </span>
                </dt>
                <dd>
                 <p>
                  Eig uses a eigendecomposition of the covariance matrix, and is much
faster.
                 </p>
                </dd>
                <dt>
                 <strong>
                  fit_intercept
                 </strong>
                 <span class="classifier">
                  boolean (default = True)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, Ridge adds an additional term c to correct for the global
mean of y, modeling the reponse as “x * beta + c”.
If False, the model expects that you have centered the data.
                 </p>
                </dd>
                <dt>
                 <strong>
                  normalize
                 </strong>
                 <span class="classifier">
                  boolean (default = False)
                 </span>
                </dt>
                <dd>
                 <p>
                  If True, the predictors in X will be normalized by dividing by it’s L2
norm.
If False, no scaling will be done.
                 </p>
                </dd>
               </dl>
              </dd>
              <dt class="field-even">
               Attributes
              </dt>
              <dd class="field-even">
               <dl class="simple">
                <dt>
                 <strong>
                  coef_
                 </strong>
                 <span class="classifier">
                  array, shape (n_features)
                 </span>
                </dt>
                <dd>
                 <p>
                  The estimated coefficients for the linear regression model.
                 </p>
                </dd>
                <dt>
                 <strong>
                  intercept_
                 </strong>
                 <span class="classifier">
                  array
                 </span>
                </dt>
                <dd>
                 <p>
                  The independent term. If
                  <a href="#id37">
                   <span class="problematic" id="id38">
                    fit_intercept_
                   </span>
                  </a>
                  is False, will be 0.
                 </p>
                </dd>
               </dl>
              </dd>
             </dl>
             <p class="rubric">
              Methods
             </p>
             <table class="longtable docutils align-default">
              <colgroup>
               <col style="width: 10%"/>
               <col style="width: 90%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.linear_model.Ridge.fit" title="cuml.dask.linear_model.Ridge.fit">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     fit
                    </span>
                   </code>
                  </a>
                  (self, X, y)
                 </p>
                </td>
                <td>
                 <p>
                  Fit the model with X and y.
                 </p>
                </td>
               </tr>
               <tr class="row-even">
                <td>
                 <p>
                  <a class="reference internal" href="#cuml.dask.linear_model.Ridge.predict" title="cuml.dask.linear_model.Ridge.predict">
                   <code class="xref py py-obj docutils literal notranslate">
                    <span class="pre">
                     predict
                    </span>
                   </code>
                  </a>
                  (self, X[, delayed])
                 </p>
                </td>
                <td>
                 <p>
                  Make predictions for X and returns a dask collection.
                 </p>
                </td>
               </tr>
              </tbody>
             </table>
             <table class="docutils align-default">
              <colgroup>
               <col style="width: 66%"/>
               <col style="width: 34%"/>
              </colgroup>
              <tbody>
               <tr class="row-odd">
                <td>
                 <p>
                  <strong>
                   get_param_names
                  </strong>
                 </p>
                </td>
                <td>
                </td>
               </tr>
              </tbody>
             </table>
             <dl class="method">
              <dt id="cuml.dask.linear_model.Ridge.fit">
               <code class="sig-name descname">
                fit
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                y
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.linear_model.Ridge.fit" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Fit the model with X and y.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Features for regression
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, 1)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Labels (outcome values)
                   </p>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
             <dl class="method">
              <dt id="cuml.dask.linear_model.Ridge.predict">
               <code class="sig-name descname">
                predict
               </code>
               <span class="sig-paren">
                (
               </span>
               <em class="sig-param">
                self
               </em>
               ,
               <em class="sig-param">
                X
               </em>
               ,
               <em class="sig-param">
                delayed=True
               </em>
               <span class="sig-paren">
                )
               </span>
               <a class="headerlink" href="#cuml.dask.linear_model.Ridge.predict" title="Permalink to this definition">
                ¶
               </a>
              </dt>
              <dd>
               <p>
                Make predictions for X and returns a dask collection.
               </p>
               <dl class="field-list simple">
                <dt class="field-odd">
                 Parameters
                </dt>
                <dd class="field-odd">
                 <dl class="simple">
                  <dt>
                   <strong>
                    X
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, n_features)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Distributed dense matrix (floats or doubles) of shape
(n_samples, n_features).
                   </p>
                  </dd>
                  <dt>
                   <strong>
                    delayed
                   </strong>
                   <span class="classifier">
                    bool (default = True)
                   </span>
                  </dt>
                  <dd>
                   <p>
                    Whether to do a lazy prediction (and return Delayed objects) or an
eagerly executed one.
                   </p>
                  </dd>
                 </dl>
                </dd>
                <dt class="field-even">
                 Returns
                </dt>
                <dd class="field-even">
                 <dl class="simple">
                  <dt>
                   <strong>
                    y
                   </strong>
                   <span class="classifier">
                    Dask cuDF dataframe  or CuPy backed Dask Array (n_rows, 1)
                   </span>
                  </dt>
                  <dd>
                  </dd>
                 </dl>
                </dd>
               </dl>
              </dd>
             </dl>
            </dd>
           </dl>
          </div>
          <div class="section" id="dask-base-classes-and-mixins">
           <h3>
            Dask Base Classes and Mixins
            <a class="headerlink" href="#dask-base-classes-and-mixins" title="Permalink to this headline">
             ¶
            </a>
           </h3>
           <dl class="class">
            <dt id="cuml.dask.common.base.BaseEstimator">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.common.base.
             </code>
             <code class="sig-name descname">
              BaseEstimator
             </code>
             <span class="sig-paren">
              (
             </span>
             <em class="sig-param">
              client=None
             </em>
             ,
             <em class="sig-param">
              verbose=False
             </em>
             ,
             <em class="sig-param">
              **kwargs
             </em>
             <span class="sig-paren">
              )
             </span>
             <a class="headerlink" href="#cuml.dask.common.base.BaseEstimator" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.dask.common.base.DelayedParallelFunc">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.common.base.
             </code>
             <code class="sig-name descname">
              DelayedParallelFunc
             </code>
             <a class="headerlink" href="#cuml.dask.common.base.DelayedParallelFunc" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.dask.common.base.DelayedPredictionMixin">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.common.base.
             </code>
             <code class="sig-name descname">
              DelayedPredictionMixin
             </code>
             <a class="headerlink" href="#cuml.dask.common.base.DelayedPredictionMixin" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.dask.common.base.DelayedTransformMixin">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.common.base.
             </code>
             <code class="sig-name descname">
              DelayedTransformMixin
             </code>
             <a class="headerlink" href="#cuml.dask.common.base.DelayedTransformMixin" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
            </dd>
           </dl>
           <dl class="class">
            <dt id="cuml.dask.common.base.DelayedInverseTransformMixin">
             <em class="property">
              class
             </em>
             <code class="sig-prename descclassname">
              cuml.dask.common.base.
             </code>
             <code class="sig-name descname">
              DelayedInverseTransformMixin
             </code>
             <a class="headerlink" href="#cuml.dask.common.base.DelayedInverseTransformMixin" title="Permalink to this definition">
              ¶
             </a>
            </dt>
            <dd>
            </dd>
           </dl>
          </div>
         </div>
        </div>
       </div>
      </div>
      <footer>
       <div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
        <a accesskey="p" class="btn btn-neutral float-left" href="index.html" rel="prev" title="Welcome to cuML’s documentation!">
         <span class="fa fa-arrow-circle-left">
         </span>
         Previous
        </a>
       </div>
       <hr/>
       <div role="contentinfo">
        <p>
         © Copyright 2019, nvidia
        </p>
       </div>
       Built with
       <a href="http://sphinx-doc.org/">
        Sphinx
       </a>
       using a
       <a href="https://github.com/rtfd/sphinx_rtd_theme">
        theme
       </a>
       provided by
       <a href="https://readthedocs.org">
        Read the Docs
       </a>
       .
      </footer>
     </div>
    </div>
   </section>
  </div>
  <script type="text/javascript">
   jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
  <script defer id="rapids-selector-js" src="/assets/js/custom.js">
  </script>
 </body>
</html>