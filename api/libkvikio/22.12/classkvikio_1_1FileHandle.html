<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>libkvikio: kvikio::FileHandle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer="" src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libkvikio</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/legacy">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (22.12)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libkvikio/nightly">nightly (22.12)</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">stable (22.10)</a><a class="rapids-selector__menu-item" href="/api/libkvikio/legacy">legacy (22.08)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="navpath" id="nav-path">
  <ul>
<li class="navelem"><b>kvikio</b></li><li class="navelem"><a class="el" href="classkvikio_1_1FileHandle.html">FileHandle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="#pub-static-attribs">Static Public Attributes</a> |
<a href="classkvikio_1_1FileHandle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kvikio::FileHandle Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handle of an open file registred with cufile.  
 <a href="classkvikio_1_1FileHandle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5b0b90095e1ea00f560fd2801730be04"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#a5b0b90095e1ea00f560fd2801730be04">FileHandle</a> (const std::string &amp;file_path, const std::string &amp;flags="r", mode_t mode=m644, bool compat_mode=<a class="el" href="classkvikio_1_1defaults.html#a98755e7e923ded703943426a549e39da">defaults::compat_mode</a>())</td></tr>
<tr class="memdesc:a5b0b90095e1ea00f560fd2801730be04"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a file handle from a file path.  <a href="classkvikio_1_1FileHandle.html#a5b0b90095e1ea00f560fd2801730be04">More...</a><br></td></tr>
<tr class="separator:a5b0b90095e1ea00f560fd2801730be04"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a202035ea55beeec118b59bd8afcf2aa7"><td align="right" class="memItemLeft" valign="top"><a id="a202035ea55beeec118b59bd8afcf2aa7"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#a202035ea55beeec118b59bd8afcf2aa7">FileHandle</a> (const <a class="el" href="classkvikio_1_1FileHandle.html">FileHandle</a> &amp;)=delete</td></tr>
<tr class="memdesc:a202035ea55beeec118b59bd8afcf2aa7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classkvikio_1_1FileHandle.html" title="Handle of an open file registred with cufile.">FileHandle</a> support move semantic but isn't copyable. <br></td></tr>
<tr class="separator:a202035ea55beeec118b59bd8afcf2aa7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aab4f050da9c24417519e6f0941a4e199"><td align="right" class="memItemLeft" valign="top"><a id="aab4f050da9c24417519e6f0941a4e199"></a>
<a class="el" href="classkvikio_1_1FileHandle.html">FileHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classkvikio_1_1FileHandle.html">FileHandle</a> const &amp;)=delete</td></tr>
<tr class="separator:aab4f050da9c24417519e6f0941a4e199"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a32c5f7b9dcdc522dd8e3c24e8709d344"><td align="right" class="memItemLeft" valign="top"><a id="a32c5f7b9dcdc522dd8e3c24e8709d344"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>FileHandle</b> (<a class="el" href="classkvikio_1_1FileHandle.html">FileHandle</a> &amp;&amp;o) noexcept</td></tr>
<tr class="separator:a32c5f7b9dcdc522dd8e3c24e8709d344"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa2237dc6135a0446d5585c152cc8a57c"><td align="right" class="memItemLeft" valign="top"><a id="aa2237dc6135a0446d5585c152cc8a57c"></a>
<a class="el" href="classkvikio_1_1FileHandle.html">FileHandle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classkvikio_1_1FileHandle.html">FileHandle</a> &amp;&amp;o) noexcept</td></tr>
<tr class="separator:aa2237dc6135a0446d5585c152cc8a57c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa1db0e353263047d1baaf57c4bb060cf"><td align="right" class="memItemLeft" valign="top"><a id="aa1db0e353263047d1baaf57c4bb060cf"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>closed</b> () const noexcept</td></tr>
<tr class="separator:aa1db0e353263047d1baaf57c4bb060cf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0ca06e9e693082e6dd107830225de9e5"><td align="right" class="memItemLeft" valign="top"><a id="a0ca06e9e693082e6dd107830225de9e5"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#a0ca06e9e693082e6dd107830225de9e5">close</a> () noexcept</td></tr>
<tr class="memdesc:a0ca06e9e693082e6dd107830225de9e5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister the file and close the two files. <br></td></tr>
<tr class="separator:a0ca06e9e693082e6dd107830225de9e5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:abb8c1e9948530e5d1bc758a0965a5a78"><td align="right" class="memItemLeft" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#abb8c1e9948530e5d1bc758a0965a5a78">fd</a> () const noexcept</td></tr>
<tr class="memdesc:abb8c1e9948530e5d1bc758a0965a5a78"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get one of the file descriptors.  <a href="classkvikio_1_1FileHandle.html#abb8c1e9948530e5d1bc758a0965a5a78">More...</a><br></td></tr>
<tr class="separator:abb8c1e9948530e5d1bc758a0965a5a78"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5a52c487cb509def7d72fa963686a1e6"><td align="right" class="memItemLeft" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#a5a52c487cb509def7d72fa963686a1e6">fd_open_flags</a> () const</td></tr>
<tr class="memdesc:a5a52c487cb509def7d72fa963686a1e6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the flags of one of the file descriptors (see open(2))  <a href="classkvikio_1_1FileHandle.html#a5a52c487cb509def7d72fa963686a1e6">More...</a><br></td></tr>
<tr class="separator:a5a52c487cb509def7d72fa963686a1e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad962ab570833c74291b8cfa3d04bd7ff"><td align="right" class="memItemLeft" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#ad962ab570833c74291b8cfa3d04bd7ff">nbytes</a> () const</td></tr>
<tr class="memdesc:ad962ab570833c74291b8cfa3d04bd7ff"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the file size.  <a href="classkvikio_1_1FileHandle.html#ad962ab570833c74291b8cfa3d04bd7ff">More...</a><br></td></tr>
<tr class="separator:ad962ab570833c74291b8cfa3d04bd7ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9b5085624eedc597f62bfa44b3e759b1"><td align="right" class="memItemLeft" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#a9b5085624eedc597f62bfa44b3e759b1">read</a> (void *devPtr_base, std::size_t size, std::size_t file_offset, std::size_t devPtr_offset)</td></tr>
<tr class="memdesc:a9b5085624eedc597f62bfa44b3e759b1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads specified bytes from the file into the device memory.  <a href="classkvikio_1_1FileHandle.html#a9b5085624eedc597f62bfa44b3e759b1">More...</a><br></td></tr>
<tr class="separator:a9b5085624eedc597f62bfa44b3e759b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acef5445bf5b37972efc07a23e1f1348a"><td align="right" class="memItemLeft" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#acef5445bf5b37972efc07a23e1f1348a">write</a> (const void *devPtr_base, std::size_t size, std::size_t file_offset, std::size_t devPtr_offset)</td></tr>
<tr class="memdesc:acef5445bf5b37972efc07a23e1f1348a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes specified bytes from the device memory into the file.  <a href="classkvikio_1_1FileHandle.html#acef5445bf5b37972efc07a23e1f1348a">More...</a><br></td></tr>
<tr class="separator:acef5445bf5b37972efc07a23e1f1348a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab254c5290909fcbf0347d4815ae512c4"><td align="right" class="memItemLeft" valign="top">std::future&lt; std::size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#ab254c5290909fcbf0347d4815ae512c4">pread</a> (void *buf, std::size_t size, std::size_t file_offset=0, std::size_t task_size=<a class="el" href="classkvikio_1_1defaults.html#a25042e049540a72de56f1ee5aec42828">defaults::task_size</a>())</td></tr>
<tr class="memdesc:ab254c5290909fcbf0347d4815ae512c4"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads specified bytes from the file into the device or host memory in parallel.  <a href="classkvikio_1_1FileHandle.html#ab254c5290909fcbf0347d4815ae512c4">More...</a><br></td></tr>
<tr class="separator:ab254c5290909fcbf0347d4815ae512c4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad7ba5fdf03baa5fe16cbd8d2fd7a98d7"><td align="right" class="memItemLeft" valign="top">std::future&lt; std::size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkvikio_1_1FileHandle.html#ad7ba5fdf03baa5fe16cbd8d2fd7a98d7">pwrite</a> (const void *buf, std::size_t size, std::size_t file_offset=0, std::size_t task_size=<a class="el" href="classkvikio_1_1defaults.html#a25042e049540a72de56f1ee5aec42828">defaults::task_size</a>())</td></tr>
<tr class="memdesc:ad7ba5fdf03baa5fe16cbd8d2fd7a98d7"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes specified bytes from device or host memory into the file in parallel.  <a href="classkvikio_1_1FileHandle.html#ad7ba5fdf03baa5fe16cbd8d2fd7a98d7">More...</a><br></td></tr>
<tr class="separator:ad7ba5fdf03baa5fe16cbd8d2fd7a98d7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1de3f8326c1146ae04b4c5ea88872893"><td align="right" class="memItemLeft" valign="top"><a id="a1de3f8326c1146ae04b4c5ea88872893"></a>
static constexpr mode_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>m644</b> = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH</td></tr>
<tr class="separator:a1de3f8326c1146ae04b4c5ea88872893"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Handle of an open file registred with cufile. </p>
<p>In order to utilize cufile and GDS, a file must be registred with cufile. </p>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00127">127</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5b0b90095e1ea00f560fd2801730be04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0b90095e1ea00f560fd2801730be04">◆&nbsp;</a></span>FileHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">kvikio::FileHandle::FileHandle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"><em>flags</em> = <code>"r"</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&nbsp;</td>
          <td class="paramname"><em>mode</em> = <code>m644</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>compat_mode</em> = <code><a class="el" href="classkvikio_1_1defaults.html#a98755e7e923ded703943426a549e39da">defaults::compat_mode</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Construct a file handle from a file path. </p>
<p><a class="el" href="classkvikio_1_1FileHandle.html" title="Handle of an open file registred with cufile.">FileHandle</a> opens the file twice and maintains two file descriptors. One file is opened with the specified <code>flags</code> and the other file is opened with the <code>flags</code> plus the <code>O_DIRECT</code> flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">file_path</td><td>File path to the file </td></tr>
    <tr><td class="paramname">flags</td><td>Open flags (see also <code>fopen(3)</code>): "r" -&gt; "open for reading (default)" "w" -&gt; "open for writing, truncating the file first" "a" -&gt; "open for writing, appending to the end of file if it exists" "+" -&gt; "open for updating (reading and writing)" </td></tr>
    <tr><td class="paramname">mode</td><td>Access modes (see <code>open(2)</code>). </td></tr>
    <tr><td class="paramname">compat_mode</td><td>Enable KvikIO's compatibility mode for this file. </td></tr>
  </tbody></table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00157">157</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abb8c1e9948530e5d1bc758a0965a5a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8c1e9948530e5d1bc758a0965a5a78">◆&nbsp;</a></span>fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int kvikio::FileHandle::fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get one of the file descriptors. </p>
<p>Notice, <a class="el" href="classkvikio_1_1FileHandle.html" title="Handle of an open file registred with cufile.">FileHandle</a> maintains two file descriptors - one opened with the <code>O_DIRECT</code> flag and one without. This function returns one of them but it is unspecified which one.</p>
<dl class="section return"><dt>Returns</dt><dd>File descripter </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00237">237</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>

</div>
</div>
<a id="a5a52c487cb509def7d72fa963686a1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a52c487cb509def7d72fa963686a1e6">◆&nbsp;</a></span>fd_open_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int kvikio::FileHandle::fd_open_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get the flags of one of the file descriptors (see open(2)) </p>
<p>Notice, <a class="el" href="classkvikio_1_1FileHandle.html" title="Handle of an open file registred with cufile.">FileHandle</a> maintains two file descriptors - one opened with the <code>O_DIRECT</code> flag and one without. This function returns the flags of one of them but it is unspecified which one.</p>
<dl class="section return"><dt>Returns</dt><dd>File descripter </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00248">248</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>

</div>
</div>
<a id="ad962ab570833c74291b8cfa3d04bd7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad962ab570833c74291b8cfa3d04bd7ff">◆&nbsp;</a></span>nbytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t kvikio::FileHandle::nbytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get the file size. </p>
<p>The value are cached.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00257">257</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>

</div>
</div>
<a id="ab254c5290909fcbf0347d4815ae512c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab254c5290909fcbf0347d4815ae512c4">◆&nbsp;</a></span>pread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::future&lt;std::size_t&gt; kvikio::FileHandle::pread </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>file_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>task_size</em> = <code><a class="el" href="classkvikio_1_1defaults.html#a25042e049540a72de56f1ee5aec42828">defaults::task_size</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Reads specified bytes from the file into the device or host memory in parallel. </p>
<p>This API is a parallel async version of <code>.<a class="el" href="classkvikio_1_1FileHandle.html#a9b5085624eedc597f62bfa44b3e759b1" title="Reads specified bytes from the file into the device memory.">read()</a></code> that partition the operation into tasks of size <code>task_size</code> for execution in the default thread pool.</p>
<dl class="section note"><dt>Note</dt><dd>For cuFile reads, the base address of the allocation <code>buf</code> is part of is used. This means that when registering buffers, use the base address of the allocation. This is what <code>memory_register</code> and <code>memory_deregister</code> do automatically.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">buf</td><td>Address to device or host memory. </td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes to read. </td></tr>
    <tr><td class="paramname">file_offset</td><td>Offset in the file to read from. </td></tr>
    <tr><td class="paramname">task_size</td><td>Size of each task in bytes. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future that on completion returns the size of bytes that were successfully read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00377">377</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>

</div>
</div>
<a id="ad7ba5fdf03baa5fe16cbd8d2fd7a98d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ba5fdf03baa5fe16cbd8d2fd7a98d7">◆&nbsp;</a></span>pwrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::future&lt;std::size_t&gt; kvikio::FileHandle::pwrite </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>file_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>task_size</em> = <code><a class="el" href="classkvikio_1_1defaults.html#a25042e049540a72de56f1ee5aec42828">defaults::task_size</a>()</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Writes specified bytes from device or host memory into the file in parallel. </p>
<p>This API is a parallel async version of <code>.<a class="el" href="classkvikio_1_1FileHandle.html#acef5445bf5b37972efc07a23e1f1348a" title="Writes specified bytes from the device memory into the file.">write()</a></code> that partition the operation into tasks of size <code>task_size</code> for execution in the default thread pool.</p>
<dl class="section note"><dt>Note</dt><dd>For cuFile reads, the base address of the allocation <code>buf</code> is part of is used. This means that when registering buffers, use the base address of the allocation. This is what <code>memory_register</code> and <code>memory_deregister</code> do automatically.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">buf</td><td>Address to device or host memory. </td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes to write. </td></tr>
    <tr><td class="paramname">file_offset</td><td>Offset in the file to write from. </td></tr>
    <tr><td class="paramname">task_size</td><td>Size of each task in bytes. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future that on completion returns the size of bytes that were successfully written. </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00423">423</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>

</div>
</div>
<a id="a9b5085624eedc597f62bfa44b3e759b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5085624eedc597f62bfa44b3e759b1">◆&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t kvikio::FileHandle::read </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"><em>devPtr_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>file_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>devPtr_offset</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Reads specified bytes from the file into the device memory. </p>
<p>This API reads the data from the GPU memory to the file at a specified offset and size bytes by using GDS functionality. The API works correctly for unaligned offset and data sizes, although the performance is not on-par with aligned read. This is a synchronous call and will block until the IO is complete.</p>
<dl class="section note"><dt>Note</dt><dd>For the <code>devPtr_offset</code>, if data will be read starting exactly from the <code>devPtr_base</code> that is registered with <code>buffer_register</code>, <code>devPtr_offset</code> should be set to 0. To read starting from an offset in the registered buffer range, the relative offset should be specified in the <code>devPtr_offset</code>, and the <code>devPtr_base</code> must remain set to the base address that was used in the <code>buffer_register</code> call.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">devPtr_base</td><td>Base address of buffer in device memory. For registered buffers, <code>devPtr_base</code> must remain set to the base address used in the <code>buffer_register</code> call. </td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes to read. </td></tr>
    <tr><td class="paramname">file_offset</td><td>Offset in the file to read from. </td></tr>
    <tr><td class="paramname">devPtr_offset</td><td>Offset relative to the <code>devPtr_base</code> pointer to read into. This parameter should be used only with registered buffers. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of bytes that were successfully read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00287">287</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>

</div>
</div>
<a id="acef5445bf5b37972efc07a23e1f1348a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef5445bf5b37972efc07a23e1f1348a">◆&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t kvikio::FileHandle::write </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"><em>devPtr_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>file_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>devPtr_offset</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Writes specified bytes from the device memory into the file. </p>
<p>This API writes the data from the GPU memory to the file at a specified offset and size bytes by using GDS functionality. The API works correctly for unaligned offset and data sizes, although the performance is not on-par with aligned writes. This is a synchronous call and will block until the IO is complete.</p>
<dl class="section note"><dt>Note</dt><dd>GDS functionality modified the standard file system metadata in SysMem. However, GDS functionality does not take any special responsibility for writing that metadata back to permanent storage. The data is not guaranteed to be present after a system crash unless the application uses an explicit <code>fsync(2)</code> call. If the file is opened with an <code>O_SYNC</code> flag, the metadata will be written to the disk before the call is complete. Refer to the note in read for more information about <code>devPtr_offset</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">devPtr_base</td><td>Base address of buffer in device memory. For registered buffers, <code>devPtr_base</code> must remain set to the base address used in the <code>buffer_register</code> call. </td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes to write. </td></tr>
    <tr><td class="paramname">file_offset</td><td>Offset in the file to write from. </td></tr>
    <tr><td class="paramname">devPtr_offset</td><td>Offset relative to the <code>devPtr_base</code> pointer to write into. This parameter should be used only with registered buffers. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of bytes that were successfully written. </dd></dl>

<p class="definition">Definition at line <a class="el" href="file__handle_8hpp_source.html#l00335">335</a> of file <a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a>.</p>

</div>
</div>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="file__handle_8hpp_source.html">file_handle.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>