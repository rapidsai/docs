<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>RMM: rmm::device_uvector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">librmm</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/nightly/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (21.06)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/librmm/nightly/annotated.html">nightly (21.10)</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">stable (21.08)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/librmm/legacy/annotated.html">legacy (21.06)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="navpath" id="nav-path">
<ul>
<li class="navelem"><b>rmm</b></li><li class="navelem"><a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a></li> </ul>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#pub-types">Public Types</a> |
<a href="#pub-methods">Public Member Functions</a> |
<a href="classrmm_1_1device__uvector-members.html">List of all members</a> </div>
<div class="headertitle">
<div class="title">rmm::device_uvector&lt; T &gt; Class Template Reference</div> </div>
</div><!--header-->
<div class="contents">
<p>An <em>uninitialized</em> vector of elements in device memory.  
 <a href="classrmm_1_1device__uvector.html#details">More...</a></p>
<p><code>#include &lt;<a class="el" href="device__uvector_8hpp_source.html">device_uvector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7d6c366f8c306a2d15edc8a36470e44c"><td align="right" class="memItemLeft" valign="top"><a id="a7d6c366f8c306a2d15edc8a36470e44c"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a7d6c366f8c306a2d15edc8a36470e44c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a62658655d1bbf2c201116a979c9d5d98"><td align="right" class="memItemLeft" valign="top"><a id="a62658655d1bbf2c201116a979c9d5d98"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="separator:a62658655d1bbf2c201116a979c9d5d98"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa7581ab33324828b20b5d2dd9feccbf5"><td align="right" class="memItemLeft" valign="top"><a id="aa7581ab33324828b20b5d2dd9feccbf5"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:aa7581ab33324828b20b5d2dd9feccbf5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ae69a91e1a84fa2c364b86c07ed6e3f2b"><td align="right" class="memItemLeft" valign="top"><a id="ae69a91e1a84fa2c364b86c07ed6e3f2b"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = value_type const  &amp;</td></tr>
<tr class="separator:ae69a91e1a84fa2c364b86c07ed6e3f2b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a127b17c327cb09557392c28ddc0102b8"><td align="right" class="memItemLeft" valign="top"><a id="a127b17c327cb09557392c28ddc0102b8"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = value_type *</td></tr>
<tr class="separator:a127b17c327cb09557392c28ddc0102b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ad82fd1ba35c3c120ac684dc569c975d4"><td align="right" class="memItemLeft" valign="top"><a id="ad82fd1ba35c3c120ac684dc569c975d4"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = value_type const  *</td></tr>
<tr class="separator:ad82fd1ba35c3c120ac684dc569c975d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa3c06cada6c9eb0f85add24855d77b1e"><td align="right" class="memItemLeft" valign="top"><a id="aa3c06cada6c9eb0f85add24855d77b1e"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = pointer</td></tr>
<tr class="separator:aa3c06cada6c9eb0f85add24855d77b1e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8f12ae66a3a91125f235f10d5ccd7069"><td align="right" class="memItemLeft" valign="top"><a id="a8f12ae66a3a91125f235f10d5ccd7069"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = const_pointer</td></tr>
<tr class="separator:a8f12ae66a3a91125f235f10d5ccd7069"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab19b0bb1a7af731794eef0c6a42ebcc8"><td align="right" class="memItemLeft" valign="top"><a id="ab19b0bb1a7af731794eef0c6a42ebcc8"></a>
RMM_EXEC_CHECK_DISABLE&nbsp;</td><td class="memItemRight" valign="bottom"><b>device_uvector</b> (<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ab19b0bb1a7af731794eef0c6a42ebcc8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8ce2695d014a145dc5a2a4cbf06b6d43"><td align="right" class="memItemLeft" valign="top"><a id="a8ce2695d014a145dc5a2a4cbf06b6d43"></a>
<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a8ce2695d014a145dc5a2a4cbf06b6d43"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a28ced74941f677048210e45bc851b87b"><td align="right" class="memItemLeft" valign="top"><a id="a28ced74941f677048210e45bc851b87b"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a28ced74941f677048210e45bc851b87b">device_uvector</a> (<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a28ced74941f677048210e45bc851b87b"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy ctor is deleted as it doesn't allow a stream argument. <br></td></tr>
<tr class="separator:a28ced74941f677048210e45bc851b87b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a991948318367bfff1d768ee91438371d"><td align="right" class="memItemLeft" valign="top"><a id="a991948318367bfff1d768ee91438371d"></a>
<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a991948318367bfff1d768ee91438371d">operator=</a> (<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a991948318367bfff1d768ee91438371d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy assignment is deleted as it doesn't allow a stream argument. <br></td></tr>
<tr class="separator:a991948318367bfff1d768ee91438371d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ace41a8c2cdfb33b0ff01ca699527416d"><td align="right" class="memItemLeft" valign="top"><a id="ace41a8c2cdfb33b0ff01ca699527416d"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#ace41a8c2cdfb33b0ff01ca699527416d">device_uvector</a> ()=delete</td></tr>
<tr class="memdesc:ace41a8c2cdfb33b0ff01ca699527416d"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor is deleted as it doesn't allow a stream argument. <br></td></tr>
<tr class="separator:ace41a8c2cdfb33b0ff01ca699527416d"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aaf8e36f398137fea17b8403908c817e8"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#aaf8e36f398137fea17b8403908c817e8">device_uvector</a> (std::size_t <a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693">size</a>, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream, <a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:aaf8e36f398137fea17b8403908c817e8"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <code><a class="el" href="classrmm_1_1device__uvector.html" title="An uninitialized vector of elements in device memory.">device_uvector</a></code> with sufficient uninitialized storage for <code>size</code> elements.  <a href="classrmm_1_1device__uvector.html#aaf8e36f398137fea17b8403908c817e8">More...</a><br></td></tr>
<tr class="separator:aaf8e36f398137fea17b8403908c817e8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6e637517602312be687f5231bd20d7cc"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a6e637517602312be687f5231bd20d7cc">device_uvector</a> (<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> const &amp;other, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream, <a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a6e637517602312be687f5231bd20d7cc"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <a class="el" href="classrmm_1_1device__uvector.html" title="An uninitialized vector of elements in device memory.">device_uvector</a> by deep copying the contents of another <code><a class="el" href="classrmm_1_1device__uvector.html" title="An uninitialized vector of elements in device memory.">device_uvector</a></code>.  <a href="classrmm_1_1device__uvector.html#a6e637517602312be687f5231bd20d7cc">More...</a><br></td></tr>
<tr class="separator:a6e637517602312be687f5231bd20d7cc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a736cb6f26d05740356b2250383154275"><td align="right" class="memItemLeft" valign="top">pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a736cb6f26d05740356b2250383154275">element_ptr</a> (std::size_t element_index) noexcept</td></tr>
<tr class="memdesc:a736cb6f26d05740356b2250383154275"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointer to the specified element.  <a href="classrmm_1_1device__uvector.html#a736cb6f26d05740356b2250383154275">More...</a><br></td></tr>
<tr class="separator:a736cb6f26d05740356b2250383154275"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a268f1916ed433f16fdbd1a1e62ded7fc"><td align="right" class="memItemLeft" valign="top">const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a268f1916ed433f16fdbd1a1e62ded7fc">element_ptr</a> (std::size_t element_index) const noexcept</td></tr>
<tr class="memdesc:a268f1916ed433f16fdbd1a1e62ded7fc"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointer to the specified element.  <a href="classrmm_1_1device__uvector.html#a268f1916ed433f16fdbd1a1e62ded7fc">More...</a><br></td></tr>
<tr class="separator:a268f1916ed433f16fdbd1a1e62ded7fc"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a80ff08f7195e98e7de1176097c6651c0"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a80ff08f7195e98e7de1176097c6651c0">set_element</a> (std::size_t element_index, T const &amp;v, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> s)</td></tr>
<tr class="memdesc:a80ff08f7195e98e7de1176097c6651c0"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a synchronous copy of <code>v</code> to the specified element in device memory.  <a href="classrmm_1_1device__uvector.html#a80ff08f7195e98e7de1176097c6651c0">More...</a><br></td></tr>
<tr class="separator:a80ff08f7195e98e7de1176097c6651c0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afbdc625ba4fd0d5c3f87e364bd8c65f6"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#afbdc625ba4fd0d5c3f87e364bd8c65f6">set_element_async</a> (std::size_t element_index, value_type const &amp;v, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> s)</td></tr>
<tr class="memdesc:afbdc625ba4fd0d5c3f87e364bd8c65f6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs an asynchronous copy of <code>v</code> to the specified element in device memory.  <a href="classrmm_1_1device__uvector.html#afbdc625ba4fd0d5c3f87e364bd8c65f6">More...</a><br></td></tr>
<tr class="separator:afbdc625ba4fd0d5c3f87e364bd8c65f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a74209ef05ebdac434d17641ed21b87e7"><td align="right" class="memItemLeft" valign="top"><a id="a74209ef05ebdac434d17641ed21b87e7"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_element_async</b> (std::size_t element_index, value_type const &amp;&amp;v, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> s)=delete</td></tr>
<tr class="separator:a74209ef05ebdac434d17641ed21b87e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adbf5097fbf94b7f147aea7fb571fc3ea"><td align="right" class="memItemLeft" valign="top">value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#adbf5097fbf94b7f147aea7fb571fc3ea">element</a> (std::size_t element_index, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> s) const</td></tr>
<tr class="memdesc:adbf5097fbf94b7f147aea7fb571fc3ea"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the specified element from device memory.  <a href="classrmm_1_1device__uvector.html#adbf5097fbf94b7f147aea7fb571fc3ea">More...</a><br></td></tr>
<tr class="separator:adbf5097fbf94b7f147aea7fb571fc3ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a71df23a3dc3cba930dd70b7cd73d4947"><td align="right" class="memItemLeft" valign="top">value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a71df23a3dc3cba930dd70b7cd73d4947">front_element</a> (<a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> s) const</td></tr>
<tr class="memdesc:a71df23a3dc3cba930dd70b7cd73d4947"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first element.  <a href="classrmm_1_1device__uvector.html#a71df23a3dc3cba930dd70b7cd73d4947">More...</a><br></td></tr>
<tr class="separator:a71df23a3dc3cba930dd70b7cd73d4947"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a01fc23eb75b33021fd2281f6c7941c6e"><td align="right" class="memItemLeft" valign="top">value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a01fc23eb75b33021fd2281f6c7941c6e">back_element</a> (<a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> s) const</td></tr>
<tr class="memdesc:a01fc23eb75b33021fd2281f6c7941c6e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last element.  <a href="classrmm_1_1device__uvector.html#a01fc23eb75b33021fd2281f6c7941c6e">More...</a><br></td></tr>
<tr class="separator:a01fc23eb75b33021fd2281f6c7941c6e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a12352ccb04d368540eb7ebf0ceb6ef20"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a12352ccb04d368540eb7ebf0ceb6ef20">resize</a> (std::size_t new_size, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream)</td></tr>
<tr class="memdesc:a12352ccb04d368540eb7ebf0ceb6ef20"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes the vector to contain <code>new_size</code> elements.  <a href="classrmm_1_1device__uvector.html#a12352ccb04d368540eb7ebf0ceb6ef20">More...</a><br></td></tr>
<tr class="separator:a12352ccb04d368540eb7ebf0ceb6ef20"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a58322e351f40b7419c2e09da3a8a6f47"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a58322e351f40b7419c2e09da3a8a6f47">shrink_to_fit</a> (<a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream)</td></tr>
<tr class="memdesc:a58322e351f40b7419c2e09da3a8a6f47"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces deallocation of unused device memory.  <a href="classrmm_1_1device__uvector.html#a58322e351f40b7419c2e09da3a8a6f47">More...</a><br></td></tr>
<tr class="separator:a58322e351f40b7419c2e09da3a8a6f47"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a90d5b1937703ac8befe42807d5686e4a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classrmm_1_1device__buffer.html">device_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a90d5b1937703ac8befe42807d5686e4a">release</a> () noexcept</td></tr>
<tr class="memdesc:a90d5b1937703ac8befe42807d5686e4a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release ownership of device memory storage.  <a href="classrmm_1_1device__uvector.html#a90d5b1937703ac8befe42807d5686e4a">More...</a><br></td></tr>
<tr class="separator:a90d5b1937703ac8befe42807d5686e4a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a11ada0f15bf7d25a70b6a3c6b4f52f8f"><td align="right" class="memItemLeft" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a11ada0f15bf7d25a70b6a3c6b4f52f8f">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a11ada0f15bf7d25a70b6a3c6b4f52f8f"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements that can be held in currently allocated storage.  <a href="classrmm_1_1device__uvector.html#a11ada0f15bf7d25a70b6a3c6b4f52f8f">More...</a><br></td></tr>
<tr class="separator:a11ada0f15bf7d25a70b6a3c6b4f52f8f"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a53e0aa307e0cc93c4fef5e410f1f40d1"><td align="right" class="memItemLeft" valign="top">pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a53e0aa307e0cc93c4fef5e410f1f40d1">data</a> () noexcept</td></tr>
<tr class="memdesc:a53e0aa307e0cc93c4fef5e410f1f40d1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointer to underlying device storage.  <a href="classrmm_1_1device__uvector.html#a53e0aa307e0cc93c4fef5e410f1f40d1">More...</a><br></td></tr>
<tr class="separator:a53e0aa307e0cc93c4fef5e410f1f40d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2f2100a00c59ae071568812aec023fbd"><td align="right" class="memItemLeft" valign="top">const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a2f2100a00c59ae071568812aec023fbd">data</a> () const noexcept</td></tr>
<tr class="memdesc:a2f2100a00c59ae071568812aec023fbd"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns const pointer to underlying device storage.  <a href="classrmm_1_1device__uvector.html#a2f2100a00c59ae071568812aec023fbd">More...</a><br></td></tr>
<tr class="separator:a2f2100a00c59ae071568812aec023fbd"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afd66a263437a87ff6ec1f3c33f61c589"><td align="right" class="memItemLeft" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#afd66a263437a87ff6ec1f3c33f61c589">begin</a> () noexcept</td></tr>
<tr class="memdesc:afd66a263437a87ff6ec1f3c33f61c589"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator to the first element.  <a href="classrmm_1_1device__uvector.html#afd66a263437a87ff6ec1f3c33f61c589">More...</a><br></td></tr>
<tr class="separator:afd66a263437a87ff6ec1f3c33f61c589"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7de2d89114f7b7aaee795e5d22ebce68"><td align="right" class="memItemLeft" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a7de2d89114f7b7aaee795e5d22ebce68">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a7de2d89114f7b7aaee795e5d22ebce68"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const_iterator to the first element.  <a href="classrmm_1_1device__uvector.html#a7de2d89114f7b7aaee795e5d22ebce68">More...</a><br></td></tr>
<tr class="separator:a7de2d89114f7b7aaee795e5d22ebce68"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:afd5e157b76dcdc58696b5891ee25a3ae"><td align="right" class="memItemLeft" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#afd5e157b76dcdc58696b5891ee25a3ae">begin</a> () const noexcept</td></tr>
<tr class="memdesc:afd5e157b76dcdc58696b5891ee25a3ae"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const_iterator to the first element.  <a href="classrmm_1_1device__uvector.html#afd5e157b76dcdc58696b5891ee25a3ae">More...</a><br></td></tr>
<tr class="separator:afd5e157b76dcdc58696b5891ee25a3ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5acf12a008a67f827cfa61db0ae1e8b1"><td align="right" class="memItemLeft" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a5acf12a008a67f827cfa61db0ae1e8b1">end</a> () noexcept</td></tr>
<tr class="memdesc:a5acf12a008a67f827cfa61db0ae1e8b1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator to the element following the last element of the vector.  <a href="classrmm_1_1device__uvector.html#a5acf12a008a67f827cfa61db0ae1e8b1">More...</a><br></td></tr>
<tr class="separator:a5acf12a008a67f827cfa61db0ae1e8b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a03e450d354cd8264cb3e9645a7fde54c"><td align="right" class="memItemLeft" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a03e450d354cd8264cb3e9645a7fde54c">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a03e450d354cd8264cb3e9645a7fde54c"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const_iterator to the element following the last element of the vector.  <a href="classrmm_1_1device__uvector.html#a03e450d354cd8264cb3e9645a7fde54c">More...</a><br></td></tr>
<tr class="separator:a03e450d354cd8264cb3e9645a7fde54c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab92af2fe8fc1cdf6060524659247c611"><td align="right" class="memItemLeft" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#ab92af2fe8fc1cdf6060524659247c611">end</a> () const noexcept</td></tr>
<tr class="memdesc:ab92af2fe8fc1cdf6060524659247c611"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator to the element following the last element of the vector.  <a href="classrmm_1_1device__uvector.html#ab92af2fe8fc1cdf6060524659247c611">More...</a><br></td></tr>
<tr class="separator:ab92af2fe8fc1cdf6060524659247c611"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4d87b3421b2c9608115709351fa0b693"><td align="right" class="memItemLeft" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693">size</a> () const noexcept</td></tr>
<tr class="memdesc:a4d87b3421b2c9608115709351fa0b693"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements in the vector.  <a href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693">More...</a><br></td></tr>
<tr class="separator:a4d87b3421b2c9608115709351fa0b693"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2d90e6e8ac5ce64b1562f494113ced94"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#a2d90e6e8ac5ce64b1562f494113ced94">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:a2d90e6e8ac5ce64b1562f494113ced94"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the vector contains no elements, i.e., <code><a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a> == 0</code>.  <a href="classrmm_1_1device__uvector.html#a2d90e6e8ac5ce64b1562f494113ced94">More...</a><br></td></tr>
<tr class="separator:a2d90e6e8ac5ce64b1562f494113ced94"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab816bd74178d12d004a6bac4b1b43a34"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">mr::device_memory_resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1device__uvector.html#ab816bd74178d12d004a6bac4b1b43a34">memory_resource</a> () const noexcept</td></tr>
<tr class="memdesc:ab816bd74178d12d004a6bac4b1b43a34"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointer to the resource used to allocate and deallocate the device storage.  <a href="classrmm_1_1device__uvector.html#ab816bd74178d12d004a6bac4b1b43a34">More...</a><br></td></tr>
<tr class="separator:ab816bd74178d12d004a6bac4b1b43a34"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br>
class rmm::device_uvector&lt; T &gt;</h3>
<p>An <em>uninitialized</em> vector of elements in device memory. </p>
<p>Similar to a <code>thrust::device_vector</code>, <code><a class="el" href="classrmm_1_1device__uvector.html" title="An uninitialized vector of elements in device memory.">device_uvector</a></code> is a random access container of elements stored contiguously in device memory. However, unlike <code>thrust::device_vector</code>, <code><a class="el" href="classrmm_1_1device__uvector.html" title="An uninitialized vector of elements in device memory.">device_uvector</a></code> does <em>not</em> default initialize the vector elements.</p>
<p>If initialization is desired, this must be done explicitly by the caller, e.g., with <code>thrust::uninitialized_fill</code>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> * mr = <span class="keyword">new</span> my_custom_resource();</div>
<div class="line"><a class="code" href="classrmm_1_1cuda__stream__view.html">rmm::cuda_stream_view</a> s{};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Allocates *uninitialized* device memory on stream `s` sufficient for 100 ints using the</span></div>
<div class="line"><span class="comment">// supplied resource `mr`</span></div>
<div class="line"><a class="code" href="classrmm_1_1device__uvector.html">rmm::device_uvector&lt;int&gt;</a> uv(100, s, mr);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initializes all elements to 0 on stream `s`</span></div>
<div class="line">thrust::uninitialized_fill(thrust::cuda::par.on(s), uv.begin(), uv.end(), 0);</div>
</div><!-- fragment --><p>Avoiding default initialization improves performance by eliminating the kernel launch required to default initialize the elements. This initialization is often unnecessary, e.g., when the vector is created to hold some output from some operation.</p>
<p>However, this restricts the element type <code>T</code> to only trivially copyable types. In short, trivially copyable types can be safely copied with <code>memcpy</code>. For more information, see <a href="https://en.cppreference.com/w/cpp/types/is_trivially_copyable">https://en.cppreference.com/w/cpp/types/is_trivially_copyable</a>.</p>
<p>Another key difference over <code>thrust::device_vector</code> is that all operations that invoke allocation, kernels, or memcpys take a CUDA stream parameter to indicate on which stream the operation will be performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tbody><tr><td class="paramname">T</td><td>Trivially copyable element type </td></tr>
</tbody></table>
</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaf8e36f398137fea17b8403908c817e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8e36f398137fea17b8403908c817e8">◆&nbsp;</a></span>device_uvector() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname"><a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> </td>
<td>(</td>
<td class="paramtype">std::size_t&nbsp;</td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>stream</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Construct a new <code><a class="el" href="classrmm_1_1device__uvector.html" title="An uninitialized vector of elements in device memory.">device_uvector</a></code> with sufficient uninitialized storage for <code>size</code> elements. </p>
<p>Elements are uninitialized. Reading an element before it is initialized results in undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">size</td><td>The number of elements to allocate storage for </td></tr>
<tr><td class="paramname">stream</td><td>The stream on which to perform the allocation </td></tr>
<tr><td class="paramname">mr</td><td>The resource used to allocate the device storage </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a6e637517602312be687f5231bd20d7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e637517602312be687f5231bd20d7cc">◆&nbsp;</a></span>device_uvector() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname"><a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::<a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classrmm_1_1device__uvector.html">device_uvector</a>&lt; T &gt; const &amp;&nbsp;</td>
<td class="paramname"><em>other</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>stream</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a> *&nbsp;</td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Construct a new <a class="el" href="classrmm_1_1device__uvector.html" title="An uninitialized vector of elements in device memory.">device_uvector</a> by deep copying the contents of another <code><a class="el" href="classrmm_1_1device__uvector.html" title="An uninitialized vector of elements in device memory.">device_uvector</a></code>. </p>
<p>Elements are copied as if by <code>memcpy</code>, i.e., <code>T</code>'s copy constructor is not invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">other</td><td>The vector to copy from </td></tr>
<tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
<tr><td class="paramname">mr</td><td>The resource used to allocate device memory for the new vector </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a01fc23eb75b33021fd2281f6c7941c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fc23eb75b33021fd2281f6c7941c6e">◆&nbsp;</a></span>back_element()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">value_type <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::back_element </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>s</em></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns the last element. </p>
<dl class="section note"><dt>Note</dt><dd>This function incurs a device-to-host memcpy and should be used sparingly. </dd>
<dd>
This function synchronizes <code>stream</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="classrmm_1_1out__of__range.html" title="Exception thrown when attempting to access outside of a defined range.">rmm::out_of_range</a></td><td>exception if the vector is empty.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">s</td><td>The stream on which to perform the copy </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the last element </dd></dl>
</div>
</div>
<a id="afd5e157b76dcdc58696b5891ee25a3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5e157b76dcdc58696b5891ee25a3ae">◆&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">const_iterator <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::begin </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns a const_iterator to the first element. </p>
<p>If the vector is empty, then <code><a class="el" href="classrmm_1_1device__uvector.html#afd66a263437a87ff6ec1f3c33f61c589" title="Returns an iterator to the first element.">begin()</a> == <a class="el" href="classrmm_1_1device__uvector.html#a5acf12a008a67f827cfa61db0ae1e8b1" title="Returns an iterator to the element following the last element of the vector.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Immutable iterator to the first element. </dd></dl>
</div>
</div>
<a id="afd66a263437a87ff6ec1f3c33f61c589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd66a263437a87ff6ec1f3c33f61c589">◆&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">iterator <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::begin </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns an iterator to the first element. </p>
<p>If the vector is empty, then <code><a class="el" href="classrmm_1_1device__uvector.html#afd66a263437a87ff6ec1f3c33f61c589" title="Returns an iterator to the first element.">begin()</a> == <a class="el" href="classrmm_1_1device__uvector.html#a5acf12a008a67f827cfa61db0ae1e8b1" title="Returns an iterator to the element following the last element of the vector.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>
</div>
</div>
<a id="a11ada0f15bf7d25a70b6a3c6b4f52f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ada0f15bf7d25a70b6a3c6b4f52f8f">◆&nbsp;</a></span>capacity()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">std::size_t <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::capacity </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns the number of elements that can be held in currently allocated storage. </p>
<dl class="section return"><dt>Returns</dt><dd>std::size_t The number of elements that can be stored without requiring a new allocation. </dd></dl>
</div>
</div>
<a id="a7de2d89114f7b7aaee795e5d22ebce68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de2d89114f7b7aaee795e5d22ebce68">◆&nbsp;</a></span>cbegin()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">const_iterator <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::cbegin </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns a const_iterator to the first element. </p>
<p>If the vector is empty, then <code><a class="el" href="classrmm_1_1device__uvector.html#a7de2d89114f7b7aaee795e5d22ebce68" title="Returns a const_iterator to the first element.">cbegin()</a> == <a class="el" href="classrmm_1_1device__uvector.html#a03e450d354cd8264cb3e9645a7fde54c" title="Returns a const_iterator to the element following the last element of the vector.">cend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Immutable iterator to the first element. </dd></dl>
</div>
</div>
<a id="a03e450d354cd8264cb3e9645a7fde54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e450d354cd8264cb3e9645a7fde54c">◆&nbsp;</a></span>cend()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">const_iterator <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::cend </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns a const_iterator to the element following the last element of the vector. </p>
<p>The element referenced by <code><a class="el" href="classrmm_1_1device__uvector.html#a5acf12a008a67f827cfa61db0ae1e8b1" title="Returns an iterator to the element following the last element of the vector.">end()</a></code> is a placeholder and dereferencing it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Immutable iterator to one past the last element. </dd></dl>
</div>
</div>
<a id="a2f2100a00c59ae071568812aec023fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2100a00c59ae071568812aec023fbd">◆&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">const_pointer <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::data </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns const pointer to underlying device storage. </p>
<dl class="section note"><dt>Note</dt><dd>If <code><a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a> == 0</code> it is undefined behavior to deference the returned pointer. Furthermore, the returned pointer may or may not be equal to <code>nullptr</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>const_pointer Raw const pointer to element storage in device memory. </dd></dl>
</div>
</div>
<a id="a53e0aa307e0cc93c4fef5e410f1f40d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e0aa307e0cc93c4fef5e410f1f40d1">◆&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">pointer <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::data </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns pointer to underlying device storage. </p>
<dl class="section note"><dt>Note</dt><dd>If <code><a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a> == 0</code> it is undefined behavior to deference the returned pointer. Furthermore, the returned pointer may or may not be equal to <code>nullptr</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to element storage in device memory. </dd></dl>
</div>
</div>
<a id="adbf5097fbf94b7f147aea7fb571fc3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf5097fbf94b7f147aea7fb571fc3ea">◆&nbsp;</a></span>element()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">value_type <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::element </td>
<td>(</td>
<td class="paramtype">std::size_t&nbsp;</td>
<td class="paramname"><em>element_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>s</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns the specified element from device memory. </p>
<dl class="section note"><dt>Note</dt><dd>This function incurs a device to host memcpy and should be used sparingly. </dd>
<dd>
This function synchronizes <code>stream</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="classrmm_1_1out__of__range.html" title="Exception thrown when attempting to access outside of a defined range.">rmm::out_of_range</a></td><td>exception if <code>element_index &gt;= <a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a></code></td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">element_index</td><td>Index of the desired element </td></tr>
<tr><td class="paramname">s</td><td>The stream on which to perform the copy </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the specified element </dd></dl>
</div>
</div>
<a id="a268f1916ed433f16fdbd1a1e62ded7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268f1916ed433f16fdbd1a1e62ded7fc">◆&nbsp;</a></span>element_ptr() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">const_pointer <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::element_ptr </td>
<td>(</td>
<td class="paramtype">std::size_t&nbsp;</td>
<td class="paramname"><em>element_index</em></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns pointer to the specified element. </p>
<p>Behavior is undefined if <code>element_index &gt;= <a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">element_index</td><td>Index of the specified element. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T* Pointer to the desired element </dd></dl>
</div>
</div>
<a id="a736cb6f26d05740356b2250383154275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736cb6f26d05740356b2250383154275">◆&nbsp;</a></span>element_ptr() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">pointer <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::element_ptr </td>
<td>(</td>
<td class="paramtype">std::size_t&nbsp;</td>
<td class="paramname"><em>element_index</em></td><td>)</td>
<td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns pointer to the specified element. </p>
<p>Behavior is undefined if <code>element_index &gt;= <a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">element_index</td><td>Index of the specified element. </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T* Pointer to the desired element </dd></dl>
</div>
</div>
<a id="ab92af2fe8fc1cdf6060524659247c611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92af2fe8fc1cdf6060524659247c611">◆&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">const_iterator <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::end </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns an iterator to the element following the last element of the vector. </p>
<p>The element referenced by <code><a class="el" href="classrmm_1_1device__uvector.html#a5acf12a008a67f827cfa61db0ae1e8b1" title="Returns an iterator to the element following the last element of the vector.">end()</a></code> is a placeholder and dereferencing it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Immutable iterator to one past the last element. </dd></dl>
</div>
</div>
<a id="a5acf12a008a67f827cfa61db0ae1e8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acf12a008a67f827cfa61db0ae1e8b1">◆&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">iterator <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::end </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns an iterator to the element following the last element of the vector. </p>
<p>The element referenced by <code><a class="el" href="classrmm_1_1device__uvector.html#a5acf12a008a67f827cfa61db0ae1e8b1" title="Returns an iterator to the element following the last element of the vector.">end()</a></code> is a placeholder and dereferencing it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to one past the last element. </dd></dl>
</div>
</div>
<a id="a71df23a3dc3cba930dd70b7cd73d4947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71df23a3dc3cba930dd70b7cd73d4947">◆&nbsp;</a></span>front_element()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">value_type <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::front_element </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>s</em></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns the first element. </p>
<dl class="section note"><dt>Note</dt><dd>This function incurs a device-to-host memcpy and should be used sparingly. </dd>
<dd>
This function synchronizes <code>stream</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="classrmm_1_1out__of__range.html" title="Exception thrown when attempting to access outside of a defined range.">rmm::out_of_range</a></td><td>exception if the vector is empty.</td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">s</td><td>The stream on which to perform the copy </td></tr>
</tbody></table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the first element </dd></dl>
</div>
</div>
<a id="a2d90e6e8ac5ce64b1562f494113ced94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d90e6e8ac5ce64b1562f494113ced94">◆&nbsp;</a></span>is_empty()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">bool <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::is_empty </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns true if the vector contains no elements, i.e., <code><a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a> == 0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>true The vector is empty </dd>
<dd>
false The vector is not empty </dd></dl>
</div>
</div>
<a id="ab816bd74178d12d004a6bac4b1b43a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab816bd74178d12d004a6bac4b1b43a34">◆&nbsp;</a></span>memory_resource()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname"><a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">mr::device_memory_resource</a>* <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::memory_resource </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns pointer to the resource used to allocate and deallocate the device storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to underlying resource </dd></dl>
</div>
</div>
<a id="a90d5b1937703ac8befe42807d5686e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d5b1937703ac8befe42807d5686e4a">◆&nbsp;</a></span>release()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname"><a class="el" href="classrmm_1_1device__buffer.html">device_buffer</a> <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::release </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Release ownership of device memory storage. </p>
<dl class="section return"><dt>Returns</dt><dd>The <code><a class="el" href="classrmm_1_1device__buffer.html">device_buffer</a></code> used to store the vector elements </dd></dl>
</div>
</div>
<a id="a12352ccb04d368540eb7ebf0ceb6ef20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12352ccb04d368540eb7ebf0ceb6ef20">◆&nbsp;</a></span>resize()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">void <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::resize </td>
<td>(</td>
<td class="paramtype">std::size_t&nbsp;</td>
<td class="paramname"><em>new_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>stream</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Resizes the vector to contain <code>new_size</code> elements. </p>
<p>If <code>new_size &gt; <a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a></code>, the additional elements are uninitialized.</p>
<p>If <code>new_size &lt; <a class="el" href="classrmm_1_1device__uvector.html#a11ada0f15bf7d25a70b6a3c6b4f52f8f" title="Returns the number of elements that can be held in currently allocated storage.">capacity()</a></code>, no action is taken other than updating the value of <code><a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a></code>. No memory is allocated nor copied. <code><a class="el" href="classrmm_1_1device__uvector.html#a58322e351f40b7419c2e09da3a8a6f47" title="Forces deallocation of unused device memory.">shrink_to_fit()</a></code> may be used to force deallocation of unused memory.</p>
<p>If <code>new_size &gt; <a class="el" href="classrmm_1_1device__uvector.html#a11ada0f15bf7d25a70b6a3c6b4f52f8f" title="Returns the number of elements that can be held in currently allocated storage.">capacity()</a></code>, elements are copied as if by mempcy to a new allocation.</p>
<p>The invariant <code><a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a> &lt;= <a class="el" href="classrmm_1_1device__uvector.html#a11ada0f15bf7d25a70b6a3c6b4f52f8f" title="Returns the number of elements that can be held in currently allocated storage.">capacity()</a></code> holds.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">new_size</td><td>The desired number of elements </td></tr>
<tr><td class="paramname">stream</td><td>The stream on which to perform the allocation/copy (if any) </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a80ff08f7195e98e7de1176097c6651c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ff08f7195e98e7de1176097c6651c0">◆&nbsp;</a></span>set_element()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">void <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::set_element </td>
<td>(</td>
<td class="paramtype">std::size_t&nbsp;</td>
<td class="paramname"><em>element_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">T const &amp;&nbsp;</td>
<td class="paramname"><em>v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>s</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Performs a synchronous copy of <code>v</code> to the specified element in device memory. </p>
<p>Because this function synchronizes the stream <code>s</code>, it is safe to destroy or modify the object referenced by <code>v</code> after this function has returned.</p>
<dl class="section note"><dt>Note</dt><dd>This function incurs a host to device memcpy and should be used sparingly. </dd>
<dd>
This function synchronizes <code>stream</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classrmm_1_1device__uvector.html">rmm::device_uvector&lt;int32_t&gt;</a> vec(100, stream);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> v{42};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Copies 42 to element 0 on `stream` and synchronizes the stream</span></div>
<div class="line">vec.set_element(0, v, stream);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// It is safe to destroy or modify `v`</span></div>
<div class="line">v = 13;</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="classrmm_1_1out__of__range.html" title="Exception thrown when attempting to access outside of a defined range.">rmm::out_of_range</a></td><td>exception if <code>element_index &gt;= <a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a></code></td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">element_index</td><td>Index of the target element </td></tr>
<tr><td class="paramname">v</td><td>The value to copy to the specified element </td></tr>
<tr><td class="paramname">s</td><td>The stream on which to perform the copy </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="afbdc625ba4fd0d5c3f87e364bd8c65f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdc625ba4fd0d5c3f87e364bd8c65f6">◆&nbsp;</a></span>set_element_async()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">void <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::set_element_async </td>
<td>(</td>
<td class="paramtype">std::size_t&nbsp;</td>
<td class="paramname"><em>element_index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">value_type const &amp;&nbsp;</td>
<td class="paramname"><em>v</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>s</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Performs an asynchronous copy of <code>v</code> to the specified element in device memory. </p>
<p>This function does not synchronize stream <code>s</code> before returning. Therefore, the object referenced by <code>v</code> should not be destroyed or modified until <code>stream</code> has been synchronized. Otherwise, behavior is undefined.</p>
<dl class="section note"><dt>Note</dt><dd>This function incurs a host to device memcpy and should be used sparingly.</dd>
<dd>
Calling this function with a literal or other r-value reference for <code>v</code> is disallowed to prevent the implementation from asynchronously copying from a literal or other implicit temporary after it is deleted or goes out of scope.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classrmm_1_1device__uvector.html">rmm::device_uvector&lt;int32_t&gt;</a> vec(100, stream);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> v{42};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Copies 42 to element 0 on `stream`. Does _not_ synchronize</span></div>
<div class="line">vec.set_element_async(0, v, stream);</div>
<div class="line">...</div>
<div class="line">cudaStreamSynchronize(stream);</div>
<div class="line"><span class="comment">// Synchronization is required before `v` can be modified</span></div>
<div class="line">v = 13;</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tbody><tr><td class="paramname"><a class="el" href="classrmm_1_1out__of__range.html" title="Exception thrown when attempting to access outside of a defined range.">rmm::out_of_range</a></td><td>exception if <code>element_index &gt;= <a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a></code></td></tr>
</tbody></table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">element_index</td><td>Index of the target element </td></tr>
<tr><td class="paramname">v</td><td>The value to copy to the specified element </td></tr>
<tr><td class="paramname">s</td><td>The stream on which to perform the copy </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a58322e351f40b7419c2e09da3a8a6f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58322e351f40b7419c2e09da3a8a6f47">◆&nbsp;</a></span>shrink_to_fit()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">void <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::shrink_to_fit </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
<td class="paramname"><em>stream</em></td><td>)</td>
<td></td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Forces deallocation of unused device memory. </p>
<p>If <code><a class="el" href="classrmm_1_1device__uvector.html#a11ada0f15bf7d25a70b6a3c6b4f52f8f" title="Returns the number of elements that can be held in currently allocated storage.">capacity()</a> &gt; <a class="el" href="classrmm_1_1device__uvector.html#a4d87b3421b2c9608115709351fa0b693" title="Returns the number of elements in the vector.">size()</a></code>, reallocates and copies vector contents to eliminate unused memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tbody><tr><td class="paramname">stream</td><td>Stream on which to perform allocation and copy </td></tr>
</tbody></table>
</dd>
</dl>
</div>
</div>
<a id="a4d87b3421b2c9608115709351fa0b693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d87b3421b2c9608115709351fa0b693">◆&nbsp;</a></span>size()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tbody><tr>
<td class="mlabels-left">
<table class="memname">
<tbody><tr>
<td class="memname">std::size_t <a class="el" href="classrmm_1_1device__uvector.html">rmm::device_uvector</a>&lt; T &gt;::size </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</tbody></table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span> </td>
</tr>
</tbody></table>
</div><div class="memdoc">
<p>Returns the number of elements in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements. </dd></dl>
</div>
</div>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="device__uvector_8hpp_source.html">device_uvector.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassrmm_1_1cuda__stream__view_html"><div class="ttname"><a href="classrmm_1_1cuda__stream__view.html">rmm::cuda_stream_view</a></div><div class="ttdoc">Strongly-typed non-owning wrapper for CUDA streams with default constructor.</div><div class="ttdef"><b>Definition:</b> cuda_stream_view.hpp:34</div></div>
<div class="ttc" id="aclassrmm_1_1device__uvector_html"><div class="ttname"><a href="classrmm_1_1device__uvector.html">rmm::device_uvector</a></div><div class="ttdoc">An uninitialized vector of elements in device memory.</div><div class="ttdef"><b>Definition:</b> device_uvector.hpp:68</div></div>
<div class="ttc" id="aclassrmm_1_1mr_1_1device__memory__resource_html"><div class="ttname"><a href="classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a></div><div class="ttdoc">Base class for all libcudf device memory allocation.</div><div class="ttdef"><b>Definition:</b> device_memory_resource.hpp:83</div></div>
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body></html>