<!-- HTML header for doxygen 1.8.20--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type">
<meta content="IE=9" http-equiv="X-UA-Compatible">
<meta content="Doxygen 1.8.20" name="generator">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>RMM: rmm::mr::pool_memory_resource&lt; Upstream &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- RAPIDS CUSTOM JS & CSS: START, Please add these two lines back after every version upgrade -->
<script defer="" src="https://docs.rapids.ai/assets/js/custom.js"></script>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet">
<!-- RAPIDS CUSTOM JS & CSS: END -->
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"><script id="rapids-selector-pixel-src" src="https://assets.adobedtm.com/5d4962a43b79/814eb6e9b4e1/launch-4bc07f1e0b0b.min.js"></script><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">librmm</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/nightly">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/kvikio/stable/api.html">kvikio</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libcuspatial/stable">libcuspatial</a><a class="rapids-selector__menu-item" href="/api/libkvikio/stable">libkvikio</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/raft/stable">raft</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (23.02)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/librmm/nightly/annotated.html">nightly (23.02)</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">stable (22.12)</a><a class="rapids-selector__menu-item" href="/api/librmm/legacy/annotated.html">legacy (22.10)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>

<div class="navpath" id="nav-path">
  <ul>
<li class="navelem"><b>rmm</b></li><li class="navelem"><b>mr</b></li><li class="navelem"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="#pro-types">Protected Types</a> |
<a href="#pro-methods">Protected Member Functions</a> |
<a href="#friends">Friends</a> |
<a href="classrmm_1_1mr_1_1pool__memory__resource-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rmm::mr::pool_memory_resource&lt; Upstream &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A coalescing best-fit suballocator which uses a pool of memory allocated from an upstream memory_resource.  
 <a href="classrmm_1_1mr_1_1pool__memory__resource.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pool__memory__resource_8hpp_source.html">pool_memory_resource.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rmm::mr::pool_memory_resource&lt; Upstream &gt;:</div>
<div class="dyncontent">
<div class="center"><img alt="Inheritance graph" border="0" src="classrmm_1_1mr_1_1pool__memory__resource__inherit__graph.png" usemap="#armm_1_1mr_1_1pool__memory__resource_3_01Upstream_01_4_inherit__map"></div>
<map id="armm_1_1mr_1_1pool__memory__resource_3_01Upstream_01_4_inherit__map" name="rmm_1_1mr_1_1pool__memory__resource_3_01Upstream_01_4_inherit__map">
<area alt="" coords="520,50,699,91" shape="rect" title="A coalescing best-fit suballocator which uses a pool of memory allocated from an upstream memory_reso...">
<area alt="" coords="245,28,472,113" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html" shape="rect" title=" ">
<area alt="" coords="6,5,197,61" href="structrmm_1_1mr_1_1detail_1_1crtp.html" shape="rect" title=" ">
<area alt="" coords="5,86,197,127" href="classrmm_1_1mr_1_1device__memory__resource.html" shape="rect" title="Base class for all libcudf device memory allocation.">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rmm::mr::pool_memory_resource&lt; Upstream &gt;:</div>
<div class="dyncontent">
<div class="center"><img alt="Collaboration graph" border="0" src="classrmm_1_1mr_1_1pool__memory__resource__coll__graph.png" usemap="#armm_1_1mr_1_1pool__memory__resource_3_01Upstream_01_4_coll__map"></div>
<map id="armm_1_1mr_1_1pool__memory__resource_3_01Upstream_01_4_coll__map" name="rmm_1_1mr_1_1pool__memory__resource_3_01Upstream_01_4_coll__map">
<area alt="" coords="520,50,699,91" shape="rect" title="A coalescing best-fit suballocator which uses a pool of memory allocated from an upstream memory_reso...">
<area alt="" coords="245,28,472,113" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html" shape="rect" title=" ">
<area alt="" coords="6,5,197,61" href="structrmm_1_1mr_1_1detail_1_1crtp.html" shape="rect" title=" ">
<area alt="" coords="5,86,197,127" href="classrmm_1_1mr_1_1device__memory__resource.html" shape="rect" title="Base class for all libcudf device memory allocation.">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe379e73e90282a0efd2ef1569ce22a5"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#afe379e73e90282a0efd2ef1569ce22a5">pool_memory_resource</a> (Upstream *upstream_mr, thrust::optional&lt; std::size_t &gt; initial_pool_size=thrust::nullopt, thrust::optional&lt; std::size_t &gt; maximum_pool_size=thrust::nullopt)</td></tr>
<tr class="memdesc:afe379e73e90282a0efd2ef1569ce22a5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <code><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html" title="A coalescing best-fit suballocator which uses a pool of memory allocated from an upstream memory_reso...">pool_memory_resource</a></code> and allocate the initial device memory pool using <code>upstream_mr</code>.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#afe379e73e90282a0efd2ef1569ce22a5">More...</a><br></td></tr>
<tr class="separator:afe379e73e90282a0efd2ef1569ce22a5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acf2d916010f1bdb218f214f09821b3bf"><td align="right" class="memItemLeft" valign="top"><a id="acf2d916010f1bdb218f214f09821b3bf"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#acf2d916010f1bdb218f214f09821b3bf">~pool_memory_resource</a> () override</td></tr>
<tr class="memdesc:acf2d916010f1bdb218f214f09821b3bf"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the <code><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html" title="A coalescing best-fit suballocator which uses a pool of memory allocated from an upstream memory_reso...">pool_memory_resource</a></code> and deallocate all memory it allocated using the upstream resource. <br></td></tr>
<tr class="separator:acf2d916010f1bdb218f214f09821b3bf"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a23dea77d297c9fe376929fa98291eb03"><td align="right" class="memItemLeft" valign="top"><a id="a23dea77d297c9fe376929fa98291eb03"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>pool_memory_resource</b> (<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a> const &amp;)=delete</td></tr>
<tr class="separator:a23dea77d297c9fe376929fa98291eb03"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a160f113adbce6cb0d35d4966b8780f60"><td align="right" class="memItemLeft" valign="top"><a id="a160f113adbce6cb0d35d4966b8780f60"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>pool_memory_resource</b> (<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a160f113adbce6cb0d35d4966b8780f60"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4656371d86484d31f60d0699a1227c80"><td align="right" class="memItemLeft" valign="top"><a id="a4656371d86484d31f60d0699a1227c80"></a>
<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a> const &amp;)=delete</td></tr>
<tr class="separator:a4656371d86484d31f60d0699a1227c80"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7cc3092e136d88f96fc3602691aa8306"><td align="right" class="memItemLeft" valign="top"><a id="a7cc3092e136d88f96fc3602691aa8306"></a>
<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a7cc3092e136d88f96fc3602691aa8306"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3984b5b250cf0380ba36b03fe62d4f6a"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a3984b5b250cf0380ba36b03fe62d4f6a">supports_streams</a> () const noexcept override</td></tr>
<tr class="memdesc:a3984b5b250cf0380ba36b03fe62d4f6a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries whether the resource supports use of non-null CUDA streams for allocation/deallocation.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a3984b5b250cf0380ba36b03fe62d4f6a">More...</a><br></td></tr>
<tr class="separator:a3984b5b250cf0380ba36b03fe62d4f6a"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7bc1a125d8ac7fbcb8df3057865357a0"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a7bc1a125d8ac7fbcb8df3057865357a0">supports_get_mem_info</a> () const noexcept override</td></tr>
<tr class="memdesc:a7bc1a125d8ac7fbcb8df3057865357a0"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query whether the resource supports the get_mem_info API.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a7bc1a125d8ac7fbcb8df3057865357a0">More...</a><br></td></tr>
<tr class="separator:a7bc1a125d8ac7fbcb8df3057865357a0"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a7d8ad0f62b020049239f1642a1099039"><td align="right" class="memItemLeft" valign="top">Upstream *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a7d8ad0f62b020049239f1642a1099039">get_upstream</a> () const noexcept</td></tr>
<tr class="memdesc:a7d8ad0f62b020049239f1642a1099039"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the upstream memory_resource object.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a7d8ad0f62b020049239f1642a1099039">More...</a><br></td></tr>
<tr class="separator:a7d8ad0f62b020049239f1642a1099039"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac7159078675d349b7fe7a8b3429339c6"><td align="right" class="memItemLeft" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#ac7159078675d349b7fe7a8b3429339c6">pool_size</a> () const noexcept</td></tr>
<tr class="memdesc:ac7159078675d349b7fe7a8b3429339c6"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the size of the current pool.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#ac7159078675d349b7fe7a8b3429339c6">More...</a><br></td></tr>
<tr class="separator:ac7159078675d349b7fe7a8b3429339c6"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="inherit_header pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource')"><img alt="-" src="closed.png">&nbsp;Public Member Functions inherited from <a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">rmm::mr::detail::stream_ordered_memory_resource&lt; pool_memory_resource&lt; Upstream &gt;, detail::coalescing_free_list &gt;</a></td></tr>
<tr class="memitem:af4176ff212f7d073443026dfc69b269f inherit pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="af4176ff212f7d073443026dfc69b269f"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>stream_ordered_memory_resource</b> (<a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">stream_ordered_memory_resource</a> const &amp;)=delete</td></tr>
<tr class="separator:af4176ff212f7d073443026dfc69b269f inherit pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8f737695f280cb4301915240c4ceb02a inherit pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a8f737695f280cb4301915240c4ceb02a"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>stream_ordered_memory_resource</b> (<a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">stream_ordered_memory_resource</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a8f737695f280cb4301915240c4ceb02a inherit pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2e37d65baa1d3698b096df10e2acd7e9 inherit pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a2e37d65baa1d3698b096df10e2acd7e9"></a>
<a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">stream_ordered_memory_resource</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">stream_ordered_memory_resource</a> const &amp;)=delete</td></tr>
<tr class="separator:a2e37d65baa1d3698b096df10e2acd7e9 inherit pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a74a6f340d5ea6d036bb947a20d7f77f4 inherit pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a74a6f340d5ea6d036bb947a20d7f77f4"></a>
<a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">stream_ordered_memory_resource</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">stream_ordered_memory_resource</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a74a6f340d5ea6d036bb947a20d7f77f4 inherit pub_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="inherit_header pub_methods_structrmm_1_1mr_1_1detail_1_1crtp"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structrmm_1_1mr_1_1detail_1_1crtp')"><img alt="-" src="closed.png">&nbsp;Public Member Functions inherited from <a class="el" href="structrmm_1_1mr_1_1detail_1_1crtp.html">rmm::mr::detail::crtp&lt; pool_memory_resource&lt; Upstream &gt; &gt;</a></td></tr>
<tr class="memitem:a691d9294763840ef4174208444495992 inherit pub_methods_structrmm_1_1mr_1_1detail_1_1crtp"><td align="right" class="memItemLeft" valign="top"><a id="a691d9294763840ef4174208444495992"></a>
<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a>&lt; Upstream &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>underlying</b> ()</td></tr>
<tr class="separator:a691d9294763840ef4174208444495992 inherit pub_methods_structrmm_1_1mr_1_1detail_1_1crtp"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a067c424b53bbe70f677e6c4377c45bff inherit pub_methods_structrmm_1_1mr_1_1detail_1_1crtp"><td align="right" class="memItemLeft" valign="top"><a id="a067c424b53bbe70f677e6c4377c45bff"></a>
<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a>&lt; Upstream &gt; const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>underlying</b> () const</td></tr>
<tr class="separator:a067c424b53bbe70f677e6c4377c45bff inherit pub_methods_structrmm_1_1mr_1_1detail_1_1crtp"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="inherit_header pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrmm_1_1mr_1_1device__memory__resource')"><img alt="-" src="closed.png">&nbsp;Public Member Functions inherited from <a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a></td></tr>
<tr class="memitem:acc4528bd5f95ca3cb85b9940217e0f83 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="acc4528bd5f95ca3cb85b9940217e0f83"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>device_memory_resource</b> (<a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">device_memory_resource</a> const &amp;)=default</td></tr>
<tr class="separator:acc4528bd5f95ca3cb85b9940217e0f83 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8c8df497e0066c89fb5570aff38f231e inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a8c8df497e0066c89fb5570aff38f231e"></a>
<a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">device_memory_resource</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">device_memory_resource</a> const &amp;)=default</td></tr>
<tr class="separator:a8c8df497e0066c89fb5570aff38f231e inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a21eb17658438dff037483606b4a56090 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a21eb17658438dff037483606b4a56090"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>device_memory_resource</b> (<a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">device_memory_resource</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a21eb17658438dff037483606b4a56090 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6d6424210e67152eeff458712de59fe5 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a6d6424210e67152eeff458712de59fe5"></a>
<a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">device_memory_resource</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">device_memory_resource</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a6d6424210e67152eeff458712de59fe5 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a54b78031deb92654df581d496b9b8099 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td align="right" class="memItemLeft" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html#a54b78031deb92654df581d496b9b8099">allocate</a> (std::size_t bytes, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream=<a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>{})</td></tr>
<tr class="memdesc:a54b78031deb92654df581d496b9b8099 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates memory of size at least <code>bytes</code>.  <a href="classrmm_1_1mr_1_1device__memory__resource.html#a54b78031deb92654df581d496b9b8099">More...</a><br></td></tr>
<tr class="separator:a54b78031deb92654df581d496b9b8099 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8c0227abc75ee1804fe6f11726bd1ed1 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html#a8c0227abc75ee1804fe6f11726bd1ed1">deallocate</a> (void *ptr, std::size_t bytes, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream=<a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>{})</td></tr>
<tr class="memdesc:a8c0227abc75ee1804fe6f11726bd1ed1 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate memory pointed to by <code>p</code>.  <a href="classrmm_1_1mr_1_1device__memory__resource.html#a8c0227abc75ee1804fe6f11726bd1ed1">More...</a><br></td></tr>
<tr class="separator:a8c0227abc75ee1804fe6f11726bd1ed1 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aeaed913bfdd02266062b7880d5bb350f inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html#aeaed913bfdd02266062b7880d5bb350f">is_equal</a> (<a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">device_memory_resource</a> const &amp;other) const noexcept</td></tr>
<tr class="memdesc:aeaed913bfdd02266062b7880d5bb350f inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare this resource to another.  <a href="classrmm_1_1mr_1_1device__memory__resource.html#aeaed913bfdd02266062b7880d5bb350f">More...</a><br></td></tr>
<tr class="separator:aeaed913bfdd02266062b7880d5bb350f inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a017ba1b464063d71942875a5178f8668 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td align="right" class="memItemLeft" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html#a017ba1b464063d71942875a5178f8668">get_mem_info</a> (<a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream) const</td></tr>
<tr class="memdesc:a017ba1b464063d71942875a5178f8668 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the amount of free and total memory for the resource.  <a href="classrmm_1_1mr_1_1device__memory__resource.html#a017ba1b464063d71942875a5178f8668">More...</a><br></td></tr>
<tr class="separator:a017ba1b464063d71942875a5178f8668 inherit pub_methods_classrmm_1_1mr_1_1device__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:acfd207d1f6037f84944dc9bcff37e643"><td align="right" class="memItemLeft" valign="top"><a id="acfd207d1f6037f84944dc9bcff37e643"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>free_list</b> = <a class="el" href="structrmm_1_1mr_1_1detail_1_1coalescing__free__list.html">detail::coalescing_free_list</a></td></tr>
<tr class="separator:acfd207d1f6037f84944dc9bcff37e643"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4df78cb76697bf0dcf307ca148e0f1ca"><td align="right" class="memItemLeft" valign="top"><a id="a4df78cb76697bf0dcf307ca148e0f1ca"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>block_type</b> = <a class="el" href="structrmm_1_1mr_1_1detail_1_1block.html">free_list::block_type</a></td></tr>
<tr class="separator:a4df78cb76697bf0dcf307ca148e0f1ca"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa87e80a02ccdaa61068d8a38ce87b460"><td align="right" class="memItemLeft" valign="top"><a id="aa87e80a02ccdaa61068d8a38ce87b460"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>lock_guard</b> = std::lock_guard&lt; std::mutex &gt;</td></tr>
<tr class="separator:aa87e80a02ccdaa61068d8a38ce87b460"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="inherit_header pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource')"><img alt="-" src="closed.png">&nbsp;Protected Types inherited from <a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">rmm::mr::detail::stream_ordered_memory_resource&lt; pool_memory_resource&lt; Upstream &gt;, detail::coalescing_free_list &gt;</a></td></tr>
<tr class="memitem:a189c56e426f3ad14f90584435ccceeed inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a189c56e426f3ad14f90584435ccceeed"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>free_list</b> = <a class="el" href="structrmm_1_1mr_1_1detail_1_1coalescing__free__list.html">detail::coalescing_free_list</a></td></tr>
<tr class="separator:a189c56e426f3ad14f90584435ccceeed inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a89c7dd7c132bcd38eedaa324736e57e6 inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a89c7dd7c132bcd38eedaa324736e57e6"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>block_type</b> = typename <a class="el" href="structrmm_1_1mr_1_1detail_1_1block.html">free_list::block_type</a></td></tr>
<tr class="separator:a89c7dd7c132bcd38eedaa324736e57e6 inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa00fff7c46c352d59114201f94cb1262 inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="aa00fff7c46c352d59114201f94cb1262"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><b>lock_guard</b> = std::lock_guard&lt; std::mutex &gt;</td></tr>
<tr class="separator:aa00fff7c46c352d59114201f94cb1262 inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a80561e617cbaf5a13aafe4e76593367f inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="a80561e617cbaf5a13aafe4e76593367f"></a>
using&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#a80561e617cbaf5a13aafe4e76593367f">split_block</a> = std::pair&lt; block_type, block_type &gt;</td></tr>
<tr class="memdesc:a80561e617cbaf5a13aafe4e76593367f inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pair representing a block that has been split for allocation. <br></td></tr>
<tr class="separator:a80561e617cbaf5a13aafe4e76593367f inherit pro_types_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6d0c0b77cfb7db5e1ef9e4bee8b29102"><td align="right" class="memItemLeft" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a6d0c0b77cfb7db5e1ef9e4bee8b29102">get_maximum_allocation_size</a> () const</td></tr>
<tr class="memdesc:a6d0c0b77cfb7db5e1ef9e4bee8b29102"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum size of allocations supported by this memory resource.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a6d0c0b77cfb7db5e1ef9e4bee8b29102">More...</a><br></td></tr>
<tr class="separator:a6d0c0b77cfb7db5e1ef9e4bee8b29102"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9cf3b3ae8e75322c61ef8514b3f400be"><td align="right" class="memItemLeft" valign="top">block_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a9cf3b3ae8e75322c61ef8514b3f400be">try_to_expand</a> (std::size_t try_size, std::size_t min_size, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream)</td></tr>
<tr class="memdesc:a9cf3b3ae8e75322c61ef8514b3f400be"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to expand the pool by allocating a block of at least <code>min_size</code> bytes from upstream.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a9cf3b3ae8e75322c61ef8514b3f400be">More...</a><br></td></tr>
<tr class="separator:a9cf3b3ae8e75322c61ef8514b3f400be"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a04d480a01723347527c62772c2c7e8b9"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a04d480a01723347527c62772c2c7e8b9">initialize_pool</a> (thrust::optional&lt; std::size_t &gt; initial_size, thrust::optional&lt; std::size_t &gt; maximum_size)</td></tr>
<tr class="memdesc:a04d480a01723347527c62772c2c7e8b9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate initial memory for the pool.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a04d480a01723347527c62772c2c7e8b9">More...</a><br></td></tr>
<tr class="separator:a04d480a01723347527c62772c2c7e8b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6fc2f58dc325d8d5851ba0b40c952f5e"><td align="right" class="memItemLeft" valign="top">block_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a6fc2f58dc325d8d5851ba0b40c952f5e">expand_pool</a> (std::size_t size, <a class="el" href="structrmm_1_1mr_1_1detail_1_1coalescing__free__list.html">free_list</a> &amp;blocks, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream)</td></tr>
<tr class="memdesc:a6fc2f58dc325d8d5851ba0b40c952f5e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate space from upstream to supply the suballocation pool and return a sufficiently sized block.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a6fc2f58dc325d8d5851ba0b40c952f5e">More...</a><br></td></tr>
<tr class="separator:a6fc2f58dc325d8d5851ba0b40c952f5e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2fab047603acc9b8152b691881476da8"><td align="right" class="memItemLeft" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a2fab047603acc9b8152b691881476da8">size_to_grow</a> (std::size_t size) const</td></tr>
<tr class="memdesc:a2fab047603acc9b8152b691881476da8"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a minimum size, computes an appropriate size to grow the pool.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a2fab047603acc9b8152b691881476da8">More...</a><br></td></tr>
<tr class="separator:a2fab047603acc9b8152b691881476da8"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a4c687e04a1cc07fe5f9cfee3105f5335"><td align="right" class="memItemLeft" valign="top">thrust::optional&lt; block_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a4c687e04a1cc07fe5f9cfee3105f5335">block_from_upstream</a> (std::size_t size, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream)</td></tr>
<tr class="memdesc:a4c687e04a1cc07fe5f9cfee3105f5335"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block from upstream to expand the suballocation pool.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a4c687e04a1cc07fe5f9cfee3105f5335">More...</a><br></td></tr>
<tr class="separator:a4c687e04a1cc07fe5f9cfee3105f5335"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1c587aaeb13b96bda73f9af1ffaee76e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#a80561e617cbaf5a13aafe4e76593367f">split_block</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a1c587aaeb13b96bda73f9af1ffaee76e">allocate_from_block</a> (block_type const &amp;block, std::size_t size)</td></tr>
<tr class="memdesc:a1c587aaeb13b96bda73f9af1ffaee76e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Splits <code>block</code> if necessary to return a pointer to memory of <code>size</code> bytes.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a1c587aaeb13b96bda73f9af1ffaee76e">More...</a><br></td></tr>
<tr class="separator:a1c587aaeb13b96bda73f9af1ffaee76e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a13148a206f1763fba4cd18931f3418aa"><td align="right" class="memItemLeft" valign="top">block_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a13148a206f1763fba4cd18931f3418aa">free_block</a> (void *ptr, std::size_t size) noexcept</td></tr>
<tr class="memdesc:a13148a206f1763fba4cd18931f3418aa"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds, frees and returns the block associated with pointer <code>ptr</code>.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a13148a206f1763fba4cd18931f3418aa">More...</a><br></td></tr>
<tr class="separator:a13148a206f1763fba4cd18931f3418aa"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a9b2f74a2c248a1b9224c169b8b9e3fa2"><td align="right" class="memItemLeft" valign="top"><a id="a9b2f74a2c248a1b9224c169b8b9e3fa2"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a9b2f74a2c248a1b9224c169b8b9e3fa2">release</a> ()</td></tr>
<tr class="memdesc:a9b2f74a2c248a1b9224c169b8b9e3fa2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all memory allocated from the upstream memory_resource. <br></td></tr>
<tr class="separator:a9b2f74a2c248a1b9224c169b8b9e3fa2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5b75713a57836096f79d00c1544d314e"><td align="right" class="memItemLeft" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a5b75713a57836096f79d00c1544d314e">free_list_summary</a> (<a class="el" href="structrmm_1_1mr_1_1detail_1_1coalescing__free__list.html">free_list</a> const &amp;blocks)</td></tr>
<tr class="memdesc:a5b75713a57836096f79d00c1544d314e"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the largest available block size and total free size in the specified free list.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a5b75713a57836096f79d00c1544d314e">More...</a><br></td></tr>
<tr class="separator:a5b75713a57836096f79d00c1544d314e"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a5cac2b0ee64cf7458934f6d7393c40a3"><td align="right" class="memItemLeft" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html#a5cac2b0ee64cf7458934f6d7393c40a3">do_get_mem_info</a> (<a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream) const override</td></tr>
<tr class="memdesc:a5cac2b0ee64cf7458934f6d7393c40a3"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get free and available memory for memory resource.  <a href="classrmm_1_1mr_1_1pool__memory__resource.html#a5cac2b0ee64cf7458934f6d7393c40a3">More...</a><br></td></tr>
<tr class="separator:a5cac2b0ee64cf7458934f6d7393c40a3"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="inherit_header pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource')"><img alt="-" src="closed.png">&nbsp;Protected Member Functions inherited from <a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html">rmm::mr::detail::stream_ordered_memory_resource&lt; pool_memory_resource&lt; Upstream &gt;, detail::coalescing_free_list &gt;</a></td></tr>
<tr class="memitem:ac1daa0cf0aa4d20d628197b0383d5afd inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#ac1daa0cf0aa4d20d628197b0383d5afd">insert_block</a> (block_type const &amp;<a class="el" href="structrmm_1_1mr_1_1detail_1_1block.html">block</a>, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream)</td></tr>
<tr class="memdesc:ac1daa0cf0aa4d20d628197b0383d5afd inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the block <code>b</code> (last used on stream <code>stream_event</code>) to the pool.  <a href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#ac1daa0cf0aa4d20d628197b0383d5afd">More...</a><br></td></tr>
<tr class="separator:ac1daa0cf0aa4d20d628197b0383d5afd inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa797194007141fa6d1aba8b2c189f057 inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top"><a id="aa797194007141fa6d1aba8b2c189f057"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>insert_blocks</b> (<a class="el" href="structrmm_1_1mr_1_1detail_1_1coalescing__free__list.html">free_list</a> &amp;&amp;blocks, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream)</td></tr>
<tr class="separator:aa797194007141fa6d1aba8b2c189f057 inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a115882e92e73a7e76cf51537dbceab9b inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top">std::mutex &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#a115882e92e73a7e76cf51537dbceab9b">get_mutex</a> ()</td></tr>
<tr class="memdesc:a115882e92e73a7e76cf51537dbceab9b inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutex object.  <a href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#a115882e92e73a7e76cf51537dbceab9b">More...</a><br></td></tr>
<tr class="separator:a115882e92e73a7e76cf51537dbceab9b inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ac8545c712c41a34a27159531e069c7f6 inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#ac8545c712c41a34a27159531e069c7f6">do_allocate</a> (std::size_t size, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream) override</td></tr>
<tr class="memdesc:ac8545c712c41a34a27159531e069c7f6 inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates memory of size at least <code>bytes</code>.  <a href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#ac8545c712c41a34a27159531e069c7f6">More...</a><br></td></tr>
<tr class="separator:ac8545c712c41a34a27159531e069c7f6 inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a0b45555ae4ead99f9fc578cf05e1c82f inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#a0b45555ae4ead99f9fc578cf05e1c82f">do_deallocate</a> (void *ptr, std::size_t size, <a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a> stream) override</td></tr>
<tr class="memdesc:a0b45555ae4ead99f9fc578cf05e1c82f inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate memory pointed to by <code>p</code>.  <a href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#a0b45555ae4ead99f9fc578cf05e1c82f">More...</a><br></td></tr>
<tr class="separator:a0b45555ae4ead99f9fc578cf05e1c82f inherit pro_methods_classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table><table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a29f548b52c12960379bed60af7096c0c"><td align="right" class="memItemLeft" valign="top"><a id="a29f548b52c12960379bed60af7096c0c"></a>
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>detail::stream_ordered_memory_resource&lt; pool_memory_resource&lt; Upstream &gt;, detail::coalescing_free_list &gt;</b></td></tr>
<tr class="separator:a29f548b52c12960379bed60af7096c0c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Upstream&gt;<br>
class rmm::mr::pool_memory_resource&lt; Upstream &gt;</h3>

<p>A coalescing best-fit suballocator which uses a pool of memory allocated from an upstream memory_resource. </p>
<p>Allocation (<a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#ac8545c712c41a34a27159531e069c7f6" title="Allocates memory of size at least bytes.">do_allocate()</a>) and deallocation (<a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#a0b45555ae4ead99f9fc578cf05e1c82f" title="Deallocate memory pointed to by p.">do_deallocate()</a>) are thread-safe. Also, this class is compatible with CUDA per-thread default stream.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">UpstreamResource</td><td>memory_resource to use for allocating the pool. Implements <a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html" title="Base class for all libcudf device memory allocation.">rmm::mr::device_memory_resource</a> interface. </td></tr>
  </tbody></table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afe379e73e90282a0efd2ef1569ce22a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe379e73e90282a0efd2ef1569ce22a5">◆&nbsp;</a></span>pool_memory_resource()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::<a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">pool_memory_resource</a> </td>
          <td>(</td>
          <td class="paramtype">Upstream *&nbsp;</td>
          <td class="paramname"><em>upstream_mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thrust::optional&lt; std::size_t &gt;&nbsp;</td>
          <td class="paramname"><em>initial_pool_size</em> = <code>thrust::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thrust::optional&lt; std::size_t &gt;&nbsp;</td>
          <td class="paramname"><em>maximum_pool_size</em> = <code>thrust::nullopt</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html" title="A coalescing best-fit suballocator which uses a pool of memory allocated from an upstream memory_reso...">pool_memory_resource</a></code> and allocate the initial device memory pool using <code>upstream_mr</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="structrmm_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">rmm::logic_error</a></td><td>if <code>upstream_mr == nullptr</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structrmm_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">rmm::logic_error</a></td><td>if <code>initial_pool_size</code> is neither the default nor aligned to a multiple of pool_memory_resource::allocation_alignment bytes. </td></tr>
    <tr><td class="paramname"><a class="el" href="structrmm_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">rmm::logic_error</a></td><td>if <code>maximum_pool_size</code> is neither the default nor aligned to a multiple of pool_memory_resource::allocation_alignment bytes.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">upstream_mr</td><td>The memory_resource from which to allocate blocks for the pool. </td></tr>
    <tr><td class="paramname">initial_pool_size</td><td>Minimum size, in bytes, of the initial pool. Defaults to half of the available memory on the current device. </td></tr>
    <tr><td class="paramname">maximum_pool_size</td><td>Maximum size, in bytes, that the pool can grow to. Defaults to all of the available memory on the current device. </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c587aaeb13b96bda73f9af1ffaee76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c587aaeb13b96bda73f9af1ffaee76e">◆&nbsp;</a></span>allocate_from_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classrmm_1_1mr_1_1detail_1_1stream__ordered__memory__resource.html#a80561e617cbaf5a13aafe4e76593367f">split_block</a> <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::allocate_from_block </td>
          <td>(</td>
          <td class="paramtype">block_type const &amp;&nbsp;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Splits <code>block</code> if necessary to return a pointer to memory of <code>size</code> bytes. </p>
<p>If the block is split, the remainder is returned to the pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">block</td><td>The block to allocate from. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the requested allocation. </td></tr>
    <tr><td class="paramname">stream_event</td><td>The stream and associated event on which the allocation will be used. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair comprising the allocated pointer and any unallocated remainder of the input block. </dd></dl>

</div>
</div>
<a id="a4c687e04a1cc07fe5f9cfee3105f5335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c687e04a1cc07fe5f9cfee3105f5335">◆&nbsp;</a></span>block_from_upstream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">thrust::optional&lt;block_type&gt; <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::block_from_upstream </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Allocate a block from upstream to expand the suballocation pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">size</td><td>The size in bytes to allocate from the upstream resource </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which the memory is to be used. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>block_type The allocated block </dd></dl>

</div>
</div>
<a id="a5cac2b0ee64cf7458934f6d7393c40a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cac2b0ee64cf7458934f6d7393c40a3">◆&nbsp;</a></span>do_get_mem_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::pair&lt;std::size_t, std::size_t&gt; <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::do_get_mem_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get free and available memory for memory resource. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname">nothing</td><td></td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">stream</td><td>to execute on </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair contaiing free_size and total_size of memory </dd></dl>

<p>Implements <a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html">rmm::mr::device_memory_resource</a>.</p>

</div>
</div>
<a id="a6fc2f58dc325d8d5851ba0b40c952f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc2f58dc325d8d5851ba0b40c952f5e">◆&nbsp;</a></span>expand_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">block_type <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::expand_pool </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmm_1_1mr_1_1detail_1_1coalescing__free__list.html">free_list</a> &amp;&nbsp;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Allocate space from upstream to supply the suballocation pool and return a sufficiently sized block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">size</td><td>The minimum size to allocate </td></tr>
    <tr><td class="paramname">blocks</td><td>The free list (ignored in this implementation) </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which the memory is to be used. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>block_type a block of at least <code>size</code> bytes </dd></dl>

</div>
</div>
<a id="a13148a206f1763fba4cd18931f3418aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13148a206f1763fba4cd18931f3418aa">◆&nbsp;</a></span>free_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">block_type <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::free_block </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Finds, frees and returns the block associated with pointer <code>ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ptr</td><td>The pointer to the memory to free. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the memory to free. Must be equal to the original allocation size. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream-event pair for the stream on which the memory was last used. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (now freed) block associated with <code>p</code>. The caller is expected to return the block to the pool. </dd></dl>

</div>
</div>
<a id="a5b75713a57836096f79d00c1544d314e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b75713a57836096f79d00c1544d314e">◆&nbsp;</a></span>free_list_summary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::pair&lt;std::size_t, std::size_t&gt; <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::free_list_summary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrmm_1_1mr_1_1detail_1_1coalescing__free__list.html">free_list</a> const &amp;&nbsp;</td>
          <td class="paramname"><em>blocks</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get the largest available block size and total free size in the specified free list. </p>
<p>This is intended only for debugging</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">blocks</td><td>The free list from which to return the summary </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::size_t, std::size_t&gt; Pair of largest available block, total free size </dd></dl>

</div>
</div>
<a id="a6d0c0b77cfb7db5e1ef9e4bee8b29102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0c0b77cfb7db5e1ef9e4bee8b29102">◆&nbsp;</a></span>get_maximum_allocation_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::get_maximum_allocation_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get the maximum size of allocations supported by this memory resource. </p>
<p>Note this does not depend on the memory size of the device. It simply returns the maximum value of <code>std::size_t</code></p>
<dl class="section return"><dt>Returns</dt><dd>std::size_t The maximum size of a single allocation supported by this memory resource </dd></dl>

</div>
</div>
<a id="a7d8ad0f62b020049239f1642a1099039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8ad0f62b020049239f1642a1099039">◆&nbsp;</a></span>get_upstream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">Upstream* <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::get_upstream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Get the upstream memory_resource object. </p>
<dl class="section return"><dt>Returns</dt><dd>UpstreamResource* the upstream memory resource. </dd></dl>

</div>
</div>
<a id="a04d480a01723347527c62772c2c7e8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d480a01723347527c62772c2c7e8b9">◆&nbsp;</a></span>initialize_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::initialize_pool </td>
          <td>(</td>
          <td class="paramtype">thrust::optional&lt; std::size_t &gt;&nbsp;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thrust::optional&lt; std::size_t &gt;&nbsp;</td>
          <td class="paramname"><em>maximum_size</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Allocate initial memory for the pool. </p>
<p>If initial_size is unset, then queries the upstream memory resource for available memory if upstream supports <code>get_mem_info</code>, or queries the device (using CUDA API) for available memory if not. Then attempts to initialize to half the available memory.</p>
<p>If initial_size is set, then tries to initialize the pool to that size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">initial_size</td><td>The optional initial size for the pool </td></tr>
    <tr><td class="paramname">maximum_size</td><td>The optional maximum size for the pool </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a id="ac7159078675d349b7fe7a8b3429339c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7159078675d349b7fe7a8b3429339c6">◆&nbsp;</a></span>pool_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::pool_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Computes the size of the current pool. </p>
<p>Includes allocated as well as free memory.</p>
<dl class="section return"><dt>Returns</dt><dd>std::size_t The total size of the currently allocated pool. </dd></dl>

</div>
</div>
<a id="a2fab047603acc9b8152b691881476da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fab047603acc9b8152b691881476da8">◆&nbsp;</a></span>size_to_grow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">std::size_t <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::size_to_grow </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Given a minimum size, computes an appropriate size to grow the pool. </p>
<p>Strategy is to try to grow the pool by half the difference between the configured maximum pool size and the current pool size, if the maximum pool size is set. If it is not set, try to double the current pool size.</p>
<p>Returns 0 if the requested size cannot be satisfied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">size</td><td>The size of the minimum allocation immediately needed </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t The computed size to grow the pool. </dd></dl>

</div>
</div>
<a id="a7bc1a125d8ac7fbcb8df3057865357a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc1a125d8ac7fbcb8df3057865357a0">◆&nbsp;</a></span>supports_get_mem_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::supports_get_mem_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Query whether the resource supports the get_mem_info API. </p>
<dl class="section return"><dt>Returns</dt><dd>bool false </dd></dl>

<p>Implements <a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html#a96e73e2a8eca60ee7b1c86ed03d7538b">rmm::mr::device_memory_resource</a>.</p>

</div>
</div>
<a id="a3984b5b250cf0380ba36b03fe62d4f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3984b5b250cf0380ba36b03fe62d4f6a">◆&nbsp;</a></span>supports_streams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::supports_streams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Queries whether the resource supports use of non-null CUDA streams for allocation/deallocation. </p>
<dl class="section return"><dt>Returns</dt><dd>bool true. </dd></dl>

<p>Implements <a class="el" href="classrmm_1_1mr_1_1device__memory__resource.html#a04598a0abd19625d081a69599360b215">rmm::mr::device_memory_resource</a>.</p>

</div>
</div>
<a id="a9cf3b3ae8e75322c61ef8514b3f400be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf3b3ae8e75322c61ef8514b3f400be">◆&nbsp;</a></span>try_to_expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Upstream &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">block_type <a class="el" href="classrmm_1_1mr_1_1pool__memory__resource.html">rmm::mr::pool_memory_resource</a>&lt; Upstream &gt;::try_to_expand </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>try_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrmm_1_1cuda__stream__view.html">cuda_stream_view</a>&nbsp;</td>
          <td class="paramname"><em>stream</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Try to expand the pool by allocating a block of at least <code>min_size</code> bytes from upstream. </p>
<p>Attempts to allocate <code>try_size</code> bytes from upstream. If it fails, it iteratively reduces the attempted size by half until <code>min_size</code>, returning the allocated block once it succeeds.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tbody><tr><td class="paramname"><a class="el" href="classrmm_1_1bad__alloc.html" title="Exception thrown when an RMM allocation fails.">rmm::bad_alloc</a></td><td>if <code>min_size</code> bytes cannot be allocated from upstream or maximum pool size is exceeded.</td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">try_size</td><td>The initial requested size to try allocating. </td></tr>
    <tr><td class="paramname">min_size</td><td>The minimum requested size to try allocating. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which the memory is to be used. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>block_type a block of at least <code>min_size</code> bytes </dd></dl>

</div>
</div>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="pool__memory__resource_8hpp_source.html">pool_memory_resource.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>
Generated by&nbsp;<a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"></a> 1.8.20
</small></address>


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script><script id="rapids-selector-pixel-invocation" type="text/javascript">_satellite.pageBottom();</script></body></html>